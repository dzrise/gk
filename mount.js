
var requirejs, require, define;
(function (e) {
    function h(e, t) {
        return f.call(e, t);
    }
    function p(e, t) {
        var n,
            r,
            i,
            s,
            o,
            a,
            f,
            l,
            h,
            p,
            d,
            v = t && t.split("/"),
            m = u.map,
            g = (m && m["*"]) || {};
        if (e && e.charAt(0) === ".")
            if (t) {
                (v = v.slice(0, v.length - 1)), (e = e.split("/")), (o = e.length - 1), u.nodeIdCompat && c.test(e[o]) && (e[o] = e[o].replace(c, "")), (e = v.concat(e));
                for (h = 0; h < e.length; h += 1) {
                    d = e[h];
                    if (d === ".") e.splice(h, 1), (h -= 1);
                    else if (d === "..") {
                        if (h === 1 && (e[2] === ".." || e[0] === "..")) break;
                        h > 0 && (e.splice(h - 1, 2), (h -= 2));
                    }
                }
                e = e.join("/");
            } else e.indexOf("./") === 0 && (e = e.substring(2));
        if ((v || g) && m) {
            n = e.split("/");
            for (h = n.length; h > 0; h -= 1) {
                r = n.slice(0, h).join("/");
                if (v)
                    for (p = v.length; p > 0; p -= 1) {
                        i = m[v.slice(0, p).join("/")];
                        if (i) {
                            i = i[r];
                            if (i) {
                                (s = i), (a = h);
                                break;
                            }
                        }
                    }
                if (s) break;
                !f && g && g[r] && ((f = g[r]), (l = h));
            }
            !s && f && ((s = f), (a = l)), s && (n.splice(0, a, s), (e = n.join("/")));
        }
        return e;
    }
    function d(t, r) {
        return function () {
            return n.apply(e, l.call(arguments, 0).concat([t, r]));
        };
    }
    function v(e) {
        return function (t) {
            return p(t, e);
        };
    }
    function m(e) {
        return function (t) {
            s[e] = t;
        };
    }
    function g(n) {
        if (h(o, n)) {
            var r = o[n];
            delete o[n], (a[n] = !0), t.apply(e, r);
        }
        if (!h(s, n) && !h(a, n)) throw new Error("No " + n);
        return s[n];
    }
    function y(e) {
        var t,
            n = e ? e.indexOf("!") : -1;
        return n > -1 && ((t = e.substring(0, n)), (e = e.substring(n + 1, e.length))), [t, e];
    }
    function b(e) {
        return function () {
            return (u && u.config && u.config[e]) || {};
        };
    }
    var t,
        n,
        r,
        i,
        s = {},
        o = {},
        u = {},
        a = {},
        f = Object.prototype.hasOwnProperty,
        l = [].slice,
        c = /\.js$/;
    (r = function (e, t) {
        var n,
            r = y(e),
            i = r[0];
        return (
            (e = r[1]),
            i && ((i = p(i, t)), (n = g(i))),
                i ? (n && n.normalize ? (e = n.normalize(e, v(t))) : (e = p(e, t))) : ((e = p(e, t)), (r = y(e)), (i = r[0]), (e = r[1]), i && (n = g(i))),
                { f: i ? i + "!" + e : e, n: e, pr: i, p: n }
        );
    }),
        (i = {
            require: function (e) {
                return d(e);
            },
            exports: function (e) {
                var t = s[e];
                return typeof t != "undefined" ? t : (s[e] = {});
            },
            module: function (e) {
                return { id: e, uri: "", exports: s[e], config: b(e) };
            },
        }),
        (t = function (t, n, u, f) {
            var l,
                c,
                p,
                v,
                y,
                b = [],
                w = typeof u,
                E;
            f = f || t;
            if (w === "undefined" || w === "function") {
                n = !n.length && u.length ? ["require", "exports", "module"] : n;
                for (y = 0; y < n.length; y += 1) {
                    (v = r(n[y], f)), (c = v.f);
                    if (c === "require") b[y] = i.require(t);
                    else if (c === "exports") (b[y] = i.exports(t)), (E = !0);
                    else if (c === "module") l = b[y] = i.module(t);
                    else if (h(s, c) || h(o, c) || h(a, c)) b[y] = g(c);
                    else {
                        if (!v.p) throw new Error(t + " missing " + c);
                        v.p.load(v.n, d(f, !0), m(c), {}), (b[y] = s[c]);
                    }
                }
                p = u ? u.apply(s[t], b) : undefined;
                if (t)
                    if (l && l.exports !== e && l.exports !== s[t]) s[t] = l.exports;
                    else if (p !== e || !E) s[t] = p;
            } else t && (s[t] = u);
        }),
        (requirejs = require = n = function (s, o, a, f, l) {
            if (typeof s == "string") return i[s] ? i[s](o) : g(r(s, o).f);
            if (!s.splice) {
                (u = s), u.deps && n(u.deps, u.callback);
                if (!o) return;
                o.splice ? ((s = o), (o = a), (a = null)) : (s = e);
            }
            return (
                (o = o || function () {}),
                typeof a == "function" && ((a = f), (f = l)),
                    f
                        ? t(e, s, o, a)
                        : setTimeout(function () {
                            t(e, s, o, a);
                        }, 4),
                    n
            );
        }),
        (n.config = function (e) {
            return n(e);
        }),
        (requirejs._defined = s),
        (define = function (e, t, n) {
            t.splice || ((n = t), (t = [])), !h(s, e) && !h(o, e) && (o[e] = [e, t, n]);
        }),
        (define.amd = { jQuery: !0 });
})(),
    define("almond", function () {}),
    define("class", [], function () {
        var e = function () {
                this.initialize.apply(this, arguments);
            },
            t = function (e, t) {
                var n = this,
                    r;
                e && _.has(e, "constructor")
                    ? (r = e.constructor)
                    : (r = function () {
                        return n.apply(this, arguments);
                    }),
                    _.extend(r, n, t);
                var i = function () {
                    this.constructor = r;
                };
                return (i.prototype = n.prototype), (r.prototype = new i()), e && _.extend(r.prototype, e), (r.__super__ = n.prototype), r;
            };
        e.extend = t;
        var n = {
                on: function (e, t, n) {
                    if (!i(this, "on", e, [t, n]) || !t) return this;
                    this._events || (this._events = {});
                    var r = this._events[e] || (this._events[e] = []);
                    return r.push({ callback: t, context: n, ctx: n || this }), this;
                },
                off: function (e, t, n) {
                    var r, s, o, u, a, f, l, c;
                    if (!this._events || !i(this, "off", e, [t, n])) return this;
                    if (!e && !t && !n) return (this._events = {}), this;
                    u = e ? [e] : _.keys(this._events);
                    for (a = 0, f = u.length; a < f; a++) {
                        e = u[a];
                        if ((o = this._events[e])) {
                            this._events[e] = r = [];
                            if (t || n) for (l = 0, c = o.length; l < c; l++) (s = o[l]), ((t && t !== s.callback && t !== s.callback._callback) || (n && n !== s.context)) && r.push(s);
                            r.length || delete this._events[e];
                        }
                    }
                    return this;
                },
                trigger: function (e) {
                    if (!this._events) return this;
                    var t = [].slice.call(arguments, 1);
                    if (!i(this, "trigger", e, t)) return this;
                    var n = this._events[e],
                        r = this._events.all;
                    return n && s(n, t), r && s(r, arguments), this;
                },
            },
            r = /\s+/,
            i = function (e, t, n, i) {
                if (!n) return !0;
                if (typeof n == "object") {
                    for (var s in n) e[t].apply(e, [s, n[s]].concat(i));
                    return !1;
                }
                if (r.test(n)) {
                    var o = n.split(r);
                    for (var u = 0, a = o.length; u < a; u++) e[t].apply(e, [o[u]].concat(i));
                    return !1;
                }
                return !0;
            },
            s = function (e, t) {
                var n,
                    r = -1,
                    i = e.length,
                    s = t[0],
                    o = t[1],
                    u = t[2];
                switch (t.length) {
                    case 0:
                        while (++r < i) (n = e[r]).callback.call(n.ctx);
                        return;
                    case 1:
                        while (++r < i) (n = e[r]).callback.call(n.ctx, s);
                        return;
                    case 2:
                        while (++r < i) (n = e[r]).callback.call(n.ctx, s, o);
                        return;
                    case 3:
                        while (++r < i) (n = e[r]).callback.call(n.ctx, s, o, u);
                        return;
                    default:
                        while (++r < i) (n = e[r]).callback.apply(n.ctx, t);
                }
            };
        return _.extend(e.prototype, n), e;
    }),
    define("textureloader", ["class"], function (e) {
        var t = e.extend({
            initialize: function (e) {
                (this.loaded = !1), (this.textures = {}), (this.path = e.path), (this.files = e.files);
            },
            loadAllFiles: function () {
                var e = new jQuery.Deferred(),
                    t = _.size(this.files);
                return (
                    _.each(
                        this.files,
                        function (n, r) {
                            this.textures[r] = new THREE.ImageUtils.loadTexture(this.path + n, null, function () {
                                --t == 0 && e.resolve();
                            });
                        },
                        this
                    ),
                        (this.loaded = !0),
                        e.promise()
                );
            },
            getById: function (e) {
                return this.loaded || this.loadAllFiles(), this.textures[e];
            },
        });
        return t;
    }),
    define("neons/textures", ["../textureloader"], function (e) {
        var t = "textures/neons/",
            n = { lightgradient: "light-gradient.png", light: "light.png", head: "head.png", flare: "flare.png", grid: "grid.png", tower: "tower.png", box: "box.png" },
            r = new e({ files: n, path: t });
        return { loadAll: r.loadAllFiles.bind(r), get: r.getById.bind(r) };
    }),
    define("neons/objects", ["./textures"], function (e) {
        var t = {};
        return (
            (t.createGround = function (t) {
                var t = _.extend({ opacity: 1 }, t),
                    n = e.get("grid");
                (n.wrapS = THREE.RepeatWrapping), (n.wrapT = THREE.RepeatWrapping), (n.repeat.x = 80), (n.repeat.y = 16);
                var r = new THREE.Mesh(new THREE.PlaneGeometry(10240, 2048, 1, 1), new THREE.MeshPhongMaterial({ map: n, shininess: 1, specular: 0 }));
                return (r.position.y = 0.01), (r.rotation.x = -Math.PI / 2), (r.position.x = 2560), r;
            }),
                (t.createLine = function (e) {
                    var e = _.extend({ color: 16777215, start: 0, end: 5e3, pos: 10, linewidth: 1, speed: 250 }, e),
                        t = new THREE.Geometry(),
                        n = new THREE.LineBasicMaterial({ color: e.color, blending: THREE.AdditiveBlending, linewidth: e.linewidth });
                    t.vertices = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(e.end, 0, 0)];
                    var r = new THREE.Line(t, n);
                    return (
                        (r.type = THREE.LinePieces),
                            (r.start = e.start),
                            (r.end = e.end),
                            (r.speed = e.speed),
                            (r.geometry.dynamic = !0),
                            r.position.set(e.start, 0.5, e.pos - 500),
                            (r.update = function (e) {
                                (r.geometry.vertices[1].x = e * r.end), (r.geometry.verticesNeedUpdate = !0);
                            }),
                            r
                    );
                }),
                (t.createQuad = function (e) {
                    var t = new THREE.Mesh(new THREE.PlaneGeometry(e.width, e.height, 1, 1), e.material);
                    return t;
                }),
                (t.createFlare = function (e) {
                    var n = e.width || 128,
                        r = e.height || 128,
                        i = new THREE.Geometry(),
                        s = new THREE.MeshBasicMaterial({ map: e.map, transparent: !0, depthWrite: !1, depthTest: !1, blending: THREE.AdditiveBlending, side: THREE.DoubleSide }),
                        o = t.createQuad({ width: n, height: r, material: s });
                    return o;
                }),
                t
        );
    }),
    define("modelloader", ["class"], function (e) {
        var t = e.extend({
            initialize: function (e) {
                (this.loaded = !1), (this.models = {}), (this.path = e.path), (this.files = e.files);
            },
            loadAllFiles: function () {
                var e = new jQuery.Deferred(),
                    t = _.size(this.files),
                    n = this.models,
                    r = new THREE.JSONLoader();
                return (
                    _.each(
                        this.files,
                        function (i, s) {
                            r.load(this.path + i, function (r, i) {
                                (n[s] = new THREE.Mesh(r, new THREE.MeshFaceMaterial(i))), --t == 0 && e.resolve();
                            });
                        },
                        this
                    ),
                        (this.loaded = !0),
                        e.promise()
                );
            },
            getById: function (e) {
                return this.loaded || this.loadAllFiles(), this.models[e];
            },
        });
        return t;
    }),
    define("neons/models", ["../modelloader"], function (e) {
        var t = "models/",
            n = { tower: "tower.js", box: "box.js" },
            r = new e({ files: n, path: t });
        return { loadAll: r.loadAllFiles.bind(r), get: r.getById.bind(r) };
    }),
    define("world", ["class"], function (e) {
        function n(e) {
            var e = _.extend({ fov: 45, aspectRatio: WIDTH / HEIGHT, near: 1, far: 1e4 }, e),
                t = new THREE.PerspectiveCamera(e.fov, e.aspectRatio, e.near, e.far);
            return t;
        }
        var t = e.extend({
            initialize: function () {
                (this.scene = new THREE.Scene()),
                    (this.lights = []),
                    (this.camera = n()),
                    this.camera.position.set(0, 200, 550),
                    this.camera.lookAt(new THREE.Vector3(0, -150, 0)),
                    (this.cameraContainer = new THREE.Gyroscope()),
                    this.cameraContainer.add(this.camera),
                    this.scene.add(this.cameraContainer);
            },
            update: function () {},
            setupDatGUI: function (e) {},
            setupCompositing: function (e) {
                var t = new THREE.RenderPass(this.scene, this.camera);
                e.addPass(t);
            },
            initHelpers: function () {
                (this.helpers = []),
                    _.each(
                        this.lights,
                        _.bind(function (e) {
                            var t = new THREE.PointLightHelper(e, 5);
                            t.material.color.setHex(0), this.scene.add(t), this.helpers.push(t);
                        }, this)
                    );
                var e = new THREE.AxisHelper(20);
                (e.position.y += 0.05), this.scene.add(e), this.helpers.push(e);
            },
            toggleHelpers: function () {
                _.each(this.helpers, function (e) {
                    e.visible = !e.visible;
                });
            },
            setAspectRatio: function (e) {
                (this.camera.aspect = e), this.camera.updateProjectionMatrix();
            },
        });
        return t;
    }),
    define("neons/neon", ["class", "./objects", "./textures"], function (e, t, n) {
        function i(e) {
            var t = [],
                n = e.length;
            return (
                _.each(e, function (r, i) {
                    i === 0 ? t.push(new THREE.Vector3(0, r, 0)) : r !== e[i - 1] && (t.push(new THREE.Vector3(i * 128, e[i - 1], 0)), t.push(new THREE.Vector3(i * 128, r, 0))), i === n - 1 && t.push(new THREE.Vector3((i + 1) * 128, r, 0));
                }),
                    t
            );
        }
        var r = e.extend({
            initialize: function (e) {
                var t = new THREE.Object3D();
                (this.scene = e.scene),
                    (this.length = 0),
                    this.createSegments({ vertices: i(e.row), start: 0, pos: e.pos }),
                    t.add(this.segments),
                    (this.obj = t),
                    (this.segments = this.obj.children[0].children),
                    (this.flares = []),
                    this.createHead(),
                    (this.currentSegmentIndex = 0),
                    (this.speed = this.length / e.duration);
            },
            reset: function () {
                _.each(this.segments, function (e) {
                    (e.material.opacity = 0), (e.children[0].material.opacity = 0);
                }),
                    _.each(this.flares, function (e) {
                        e.visible = !1;
                    }),
                    (this.flares = []);
            },
            getCurrentSegment: function () {
                return this.segments[this.currentSegmentIndex];
            },
            getSegmentByProgress: function (e) {
                return (
                    e > 1 && (e = 1),
                        _.find(
                            this.segments,
                            function (t) {
                                return t.endingPosition / this.length >= e;
                            },
                            this
                        )
                );
            },
            getCurrentPosition: function (e) {
                var t = new THREE.Vector3(0, 0, 0),
                    n = this.getSegmentByProgress(e);
                return n && ((t = n.geometry.vertices[1].clone()), t.applyMatrix4(n.matrixWorld), (t.z += 20)), t;
            },
            showSegment: function (e) {
                (e.material.opacity = 1), (e.children[0].material.opacity = 1);
            },
            completeSegment: function (e) {
                (e.geometry.vertices[1].x = e.length / 2), (e.geometry.vertices[3].x = e.length / 2), (e.geometry.verticesNeedUpdate = !0), e.orientation === 1 && _.contains(this.flares, e.flare) === !1 && this.flares.push(e.flare);
            },
            createSegment: function (e) {
                var r = new THREE.MeshBasicMaterial({ map: e.map, transparent: !0, blending: THREE.AdditiveBlending, side: THREE.DoubleSide }),
                    i = t.createQuad({ width: e.length, height: 60, material: r });
                i.rotation.x = -Math.PI / 2;
                var s = n.get("lightgradient"),
                    o = i.clone();
                (o.material = i.material.clone()),
                    (o.material.map = s),
                    i.add(o),
                    e.orientation === 1 ? (i.rotation.y = -Math.PI / 2) : e.orientation === -1 && (i.rotation.y = Math.PI / 2),
                    (i.length = e.length),
                    (i.orientation = e.orientation),
                    (o.position.z = 10),
                    (o.rotation.x = Math.PI / 2),
                    (o.material.depthWrite = !1),
                    (i.material.opacity = 0),
                    (o.material.opacity = 0);
                if (i.orientation !== 0) {
                    var u = t.createFlare({ map: n.get("flare"), height: 60, width: 60 });
                    (u.visible = !1), this.scene.add(u), (i.flare = u), i.orientation !== 0 && i.flare.position.setY(e.length / 2);
                }
                return i;
            },
            createSegments: function (e) {
                this.segments = new THREE.Object3D();
                var t = n.get("light"),
                    r = 0;
                for (var i = 0; i < e.vertices.length - 1; i++) {
                    var s = e.vertices[i],
                        o = e.vertices[i + 1],
                        u = s.distanceTo(o),
                        a;
                    r++;
                    if (o.y > s.y) {
                        a = 1;
                        var f = this.createSegment({ map: t, length: u, orientation: a });
                        f.position.set(s.x - 0.1, s.y + u / 2, e.pos - 512), f.flare.position.add(f.position);
                    } else if (o.y < s.y) {
                        a = -1;
                        var f = this.createSegment({ map: t, length: u, orientation: a });
                        f.position.set(s.x + 0.1, s.y - u / 2, e.pos - 512), f.flare.position.add(f.position);
                    } else {
                        a = 0;
                        var f = this.createSegment({ map: t, length: u, orientation: a });
                        f.position.set(s.x + u / 2, s.y + 0.1, e.pos - 512);
                    }
                    this.segments.add(f), (this.length += u), (f.startingPosition = this.length - u), (f.endingPosition = this.length), (f.index = r), i === 0 && ((f.frustumCulled = !1), (f.children[0].frustumCulled = !1));
                }
            },
            createHead: function () {
                var e = n.get("head"),
                    r = new THREE.MeshBasicMaterial({ map: e, transparent: !0, blending: THREE.AdditiveBlending, side: THREE.DoubleSide }),
                    i = t.createQuad({ height: 60, width: 60, material: r });
                (i.rotation.x = Math.PI / 2), this.obj.add(i), (this.head = i);
            },
            moveTo: function (e, t) {
                var n = e.startingPosition / this.length,
                    r = e.endingPosition / this.length,
                    i = r - n,
                    s = (t - n) / i,
                    o = s * e.length - e.length / 2;
                _.each(
                    _.first(this.segments, e.index),
                    function (e) {
                        this.completeSegment(e);
                    },
                    this
                ),
                    this.showSegment(e),
                    (e.geometry.vertices[1].x = o),
                    (e.geometry.vertices[3].x = o),
                    (e.geometry.verticesNeedUpdate = !0),
                    (this.head.position = this.getCurrentPosition(t)),
                    (this.head.position.x += 30),
                    (this.head.position.z += 10),
                    this.updateComponents(e, s * e.length);
            },
            updateComponents: function (e, t) {
                e.orientation === -1 && (_.contains(this.flares, e.flare) === !1 && this.flares.push(e.flare), (this.head.material.opacity = 0)),
                e.orientation === 1 && (this.head.material.opacity = 0),
                e.orientation === 0 &&
                ((this.head.material.opacity = 1),
                    t < 120
                        ? ((this.head.geometry.vertices[1].x = t / 2 - 30), (this.head.geometry.vertices[3].x = t / 2 - 30), (this.head.geometry.verticesNeedUpdate = !0))
                        : ((this.head.geometry.vertices[1].x = 30), (this.head.geometry.vertices[3].x = 30), (this.head.geometry.verticesNeedUpdate = !0)));
            },
            update: function (e, t, n, r) {
                var i = this.getSegmentByProgress(r);
                _.each(
                    this.flares,
                    function (r) {
                        if (e.intersectsObject(r)) {
                            n(r, r.position.clone()), r.lookAt(t.position);
                            var i = r.position.distanceTo(t.position) / 500;
                            r.scale.set(i, i, i);
                        }
                    },
                    this
                ),
                    this.moveTo(i, r);
            },
        });
        return r;
    }),
    define("neons/neons", ["../world", "./objects", "./textures", "./models", "./neon"], function (e, t, n, r, i) {
        function a() {
            var e = [4317433, 2228221, 1989848, 4097011],
                t = Math.floor(Math.random() * 4);
            return e[t];
        }
        var s = 17500,
            o = (5120 / s) * 1e3,
            u = e.extend({
                initialize: function (t) {
                    e.prototype.initialize.call(this);
                    var n = this.loadBoxMap();
                    (this.BOUNDARIES = { x: WIDTH / 10, y: HEIGHT / 10 }),
                        (this.raycaster = new THREE.Raycaster()),
                        (this.pointLights = new THREE.Object3D()),
                        this.scene.add(this.pointLights),
                        (this.progress = 0),
                        this.createLights(),
                        this.createGround(),
                        this.createBoxes(n),
                        this.createNeons(n, [8, 12, 16, 18, 20, 22]).done(this.start.bind(this)),
                        this.createTowers(),
                        this.createLines([6, 10, 11, 14, 15, 20, 23]),
                        (this.camera.target = new THREE.Vector3(0, 0, 0)),
                        this.camera.lookAt(this.camera.target);
                },
                start: function () {
                    (this.started = !0), this.trigger("started");
                },
                createLights: function () {
                    (this.dirLight = new THREE.DirectionalLight(16777215, 1)),
                        this.dirLight.position.set(0, 500, -350),
                        (this.dirLight.castShadow = !0),
                        (this.dirLight.shadowDarkness = 0.25),
                        this.scene.add(this.dirLight),
                        (this.spotLight = new THREE.SpotLight(16777215)),
                        this.spotLight.position.set(0, 400, -500),
                        (this.spotLight.intensity = 4),
                        (this.spotLight.angle = Math.PI / 12),
                        (this.spotLight.exponent = 50),
                        this.scene.add(this.spotLight),
                        this.lights.push(this.spotLight);
                },
                createGround: function () {
                    (this.ground = t.createGround({ opacity: 0.85 })), this.ground.position.setY(0.01), (this.ground.receiveShadow = !0), this.scene.add(this.ground);
                },
                loadBoxMap: function (e) {
                    var t = new jQuery.Deferred(),
                        n = new Image();
                    return (
                        (n.onload = function () {
                            var e = document.createElement("canvas");
                            (e.width = 40), (e.height = 32);
                            var r = e.getContext("2d");
                            r.drawImage(n, 0, 0, e.width, e.height);
                            var i = r.getImageData(0, 0, e.width, e.height);
                            t.resolve(i);
                        }),
                            (n.src = "textures/neons/map.png"),
                            t.promise()
                    );
                },
                createTowers: function (e) {
                    this.towers = new THREE.Object3D();
                    var t = r.get("tower"),
                        i = n.get("tower"),
                        s = new THREE.MeshPhongMaterial({ map: i, shading: THREE.FlatShading, shininess: 1 });
                    (t.material.materials[0] = s), (t.material.materials[1].shading = THREE.FlatShading), (t.material.needsUpdate = !0), (t.castShadow = !0), (t.receiveShadow = !0);
                    var t = t.clone();
                    t.position.set(1500, 80, 200), this.towers.add(t);
                    var t = t.clone();
                    t.position.set(2500, 80, 300), this.towers.add(t);
                    var t = t.clone();
                    t.position.set(3e3, 80, -50), this.towers.add(t);
                    var t = t.clone();
                    t.position.set(4e3, 80, 50), this.towers.add(t), this.scene.add(this.towers);
                },
                createBoxes: function (e) {
                    var t = (this.boxes = new THREE.Object3D());
                    this.scene.add(t);
                    var i = n.get("box"),
                        s = r.get("box"),
                        o = new THREE.MeshPhongMaterial({ map: i, shading: THREE.FlatShading, shininess: 1 });
                    (s.material = o),
                        (s.castShadow = !0),
                        (s.receiveShadow = !0),
                        e.done(function (e) {
                            for (var n = 0; n < e.height; n++)
                                for (var r = 0; r < e.width; r++) {
                                    var i = (n * e.width + r) * 4,
                                        o = (e.data[i] / 255) * 80;
                                    if (o > 0) {
                                        var u = s.clone();
                                        t.add(u);
                                        var a = 64 + r * 128,
                                            f = 16 + n * 32,
                                            l = o - 50;
                                        u.position.set(a, l, -512 + f);
                                        if (r < 8) {
                                            var c = u.clone();
                                            (c.position.x += 5120), t.add(c);
                                        }
                                        if (r > 32) {
                                            var c = u.clone();
                                            (c.position.x -= 5120), t.add(c);
                                        }
                                    }
                                }
                        });
                },
                createNeons: function (e, t) {
                    var n = new jQuery.Deferred(),
                        r = new THREE.Object3D();
                    return (
                        (this.neons = []),
                            this.scene.add(r),
                            e.done(
                                _.bind(function (e) {
                                    var o = [];
                                    for (var u = 0; u < e.height; u++) {
                                        o[u] = [];
                                        for (var a = 0; a < e.width; a++) {
                                            var f = (u * e.width + a) * 4;
                                            if (e.data[f] !== 0) {
                                                var l = (e.data[f] / 255) * 80;
                                                o[u].push(l);
                                            } else o[u].push(0);
                                        }
                                    }
                                    _.each(
                                        t,
                                        function (e, t) {
                                            var n = new i({ row: o[e], pos: e * 32 + 5, scene: this.scene, duration: s });
                                            this.neons.push(n), r.add(n.obj);
                                            if (t === 3 || t === 4 || t === 5) {
                                                var u = new THREE.PointLight(12556543, 1.5, 400);
                                                (u.i = t), this.pointLights.add(u);
                                            }
                                        },
                                        this
                                    );
                                    var c = r.clone();
                                    (c.position.x -= 5120),
                                        this.scene.add(c),
                                        _.each(c.children, function (e) {
                                            _.each(e.children[0].children, function (e) {
                                                var t = e.children[0];
                                                (e.geometry = e.geometry.clone()), (t.geometry = t.geometry.clone()), (e.material = e.material.clone()), (t.material = t.material.clone()), (e.material.opacity = 1), (t.material.opacity = 1);
                                            });
                                        }),
                                        n.resolve();
                                }, this)
                            ),
                            n.promise()
                    );
                },
                createLines: function (e) {
                    (this.lines = []),
                        (this.lines2 = []),
                        _.each(
                            e,
                            function (e) {
                                this.lines.push(t.createLine({ color: a(), pos: e * 32, start: Math.random() * 300 - 150, end: 5120, linewidth: 3 }));
                            },
                            this
                        ),
                        _.each(
                            this.lines,
                            function (e) {
                                this.scene.add(e);
                                var t = e.clone();
                                (t.geometry = e.geometry.clone()), (t.position.x = -5120 + e.start), this.scene.add(t);
                            },
                            this
                        );
                },
                setupDatGUI: function (e) {
                    var t = e.addFolder("Light position"),
                        n = this.lights[0];
                    t.add(n.position, "x"), t.add(n.position, "y"), t.add(n.position, "z"), t.open();
                },
                setupCompositing: function (e) {
                    var t = new THREE.RenderPass(this.scene, this.camera),
                        n = new THREE.ShaderPass(THREE.RGBShiftShader);
                    (n.uniforms.amount.value = 0.03), e.addPass(t), e.addPass(n);
                },
                updateLines: function (e) {
                    _.each(
                        this.lines,
                        function (e) {
                            e.update(this.progress);
                        },
                        this
                    );
                },
                updateDirLight: function () {
                    (this.dirLight.position.x = this.camera.position.x), (this.dirLight.target.position.x = this.camera.position.x);
                },
                updateSpotLight: function (e) {
                    (this.spotLight.position.x = this.camera.position.x), (this.spotLight.target.position.x = this.camera.position.x + e), (this.spotLight.target.position.z = e);
                },
                updatePointLights: function () {
                    _.each(
                        this.pointLights.children,
                        function (e) {
                            e.position = this.neons[e.i].getCurrentPosition(this.progress);
                        },
                        this
                    );
                },
                updateFlareVisibility: function (e, t) {
                    var n = t.sub(this.camera.position),
                        r = n.length();
                    (this.raycaster.far = r), this.raycaster.set(this.camera.position, n.normalize());
                    var i = this.raycaster.intersectObjects(this.boxes.children, !0);
                    i.length > 0 ? (e.visible = !1) : (e.visible = !0);
                },
                updateNeons: function () {
                    var e = this.getCameraFrustum();
                    _.each(
                        this.neons,
                        function (t) {
                            t.update(e, this.camera, this.updateFlareVisibility.bind(this), this.progress);
                        },
                        this
                    );
                },
                getCameraFrustum: function () {
                    var e = new THREE.Frustum(),
                        t = new THREE.Matrix4();
                    return this.camera.updateMatrixWorld(), this.camera.matrixWorldInverse.getInverse(this.camera.matrixWorld), t.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse), e.setFromMatrix(t), e;
                },
                updateCamera: function (e, t) {
                    (this.camera.position.y = 200 + t / 2), (this.camera.position.x += o * e), (this.camera.position.z = 550);
                    if (this.camera.position.x > 5120) {
                        var n = 5120 - this.camera.target.x;
                        (this.camera.target.x = -n),
                            (this.camera.position.x = 0),
                            _.each(
                                this.neons,
                                function (e) {
                                    e.reset();
                                },
                                this
                            );
                    }
                    var r = this.BOUNDARIES.x * mouseX,
                        i = this.BOUNDARIES.y * -mouseY,
                        s = new THREE.Vector3(this.camera.position.x + r, i, 0);
                    (this.camera.target.x += o * e), this.camera.lookAt(this.camera.target.lerp(s, 0.1)), (this.progress = this.camera.position.x / 5120);
                },
                update: function (e, t) {
                    var n = Math.sin((Math.PI / 2) * e * 0.3) * 100;
                    this.started && (this.updateCamera(t, n), this.updateLines(t), this.updateSpotLight(n), this.updateDirLight(), this.updateNeons(), this.updatePointLights());
                },
            });
        return u;
    });
var THREE = THREE || { REVISION: "61" };
(self.console = self.console || { info: function () {}, log: function () {}, debug: function () {}, warn: function () {}, error: function () {} }),
    (String.prototype.trim =
        String.prototype.trim ||
        function () {
            return this.replace(/^\s+|\s+$/g, "");
        }),
    (THREE.extend = function (e, t) {
        if (Object.keys) {
            var n = Object.keys(t);
            for (var r = 0, i = n.length; r < i; r++) {
                var s = n[r];
                Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(t, s));
            }
        } else {
            var o = {}.hasOwnProperty;
            for (var s in t) o.call(t, s) && (e[s] = t[s]);
        }
        return e;
    }),
    (function () {
        var e = 0,
            t = ["ms", "moz", "webkit", "o"];
        for (var n = 0; n < t.length && !self.requestAnimationFrame; ++n)
            (self.requestAnimationFrame = self[t[n] + "RequestAnimationFrame"]), (self.cancelAnimationFrame = self[t[n] + "CancelAnimationFrame"] || self[t[n] + "CancelRequestAnimationFrame"]);
        self.requestAnimationFrame === undefined &&
        self.setTimeout !== undefined &&
        (self.requestAnimationFrame = function (t) {
            var n = Date.now(),
                r = Math.max(0, 16 - (n - e)),
                i = self.setTimeout(function () {
                    t(n + r);
                }, r);
            return (e = n + r), i;
        }),
        self.cancelAnimationFrame === undefined &&
        self.clearTimeout !== undefined &&
        (self.cancelAnimationFrame = function (e) {
            self.clearTimeout(e);
        });
    })(),
    (THREE.CullFaceNone = 0),
    (THREE.CullFaceBack = 1),
    (THREE.CullFaceFront = 2),
    (THREE.CullFaceFrontBack = 3),
    (THREE.FrontFaceDirectionCW = 0),
    (THREE.FrontFaceDirectionCCW = 1),
    (THREE.BasicShadowMap = 0),
    (THREE.PCFShadowMap = 1),
    (THREE.PCFSoftShadowMap = 2),
    (THREE.FrontSide = 0),
    (THREE.BackSide = 1),
    (THREE.DoubleSide = 2),
    (THREE.NoShading = 0),
    (THREE.FlatShading = 1),
    (THREE.SmoothShading = 2),
    (THREE.NoColors = 0),
    (THREE.FaceColors = 1),
    (THREE.VertexColors = 2),
    (THREE.NoBlending = 0),
    (THREE.NormalBlending = 1),
    (THREE.AdditiveBlending = 2),
    (THREE.SubtractiveBlending = 3),
    (THREE.MultiplyBlending = 4),
    (THREE.CustomBlending = 5),
    (THREE.AddEquation = 100),
    (THREE.SubtractEquation = 101),
    (THREE.ReverseSubtractEquation = 102),
    (THREE.ZeroFactor = 200),
    (THREE.OneFactor = 201),
    (THREE.SrcColorFactor = 202),
    (THREE.OneMinusSrcColorFactor = 203),
    (THREE.SrcAlphaFactor = 204),
    (THREE.OneMinusSrcAlphaFactor = 205),
    (THREE.DstAlphaFactor = 206),
    (THREE.OneMinusDstAlphaFactor = 207),
    (THREE.DstColorFactor = 208),
    (THREE.OneMinusDstColorFactor = 209),
    (THREE.SrcAlphaSaturateFactor = 210),
    (THREE.MultiplyOperation = 0),
    (THREE.MixOperation = 1),
    (THREE.AddOperation = 2),
    (THREE.UVMapping = function () {}),
    (THREE.CubeReflectionMapping = function () {}),
    (THREE.CubeRefractionMapping = function () {}),
    (THREE.SphericalReflectionMapping = function () {}),
    (THREE.SphericalRefractionMapping = function () {}),
    (THREE.RepeatWrapping = 1e3),
    (THREE.ClampToEdgeWrapping = 1001),
    (THREE.MirroredRepeatWrapping = 1002),
    (THREE.NearestFilter = 1003),
    (THREE.NearestMipMapNearestFilter = 1004),
    (THREE.NearestMipMapLinearFilter = 1005),
    (THREE.LinearFilter = 1006),
    (THREE.LinearMipMapNearestFilter = 1007),
    (THREE.LinearMipMapLinearFilter = 1008),
    (THREE.UnsignedByteType = 1009),
    (THREE.ByteType = 1010),
    (THREE.ShortType = 1011),
    (THREE.UnsignedShortType = 1012),
    (THREE.IntType = 1013),
    (THREE.UnsignedIntType = 1014),
    (THREE.FloatType = 1015),
    (THREE.UnsignedShort4444Type = 1016),
    (THREE.UnsignedShort5551Type = 1017),
    (THREE.UnsignedShort565Type = 1018),
    (THREE.AlphaFormat = 1019),
    (THREE.RGBFormat = 1020),
    (THREE.RGBAFormat = 1021),
    (THREE.LuminanceFormat = 1022),
    (THREE.LuminanceAlphaFormat = 1023),
    (THREE.RGB_S3TC_DXT1_Format = 2001),
    (THREE.RGBA_S3TC_DXT1_Format = 2002),
    (THREE.RGBA_S3TC_DXT3_Format = 2003),
    (THREE.RGBA_S3TC_DXT5_Format = 2004),
    (THREE.Color = function (e) {
        return e !== undefined && this.set(e), this;
    }),
    (THREE.Color.prototype = {
        constructor: THREE.Color,
        r: 1,
        g: 1,
        b: 1,
        set: function (e) {
            return e instanceof THREE.Color ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
        },
        setHex: function (e) {
            return (e = Math.floor(e)), (this.r = ((e >> 16) & 255) / 255), (this.g = ((e >> 8) & 255) / 255), (this.b = (e & 255) / 255), this;
        },
        setRGB: function (e, t, n) {
            return (this.r = e), (this.g = t), (this.b = n), this;
        },
        setHSL: function (e, t, n) {
            if (t === 0) this.r = this.g = this.b = n;
            else {
                var r = function (e, t, n) {
                        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 0.5 ? t : n < 2 / 3 ? e + (t - e) * 6 * (2 / 3 - n) : e;
                    },
                    i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
                    s = 2 * n - i;
                (this.r = r(s, i, e + 1 / 3)), (this.g = r(s, i, e)), (this.b = r(s, i, e - 1 / 3));
            }
            return this;
        },
        setStyle: function (e) {
            if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(e)) {
                var t = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(e);
                return (this.r = Math.min(255, parseInt(t[1], 10)) / 255), (this.g = Math.min(255, parseInt(t[2], 10)) / 255), (this.b = Math.min(255, parseInt(t[3], 10)) / 255), this;
            }
            if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(e)) {
                var t = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(e);
                return (this.r = Math.min(100, parseInt(t[1], 10)) / 100), (this.g = Math.min(100, parseInt(t[2], 10)) / 100), (this.b = Math.min(100, parseInt(t[3], 10)) / 100), this;
            }
            if (/^\#([0-9a-f]{6})$/i.test(e)) {
                var t = /^\#([0-9a-f]{6})$/i.exec(e);
                return this.setHex(parseInt(t[1], 16)), this;
            }
            if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(e)) {
                var t = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(e);
                return this.setHex(parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3], 16)), this;
            }
            if (/^(\w+)$/i.test(e)) return this.setHex(THREE.ColorKeywords[e]), this;
        },
        copy: function (e) {
            return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        },
        copyGammaToLinear: function (e) {
            return (this.r = e.r * e.r), (this.g = e.g * e.g), (this.b = e.b * e.b), this;
        },
        copyLinearToGamma: function (e) {
            return (this.r = Math.sqrt(e.r)), (this.g = Math.sqrt(e.g)), (this.b = Math.sqrt(e.b)), this;
        },
        convertGammaToLinear: function () {
            var e = this.r,
                t = this.g,
                n = this.b;
            return (this.r = e * e), (this.g = t * t), (this.b = n * n), this;
        },
        convertLinearToGamma: function () {
            return (this.r = Math.sqrt(this.r)), (this.g = Math.sqrt(this.g)), (this.b = Math.sqrt(this.b)), this;
        },
        getHex: function () {
            return ((this.r * 255) << 16) ^ ((this.g * 255) << 8) ^ ((this.b * 255) << 0);
        },
        getHexString: function () {
            return ("000000" + this.getHex().toString(16)).slice(-6);
        },
        getHSL: (function () {
            var e = { h: 0, s: 0, l: 0 };
            return function () {
                var t = this.r,
                    n = this.g,
                    r = this.b,
                    i = Math.max(t, n, r),
                    s = Math.min(t, n, r),
                    o,
                    u,
                    a = (s + i) / 2;
                if (s === i) (o = 0), (u = 0);
                else {
                    var f = i - s;
                    u = a <= 0.5 ? f / (i + s) : f / (2 - i - s);
                    switch (i) {
                        case t:
                            o = (n - r) / f + (n < r ? 6 : 0);
                            break;
                        case n:
                            o = (r - t) / f + 2;
                            break;
                        case r:
                            o = (t - n) / f + 4;
                    }
                    o /= 6;
                }
                return (e.h = o), (e.s = u), (e.l = a), e;
            };
        })(),
        getStyle: function () {
            return "rgb(" + ((this.r * 255) | 0) + "," + ((this.g * 255) | 0) + "," + ((this.b * 255) | 0) + ")";
        },
        offsetHSL: function (e, t, n) {
            var r = this.getHSL();
            return (r.h += e), (r.s += t), (r.l += n), this.setHSL(r.h, r.s, r.l), this;
        },
        add: function (e) {
            return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        },
        addColors: function (e, t) {
            return (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this;
        },
        addScalar: function (e) {
            return (this.r += e), (this.g += e), (this.b += e), this;
        },
        multiply: function (e) {
            return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        },
        multiplyScalar: function (e) {
            return (this.r *= e), (this.g *= e), (this.b *= e), this;
        },
        lerp: function (e, t) {
            return (this.r += (e.r - this.r) * t), (this.g += (e.g - this.g) * t), (this.b += (e.b - this.b) * t), this;
        },
        equals: function (e) {
            return e.r === this.r && e.g === this.g && e.b === this.b;
        },
        fromArray: function (e) {
            return (this.r = e[0]), (this.g = e[1]), (this.b = e[2]), this;
        },
        toArray: function () {
            return [this.r, this.g, this.b];
        },
        clone: function () {
            return new THREE.Color().setRGB(this.r, this.g, this.b);
        },
    }),
    (THREE.ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
    }),
    (THREE.Quaternion = function (e, t, n, r) {
        (this._x = e || 0), (this._y = t || 0), (this._z = n || 0), (this._w = r !== undefined ? r : 1);
    }),
    (THREE.Quaternion.prototype = {
        constructor: THREE.Quaternion,
        _x: 0,
        _y: 0,
        _z: 0,
        _w: 0,
        _euler: undefined,
        _updateEuler: function (e) {
            this._euler !== undefined && this._euler.setFromQuaternion(this, undefined, !1);
        },
        get x() {
            return this._x;
        },
        set x(e) {
            (this._x = e), this._updateEuler();
        },
        get y() {
            return this._y;
        },
        set y(e) {
            (this._y = e), this._updateEuler();
        },
        get z() {
            return this._z;
        },
        set z(e) {
            (this._z = e), this._updateEuler();
        },
        get w() {
            return this._w;
        },
        set w(e) {
            (this._w = e), this._updateEuler();
        },
        set: function (e, t, n, r) {
            return (this._x = e), (this._y = t), (this._z = n), (this._w = r), this._updateEuler(), this;
        },
        copy: function (e) {
            return (this._x = e._x), (this._y = e._y), (this._z = e._z), (this._w = e._w), this._updateEuler(), this;
        },
        setFromEuler: function (e, t) {
            if (e instanceof THREE.Euler == 0) throw new Error("ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
            var n = Math.cos(e._x / 2),
                r = Math.cos(e._y / 2),
                i = Math.cos(e._z / 2),
                s = Math.sin(e._x / 2),
                o = Math.sin(e._y / 2),
                u = Math.sin(e._z / 2);
            return (
                e.order === "XYZ"
                    ? ((this._x = s * r * i + n * o * u), (this._y = n * o * i - s * r * u), (this._z = n * r * u + s * o * i), (this._w = n * r * i - s * o * u))
                    : e.order === "YXZ"
                    ? ((this._x = s * r * i + n * o * u), (this._y = n * o * i - s * r * u), (this._z = n * r * u - s * o * i), (this._w = n * r * i + s * o * u))
                    : e.order === "ZXY"
                        ? ((this._x = s * r * i - n * o * u), (this._y = n * o * i + s * r * u), (this._z = n * r * u + s * o * i), (this._w = n * r * i - s * o * u))
                        : e.order === "ZYX"
                            ? ((this._x = s * r * i - n * o * u), (this._y = n * o * i + s * r * u), (this._z = n * r * u - s * o * i), (this._w = n * r * i + s * o * u))
                            : e.order === "YZX"
                                ? ((this._x = s * r * i + n * o * u), (this._y = n * o * i + s * r * u), (this._z = n * r * u - s * o * i), (this._w = n * r * i - s * o * u))
                                : e.order === "XZY" && ((this._x = s * r * i - n * o * u), (this._y = n * o * i - s * r * u), (this._z = n * r * u + s * o * i), (this._w = n * r * i + s * o * u)),
                t !== !1 && this._updateEuler(),
                    this
            );
        },
        setFromAxisAngle: function (e, t) {
            var n = t / 2,
                r = Math.sin(n);
            return (this._x = e.x * r), (this._y = e.y * r), (this._z = e.z * r), (this._w = Math.cos(n)), this._updateEuler(), this;
        },
        setFromRotationMatrix: function (e) {
            var t = e.elements,
                n = t[0],
                r = t[4],
                i = t[8],
                s = t[1],
                o = t[5],
                u = t[9],
                a = t[2],
                f = t[6],
                l = t[10],
                c = n + o + l,
                h;
            return (
                c > 0
                    ? ((h = 0.5 / Math.sqrt(c + 1)), (this._w = 0.25 / h), (this._x = (f - u) * h), (this._y = (i - a) * h), (this._z = (s - r) * h))
                    : n > o && n > l
                    ? ((h = 2 * Math.sqrt(1 + n - o - l)), (this._w = (f - u) / h), (this._x = 0.25 * h), (this._y = (r + s) / h), (this._z = (i + a) / h))
                    : o > l
                        ? ((h = 2 * Math.sqrt(1 + o - n - l)), (this._w = (i - a) / h), (this._x = (r + s) / h), (this._y = 0.25 * h), (this._z = (u + f) / h))
                        : ((h = 2 * Math.sqrt(1 + l - n - o)), (this._w = (s - r) / h), (this._x = (i + a) / h), (this._y = (u + f) / h), (this._z = 0.25 * h)),
                    this._updateEuler(),
                    this
            );
        },
        inverse: function () {
            return this.conjugate().normalize(), this;
        },
        conjugate: function () {
            return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._updateEuler(), this;
        },
        lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        },
        length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        },
        normalize: function () {
            var e = this.length();
            return e === 0 ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1)) : ((e = 1 / e), (this._x = this._x * e), (this._y = this._y * e), (this._z = this._z * e), (this._w = this._w * e)), this;
        },
        multiply: function (e, t) {
            return t !== undefined ? (console.warn("DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e);
        },
        multiplyQuaternions: function (e, t) {
            var n = e._x,
                r = e._y,
                i = e._z,
                s = e._w,
                o = t._x,
                u = t._y,
                a = t._z,
                f = t._w;
            return (this._x = n * f + s * o + r * a - i * u), (this._y = r * f + s * u + i * o - n * a), (this._z = i * f + s * a + n * u - r * o), (this._w = s * f - n * o - r * u - i * a), this._updateEuler(), this;
        },
        multiplyVector3: function (e) {
            return console.warn("DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this);
        },
        slerp: function (e, t) {
            var n = this._x,
                r = this._y,
                i = this._z,
                s = this._w,
                o = s * e._w + n * e._x + r * e._y + i * e._z;
            o < 0 ? ((this._w = -e._w), (this._x = -e._x), (this._y = -e._y), (this._z = -e._z), (o = -o)) : this.copy(e);
            if (o >= 1) return (this._w = s), (this._x = n), (this._y = r), (this._z = i), this;
            var u = Math.acos(o),
                a = Math.sqrt(1 - o * o);
            if (Math.abs(a) < 0.001) return (this._w = 0.5 * (s + this._w)), (this._x = 0.5 * (n + this._x)), (this._y = 0.5 * (r + this._y)), (this._z = 0.5 * (i + this._z)), this;
            var f = Math.sin((1 - t) * u) / a,
                l = Math.sin(t * u) / a;
            return (this._w = s * f + this._w * l), (this._x = n * f + this._x * l), (this._y = r * f + this._y * l), (this._z = i * f + this._z * l), this._updateEuler(), this;
        },
        equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
        },
        fromArray: function (e) {
            return (this._x = e[0]), (this._y = e[1]), (this._z = e[2]), (this._w = e[3]), this._updateEuler(), this;
        },
        toArray: function () {
            return [this._x, this._y, this._z, this._w];
        },
        clone: function () {
            return new THREE.Quaternion(this._x, this._y, this._z, this._w);
        },
    }),
    (THREE.Quaternion.slerp = function (e, t, n, r) {
        return n.copy(e).slerp(t, r);
    }),
    (THREE.Vector2 = function (e, t) {
        (this.x = e || 0), (this.y = t || 0);
    }),
    (THREE.Vector2.prototype = {
        constructor: THREE.Vector2,
        set: function (e, t) {
            return (this.x = e), (this.y = t), this;
        },
        setX: function (e) {
            return (this.x = e), this;
        },
        setY: function (e) {
            return (this.y = e), this;
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e);
            }
        },
        copy: function (e) {
            return (this.x = e.x), (this.y = e.y), this;
        },
        add: function (e, t) {
            return t !== undefined ? (console.warn("DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : ((this.x += e.x), (this.y += e.y), this);
        },
        addVectors: function (e, t) {
            return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        },
        addScalar: function (e) {
            return (this.x += e), (this.y += e), this;
        },
        sub: function (e, t) {
            return t !== undefined ? (console.warn("DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : ((this.x -= e.x), (this.y -= e.y), this);
        },
        subVectors: function (e, t) {
            return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        },
        multiplyScalar: function (e) {
            return (this.x *= e), (this.y *= e), this;
        },
        divideScalar: function (e) {
            if (e !== 0) {
                var t = 1 / e;
                (this.x *= t), (this.y *= t);
            } else (this.x = 0), (this.y = 0);
            return this;
        },
        min: function (e) {
            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this;
        },
        max: function (e) {
            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this;
        },
        clamp: function (e, t) {
            return this.x < e.x ? (this.x = e.x) : this.x > t.x && (this.x = t.x), this.y < e.y ? (this.y = e.y) : this.y > t.y && (this.y = t.y), this;
        },
        negate: function () {
            return this.multiplyScalar(-1);
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y;
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y;
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        normalize: function () {
            return this.divideScalar(this.length());
        },
        distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e));
        },
        distanceToSquared: function (e) {
            var t = this.x - e.x,
                n = this.y - e.y;
            return t * t + n * n;
        },
        setLength: function (e) {
            var t = this.length();
            return t !== 0 && e !== t && this.multiplyScalar(e / t), this;
        },
        lerp: function (e, t) {
            return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y;
        },
        fromArray: function (e) {
            return (this.x = e[0]), (this.y = e[1]), this;
        },
        toArray: function () {
            return [this.x, this.y];
        },
        clone: function () {
            return new THREE.Vector2(this.x, this.y);
        },
    }),
    (THREE.Vector3 = function (e, t, n) {
        (this.x = e || 0), (this.y = t || 0), (this.z = n || 0);
    }),
    (THREE.Vector3.prototype = {
        constructor: THREE.Vector3,
        set: function (e, t, n) {
            return (this.x = e), (this.y = t), (this.z = n), this;
        },
        setX: function (e) {
            return (this.x = e), this;
        },
        setY: function (e) {
            return (this.y = e), this;
        },
        setZ: function (e) {
            return (this.z = e), this;
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e);
            }
        },
        copy: function (e) {
            return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        },
        add: function (e, t) {
            return t !== undefined ? (console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
        },
        addScalar: function (e) {
            return (this.x += e), (this.y += e), (this.z += e), this;
        },
        addVectors: function (e, t) {
            return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this;
        },
        sub: function (e, t) {
            return t !== undefined ? (console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
        },
        subVectors: function (e, t) {
            return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this;
        },
        multiply: function (e, t) {
            return t !== undefined
                ? (console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t))
                : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
        },
        multiplyScalar: function (e) {
            return (this.x *= e), (this.y *= e), (this.z *= e), this;
        },
        multiplyVectors: function (e, t) {
            return (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this;
        },
        applyMatrix3: function (e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements;
            return (this.x = i[0] * t + i[3] * n + i[6] * r), (this.y = i[1] * t + i[4] * n + i[7] * r), (this.z = i[2] * t + i[5] * n + i[8] * r), this;
        },
        applyMatrix4: function (e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements;
            return (this.x = i[0] * t + i[4] * n + i[8] * r + i[12]), (this.y = i[1] * t + i[5] * n + i[9] * r + i[13]), (this.z = i[2] * t + i[6] * n + i[10] * r + i[14]), this;
        },
        applyProjection: function (e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements,
                s = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
            return (this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * s), (this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * s), (this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * s), this;
        },
        applyQuaternion: function (e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.x,
                s = e.y,
                o = e.z,
                u = e.w,
                a = u * t + s * r - o * n,
                f = u * n + o * t - i * r,
                l = u * r + i * n - s * t,
                c = -i * t - s * n - o * r;
            return (this.x = a * u + c * -i + f * -o - l * -s), (this.y = f * u + c * -s + l * -i - a * -o), (this.z = l * u + c * -o + a * -s - f * -i), this;
        },
        transformDirection: function (e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements;
            return (this.x = i[0] * t + i[4] * n + i[8] * r), (this.y = i[1] * t + i[5] * n + i[9] * r), (this.z = i[2] * t + i[6] * n + i[10] * r), this.normalize(), this;
        },
        divide: function (e) {
            return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        },
        divideScalar: function (e) {
            if (e !== 0) {
                var t = 1 / e;
                (this.x *= t), (this.y *= t), (this.z *= t);
            } else (this.x = 0), (this.y = 0), (this.z = 0);
            return this;
        },
        min: function (e) {
            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this;
        },
        max: function (e) {
            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this;
        },
        clamp: function (e, t) {
            return this.x < e.x ? (this.x = e.x) : this.x > t.x && (this.x = t.x), this.y < e.y ? (this.y = e.y) : this.y > t.y && (this.y = t.y), this.z < e.z ? (this.z = e.z) : this.z > t.z && (this.z = t.z), this;
        },
        negate: function () {
            return this.multiplyScalar(-1);
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z;
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },
        normalize: function () {
            return this.divideScalar(this.length());
        },
        setLength: function (e) {
            var t = this.length();
            return t !== 0 && e !== t && this.multiplyScalar(e / t), this;
        },
        lerp: function (e, t) {
            return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), this;
        },
        cross: function (e, t) {
            if (t !== undefined) return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t);
            var n = this.x,
                r = this.y,
                i = this.z;
            return (this.x = r * e.z - i * e.y), (this.y = i * e.x - n * e.z), (this.z = n * e.y - r * e.x), this;
        },
        crossVectors: function (e, t) {
            var n = e.x,
                r = e.y,
                i = e.z,
                s = t.x,
                o = t.y,
                u = t.z;
            return (this.x = r * u - i * o), (this.y = i * s - n * u), (this.z = n * o - r * s), this;
        },
        angleTo: function (e) {
            var t = this.dot(e) / (this.length() * e.length());
            return Math.acos(THREE.Math.clamp(t, -1, 1));
        },
        distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e));
        },
        distanceToSquared: function (e) {
            var t = this.x - e.x,
                n = this.y - e.y,
                r = this.z - e.z;
            return t * t + n * n + r * r;
        },
        setEulerFromRotationMatrix: function (e, t) {
            console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.");
        },
        setEulerFromQuaternion: function (e, t) {
            console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.");
        },
        getPositionFromMatrix: function (e) {
            return (this.x = e.elements[12]), (this.y = e.elements[13]), (this.z = e.elements[14]), this;
        },
        getScaleFromMatrix: function (e) {
            var t = this.set(e.elements[0], e.elements[1], e.elements[2]).length(),
                n = this.set(e.elements[4], e.elements[5], e.elements[6]).length(),
                r = this.set(e.elements[8], e.elements[9], e.elements[10]).length();
            return (this.x = t), (this.y = n), (this.z = r), this;
        },
        getColumnFromMatrix: function (e, t) {
            var n = e * 4,
                r = t.elements;
            return (this.x = r[n]), (this.y = r[n + 1]), (this.z = r[n + 2]), this;
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z;
        },
        fromArray: function (e) {
            return (this.x = e[0]), (this.y = e[1]), (this.z = e[2]), this;
        },
        toArray: function () {
            return [this.x, this.y, this.z];
        },
        clone: function () {
            return new THREE.Vector3(this.x, this.y, this.z);
        },
    }),
    THREE.extend(THREE.Vector3.prototype, {
        applyEuler: (function () {
            var e = new THREE.Quaternion();
            return function (t) {
                return t instanceof THREE.Euler == 0 && console.error("ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code."), this.applyQuaternion(e.setFromEuler(t)), this;
            };
        })(),
        applyAxisAngle: (function () {
            var e = new THREE.Quaternion();
            return function (t, n) {
                return this.applyQuaternion(e.setFromAxisAngle(t, n)), this;
            };
        })(),
        projectOnVector: (function () {
            var e = new THREE.Vector3();
            return function (t) {
                e.copy(t).normalize();
                var n = this.dot(e);
                return this.copy(e).multiplyScalar(n);
            };
        })(),
        projectOnPlane: (function () {
            var e = new THREE.Vector3();
            return function (t) {
                return e.copy(this).projectOnVector(t), this.sub(e);
            };
        })(),
        reflect: (function () {
            var e = new THREE.Vector3();
            return function (t) {
                return e.copy(this).projectOnVector(t).multiplyScalar(2), this.subVectors(e, this);
            };
        })(),
    }),
    (THREE.Vector4 = function (e, t, n, r) {
        (this.x = e || 0), (this.y = t || 0), (this.z = n || 0), (this.w = r !== undefined ? r : 1);
    }),
    (THREE.Vector4.prototype = {
        constructor: THREE.Vector4,
        set: function (e, t, n, r) {
            return (this.x = e), (this.y = t), (this.z = n), (this.w = r), this;
        },
        setX: function (e) {
            return (this.x = e), this;
        },
        setY: function (e) {
            return (this.y = e), this;
        },
        setZ: function (e) {
            return (this.z = e), this;
        },
        setW: function (e) {
            return (this.w = e), this;
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e);
            }
        },
        copy: function (e) {
            return (this.x = e.x), (this.y = e.y), (this.z = e.z), (this.w = e.w !== undefined ? e.w : 1), this;
        },
        add: function (e, t) {
            return t !== undefined
                ? (console.warn("DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t))
                : ((this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this);
        },
        addScalar: function (e) {
            return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
        },
        addVectors: function (e, t) {
            return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), (this.w = e.w + t.w), this;
        },
        sub: function (e, t) {
            return t !== undefined
                ? (console.warn("DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t))
                : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this);
        },
        subVectors: function (e, t) {
            return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), (this.w = e.w - t.w), this;
        },
        multiplyScalar: function (e) {
            return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
        },
        applyMatrix4: function (e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = this.w,
                s = e.elements;
            return (
                (this.x = s[0] * t + s[4] * n + s[8] * r + s[12] * i),
                    (this.y = s[1] * t + s[5] * n + s[9] * r + s[13] * i),
                    (this.z = s[2] * t + s[6] * n + s[10] * r + s[14] * i),
                    (this.w = s[3] * t + s[7] * n + s[11] * r + s[15] * i),
                    this
            );
        },
        divideScalar: function (e) {
            if (e !== 0) {
                var t = 1 / e;
                (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t);
            } else (this.x = 0), (this.y = 0), (this.z = 0), (this.w = 1);
            return this;
        },
        setAxisAngleFromQuaternion: function (e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? ((this.x = 1), (this.y = 0), (this.z = 0)) : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)), this;
        },
        setAxisAngleFromRotationMatrix: function (e) {
            var t,
                n,
                r,
                i,
                s = 0.01,
                o = 0.1,
                u = e.elements,
                a = u[0],
                f = u[4],
                l = u[8],
                c = u[1],
                h = u[5],
                p = u[9],
                d = u[2],
                v = u[6],
                m = u[10];
            if (Math.abs(f - c) < s && Math.abs(l - d) < s && Math.abs(p - v) < s) {
                if (Math.abs(f + c) < o && Math.abs(l + d) < o && Math.abs(p + v) < o && Math.abs(a + h + m - 3) < o) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                var g = (a + 1) / 2,
                    y = (h + 1) / 2,
                    b = (m + 1) / 2,
                    w = (f + c) / 4,
                    E = (l + d) / 4,
                    S = (p + v) / 4;
                return (
                    g > y && g > b
                        ? g < s
                        ? ((n = 0), (r = 0.707106781), (i = 0.707106781))
                        : ((n = Math.sqrt(g)), (r = w / n), (i = E / n))
                        : y > b
                        ? y < s
                            ? ((n = 0.707106781), (r = 0), (i = 0.707106781))
                            : ((r = Math.sqrt(y)), (n = w / r), (i = S / r))
                        : b < s
                            ? ((n = 0.707106781), (r = 0.707106781), (i = 0))
                            : ((i = Math.sqrt(b)), (n = E / i), (r = S / i)),
                        this.set(n, r, i, t),
                        this
                );
            }
            var x = Math.sqrt((v - p) * (v - p) + (l - d) * (l - d) + (c - f) * (c - f));
            return Math.abs(x) < 0.001 && (x = 1), (this.x = (v - p) / x), (this.y = (l - d) / x), (this.z = (c - f) / x), (this.w = Math.acos((a + h + m - 1) / 2)), this;
        },
        min: function (e) {
            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this.w > e.w && (this.w = e.w), this;
        },
        max: function (e) {
            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this.w < e.w && (this.w = e.w), this;
        },
        clamp: function (e, t) {
            return (
                this.x < e.x ? (this.x = e.x) : this.x > t.x && (this.x = t.x),
                    this.y < e.y ? (this.y = e.y) : this.y > t.y && (this.y = t.y),
                    this.z < e.z ? (this.z = e.z) : this.z > t.z && (this.z = t.z),
                    this.w < e.w ? (this.w = e.w) : this.w > t.w && (this.w = t.w),
                    this
            );
        },
        negate: function () {
            return this.multiplyScalar(-1);
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        },
        lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        },
        normalize: function () {
            return this.divideScalar(this.length());
        },
        setLength: function (e) {
            var t = this.length();
            return t !== 0 && e !== t && this.multiplyScalar(e / t), this;
        },
        lerp: function (e, t) {
            return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), (this.w += (e.w - this.w) * t), this;
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
        },
        fromArray: function (e) {
            return (this.x = e[0]), (this.y = e[1]), (this.z = e[2]), (this.w = e[3]), this;
        },
        toArray: function () {
            return [this.x, this.y, this.z, this.w];
        },
        clone: function () {
            return new THREE.Vector4(this.x, this.y, this.z, this.w);
        },
    }),
    (THREE.Euler = function (e, t, n, r) {
        (this._x = e || 0), (this._y = t || 0), (this._z = n || 0), (this._order = r || THREE.Euler.DefaultOrder);
    }),
    (THREE.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
    (THREE.Euler.DefaultOrder = "XYZ"),
    (THREE.Euler.prototype = {
        constructor: THREE.Euler,
        _x: 0,
        _y: 0,
        _z: 0,
        _order: THREE.Euler.DefaultOrder,
        _quaternion: undefined,
        _updateQuaternion: function () {
            this._quaternion !== undefined && this._quaternion.setFromEuler(this, !1);
        },
        get x() {
            return this._x;
        },
        set x(e) {
            (this._x = e), this._updateQuaternion();
        },
        get y() {
            return this._y;
        },
        set y(e) {
            (this._y = e), this._updateQuaternion();
        },
        get z() {
            return this._z;
        },
        set z(e) {
            (this._z = e), this._updateQuaternion();
        },
        get order() {
            return this._order;
        },
        set order(e) {
            (this._order = e), this._updateQuaternion();
        },
        set: function (e, t, n, r) {
            return (this._x = e), (this._y = t), (this._z = n), (this._order = r || this._order), this._updateQuaternion(), this;
        },
        copy: function (e) {
            return (this._x = e._x), (this._y = e._y), (this._z = e._z), (this._order = e._order), this._updateQuaternion(), this;
        },
        setFromRotationMatrix: function (e, t) {
            function n(e) {
                return Math.min(Math.max(e, -1), 1);
            }
            var r = e.elements,
                i = r[0],
                s = r[4],
                o = r[8],
                u = r[1],
                a = r[5],
                f = r[9],
                l = r[2],
                c = r[6],
                h = r[10];
            return (
                (t = t || this._order),
                    t === "XYZ"
                        ? ((this._y = Math.asin(n(o))), Math.abs(o) < 0.99999 ? ((this._x = Math.atan2(-f, h)), (this._z = Math.atan2(-s, i))) : ((this._x = Math.atan2(c, a)), (this._z = 0)))
                        : t === "YXZ"
                        ? ((this._x = Math.asin(-n(f))), Math.abs(f) < 0.99999 ? ((this._y = Math.atan2(o, h)), (this._z = Math.atan2(u, a))) : ((this._y = Math.atan2(-l, i)), (this._z = 0)))
                        : t === "ZXY"
                            ? ((this._x = Math.asin(n(c))), Math.abs(c) < 0.99999 ? ((this._y = Math.atan2(-l, h)), (this._z = Math.atan2(-s, a))) : ((this._y = 0), (this._z = Math.atan2(u, i))))
                            : t === "ZYX"
                                ? ((this._y = Math.asin(-n(l))), Math.abs(l) < 0.99999 ? ((this._x = Math.atan2(c, h)), (this._z = Math.atan2(u, i))) : ((this._x = 0), (this._z = Math.atan2(-s, a))))
                                : t === "YZX"
                                    ? ((this._z = Math.asin(n(u))), Math.abs(u) < 0.99999 ? ((this._x = Math.atan2(-f, a)), (this._y = Math.atan2(-l, i))) : ((this._x = 0), (this._y = Math.atan2(o, h))))
                                    : t === "XZY"
                                        ? ((this._z = Math.asin(-n(s))), Math.abs(s) < 0.99999 ? ((this._x = Math.atan2(c, a)), (this._y = Math.atan2(o, i))) : ((this._x = Math.atan2(-f, h)), (this._y = 0)))
                                        : console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: " + t),
                    (this._order = t),
                    this._updateQuaternion(),
                    this
            );
        },
        setFromQuaternion: function (e, t, n) {
            function r(e) {
                return Math.min(Math.max(e, -1), 1);
            }
            var i = e.x * e.x,
                s = e.y * e.y,
                o = e.z * e.z,
                u = e.w * e.w;
            return (
                (t = t || this._order),
                    t === "XYZ"
                        ? ((this._x = Math.atan2(2 * (e.x * e.w - e.y * e.z), u - i - s + o)), (this._y = Math.asin(r(2 * (e.x * e.z + e.y * e.w)))), (this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), u + i - s - o)))
                        : t === "YXZ"
                        ? ((this._x = Math.asin(r(2 * (e.x * e.w - e.y * e.z)))), (this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), u - i - s + o)), (this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), u - i + s - o)))
                        : t === "ZXY"
                            ? ((this._x = Math.asin(r(2 * (e.x * e.w + e.y * e.z)))), (this._y = Math.atan2(2 * (e.y * e.w - e.z * e.x), u - i - s + o)), (this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), u - i + s - o)))
                            : t === "ZYX"
                                ? ((this._x = Math.atan2(2 * (e.x * e.w + e.z * e.y), u - i - s + o)), (this._y = Math.asin(r(2 * (e.y * e.w - e.x * e.z)))), (this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), u + i - s - o)))
                                : t === "YZX"
                                    ? ((this._x = Math.atan2(2 * (e.x * e.w - e.z * e.y), u - i + s - o)), (this._y = Math.atan2(2 * (e.y * e.w - e.x * e.z), u + i - s - o)), (this._z = Math.asin(r(2 * (e.x * e.y + e.z * e.w)))))
                                    : t === "XZY"
                                        ? ((this._x = Math.atan2(2 * (e.x * e.w + e.y * e.z), u - i + s - o)), (this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), u + i - s - o)), (this._z = Math.asin(r(2 * (e.z * e.w - e.x * e.y)))))
                                        : console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: " + t),
                    (this._order = t),
                n !== !1 && this._updateQuaternion(),
                    this
            );
        },
        reorder: (function () {
            var e = new THREE.Quaternion();
            return function (t) {
                e.setFromEuler(this), this.setFromQuaternion(e, t);
            };
        })(),
        fromArray: function (e) {
            return (this._x = e[0]), (this._y = e[1]), (this._z = e[2]), e[3] !== undefined && (this._order = e[3]), this._updateQuaternion(), this;
        },
        toArray: function () {
            return [this._x, this._y, this._z, this._order];
        },
        equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
        },
        clone: function () {
            return new THREE.Euler(this._x, this._y, this._z, this._order);
        },
    }),
    (THREE.Line3 = function (e, t) {
        (this.start = e !== undefined ? e : new THREE.Vector3()), (this.end = t !== undefined ? t : new THREE.Vector3());
    }),
    (THREE.Line3.prototype = {
        constructor: THREE.Line3,
        set: function (e, t) {
            return this.start.copy(e), this.end.copy(t), this;
        },
        copy: function (e) {
            return this.start.copy(e.start), this.end.copy(e.end), this;
        },
        center: function (e) {
            var t = e || new THREE.Vector3();
            return t.addVectors(this.start, this.end).multiplyScalar(0.5);
        },
        delta: function (e) {
            var t = e || new THREE.Vector3();
            return t.subVectors(this.end, this.start);
        },
        distanceSq: function () {
            return this.start.distanceToSquared(this.end);
        },
        distance: function () {
            return this.start.distanceTo(this.end);
        },
        at: function (e, t) {
            var n = t || new THREE.Vector3();
            return this.delta(n).multiplyScalar(e).add(this.start);
        },
        closestPointToPointParameter: (function () {
            var e = new THREE.Vector3(),
                t = new THREE.Vector3();
            return function (n, r) {
                e.subVectors(n, this.start), t.subVectors(this.end, this.start);
                var i = t.dot(t),
                    s = t.dot(e),
                    o = s / i;
                return r && (o = THREE.Math.clamp(o, 0, 1)), o;
            };
        })(),
        closestPointToPoint: function (e, t, n) {
            var r = this.closestPointToPointParameter(e, t),
                i = n || new THREE.Vector3();
            return this.delta(i).multiplyScalar(r).add(this.start);
        },
        applyMatrix4: function (e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
        },
        equals: function (e) {
            return e.start.equals(this.start) && e.end.equals(this.end);
        },
        clone: function () {
            return new THREE.Line3().copy(this);
        },
    }),
    (THREE.Box2 = function (e, t) {
        (this.min = e !== undefined ? e : new THREE.Vector2(Infinity, Infinity)), (this.max = t !== undefined ? t : new THREE.Vector2(-Infinity, -Infinity));
    }),
    (THREE.Box2.prototype = {
        constructor: THREE.Box2,
        set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this;
        },
        setFromPoints: function (e) {
            if (e.length > 0) {
                var t = e[0];
                this.min.copy(t), this.max.copy(t);
                for (var n = 1, r = e.length; n < r; n++) (t = e[n]), t.x < this.min.x ? (this.min.x = t.x) : t.x > this.max.x && (this.max.x = t.x), t.y < this.min.y ? (this.min.y = t.y) : t.y > this.max.y && (this.max.y = t.y);
            } else this.makeEmpty();
            return this;
        },
        setFromCenterAndSize: (function () {
            var e = new THREE.Vector2();
            return function (t, n) {
                var r = e.copy(n).multiplyScalar(0.5);
                return this.min.copy(t).sub(r), this.max.copy(t).add(r), this;
            };
        })(),
        copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this;
        },
        makeEmpty: function () {
            return (this.min.x = this.min.y = Infinity), (this.max.x = this.max.y = -Infinity), this;
        },
        empty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y;
        },
        center: function (e) {
            var t = e || new THREE.Vector2();
            return t.addVectors(this.min, this.max).multiplyScalar(0.5);
        },
        size: function (e) {
            var t = e || new THREE.Vector2();
            return t.subVectors(this.max, this.min);
        },
        expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this;
        },
        expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this;
        },
        expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this;
        },
        containsPoint: function (e) {
            return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y ? !1 : !0;
        },
        containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y ? !0 : !1;
        },
        getParameter: function (e) {
            return new THREE.Vector2((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
        },
        isIntersectionBox: function (e) {
            return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y ? !1 : !0;
        },
        clampPoint: function (e, t) {
            var n = t || new THREE.Vector2();
            return n.copy(e).clamp(this.min, this.max);
        },
        distanceToPoint: (function () {
            var e = new THREE.Vector2();
            return function (t) {
                var n = e.copy(t).clamp(this.min, this.max);
                return n.sub(t).length();
            };
        })(),
        intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this;
        },
        union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this;
        },
        translate: function (e) {
            return this.min.add(e), this.max.add(e), this;
        },
        equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max);
        },
        clone: function () {
            return new THREE.Box2().copy(this);
        },
    }),
    (THREE.Box3 = function (e, t) {
        (this.min = e !== undefined ? e : new THREE.Vector3(Infinity, Infinity, Infinity)), (this.max = t !== undefined ? t : new THREE.Vector3(-Infinity, -Infinity, -Infinity));
    }),
    (THREE.Box3.prototype = {
        constructor: THREE.Box3,
        set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this;
        },
        addPoint: function (e) {
            e.x < this.min.x ? (this.min.x = e.x) : e.x > this.max.x && (this.max.x = e.x),
                e.y < this.min.y ? (this.min.y = e.y) : e.y > this.max.y && (this.max.y = e.y),
                e.z < this.min.z ? (this.min.z = e.z) : e.z > this.max.z && (this.max.z = e.z);
        },
        setFromPoints: function (e) {
            if (e.length > 0) {
                var t = e[0];
                this.min.copy(t), this.max.copy(t);
                for (var n = 1, r = e.length; n < r; n++) this.addPoint(e[n]);
            } else this.makeEmpty();
            return this;
        },
        setFromCenterAndSize: (function () {
            var e = new THREE.Vector3();
            return function (t, n) {
                var r = e.copy(n).multiplyScalar(0.5);
                return this.min.copy(t).sub(r), this.max.copy(t).add(r), this;
            };
        })(),
        setFromObject: (function () {
            var e = new THREE.Vector3();
            return function (t) {
                var n = this;
                return (
                    t.updateMatrixWorld(!0),
                        this.makeEmpty(),
                        t.traverse(function (t) {
                            if (t.geometry !== undefined && t.geometry.vertices !== undefined) {
                                var r = t.geometry.vertices;
                                for (var i = 0, s = r.length; i < s; i++) e.copy(r[i]), e.applyMatrix4(t.matrixWorld), n.expandByPoint(e);
                            }
                        }),
                        this
                );
            };
        })(),
        copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this;
        },
        makeEmpty: function () {
            return (this.min.x = this.min.y = this.min.z = Infinity), (this.max.x = this.max.y = this.max.z = -Infinity), this;
        },
        empty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        },
        center: function (e) {
            var t = e || new THREE.Vector3();
            return t.addVectors(this.min, this.max).multiplyScalar(0.5);
        },
        size: function (e) {
            var t = e || new THREE.Vector3();
            return t.subVectors(this.max, this.min);
        },
        expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this;
        },
        expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this;
        },
        expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this;
        },
        containsPoint: function (e) {
            return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z ? !1 : !0;
        },
        containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z ? !0 : !1;
        },
        getParameter: function (e) {
            return new THREE.Vector3((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
        },
        isIntersectionBox: function (e) {
            return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z ? !1 : !0;
        },
        clampPoint: function (e, t) {
            var n = t || new THREE.Vector3();
            return n.copy(e).clamp(this.min, this.max);
        },
        distanceToPoint: (function () {
            var e = new THREE.Vector3();
            return function (t) {
                var n = e.copy(t).clamp(this.min, this.max);
                return n.sub(t).length();
            };
        })(),
        getBoundingSphere: (function () {
            var e = new THREE.Vector3();
            return function (t) {
                var n = t || new THREE.Sphere();
                return (n.center = this.center()), (n.radius = this.size(e).length() * 0.5), n;
            };
        })(),
        intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this;
        },
        union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this;
        },
        applyMatrix4: (function () {
            var e = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
            return function (t) {
                return (
                    e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                        e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                        e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                        e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                        e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                        e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                        e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                        e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                        this.makeEmpty(),
                        this.setFromPoints(e),
                        this
                );
            };
        })(),
        translate: function (e) {
            return this.min.add(e), this.max.add(e), this;
        },
        equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max);
        },
        clone: function () {
            return new THREE.Box3().copy(this);
        },
    }),
(THREE.Matrix3 = function (e, t, n, r, i, s, o, u, a) {
    (this.elements = new Float32Array(9)), this.set(e !== undefined ? e : 1, t || 0, n || 0, r || 0, i !== undefined ? i : 1, s || 0, o || 0, u || 0, a !== undefined ? a : 1);
}),
(THREE.Matrix3.prototype = {
    constructor: THREE.Matrix3,
    set: function (e, t, n, r, i, s, o, u, a) {
        var f = this.elements;
        return (f[0] = e), (f[3] = t), (f[6] = n), (f[1] = r), (f[4] = i), (f[7] = s), (f[2] = o), (f[5] = u), (f[8] = a), this;
    },
    identity: function () {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    },
    copy: function (e) {
        var t = e.elements;
        return this.set(t[0], t[3], t[6], t[1], t[4], t[7], t[2], t[5], t[8]), this;
    },
    multiplyVector3: function (e) {
        return console.warn("DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this);
    },
    multiplyVector3Array: (function () {
        var e = new THREE.Vector3();
        return function (t) {
            for (var n = 0, r = t.length; n < r; n += 3) (e.x = t[n]), (e.y = t[n + 1]), (e.z = t[n + 2]), e.applyMatrix3(this), (t[n] = e.x), (t[n + 1] = e.y), (t[n + 2] = e.z);
            return t;
        };
    })(),
    multiplyScalar: function (e) {
        var t = this.elements;
        return (t[0] *= e), (t[3] *= e), (t[6] *= e), (t[1] *= e), (t[4] *= e), (t[7] *= e), (t[2] *= e), (t[5] *= e), (t[8] *= e), this;
    },
    determinant: function () {
        var e = this.elements,
            t = e[0],
            n = e[1],
            r = e[2],
            i = e[3],
            s = e[4],
            o = e[5],
            u = e[6],
            a = e[7],
            f = e[8];
        return t * s * f - t * o * a - n * i * f + n * o * u + r * i * a - r * s * u;
    },
    getInverse: function (e, t) {
        var n = e.elements,
            r = this.elements;
        (r[0] = n[10] * n[5] - n[6] * n[9]),
            (r[1] = -n[10] * n[1] + n[2] * n[9]),
            (r[2] = n[6] * n[1] - n[2] * n[5]),
            (r[3] = -n[10] * n[4] + n[6] * n[8]),
            (r[4] = n[10] * n[0] - n[2] * n[8]),
            (r[5] = -n[6] * n[0] + n[2] * n[4]),
            (r[6] = n[9] * n[4] - n[5] * n[8]),
            (r[7] = -n[9] * n[0] + n[1] * n[8]),
            (r[8] = n[5] * n[0] - n[1] * n[4]);
        var i = n[0] * r[0] + n[1] * r[3] + n[2] * r[6];
        if (i === 0) {
            var s = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
            if (t || !1) throw new Error(s);
            return console.warn(s), this.identity(), this;
        }
        return this.multiplyScalar(1 / i), this;
    },
    transpose: function () {
        var e,
            t = this.elements;
        return (e = t[1]), (t[1] = t[3]), (t[3] = e), (e = t[2]), (t[2] = t[6]), (t[6] = e), (e = t[5]), (t[5] = t[7]), (t[7] = e), this;
    },
    getNormalMatrix: function (e) {
        return this.getInverse(e).transpose(), this;
    },
    transposeIntoArray: function (e) {
        var t = this.elements;
        return (e[0] = t[0]), (e[1] = t[3]), (e[2] = t[6]), (e[3] = t[1]), (e[4] = t[4]), (e[5] = t[7]), (e[6] = t[2]), (e[7] = t[5]), (e[8] = t[8]), this;
    },
    clone: function () {
        var e = this.elements;
        return new THREE.Matrix3(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]);
    },
}),
(THREE.Matrix4 = function (e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v) {
    this.elements = new Float32Array(16);
    var m = this.elements;
    (m[0] = e !== undefined ? e : 1),
        (m[4] = t || 0),
        (m[8] = n || 0),
        (m[12] = r || 0),
        (m[1] = i || 0),
        (m[5] = s !== undefined ? s : 1),
        (m[9] = o || 0),
        (m[13] = u || 0),
        (m[2] = a || 0),
        (m[6] = f || 0),
        (m[10] = l !== undefined ? l : 1),
        (m[14] = c || 0),
        (m[3] = h || 0),
        (m[7] = p || 0),
        (m[11] = d || 0),
        (m[15] = v !== undefined ? v : 1);
}),
(THREE.Matrix4.prototype = {
    constructor: THREE.Matrix4,
    set: function (e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v) {
        var m = this.elements;
        return (m[0] = e), (m[4] = t), (m[8] = n), (m[12] = r), (m[1] = i), (m[5] = s), (m[9] = o), (m[13] = u), (m[2] = a), (m[6] = f), (m[10] = l), (m[14] = c), (m[3] = h), (m[7] = p), (m[11] = d), (m[15] = v), this;
    },
    identity: function () {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    copy: function (e) {
        return this.elements.set(e.elements), this;
    },
    extractPosition: function (e) {
        return console.warn("DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e);
    },
    copyPosition: function (e) {
        var t = this.elements,
            n = e.elements;
        return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
    },
    extractRotation: (function () {
        var e = new THREE.Vector3();
        return function (t) {
            var n = this.elements,
                r = t.elements,
                i = 1 / e.set(r[0], r[1], r[2]).length(),
                s = 1 / e.set(r[4], r[5], r[6]).length(),
                o = 1 / e.set(r[8], r[9], r[10]).length();
            return (n[0] = r[0] * i), (n[1] = r[1] * i), (n[2] = r[2] * i), (n[4] = r[4] * s), (n[5] = r[5] * s), (n[6] = r[6] * s), (n[8] = r[8] * o), (n[9] = r[9] * o), (n[10] = r[10] * o), this;
        };
    })(),
    makeRotationFromEuler: function (e) {
        e instanceof THREE.Euler == 0 && console.error("ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
        var t = this.elements,
            n = e.x,
            r = e.y,
            i = e.z,
            s = Math.cos(n),
            o = Math.sin(n),
            u = Math.cos(r),
            a = Math.sin(r),
            f = Math.cos(i),
            l = Math.sin(i);
        if (e.order === "XYZ") {
            var c = s * f,
                h = s * l,
                p = o * f,
                d = o * l;
            (t[0] = u * f), (t[4] = -u * l), (t[8] = a), (t[1] = h + p * a), (t[5] = c - d * a), (t[9] = -o * u), (t[2] = d - c * a), (t[6] = p + h * a), (t[10] = s * u);
        } else if (e.order === "YXZ") {
            var v = u * f,
                m = u * l,
                g = a * f,
                y = a * l;
            (t[0] = v + y * o), (t[4] = g * o - m), (t[8] = s * a), (t[1] = s * l), (t[5] = s * f), (t[9] = -o), (t[2] = m * o - g), (t[6] = y + v * o), (t[10] = s * u);
        } else if (e.order === "ZXY") {
            var v = u * f,
                m = u * l,
                g = a * f,
                y = a * l;
            (t[0] = v - y * o), (t[4] = -s * l), (t[8] = g + m * o), (t[1] = m + g * o), (t[5] = s * f), (t[9] = y - v * o), (t[2] = -s * a), (t[6] = o), (t[10] = s * u);
        } else if (e.order === "ZYX") {
            var c = s * f,
                h = s * l,
                p = o * f,
                d = o * l;
            (t[0] = u * f), (t[4] = p * a - h), (t[8] = c * a + d), (t[1] = u * l), (t[5] = d * a + c), (t[9] = h * a - p), (t[2] = -a), (t[6] = o * u), (t[10] = s * u);
        } else if (e.order === "YZX") {
            var b = s * u,
                w = s * a,
                E = o * u,
                S = o * a;
            (t[0] = u * f), (t[4] = S - b * l), (t[8] = E * l + w), (t[1] = l), (t[5] = s * f), (t[9] = -o * f), (t[2] = -a * f), (t[6] = w * l + E), (t[10] = b - S * l);
        } else if (e.order === "XZY") {
            var b = s * u,
                w = s * a,
                E = o * u,
                S = o * a;
            (t[0] = u * f), (t[4] = -l), (t[8] = a * f), (t[1] = b * l + S), (t[5] = s * f), (t[9] = w * l - E), (t[2] = E * l - w), (t[6] = o * f), (t[10] = S * l + b);
        }
        return (t[3] = 0), (t[7] = 0), (t[11] = 0), (t[12] = 0), (t[13] = 0), (t[14] = 0), (t[15] = 1), this;
    },
    setRotationFromQuaternion: function (e) {
        return console.warn("DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code."), this.makeRotationFromQuaternion(e);
    },
    makeRotationFromQuaternion: function (e) {
        var t = this.elements,
            n = e.x,
            r = e.y,
            i = e.z,
            s = e.w,
            o = n + n,
            u = r + r,
            a = i + i,
            f = n * o,
            l = n * u,
            c = n * a,
            h = r * u,
            p = r * a,
            d = i * a,
            v = s * o,
            m = s * u,
            g = s * a;
        return (
            (t[0] = 1 - (h + d)),
                (t[4] = l - g),
                (t[8] = c + m),
                (t[1] = l + g),
                (t[5] = 1 - (f + d)),
                (t[9] = p - v),
                (t[2] = c - m),
                (t[6] = p + v),
                (t[10] = 1 - (f + h)),
                (t[3] = 0),
                (t[7] = 0),
                (t[11] = 0),
                (t[12] = 0),
                (t[13] = 0),
                (t[14] = 0),
                (t[15] = 1),
                this
        );
    },
    lookAt: (function () {
        var e = new THREE.Vector3(),
            t = new THREE.Vector3(),
            n = new THREE.Vector3();
        return function (r, i, s) {
            var o = this.elements;
            return (
                n.subVectors(r, i).normalize(),
                n.length() === 0 && (n.z = 1),
                    e.crossVectors(s, n).normalize(),
                e.length() === 0 && ((n.x += 1e-4), e.crossVectors(s, n).normalize()),
                    t.crossVectors(n, e),
                    (o[0] = e.x),
                    (o[4] = t.x),
                    (o[8] = n.x),
                    (o[1] = e.y),
                    (o[5] = t.y),
                    (o[9] = n.y),
                    (o[2] = e.z),
                    (o[6] = t.z),
                    (o[10] = n.z),
                    this
            );
        };
    })(),
    multiply: function (e, t) {
        return t !== undefined ? (console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e);
    },
    multiplyMatrices: function (e, t) {
        var n = e.elements,
            r = t.elements,
            i = this.elements,
            s = n[0],
            o = n[4],
            u = n[8],
            a = n[12],
            f = n[1],
            l = n[5],
            c = n[9],
            h = n[13],
            p = n[2],
            d = n[6],
            v = n[10],
            m = n[14],
            g = n[3],
            y = n[7],
            b = n[11],
            w = n[15],
            E = r[0],
            S = r[4],
            x = r[8],
            T = r[12],
            N = r[1],
            C = r[5],
            k = r[9],
            L = r[13],
            A = r[2],
            O = r[6],
            M = r[10],
            _ = r[14],
            D = r[3],
            P = r[7],
            H = r[11],
            B = r[15];
        return (
            (i[0] = s * E + o * N + u * A + a * D),
                (i[4] = s * S + o * C + u * O + a * P),
                (i[8] = s * x + o * k + u * M + a * H),
                (i[12] = s * T + o * L + u * _ + a * B),
                (i[1] = f * E + l * N + c * A + h * D),
                (i[5] = f * S + l * C + c * O + h * P),
                (i[9] = f * x + l * k + c * M + h * H),
                (i[13] = f * T + l * L + c * _ + h * B),
                (i[2] = p * E + d * N + v * A + m * D),
                (i[6] = p * S + d * C + v * O + m * P),
                (i[10] = p * x + d * k + v * M + m * H),
                (i[14] = p * T + d * L + v * _ + m * B),
                (i[3] = g * E + y * N + b * A + w * D),
                (i[7] = g * S + y * C + b * O + w * P),
                (i[11] = g * x + y * k + b * M + w * H),
                (i[15] = g * T + y * L + b * _ + w * B),
                this
        );
    },
    multiplyToArray: function (e, t, n) {
        var r = this.elements;
        return (
            this.multiplyMatrices(e, t),
                (n[0] = r[0]),
                (n[1] = r[1]),
                (n[2] = r[2]),
                (n[3] = r[3]),
                (n[4] = r[4]),
                (n[5] = r[5]),
                (n[6] = r[6]),
                (n[7] = r[7]),
                (n[8] = r[8]),
                (n[9] = r[9]),
                (n[10] = r[10]),
                (n[11] = r[11]),
                (n[12] = r[12]),
                (n[13] = r[13]),
                (n[14] = r[14]),
                (n[15] = r[15]),
                this
        );
    },
    multiplyScalar: function (e) {
        var t = this.elements;
        return (t[0] *= e), (t[4] *= e), (t[8] *= e), (t[12] *= e), (t[1] *= e), (t[5] *= e), (t[9] *= e), (t[13] *= e), (t[2] *= e), (t[6] *= e), (t[10] *= e), (t[14] *= e), (t[3] *= e), (t[7] *= e), (t[11] *= e), (t[15] *= e), this;
    },
    multiplyVector3: function (e) {
        return console.warn("DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), e.applyProjection(this);
    },
    multiplyVector4: function (e) {
        return console.warn("DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
    },
    multiplyVector3Array: (function () {
        var e = new THREE.Vector3();
        return function (t) {
            for (var n = 0, r = t.length; n < r; n += 3) (e.x = t[n]), (e.y = t[n + 1]), (e.z = t[n + 2]), e.applyProjection(this), (t[n] = e.x), (t[n + 1] = e.y), (t[n + 2] = e.z);
            return t;
        };
    })(),
    rotateAxis: function (e) {
        console.warn("DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this);
    },
    crossVector: function (e) {
        return console.warn("DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
    },
    determinant: function () {
        var e = this.elements,
            t = e[0],
            n = e[4],
            r = e[8],
            i = e[12],
            s = e[1],
            o = e[5],
            u = e[9],
            a = e[13],
            f = e[2],
            l = e[6],
            c = e[10],
            h = e[14],
            p = e[3],
            d = e[7],
            v = e[11],
            m = e[15];
        return (
            p * (+i * u * l - r * a * l - i * o * c + n * a * c + r * o * h - n * u * h) +
            d * (+t * u * h - t * a * c + i * s * c - r * s * h + r * a * f - i * u * f) +
            v * (+t * a * l - t * o * h - i * s * l + n * s * h + i * o * f - n * a * f) +
            m * (-r * o * f - t * u * l + t * o * c + r * s * l - n * s * c + n * u * f)
        );
    },
    transpose: function () {
        var e = this.elements,
            t;
        return (
            (t = e[1]),
                (e[1] = e[4]),
                (e[4] = t),
                (t = e[2]),
                (e[2] = e[8]),
                (e[8] = t),
                (t = e[6]),
                (e[6] = e[9]),
                (e[9] = t),
                (t = e[3]),
                (e[3] = e[12]),
                (e[12] = t),
                (t = e[7]),
                (e[7] = e[13]),
                (e[13] = t),
                (t = e[11]),
                (e[11] = e[14]),
                (e[14] = t),
                this
        );
    },
    flattenToArray: function (e) {
        var t = this.elements;
        return (
            (e[0] = t[0]),
                (e[1] = t[1]),
                (e[2] = t[2]),
                (e[3] = t[3]),
                (e[4] = t[4]),
                (e[5] = t[5]),
                (e[6] = t[6]),
                (e[7] = t[7]),
                (e[8] = t[8]),
                (e[9] = t[9]),
                (e[10] = t[10]),
                (e[11] = t[11]),
                (e[12] = t[12]),
                (e[13] = t[13]),
                (e[14] = t[14]),
                (e[15] = t[15]),
                e
        );
    },
    flattenToArrayOffset: function (e, t) {
        var n = this.elements;
        return (
            (e[t] = n[0]),
                (e[t + 1] = n[1]),
                (e[t + 2] = n[2]),
                (e[t + 3] = n[3]),
                (e[t + 4] = n[4]),
                (e[t + 5] = n[5]),
                (e[t + 6] = n[6]),
                (e[t + 7] = n[7]),
                (e[t + 8] = n[8]),
                (e[t + 9] = n[9]),
                (e[t + 10] = n[10]),
                (e[t + 11] = n[11]),
                (e[t + 12] = n[12]),
                (e[t + 13] = n[13]),
                (e[t + 14] = n[14]),
                (e[t + 15] = n[15]),
                e
        );
    },
    getPosition: (function () {
        var e = new THREE.Vector3();
        return function () {
            console.warn("DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.");
            var t = this.elements;
            return e.set(t[12], t[13], t[14]);
        };
    })(),
    setPosition: function (e) {
        var t = this.elements;
        return (t[12] = e.x), (t[13] = e.y), (t[14] = e.z), this;
    },
    getInverse: function (e, t) {
        var n = this.elements,
            r = e.elements,
            i = r[0],
            s = r[4],
            o = r[8],
            u = r[12],
            a = r[1],
            f = r[5],
            l = r[9],
            c = r[13],
            h = r[2],
            p = r[6],
            d = r[10],
            v = r[14],
            m = r[3],
            g = r[7],
            y = r[11],
            b = r[15];
        (n[0] = l * v * g - c * d * g + c * p * y - f * v * y - l * p * b + f * d * b),
            (n[4] = u * d * g - o * v * g - u * p * y + s * v * y + o * p * b - s * d * b),
            (n[8] = o * c * g - u * l * g + u * f * y - s * c * y - o * f * b + s * l * b),
            (n[12] = u * l * p - o * c * p - u * f * d + s * c * d + o * f * v - s * l * v),
            (n[1] = c * d * m - l * v * m - c * h * y + a * v * y + l * h * b - a * d * b),
            (n[5] = o * v * m - u * d * m + u * h * y - i * v * y - o * h * b + i * d * b),
            (n[9] = u * l * m - o * c * m - u * a * y + i * c * y + o * a * b - i * l * b),
            (n[13] = o * c * h - u * l * h + u * a * d - i * c * d - o * a * v + i * l * v),
            (n[2] = f * v * m - c * p * m + c * h * g - a * v * g - f * h * b + a * p * b),
            (n[6] = u * p * m - s * v * m - u * h * g + i * v * g + s * h * b - i * p * b),
            (n[10] = s * c * m - u * f * m + u * a * g - i * c * g - s * a * b + i * f * b),
            (n[14] = u * f * h - s * c * h - u * a * p + i * c * p + s * a * v - i * f * v),
            (n[3] = l * p * m - f * d * m - l * h * g + a * d * g + f * h * y - a * p * y),
            (n[7] = s * d * m - o * p * m + o * h * g - i * d * g - s * h * y + i * p * y),
            (n[11] = o * f * m - s * l * m - o * a * g + i * l * g + s * a * y - i * f * y),
            (n[15] = s * l * h - o * f * h + o * a * p - i * l * p - s * a * d + i * f * d);
        var w = i * n[0] + a * n[4] + h * n[8] + m * n[12];
        if (w == 0) {
            var E = "Matrix4.getInverse(): can't invert matrix, determinant is 0";
            if (t || !1) throw new Error(E);
            return console.warn(E), this.identity(), this;
        }
        return this.multiplyScalar(1 / w), this;
    },
    translate: function (e) {
        console.warn("DEPRECATED: Matrix4's .translate() has been removed.");
    },
    rotateX: function (e) {
        console.warn("DEPRECATED: Matrix4's .rotateX() has been removed.");
    },
    rotateY: function (e) {
        console.warn("DEPRECATED: Matrix4's .rotateY() has been removed.");
    },
    rotateZ: function (e) {
        console.warn("DEPRECATED: Matrix4's .rotateZ() has been removed.");
    },
    rotateByAxis: function (e, t) {
        console.warn("DEPRECATED: Matrix4's .rotateByAxis() has been removed.");
    },
    scale: function (e) {
        var t = this.elements,
            n = e.x,
            r = e.y,
            i = e.z;
        return (t[0] *= n), (t[4] *= r), (t[8] *= i), (t[1] *= n), (t[5] *= r), (t[9] *= i), (t[2] *= n), (t[6] *= r), (t[10] *= i), (t[3] *= n), (t[7] *= r), (t[11] *= i), this;
    },
    getMaxScaleOnAxis: function () {
        var e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, Math.max(n, r)));
    },
    makeTranslation: function (e, t, n) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
    },
    makeRotationX: function (e) {
        var t = Math.cos(e),
            n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
    },
    makeRotationY: function (e) {
        var t = Math.cos(e),
            n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
    },
    makeRotationZ: function (e) {
        var t = Math.cos(e),
            n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    makeRotationAxis: function (e, t) {
        var n = Math.cos(t),
            r = Math.sin(t),
            i = 1 - n,
            s = e.x,
            o = e.y,
            u = e.z,
            a = i * s,
            f = i * o;
        return this.set(a * s + n, a * o - r * u, a * u + r * o, 0, a * o + r * u, f * o + n, f * u - r * s, 0, a * u - r * o, f * u + r * s, i * u * u + n, 0, 0, 0, 0, 1), this;
    },
    makeScale: function (e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    },
    compose: function (e, t, n) {
        return this.makeRotationFromQuaternion(t), this.scale(n), this.setPosition(e), this;
    },
    decompose: (function () {
        var e = new THREE.Vector3(),
            t = new THREE.Matrix4();
        return function (n, r, i) {
            var s = this.elements,
                o = e.set(s[0], s[1], s[2]).length(),
                u = e.set(s[4], s[5], s[6]).length(),
                a = e.set(s[8], s[9], s[10]).length();
            (n.x = s[12]), (n.y = s[13]), (n.z = s[14]), t.elements.set(this.elements);
            var f = 1 / o,
                l = 1 / u,
                c = 1 / a;
            return (
                (t.elements[0] *= f),
                    (t.elements[1] *= f),
                    (t.elements[2] *= f),
                    (t.elements[4] *= l),
                    (t.elements[5] *= l),
                    (t.elements[6] *= l),
                    (t.elements[8] *= c),
                    (t.elements[9] *= c),
                    (t.elements[10] *= c),
                    r.setFromRotationMatrix(t),
                    (i.x = o),
                    (i.y = u),
                    (i.z = a),
                    this
            );
        };
    })(),
    makeFrustum: function (e, t, n, r, i, s) {
        var o = this.elements,
            u = (2 * i) / (t - e),
            a = (2 * i) / (r - n),
            f = (t + e) / (t - e),
            l = (r + n) / (r - n),
            c = -(s + i) / (s - i),
            h = (-2 * s * i) / (s - i);
        return (o[0] = u), (o[4] = 0), (o[8] = f), (o[12] = 0), (o[1] = 0), (o[5] = a), (o[9] = l), (o[13] = 0), (o[2] = 0), (o[6] = 0), (o[10] = c), (o[14] = h), (o[3] = 0), (o[7] = 0), (o[11] = -1), (o[15] = 0), this;
    },
    makePerspective: function (e, t, n, r) {
        var i = n * Math.tan(THREE.Math.degToRad(e * 0.5)),
            s = -i,
            o = s * t,
            u = i * t;
        return this.makeFrustum(o, u, s, i, n, r);
    },
    makeOrthographic: function (e, t, n, r, i, s) {
        var o = this.elements,
            u = t - e,
            a = n - r,
            f = s - i,
            l = (t + e) / u,
            c = (n + r) / a,
            h = (s + i) / f;
        return (o[0] = 2 / u), (o[4] = 0), (o[8] = 0), (o[12] = -l), (o[1] = 0), (o[5] = 2 / a), (o[9] = 0), (o[13] = -c), (o[2] = 0), (o[6] = 0), (o[10] = -2 / f), (o[14] = -h), (o[3] = 0), (o[7] = 0), (o[11] = 0), (o[15] = 1), this;
    },
    fromArray: function (e) {
        return this.elements.set(e), this;
    },
    toArray: function () {
        var e = this.elements;
        return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]];
    },
    clone: function () {
        var e = this.elements;
        return new THREE.Matrix4(e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15]);
    },
}),
(THREE.Ray = function (e, t) {
    (this.origin = e !== undefined ? e : new THREE.Vector3()), (this.direction = t !== undefined ? t : new THREE.Vector3());
}),
(THREE.Ray.prototype = {
    constructor: THREE.Ray,
    set: function (e, t) {
        return this.origin.copy(e), this.direction.copy(t), this;
    },
    copy: function (e) {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
    },
    at: function (e, t) {
        var n = t || new THREE.Vector3();
        return n.copy(this.direction).multiplyScalar(e).add(this.origin);
    },
    recast: (function () {
        var e = new THREE.Vector3();
        return function (t) {
            return this.origin.copy(this.at(t, e)), this;
        };
    })(),
    closestPointToPoint: function (e, t) {
        var n = t || new THREE.Vector3();
        n.subVectors(e, this.origin);
        var r = n.dot(this.direction);
        return r < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin);
    },
    distanceToPoint: (function () {
        var e = new THREE.Vector3();
        return function (t) {
            var n = e.subVectors(t, this.origin).dot(this.direction);
            return n < 0 ? this.origin.distanceTo(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceTo(t));
        };
    })(),
    distanceSqToSegment: function (e, t, n, r) {
        var i = e.clone().add(t).multiplyScalar(0.5),
            s = t.clone().sub(e).normalize(),
            o = e.distanceTo(t) * 0.5,
            u = this.origin.clone().sub(i),
            a = -this.direction.dot(s),
            f = u.dot(this.direction),
            l = -u.dot(s),
            c = u.lengthSq(),
            h = Math.abs(1 - a * a),
            p,
            d,
            v,
            m;
        if (h >= 0) {
            (p = a * l - f), (d = a * f - l), (m = o * h);
            if (p >= 0)
                if (d >= -m)
                    if (d <= m) {
                        var g = 1 / h;
                        (p *= g), (d *= g), (v = p * (p + a * d + 2 * f) + d * (a * p + d + 2 * l) + c);
                    } else (d = o), (p = Math.max(0, -(a * d + f))), (v = -p * p + d * (d + 2 * l) + c);
                else (d = -o), (p = Math.max(0, -(a * d + f))), (v = -p * p + d * (d + 2 * l) + c);
            else
                d <= -m
                    ? ((p = Math.max(0, -(-a * o + f))), (d = p > 0 ? -o : Math.min(Math.max(-o, -l), o)), (v = -p * p + d * (d + 2 * l) + c))
                    : d <= m
                    ? ((p = 0), (d = Math.min(Math.max(-o, -l), o)), (v = d * (d + 2 * l) + c))
                    : ((p = Math.max(0, -(a * o + f))), (d = p > 0 ? o : Math.min(Math.max(-o, -l), o)), (v = -p * p + d * (d + 2 * l) + c));
        } else (d = a > 0 ? -o : o), (p = Math.max(0, -(a * d + f))), (v = -p * p + d * (d + 2 * l) + c);
        return n && n.copy(this.direction.clone().multiplyScalar(p).add(this.origin)), r && r.copy(s.clone().multiplyScalar(d).add(i)), v;
    },
    isIntersectionSphere: function (e) {
        return this.distanceToPoint(e.center) <= e.radius;
    },
    isIntersectionPlane: function (e) {
        var t = e.distanceToPoint(this.origin);
        if (t === 0) return !0;
        var n = e.normal.dot(this.direction);
        return n * t < 0 ? !0 : !1;
    },
    distanceToPlane: function (e) {
        var t = e.normal.dot(this.direction);
        if (t == 0) return e.distanceToPoint(this.origin) == 0 ? 0 : null;
        var n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null;
    },
    intersectPlane: function (e, t) {
        var n = this.distanceToPlane(e);
        return n === null ? null : this.at(n, t);
    },
    isIntersectionBox: (function () {
        var e = new THREE.Vector3();
        return function (t) {
            return this.intersectBox(t, e) !== null;
        };
    })(),
    intersectBox: function (e, t) {
        var n,
            r,
            i,
            s,
            o,
            u,
            a = 1 / this.direction.x,
            f = 1 / this.direction.y,
            l = 1 / this.direction.z,
            c = this.origin;
        a >= 0 ? ((n = (e.min.x - c.x) * a), (r = (e.max.x - c.x) * a)) : ((n = (e.max.x - c.x) * a), (r = (e.min.x - c.x) * a)),
            f >= 0 ? ((i = (e.min.y - c.y) * f), (s = (e.max.y - c.y) * f)) : ((i = (e.max.y - c.y) * f), (s = (e.min.y - c.y) * f));
        if (n > s || i > r) return null;
        if (i > n || n !== n) n = i;
        if (s < r || r !== r) r = s;
        l >= 0 ? ((o = (e.min.z - c.z) * l), (u = (e.max.z - c.z) * l)) : ((o = (e.max.z - c.z) * l), (u = (e.min.z - c.z) * l));
        if (n > u || o > r) return null;
        if (o > n || n !== n) n = o;
        if (u < r || r !== r) r = u;
        return r < 0 ? null : this.at(n >= 0 ? n : r, t);
    },
    intersectTriangle: (function () {
        var e = new THREE.Vector3(),
            t = new THREE.Vector3(),
            n = new THREE.Vector3(),
            r = new THREE.Vector3();
        return function (i, s, o, u, a) {
            t.subVectors(s, i), n.subVectors(o, i), r.crossVectors(t, n);
            var f = this.direction.dot(r),
                l;
            if (f > 0) {
                if (u) return null;
                l = 1;
            } else {
                if (!(f < 0)) return null;
                (l = -1), (f = -f);
            }
            e.subVectors(this.origin, i);
            var c = l * this.direction.dot(n.crossVectors(e, n));
            if (c < 0) return null;
            var h = l * this.direction.dot(t.cross(e));
            if (h < 0) return null;
            if (c + h > f) return null;
            var p = -l * e.dot(r);
            return p < 0 ? null : this.at(p / f, a);
        };
    })(),
    applyMatrix4: function (e) {
        return this.direction.add(this.origin).applyMatrix4(e), this.origin.applyMatrix4(e), this.direction.sub(this.origin), this.direction.normalize(), this;
    },
    equals: function (e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction);
    },
    clone: function () {
        return new THREE.Ray().copy(this);
    },
}),
(THREE.Sphere = function (e, t) {
    (this.center = e !== undefined ? e : new THREE.Vector3()), (this.radius = t !== undefined ? t : 0);
}),
(THREE.Sphere.prototype = {
    constructor: THREE.Sphere,
    set: function (e, t) {
        return this.center.copy(e), (this.radius = t), this;
    },
    setFromPoints: (function () {
        var e = new THREE.Box3();
        return function (t, n) {
            var r = this.center;
            n !== undefined ? r.copy(n) : e.setFromPoints(t).center(r);
            var i = 0;
            for (var s = 0, o = t.length; s < o; s++) i = Math.max(i, r.distanceToSquared(t[s]));
            return (this.radius = Math.sqrt(i)), this;
        };
    })(),
    copy: function (e) {
        return this.center.copy(e.center), (this.radius = e.radius), this;
    },
    empty: function () {
        return this.radius <= 0;
    },
    containsPoint: function (e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function (e) {
        return e.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function (e) {
        var t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t;
    },
    clampPoint: function (e, t) {
        var n = this.center.distanceToSquared(e),
            r = t || new THREE.Vector3();
        return r.copy(e), n > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)), r;
    },
    getBoundingBox: function (e) {
        var t = e || new THREE.Box3();
        return t.set(this.center, this.center), t.expandByScalar(this.radius), t;
    },
    applyMatrix4: function (e) {
        return this.center.applyMatrix4(e), (this.radius = this.radius * e.getMaxScaleOnAxis()), this;
    },
    translate: function (e) {
        return this.center.add(e), this;
    },
    equals: function (e) {
        return e.center.equals(this.center) && e.radius === this.radius;
    },
    clone: function () {
        return new THREE.Sphere().copy(this);
    },
}),
(THREE.Frustum = function (e, t, n, r, i, s) {
    this.planes = [
        e !== undefined ? e : new THREE.Plane(),
        t !== undefined ? t : new THREE.Plane(),
        n !== undefined ? n : new THREE.Plane(),
        r !== undefined ? r : new THREE.Plane(),
        i !== undefined ? i : new THREE.Plane(),
        s !== undefined ? s : new THREE.Plane(),
    ];
}),
(THREE.Frustum.prototype = {
    constructor: THREE.Frustum,
    set: function (e, t, n, r, i, s) {
        var o = this.planes;
        return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(s), this;
    },
    copy: function (e) {
        var t = this.planes;
        for (var n = 0; n < 6; n++) t[n].copy(e.planes[n]);
        return this;
    },
    setFromMatrix: function (e) {
        var t = this.planes,
            n = e.elements,
            r = n[0],
            i = n[1],
            s = n[2],
            o = n[3],
            u = n[4],
            a = n[5],
            f = n[6],
            l = n[7],
            c = n[8],
            h = n[9],
            p = n[10],
            d = n[11],
            v = n[12],
            m = n[13],
            g = n[14],
            y = n[15];
        return (
            t[0].setComponents(o - r, l - u, d - c, y - v).normalize(),
                t[1].setComponents(o + r, l + u, d + c, y + v).normalize(),
                t[2].setComponents(o + i, l + a, d + h, y + m).normalize(),
                t[3].setComponents(o - i, l - a, d - h, y - m).normalize(),
                t[4].setComponents(o - s, l - f, d - p, y - g).normalize(),
                t[5].setComponents(o + s, l + f, d + p, y + g).normalize(),
                this
        );
    },
    intersectsObject: (function () {
        var e = new THREE.Sphere();
        return function (t) {
            var n = t.geometry;
            return n.boundingSphere === null && n.computeBoundingSphere(), e.copy(n.boundingSphere), e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e);
        };
    })(),
    intersectsSphere: function (e) {
        var t = this.planes,
            n = e.center,
            r = -e.radius;
        for (var i = 0; i < 6; i++) {
            var s = t[i].distanceToPoint(n);
            if (s < r) return !1;
        }
        return !0;
    },
    intersectsBox: (function () {
        var e = new THREE.Vector3(),
            t = new THREE.Vector3();
        return function (n) {
            var r = this.planes;
            for (var i = 0; i < 6; i++) {
                var s = r[i];
                (e.x = s.normal.x > 0 ? n.min.x : n.max.x),
                    (t.x = s.normal.x > 0 ? n.max.x : n.min.x),
                    (e.y = s.normal.y > 0 ? n.min.y : n.max.y),
                    (t.y = s.normal.y > 0 ? n.max.y : n.min.y),
                    (e.z = s.normal.z > 0 ? n.min.z : n.max.z),
                    (t.z = s.normal.z > 0 ? n.max.z : n.min.z);
                var o = s.distanceToPoint(e),
                    u = s.distanceToPoint(t);
                if (o < 0 && u < 0) return !1;
            }
            return !0;
        };
    })(),
    containsPoint: function (e) {
        var t = this.planes;
        for (var n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
        return !0;
    },
    clone: function () {
        return new THREE.Frustum().copy(this);
    },
}),
(THREE.Plane = function (e, t) {
    (this.normal = e !== undefined ? e : new THREE.Vector3(1, 0, 0)), (this.constant = t !== undefined ? t : 0);
}),
(THREE.Plane.prototype = {
    constructor: THREE.Plane,
    set: function (e, t) {
        return this.normal.copy(e), (this.constant = t), this;
    },
    setComponents: function (e, t, n, r) {
        return this.normal.set(e, t, n), (this.constant = r), this;
    },
    setFromNormalAndCoplanarPoint: function (e, t) {
        return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
    },
    setFromCoplanarPoints: (function () {
        var e = new THREE.Vector3(),
            t = new THREE.Vector3();
        return function (n, r, i) {
            var s = e.subVectors(i, r).cross(t.subVectors(n, r)).normalize();
            return this.setFromNormalAndCoplanarPoint(s, n), this;
        };
    })(),
    copy: function (e) {
        return this.normal.copy(e.normal), (this.constant = e.constant), this;
    },
    normalize: function () {
        var e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), (this.constant *= e), this;
    },
    negate: function () {
        return (this.constant *= -1), this.normal.negate(), this;
    },
    distanceToPoint: function (e) {
        return this.normal.dot(e) + this.constant;
    },
    distanceToSphere: function (e) {
        return this.distanceToPoint(e.center) - e.radius;
    },
    projectPoint: function (e, t) {
        return this.orthoPoint(e, t).sub(e).negate();
    },
    orthoPoint: function (e, t) {
        var n = this.distanceToPoint(e),
            r = t || new THREE.Vector3();
        return r.copy(this.normal).multiplyScalar(n);
    },
    isIntersectionLine: function (e) {
        var t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
        return (t < 0 && n > 0) || (n < 0 && t > 0);
    },
    intersectLine: (function () {
        var e = new THREE.Vector3();
        return function (t, n) {
            var r = n || new THREE.Vector3(),
                i = t.delta(e),
                s = this.normal.dot(i);
            if (s == 0) return this.distanceToPoint(t.start) == 0 ? r.copy(t.start) : undefined;
            var o = -(t.start.dot(this.normal) + this.constant) / s;
            return o < 0 || o > 1 ? undefined : r.copy(i).multiplyScalar(o).add(t.start);
        };
    })(),
    coplanarPoint: function (e) {
        var t = e || new THREE.Vector3();
        return t.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: (function () {
        var e = new THREE.Vector3(),
            t = new THREE.Vector3();
        return function (n, r) {
            r = r || new THREE.Matrix3().getNormalMatrix(n);
            var i = e.copy(this.normal).applyMatrix3(r),
                s = this.coplanarPoint(t);
            return s.applyMatrix4(n), this.setFromNormalAndCoplanarPoint(i, s), this;
        };
    })(),
    translate: function (e) {
        return (this.constant = this.constant - e.dot(this.normal)), this;
    },
    equals: function (e) {
        return e.normal.equals(this.normal) && e.constant == this.constant;
    },
    clone: function () {
        return new THREE.Plane().copy(this);
    },
}),
(THREE.Math = {
    PI2: Math.PI * 2,
    generateUUID: (function () {
        var e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
            t = new Array(36),
            n = 0,
            r;
        return function () {
            for (var i = 0; i < 36; i++)
                i == 8 || i == 13 || i == 18 || i == 23 ? (t[i] = "-") : i == 14 ? (t[i] = "4") : (n <= 2 && (n = (33554432 + Math.random() * 16777216) | 0), (r = n & 15), (n >>= 4), (t[i] = e[i == 19 ? (r & 3) | 8 : r]));
            return t.join("");
        };
    })(),
    clamp: function (e, t, n) {
        return e < t ? t : e > n ? n : e;
    },
    clampBottom: function (e, t) {
        return e < t ? t : e;
    },
    mapLinear: function (e, t, n, r, i) {
        return r + ((e - t) * (i - r)) / (n - t);
    },
    smoothstep: function (e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : ((e = (e - t) / (n - t)), e * e * (3 - 2 * e));
    },
    smootherstep: function (e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : ((e = (e - t) / (n - t)), e * e * e * (e * (e * 6 - 15) + 10));
    },
    random16: function () {
        return (65280 * Math.random() + 255 * Math.random()) / 65535;
    },
    randInt: function (e, t) {
        return e + Math.floor(Math.random() * (t - e + 1));
    },
    randFloat: function (e, t) {
        return e + Math.random() * (t - e);
    },
    randFloatSpread: function (e) {
        return e * (0.5 - Math.random());
    },
    sign: function (e) {
        return e < 0 ? -1 : e > 0 ? 1 : 0;
    },
    degToRad: (function () {
        var e = Math.PI / 180;
        return function (t) {
            return t * e;
        };
    })(),
    radToDeg: (function () {
        var e = 180 / Math.PI;
        return function (t) {
            return t * e;
        };
    })(),
}),
(THREE.Spline = function (e) {
    function h(e, t, n, r, i, s, o) {
        var u = (n - e) * 0.5,
            a = (r - t) * 0.5;
        return (2 * (t - n) + u + a) * o + (-3 * (t - n) - 2 * u - a) * s + u * i + t;
    }
    this.points = e;
    var t = [],
        n = { x: 0, y: 0, z: 0 },
        r,
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c;
    (this.initFromArray = function (e) {
        this.points = [];
        for (var t = 0; t < e.length; t++) this.points[t] = { x: e[t][0], y: e[t][1], z: e[t][2] };
    }),
        (this.getPoint = function (e) {
            return (
                (r = (this.points.length - 1) * e),
                    (i = Math.floor(r)),
                    (s = r - i),
                    (t[0] = i === 0 ? i : i - 1),
                    (t[1] = i),
                    (t[2] = i > this.points.length - 2 ? this.points.length - 1 : i + 1),
                    (t[3] = i > this.points.length - 3 ? this.points.length - 1 : i + 2),
                    (a = this.points[t[0]]),
                    (f = this.points[t[1]]),
                    (l = this.points[t[2]]),
                    (c = this.points[t[3]]),
                    (o = s * s),
                    (u = s * o),
                    (n.x = h(a.x, f.x, l.x, c.x, s, o, u)),
                    (n.y = h(a.y, f.y, l.y, c.y, s, o, u)),
                    (n.z = h(a.z, f.z, l.z, c.z, s, o, u)),
                    n
            );
        }),
        (this.getControlPointsArray = function () {
            var e,
                t,
                n = this.points.length,
                r = [];
            for (e = 0; e < n; e++) (t = this.points[e]), (r[e] = [t.x, t.y, t.z]);
            return r;
        }),
        (this.getLength = function (e) {
            var t,
                n,
                r,
                i,
                s = 0,
                o = 0,
                u = 0,
                a = new THREE.Vector3(),
                f = new THREE.Vector3(),
                l = [],
                c = 0;
            (l[0] = 0), e || (e = 100), (r = this.points.length * e), a.copy(this.points[0]);
            for (t = 1; t < r; t++) (n = t / r), (i = this.getPoint(n)), f.copy(i), (c += f.distanceTo(a)), a.copy(i), (s = (this.points.length - 1) * n), (o = Math.floor(s)), o != u && ((l[o] = c), (u = o));
            return (l[l.length] = c), { chunks: l, total: c };
        }),
        (this.reparametrizeByArcLength = function (e) {
            var t,
                n,
                r,
                i,
                s,
                o,
                u,
                a,
                f,
                l = [],
                c = new THREE.Vector3(),
                h = this.getLength();
            l.push(c.copy(this.points[0]).clone());
            for (t = 1; t < this.points.length; t++) {
                (u = h.chunks[t] - h.chunks[t - 1]), (a = Math.ceil((e * u) / h.total)), (i = (t - 1) / (this.points.length - 1)), (s = t / (this.points.length - 1));
                for (n = 1; n < a - 1; n++) (r = i + n * (1 / a) * (s - i)), (f = this.getPoint(r)), l.push(c.copy(f).clone());
                l.push(c.copy(this.points[t]).clone());
            }
            this.points = l;
        });
}),
(THREE.Triangle = function (e, t, n) {
    (this.a = e !== undefined ? e : new THREE.Vector3()), (this.b = t !== undefined ? t : new THREE.Vector3()), (this.c = n !== undefined ? n : new THREE.Vector3());
}),
(THREE.Triangle.normal = (function () {
    var e = new THREE.Vector3();
    return function (t, n, r, i) {
        var s = i || new THREE.Vector3();
        s.subVectors(r, n), e.subVectors(t, n), s.cross(e);
        var o = s.lengthSq();
        return o > 0 ? s.multiplyScalar(1 / Math.sqrt(o)) : s.set(0, 0, 0);
    };
})()),
(THREE.Triangle.barycoordFromPoint = (function () {
    var e = new THREE.Vector3(),
        t = new THREE.Vector3(),
        n = new THREE.Vector3();
    return function (r, i, s, o, u) {
        e.subVectors(o, i), t.subVectors(s, i), n.subVectors(r, i);
        var a = e.dot(e),
            f = e.dot(t),
            l = e.dot(n),
            c = t.dot(t),
            h = t.dot(n),
            p = a * c - f * f,
            d = u || new THREE.Vector3();
        if (p == 0) return d.set(-2, -1, -1);
        var v = 1 / p,
            m = (c * l - f * h) * v,
            g = (a * h - f * l) * v;
        return d.set(1 - m - g, g, m);
    };
})()),
(THREE.Triangle.containsPoint = (function () {
    var e = new THREE.Vector3();
    return function (t, n, r, i) {
        var s = THREE.Triangle.barycoordFromPoint(t, n, r, i, e);
        return s.x >= 0 && s.y >= 0 && s.x + s.y <= 1;
    };
})()),
(THREE.Triangle.prototype = {
    constructor: THREE.Triangle,
    set: function (e, t, n) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
    },
    setFromPointsAndIndices: function (e, t, n, r) {
        return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
    },
    copy: function (e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
    },
    area: (function () {
        var e = new THREE.Vector3(),
            t = new THREE.Vector3();
        return function () {
            return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), e.cross(t).length() * 0.5;
        };
    })(),
    midpoint: function (e) {
        var t = e || new THREE.Vector3();
        return t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
    },
    normal: function (e) {
        return THREE.Triangle.normal(this.a, this.b, this.c, e);
    },
    plane: function (e) {
        var t = e || new THREE.Plane();
        return t.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    barycoordFromPoint: function (e, t) {
        return THREE.Triangle.barycoordFromPoint(e, this.a, this.b, this.c, t);
    },
    containsPoint: function (e) {
        return THREE.Triangle.containsPoint(e, this.a, this.b, this.c);
    },
    equals: function (e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
    },
    clone: function () {
        return new THREE.Triangle().copy(this);
    },
}),
(THREE.Vertex = function (e) {
    return console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead."), e;
}),
(THREE.UV = function (e, t) {
    return console.warn("THREE.UV has been DEPRECATED. Use THREE.Vector2 instead."), new THREE.Vector2(e, t);
}),
(THREE.Clock = function (e) {
    (this.autoStart = e !== undefined ? e : !0), (this.startTime = 0), (this.oldTime = 0), (this.elapsedTime = 0), (this.running = !1);
}),
(THREE.Clock.prototype = {
    constructor: THREE.Clock,
    start: function () {
        (this.startTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now()), (this.oldTime = this.startTime), (this.running = !0);
    },
    stop: function () {
        this.getElapsedTime(), (this.running = !1);
    },
    getElapsedTime: function () {
        return this.getDelta(), this.elapsedTime;
    },
    getDelta: function () {
        var e = 0;
        this.autoStart && !this.running && this.start();
        if (this.running) {
            var t = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
            (e = 0.001 * (t - this.oldTime)), (this.oldTime = t), (this.elapsedTime += e);
        }
        return e;
    },
}),
(THREE.EventDispatcher = function () {}),
(THREE.EventDispatcher.prototype = {
    constructor: THREE.EventDispatcher,
    apply: function (e) {
        (e.addEventListener = THREE.EventDispatcher.prototype.addEventListener),
            (e.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener),
            (e.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener),
            (e.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent);
    },
    addEventListener: function (e, t) {
        this._listeners === undefined && (this._listeners = {});
        var n = this._listeners;
        n[e] === undefined && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
    },
    hasEventListener: function (e, t) {
        if (this._listeners === undefined) return !1;
        var n = this._listeners;
        return n[e] !== undefined && n[e].indexOf(t) !== -1 ? !0 : !1;
    },
    removeEventListener: function (e, t) {
        if (this._listeners === undefined) return;
        var n = this._listeners,
            r = n[e].indexOf(t);
        r !== -1 && n[e].splice(r, 1);
    },
    dispatchEvent: function (e) {
        if (this._listeners === undefined) return;
        var t = this._listeners,
            n = t[e.type];
        if (n !== undefined) {
            e.target = this;
            for (var r = 0, i = n.length; r < i; r++) n[r].call(this, e);
        }
    },
}),
(function (e) {
    e.Raycaster = function (t, n, r, i) {
        (this.ray = new e.Ray(t, n)), (this.near = r || 0), (this.far = i || Infinity);
    };
    var t = new e.Sphere(),
        n = new e.Ray(),
        r = new e.Plane(),
        i = new e.Vector3(),
        s = new e.Vector3(),
        o = new e.Matrix4(),
        u = function (e, t) {
            return e.distance - t.distance;
        },
        a = new e.Vector3(),
        f = new e.Vector3(),
        l = new e.Vector3(),
        c = function (r, i, u) {
            if (r instanceof e.Particle) {
                s.getPositionFromMatrix(r.matrixWorld);
                var h = i.ray.distanceToPoint(s);
                if (h > r.scale.x) return u;
                u.push({ distance: h, point: r.position, face: null, object: r });
            } else if (r instanceof e.LOD) {
                s.getPositionFromMatrix(r.matrixWorld);
                var h = i.ray.origin.distanceTo(s);
                c(r.getObjectForDistance(h), i, u);
            } else if (r instanceof e.Mesh) {
                var p = r.geometry;
                p.boundingSphere === null && p.computeBoundingSphere(), t.copy(p.boundingSphere), t.applyMatrix4(r.matrixWorld);
                if (i.ray.isIntersectionSphere(t) === !1) return u;
                o.getInverse(r.matrixWorld), n.copy(i.ray).applyMatrix4(o);
                if (p.boundingBox !== null && n.isIntersectionBox(p.boundingBox) === !1) return u;
                if (p instanceof e.BufferGeometry) {
                    var d = r.material;
                    if (d === undefined) return u;
                    if (p.dynamic === !1) return u;
                    var v,
                        m,
                        g,
                        y = i.precision;
                    if (p.attributes.index !== undefined) {
                        var b = p.offsets,
                            w = p.attributes.index.array,
                            E = p.attributes.position.array,
                            S = p.offsets.length,
                            x = p.attributes.index.array.length / 3;
                        for (var T = 0; T < S; ++T) {
                            var N = b[T].start,
                                C = b[T].count,
                                k = b[T].index;
                            for (var L = N, A = N + C; L < A; L += 3) {
                                (v = k + w[L]), (m = k + w[L + 1]), (g = k + w[L + 2]), a.set(E[v * 3], E[v * 3 + 1], E[v * 3 + 2]), f.set(E[m * 3], E[m * 3 + 1], E[m * 3 + 2]), l.set(E[g * 3], E[g * 3 + 1], E[g * 3 + 2]);
                                var O = n.intersectTriangle(a, f, l, d.side !== e.DoubleSide);
                                if (O === null) continue;
                                O.applyMatrix4(r.matrixWorld);
                                var h = i.ray.origin.distanceTo(O);
                                if (h < y || h < i.near || h > i.far) continue;
                                u.push({ distance: h, point: O, face: null, faceIndex: null, object: r });
                            }
                        }
                    } else {
                        var b = p.offsets,
                            E = p.attributes.position.array,
                            S = p.offsets.length,
                            x = p.attributes.position.array.length;
                        for (var L = 0; L < x; L += 3) {
                            (v = L), (m = L + 1), (g = L + 2), a.set(E[v * 3], E[v * 3 + 1], E[v * 3 + 2]), f.set(E[m * 3], E[m * 3 + 1], E[m * 3 + 2]), l.set(E[g * 3], E[g * 3 + 1], E[g * 3 + 2]);
                            var O = n.intersectTriangle(a, f, l, d.side !== e.DoubleSide);
                            if (O === null) continue;
                            O.applyMatrix4(r.matrixWorld);
                            var h = i.ray.origin.distanceTo(O);
                            if (h < y || h < i.near || h > i.far) continue;
                            u.push({ distance: h, point: O, face: null, faceIndex: null, object: r });
                        }
                    }
                } else if (p instanceof e.Geometry) {
                    var M = r.material instanceof e.MeshFaceMaterial,
                        _ = M === !0 ? r.material.materials : null,
                        v,
                        m,
                        g,
                        D,
                        y = i.precision,
                        P = p.vertices;
                    for (var H = 0, x = p.faces.length; H < x; H++) {
                        var B = p.faces[H],
                            d = M === !0 ? _[B.materialIndex] : r.material;
                        if (d === undefined) continue;
                        (v = P[B.a]), (m = P[B.b]), (g = P[B.c]);
                        var O = n.intersectTriangle(v, m, g, d.side !== e.DoubleSide);
                        if (O === null) continue;
                        O.applyMatrix4(r.matrixWorld);
                        var h = i.ray.origin.distanceTo(O);
                        if (h < y || h < i.near || h > i.far) continue;
                        u.push({ distance: h, point: O, face: B, faceIndex: H, object: r });
                    }
                }
            } else if (r instanceof e.Line) {
                var y = i.linePrecision,
                    j = y * y,
                    p = r.geometry;
                p.boundingSphere === null && p.computeBoundingSphere(), t.copy(p.boundingSphere), t.applyMatrix4(r.matrixWorld);
                if (i.ray.isIntersectionSphere(t) === !1) return u;
                o.getInverse(r.matrixWorld), n.copy(i.ray).applyMatrix4(o);
                if (p instanceof e.Geometry) {
                    var P = p.vertices,
                        F = P.length,
                        I = new e.Vector3(),
                        q = new e.Vector3(),
                        R = r.type === e.LineStrip ? 1 : 2;
                    for (var L = 0; L < F - 1; L += R) {
                        var U = n.distanceSqToSegment(P[L], P[L + 1], q, I);
                        if (U > j) continue;
                        var h = n.origin.distanceTo(q);
                        if (h < i.near || h > i.far) continue;
                        u.push({ distance: h, point: I.clone().applyMatrix4(r.matrixWorld), face: null, faceIndex: null, object: r });
                    }
                }
            }
        },
        h = function (e, t, n) {
            var r = e.getDescendants();
            for (var i = 0, s = r.length; i < s; i++) c(r[i], t, n);
        };
    (e.Raycaster.prototype.precision = 1e-4),
        (e.Raycaster.prototype.linePrecision = 1),
        (e.Raycaster.prototype.set = function (e, t) {
            this.ray.set(e, t);
        }),
        (e.Raycaster.prototype.intersectObject = function (e, t) {
            var n = [];
            return t === !0 && h(e, this, n), c(e, this, n), n.sort(u), n;
        }),
        (e.Raycaster.prototype.intersectObjects = function (e, t) {
            var n = [];
            for (var r = 0, i = e.length; r < i; r++) c(e[r], this, n), t === !0 && h(e[r], this, n);
            return n.sort(u), n;
        });
})(THREE),
(THREE.Object3D = function () {
    (this.id = THREE.Object3DIdCount++),
        (this.uuid = THREE.Math.generateUUID()),
        (this.name = ""),
        (this.parent = undefined),
        (this.children = []),
        (this.up = new THREE.Vector3(0, 1, 0)),
        (this.position = new THREE.Vector3()),
        (this.rotation = new THREE.Euler()),
        (this.quaternion = new THREE.Quaternion()),
        (this.scale = new THREE.Vector3(1, 1, 1)),
        (this.rotation._quaternion = this.quaternion),
        (this.quaternion._euler = this.rotation),
        (this.renderDepth = null),
        (this.rotationAutoUpdate = !0),
        (this.matrix = new THREE.Matrix4()),
        (this.matrixWorld = new THREE.Matrix4()),
        (this.matrixAutoUpdate = !0),
        (this.matrixWorldNeedsUpdate = !0),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.userData = {});
}),
(THREE.Object3D.prototype = {
    constructor: THREE.Object3D,
    get eulerOrder() {
        return console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order."), this.rotation.order;
    },
    set eulerOrder(e) {
        console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order."), (this.rotation.order = e);
    },
    get useQuaternion() {
        console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set useQuaternion(e) {
        console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    applyMatrix: (function () {
        var e = new THREE.Matrix4();
        return function (t) {
            this.matrix.multiplyMatrices(t, this.matrix), this.position.getPositionFromMatrix(this.matrix), this.scale.getScaleFromMatrix(this.matrix), e.extractRotation(this.matrix), this.quaternion.setFromRotationMatrix(e);
        };
    })(),
    setRotationFromAxisAngle: function (e, t) {
        this.quaternion.setFromAxisAngle(e, t);
    },
    setRotationFromEuler: function (e) {
        this.quaternion.setFromEuler(e, !0);
    },
    setRotationFromMatrix: function (e) {
        this.quaternion.setFromRotationMatrix(e);
    },
    setRotationFromQuaternion: function (e) {
        this.quaternion.copy(e);
    },
    rotateOnAxis: (function () {
        var e = new THREE.Quaternion();
        return function (t, n) {
            return e.setFromAxisAngle(t, n), this.quaternion.multiply(e), this;
        };
    })(),
    rotateX: (function () {
        var e = new THREE.Vector3(1, 0, 0);
        return function (t) {
            return this.rotateOnAxis(e, t);
        };
    })(),
    rotateY: (function () {
        var e = new THREE.Vector3(0, 1, 0);
        return function (t) {
            return this.rotateOnAxis(e, t);
        };
    })(),
    rotateZ: (function () {
        var e = new THREE.Vector3(0, 0, 1);
        return function (t) {
            return this.rotateOnAxis(e, t);
        };
    })(),
    translateOnAxis: (function () {
        var e = new THREE.Vector3();
        return function (t, n) {
            return e.copy(t), e.applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this;
        };
    })(),
    translate: function (e, t) {
        return console.warn("DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed."), this.translateOnAxis(t, e);
    },
    translateX: (function () {
        var e = new THREE.Vector3(1, 0, 0);
        return function (t) {
            return this.translateOnAxis(e, t);
        };
    })(),
    translateY: (function () {
        var e = new THREE.Vector3(0, 1, 0);
        return function (t) {
            return this.translateOnAxis(e, t);
        };
    })(),
    translateZ: (function () {
        var e = new THREE.Vector3(0, 0, 1);
        return function (t) {
            return this.translateOnAxis(e, t);
        };
    })(),
    localToWorld: function (e) {
        return e.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: (function () {
        var e = new THREE.Matrix4();
        return function (t) {
            return t.applyMatrix4(e.getInverse(this.matrixWorld));
        };
    })(),
    lookAt: (function () {
        var e = new THREE.Matrix4();
        return function (t) {
            e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e);
        };
    })(),
    add: function (e) {
        if (e === this) {
            console.warn("THREE.Object3D.add: An object can't be added as a child of itself.");
            return;
        }
        if (e instanceof THREE.Object3D) {
            e.parent !== undefined && e.parent.remove(e), (e.parent = this), e.dispatchEvent({ type: "added" }), this.children.push(e);
            var t = this;
            while (t.parent !== undefined) t = t.parent;
            t !== undefined && t instanceof THREE.Scene && t.__addObject(e);
        }
    },
    remove: function (e) {
        var t = this.children.indexOf(e);
        if (t !== -1) {
            (e.parent = undefined), e.dispatchEvent({ type: "removed" }), this.children.splice(t, 1);
            var n = this;
            while (n.parent !== undefined) n = n.parent;
            n !== undefined && n instanceof THREE.Scene && n.__removeObject(e);
        }
    },
    traverse: function (e) {
        e(this);
        for (var t = 0, n = this.children.length; t < n; t++) this.children[t].traverse(e);
    },
    getObjectById: function (e, t) {
        for (var n = 0, r = this.children.length; n < r; n++) {
            var i = this.children[n];
            if (i.id === e) return i;
            if (t === !0) {
                i = i.getObjectById(e, t);
                if (i !== undefined) return i;
            }
        }
        return undefined;
    },
    getObjectByName: function (e, t) {
        for (var n = 0, r = this.children.length; n < r; n++) {
            var i = this.children[n];
            if (i.name === e) return i;
            if (t === !0) {
                i = i.getObjectByName(e, t);
                if (i !== undefined) return i;
            }
        }
        return undefined;
    },
    getChildByName: function (e, t) {
        return console.warn("DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e, t);
    },
    getDescendants: function (e) {
        e === undefined && (e = []), Array.prototype.push.apply(e, this.children);
        for (var t = 0, n = this.children.length; t < n; t++) this.children[t].getDescendants(e);
        return e;
    },
    updateMatrix: function () {
        this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
    },
    updateMatrixWorld: function (e) {
        this.matrixAutoUpdate === !0 && this.updateMatrix();
        if (this.matrixWorldNeedsUpdate === !0 || e === !0)
            this.parent === undefined ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), (this.matrixWorldNeedsUpdate = !1), (e = !0);
        for (var t = 0, n = this.children.length; t < n; t++) this.children[t].updateMatrixWorld(e);
    },
    clone: function (e, t) {
        e === undefined && (e = new THREE.Object3D()),
        t === undefined && (t = !0),
            (e.name = this.name),
            e.up.copy(this.up),
            e.position.copy(this.position),
            e.quaternion.copy(this.quaternion),
            e.scale.copy(this.scale),
            (e.renderDepth = this.renderDepth),
            (e.rotationAutoUpdate = this.rotationAutoUpdate),
            e.matrix.copy(this.matrix),
            e.matrixWorld.copy(this.matrixWorld),
            (e.matrixAutoUpdate = this.matrixAutoUpdate),
            (e.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate),
            (e.visible = this.visible),
            (e.castShadow = this.castShadow),
            (e.receiveShadow = this.receiveShadow),
            (e.frustumCulled = this.frustumCulled),
            (e.userData = JSON.parse(JSON.stringify(this.userData)));
        if (t === !0)
            for (var n = 0; n < this.children.length; n++) {
                var r = this.children[n];
                e.add(r.clone());
            }
        return e;
    },
}),
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype),
(THREE.Object3DIdCount = 0),
(THREE.Projector = function () {
    function q() {
        if (t === r) {
            var e = new THREE.RenderableObject();
            return n.push(e), r++, t++, e;
        }
        return n[t++];
    }
    function R() {
        if (s === u) {
            var e = new THREE.RenderableVertex();
            return o.push(e), u++, s++, e;
        }
        return o[s++];
    }
    function U() {
        if (f === c) {
            var e = new THREE.RenderableFace3();
            return l.push(e), c++, f++, e;
        }
        return l[f++];
    }
    function z() {
        if (p === v) {
            var e = new THREE.RenderableLine();
            return d.push(e), v++, p++, e;
        }
        return d[p++];
    }
    function W() {
        if (g === b) {
            var e = new THREE.RenderableParticle();
            return y.push(e), b++, g++, e;
        }
        return y[g++];
    }
    function X(e, t) {
        return e.z !== t.z ? t.z - e.z : e.id !== t.id ? e.id - t.id : 0;
    }
    function V(e, t) {
        var n = 0,
            r = 1,
            i = e.z + e.w,
            s = t.z + t.w,
            o = -e.z + e.w,
            u = -t.z + t.w;
        return i >= 0 && s >= 0 && o >= 0 && u >= 0
            ? !0
            : (i < 0 && s < 0) || (o < 0 && u < 0)
                ? !1
                : (i < 0 ? (n = Math.max(n, i / (i - s))) : s < 0 && (r = Math.min(r, i / (i - s))), o < 0 ? (n = Math.max(n, o / (o - u))) : u < 0 && (r = Math.min(r, o / (o - u))), r < n ? !1 : (e.lerp(t, n), t.lerp(e, 1 - r), !0));
    }
    var e,
        t,
        n = [],
        r = 0,
        i,
        s,
        o = [],
        u = 0,
        a,
        f,
        l = [],
        c = 0,
        h,
        p,
        d = [],
        v = 0,
        m,
        g,
        y = [],
        b = 0,
        w = { objects: [], sprites: [], lights: [], elements: [] },
        E = new THREE.Vector3(),
        S = new THREE.Vector4(),
        x = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
        T = new THREE.Box3(),
        N = new Array(3),
        C = new Array(4),
        k = new THREE.Matrix4(),
        L = new THREE.Matrix4(),
        A,
        O = new THREE.Matrix4(),
        M = new THREE.Matrix3(),
        _ = new THREE.Matrix3(),
        D = new THREE.Vector3(),
        P = new THREE.Frustum(),
        H = new THREE.Vector4(),
        B = new THREE.Vector4();
    (this.projectVector = function (e, t) {
        return t.matrixWorldInverse.getInverse(t.matrixWorld), L.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), e.applyProjection(L);
    }),
        (this.unprojectVector = function (e, t) {
            return t.projectionMatrixInverse.getInverse(t.projectionMatrix), L.multiplyMatrices(t.matrixWorld, t.projectionMatrixInverse), e.applyProjection(L);
        }),
        (this.pickingRay = function (e, t) {
            e.z = -1;
            var n = new THREE.Vector3(e.x, e.y, 1);
            return this.unprojectVector(e, t), this.unprojectVector(n, t), n.sub(e).normalize(), new THREE.Raycaster(e, n);
        });
    var j = function (t) {
            return (e = q()), (e.id = t.id), (e.object = t), t.renderDepth !== null ? (e.z = t.renderDepth) : (E.getPositionFromMatrix(t.matrixWorld), E.applyProjection(L), (e.z = E.z)), e;
        },
        F = function (e) {
            if (e.visible === !1) return;
            e instanceof THREE.Light
                ? w.lights.push(e)
                : e instanceof THREE.Mesh || e instanceof THREE.Line
                ? (e.frustumCulled === !1 || P.intersectsObject(e) === !0) && w.objects.push(j(e))
                : (e instanceof THREE.Sprite || e instanceof THREE.Particle) && w.sprites.push(j(e));
            for (var t = 0, n = e.children.length; t < n; t++) F(e.children[t]);
        },
        I = function (e, n) {
            (t = 0), (w.objects.length = 0), (w.sprites.length = 0), (w.lights.length = 0), F(e), n === !0 && w.objects.sort(X);
        };
    this.projectScene = function (e, t, n, r) {
        var u = !1,
            l,
            c,
            d,
            v,
            y,
            b,
            E,
            C,
            j,
            F,
            q,
            $,
            J,
            K,
            Q,
            G,
            Y,
            Z,
            et,
            tt,
            nt,
            rt,
            it,
            st,
            ot,
            ut;
        (f = 0),
            (p = 0),
            (g = 0),
            (w.elements.length = 0),
        e.autoUpdate === !0 && e.updateMatrixWorld(),
        t.parent === undefined && t.updateMatrixWorld(),
            k.copy(t.matrixWorldInverse.getInverse(t.matrixWorld)),
            L.multiplyMatrices(t.projectionMatrix, k),
            _.getNormalMatrix(k),
            P.setFromMatrix(L),
            I(e, n);
        for (l = 0, c = w.objects.length; l < c; l++) {
            (J = w.objects[l].object), (A = J.matrixWorld), (s = 0);
            if (J instanceof THREE.Mesh) {
                (K = J.geometry), (Q = K.vertices), (G = K.faces), (et = K.faceVertexUvs), M.getNormalMatrix(A), (ot = J.material instanceof THREE.MeshFaceMaterial), (ut = ot === !0 ? J.material : null);
                for (d = 0, v = Q.length; d < v; d++) {
                    (i = R()), i.positionWorld.copy(Q[d]).applyMatrix4(A), i.positionScreen.copy(i.positionWorld).applyMatrix4(L);
                    var at = 1 / i.positionScreen.w;
                    (i.positionScreen.x *= at),
                        (i.positionScreen.y *= at),
                        (i.positionScreen.z *= at),
                        (i.visible = !(i.positionScreen.x < -1 || i.positionScreen.x > 1 || i.positionScreen.y < -1 || i.positionScreen.y > 1 || i.positionScreen.z < -1 || i.positionScreen.z > 1));
                }
                for (y = 0, b = G.length; y < b; y++) {
                    Y = G[y];
                    var ft = ot === !0 ? ut.materials[Y.materialIndex] : J.material;
                    if (ft === undefined) continue;
                    var lt = ft.side;
                    (nt = o[Y.a]), (rt = o[Y.b]), (it = o[Y.c]), (N[0] = nt.positionScreen), (N[1] = rt.positionScreen), (N[2] = it.positionScreen);
                    if (nt.visible !== !0 && rt.visible !== !0 && it.visible !== !0 && !x.isIntersectionBox(T.setFromPoints(N))) continue;
                    u = (it.positionScreen.x - nt.positionScreen.x) * (rt.positionScreen.y - nt.positionScreen.y) - (it.positionScreen.y - nt.positionScreen.y) * (rt.positionScreen.x - nt.positionScreen.x) < 0;
                    if (lt !== THREE.DoubleSide && u !== (lt === THREE.FrontSide)) continue;
                    (a = U()),
                        (a.id = J.id),
                        a.v1.copy(nt),
                        a.v2.copy(rt),
                        a.v3.copy(it),
                        a.normalModel.copy(Y.normal),
                    u === !1 && (lt === THREE.BackSide || lt === THREE.DoubleSide) && a.normalModel.negate(),
                        a.normalModel.applyMatrix3(M).normalize(),
                        a.normalModelView.copy(a.normalModel).applyMatrix3(_),
                        a.centroidModel.copy(Y.centroid).applyMatrix4(A),
                        (Z = Y.vertexNormals);
                    for (E = 0, C = Math.min(Z.length, 3); E < C; E++) {
                        var ct = a.vertexNormalsModel[E];
                        ct.copy(Z[E]), u === !1 && (lt === THREE.BackSide || lt === THREE.DoubleSide) && ct.negate(), ct.applyMatrix3(M).normalize();
                        var ht = a.vertexNormalsModelView[E];
                        ht.copy(ct).applyMatrix3(_);
                    }
                    a.vertexNormalsLength = Z.length;
                    for (j = 0, F = Math.min(et.length, 3); j < F; j++) {
                        tt = et[j][y];
                        if (tt === undefined) continue;
                        for (q = 0, $ = tt.length; q < $; q++) a.uvs[j][q] = tt[q];
                    }
                    (a.color = Y.color), (a.material = ft), D.copy(a.centroidModel).applyProjection(L), (a.z = D.z), w.elements.push(a);
                }
            } else if (J instanceof THREE.Line) {
                O.multiplyMatrices(L, A), (Q = J.geometry.vertices), (nt = R()), nt.positionScreen.copy(Q[0]).applyMatrix4(O);
                var pt = J.type === THREE.LinePieces ? 2 : 1;
                for (d = 1, v = Q.length; d < v; d++) {
                    (nt = R()), nt.positionScreen.copy(Q[d]).applyMatrix4(O);
                    if ((d + 1) % pt > 0) continue;
                    (rt = o[s - 2]),
                        H.copy(nt.positionScreen),
                        B.copy(rt.positionScreen),
                    V(H, B) === !0 &&
                    (H.multiplyScalar(1 / H.w),
                        B.multiplyScalar(1 / B.w),
                        (h = z()),
                        (h.id = J.id),
                        h.v1.positionScreen.copy(H),
                        h.v2.positionScreen.copy(B),
                        (h.z = Math.max(H.z, B.z)),
                        (h.material = J.material),
                    J.material.vertexColors === THREE.VertexColors && (h.vertexColors[0].copy(J.geometry.colors[d]), h.vertexColors[1].copy(J.geometry.colors[d - 1])),
                        w.elements.push(h));
                }
            }
        }
        for (l = 0, c = w.sprites.length; l < c; l++) {
            (J = w.sprites[l].object), (A = J.matrixWorld);
            if (J instanceof THREE.Particle) {
                S.set(A.elements[12], A.elements[13], A.elements[14], 1), S.applyMatrix4(L);
                var at = 1 / S.w;
                (S.z *= at),
                S.z > 0 &&
                S.z < 1 &&
                ((m = W()),
                    (m.id = J.id),
                    (m.x = S.x * at),
                    (m.y = S.y * at),
                    (m.z = S.z),
                    (m.object = J),
                    (m.rotation = J.rotation.z),
                    (m.scale.x = J.scale.x * Math.abs(m.x - (S.x + t.projectionMatrix.elements[0]) / (S.w + t.projectionMatrix.elements[12]))),
                    (m.scale.y = J.scale.y * Math.abs(m.y - (S.y + t.projectionMatrix.elements[5]) / (S.w + t.projectionMatrix.elements[13]))),
                    (m.material = J.material),
                    w.elements.push(m));
            }
        }
        return r === !0 && w.elements.sort(X), w;
    };
}),
(THREE.Face3 = function (e, t, n, r, i, s) {
    (this.a = e),
        (this.b = t),
        (this.c = n),
        (this.normal = r instanceof THREE.Vector3 ? r : new THREE.Vector3()),
        (this.vertexNormals = r instanceof Array ? r : []),
        (this.color = i instanceof THREE.Color ? i : new THREE.Color()),
        (this.vertexColors = i instanceof Array ? i : []),
        (this.vertexTangents = []),
        (this.materialIndex = s !== undefined ? s : 0),
        (this.centroid = new THREE.Vector3());
}),
(THREE.Face3.prototype = {
    constructor: THREE.Face3,
    clone: function () {
        var e = new THREE.Face3(this.a, this.b, this.c);
        e.normal.copy(this.normal), e.color.copy(this.color), e.centroid.copy(this.centroid), (e.materialIndex = this.materialIndex);
        var t, n;
        for (t = 0, n = this.vertexNormals.length; t < n; t++) e.vertexNormals[t] = this.vertexNormals[t].clone();
        for (t = 0, n = this.vertexColors.length; t < n; t++) e.vertexColors[t] = this.vertexColors[t].clone();
        for (t = 0, n = this.vertexTangents.length; t < n; t++) e.vertexTangents[t] = this.vertexTangents[t].clone();
        return e;
    },
}),
(THREE.Face4 = function (e, t, n, r, i, s, o) {
    return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new THREE.Face3(e, t, n, i, s, o);
}),
(THREE.Geometry = function () {
    (this.id = THREE.GeometryIdCount++),
        (this.uuid = THREE.Math.generateUUID()),
        (this.name = ""),
        (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphColors = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.hasTangents = !1),
        (this.dynamic = !0),
        (this.verticesNeedUpdate = !1),
        (this.elementsNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.tangentsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.lineDistancesNeedUpdate = !1),
        (this.buffersNeedUpdate = !1);
}),
(THREE.Geometry.prototype = {
    constructor: THREE.Geometry,
    applyMatrix: function (e) {
        var t = new THREE.Matrix3().getNormalMatrix(e);
        for (var n = 0, r = this.vertices.length; n < r; n++) {
            var i = this.vertices[n];
            i.applyMatrix4(e);
        }
        for (var n = 0, r = this.faces.length; n < r; n++) {
            var s = this.faces[n];
            s.normal.applyMatrix3(t).normalize();
            for (var o = 0, u = s.vertexNormals.length; o < u; o++) s.vertexNormals[o].applyMatrix3(t).normalize();
            s.centroid.applyMatrix4(e);
        }
        this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox(), this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere();
    },
    computeCentroids: function () {
        var e, t, n;
        for (e = 0, t = this.faces.length; e < t; e++) (n = this.faces[e]), n.centroid.set(0, 0, 0), n.centroid.add(this.vertices[n.a]), n.centroid.add(this.vertices[n.b]), n.centroid.add(this.vertices[n.c]), n.centroid.divideScalar(3);
    },
    computeFaceNormals: function () {
        var e = new THREE.Vector3(),
            t = new THREE.Vector3();
        for (var n = 0, r = this.faces.length; n < r; n++) {
            var i = this.faces[n],
                s = this.vertices[i.a],
                o = this.vertices[i.b],
                u = this.vertices[i.c];
            e.subVectors(u, o), t.subVectors(s, o), e.cross(t), e.normalize(), i.normal.copy(e);
        }
    },
    computeVertexNormals: function (e) {
        var t, n, r, i, s, o;
        if (this.__tmpVertices === undefined) {
            (this.__tmpVertices = new Array(this.vertices.length)), (o = this.__tmpVertices);
            for (t = 0, n = this.vertices.length; t < n; t++) o[t] = new THREE.Vector3();
            for (r = 0, i = this.faces.length; r < i; r++) (s = this.faces[r]), (s.vertexNormals = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]);
        } else {
            o = this.__tmpVertices;
            for (t = 0, n = this.vertices.length; t < n; t++) o[t].set(0, 0, 0);
        }
        if (e) {
            var u,
                a,
                f,
                l,
                c = new THREE.Vector3(),
                h = new THREE.Vector3(),
                p = new THREE.Vector3(),
                d = new THREE.Vector3(),
                v = new THREE.Vector3();
            for (r = 0, i = this.faces.length; r < i; r++)
                (s = this.faces[r]), (u = this.vertices[s.a]), (a = this.vertices[s.b]), (f = this.vertices[s.c]), c.subVectors(f, a), h.subVectors(u, a), c.cross(h), o[s.a].add(c), o[s.b].add(c), o[s.c].add(c);
        } else for (r = 0, i = this.faces.length; r < i; r++) (s = this.faces[r]), o[s.a].add(s.normal), o[s.b].add(s.normal), o[s.c].add(s.normal);
        for (t = 0, n = this.vertices.length; t < n; t++) o[t].normalize();
        for (r = 0, i = this.faces.length; r < i; r++) (s = this.faces[r]), s.vertexNormals[0].copy(o[s.a]), s.vertexNormals[1].copy(o[s.b]), s.vertexNormals[2].copy(o[s.c]);
    },
    computeMorphNormals: function () {
        var e, t, n, r, i;
        for (n = 0, r = this.faces.length; n < r; n++) {
            (i = this.faces[n]), i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : (i.__originalFaceNormal = i.normal.clone()), i.__originalVertexNormals || (i.__originalVertexNormals = []);
            for (e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : (i.__originalVertexNormals[e] = i.vertexNormals[e].clone());
        }
        var s = new THREE.Geometry();
        s.faces = this.faces;
        for (e = 0, t = this.morphTargets.length; e < t; e++) {
            if (!this.morphNormals[e]) {
                (this.morphNormals[e] = {}), (this.morphNormals[e].faceNormals = []), (this.morphNormals[e].vertexNormals = []);
                var o = this.morphNormals[e].faceNormals,
                    u = this.morphNormals[e].vertexNormals,
                    a,
                    f;
                for (n = 0, r = this.faces.length; n < r; n++) (i = this.faces[n]), (a = new THREE.Vector3()), (f = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() }), o.push(a), u.push(f);
            }
            var l = this.morphNormals[e];
            (s.vertices = this.morphTargets[e].vertices), s.computeFaceNormals(), s.computeVertexNormals();
            var a, f;
            for (n = 0, r = this.faces.length; n < r; n++)
                (i = this.faces[n]), (a = l.faceNormals[n]), (f = l.vertexNormals[n]), a.copy(i.normal), f.a.copy(i.vertexNormals[0]), f.b.copy(i.vertexNormals[1]), f.c.copy(i.vertexNormals[2]);
        }
        for (n = 0, r = this.faces.length; n < r; n++) (i = this.faces[n]), (i.normal = i.__originalFaceNormal), (i.vertexNormals = i.__originalVertexNormals);
    },
    computeTangents: function () {
        function B(e, t, n, r, i, s, o) {
            (f = e.vertices[t]),
                (l = e.vertices[n]),
                (c = e.vertices[r]),
                (h = a[i]),
                (p = a[s]),
                (d = a[o]),
                (v = l.x - f.x),
                (m = c.x - f.x),
                (g = l.y - f.y),
                (y = c.y - f.y),
                (b = l.z - f.z),
                (w = c.z - f.z),
                (E = p.x - h.x),
                (S = d.x - h.x),
                (x = p.y - h.y),
                (T = d.y - h.y),
                (N = 1 / (E * T - S * x)),
                O.set((T * v - x * m) * N, (T * g - x * y) * N, (T * b - x * w) * N),
                M.set((E * m - S * v) * N, (E * y - S * g) * N, (E * w - S * b) * N),
                L[t].add(O),
                L[n].add(O),
                L[r].add(O),
                A[t].add(M),
                A[n].add(M),
                A[r].add(M);
        }
        var e,
            t,
            n,
            r,
            i,
            s,
            o,
            u,
            a,
            f,
            l,
            c,
            h,
            p,
            d,
            v,
            m,
            g,
            y,
            b,
            w,
            E,
            S,
            x,
            T,
            N,
            C,
            k,
            L = [],
            A = [],
            O = new THREE.Vector3(),
            M = new THREE.Vector3(),
            _ = new THREE.Vector3(),
            D = new THREE.Vector3(),
            P = new THREE.Vector3(),
            H;
        for (n = 0, r = this.vertices.length; n < r; n++) (L[n] = new THREE.Vector3()), (A[n] = new THREE.Vector3());
        for (e = 0, t = this.faces.length; e < t; e++) (u = this.faces[e]), (a = this.faceVertexUvs[0][e]), B(this, u.a, u.b, u.c, 0, 1, 2);
        var j = ["a", "b", "c", "d"];
        for (e = 0, t = this.faces.length; e < t; e++) {
            u = this.faces[e];
            for (i = 0; i < Math.min(u.vertexNormals.length, 3); i++)
                P.copy(u.vertexNormals[i]),
                    (o = u[j[i]]),
                    (C = L[o]),
                    _.copy(C),
                    _.sub(P.multiplyScalar(P.dot(C))).normalize(),
                    D.crossVectors(u.vertexNormals[i], C),
                    (k = D.dot(A[o])),
                    (H = k < 0 ? -1 : 1),
                    (u.vertexTangents[i] = new THREE.Vector4(_.x, _.y, _.z, H));
        }
        this.hasTangents = !0;
    },
    computeLineDistances: function () {
        var e = 0,
            t = this.vertices;
        for (var n = 0, r = t.length; n < r; n++) n > 0 && (e += t[n].distanceTo(t[n - 1])), (this.lineDistances[n] = e);
    },
    computeBoundingBox: function () {
        this.boundingBox === null && (this.boundingBox = new THREE.Box3()), this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function () {
        this.boundingSphere === null && (this.boundingSphere = new THREE.Sphere()), this.boundingSphere.setFromPoints(this.vertices);
    },
    mergeVertices: function () {
        var e = {},
            t = [],
            n = [],
            r,
            i,
            s = 4,
            o = Math.pow(10, s),
            u,
            a,
            f,
            l,
            c,
            h,
            p,
            d;
        this.__tmpVertices = undefined;
        for (u = 0, a = this.vertices.length; u < a; u++)
            (r = this.vertices[u]), (i = Math.round(r.x * o) + "_" + Math.round(r.y * o) + "_" + Math.round(r.z * o)), e[i] === undefined ? ((e[i] = u), t.push(this.vertices[u]), (n[u] = t.length - 1)) : (n[u] = n[e[i]]);
        var v = [];
        for (u = 0, a = this.faces.length; u < a; u++) {
            (f = this.faces[u]), (f.a = n[f.a]), (f.b = n[f.b]), (f.c = n[f.c]), (l = [f.a, f.b, f.c]);
            var m = -1;
            for (var g = 0; g < 3; g++)
                if (l[g] == l[(g + 1) % 3]) {
                    (m = g), v.push(u);
                    break;
                }
        }
        for (u = v.length - 1; u >= 0; u--) {
            var y = v[u];
            this.faces.splice(y, 1);
            for (h = 0, p = this.faceVertexUvs.length; h < p; h++) this.faceVertexUvs[h].splice(y, 1);
        }
        var b = this.vertices.length - t.length;
        return (this.vertices = t), b;
    },
    clone: function () {
        var e = new THREE.Geometry(),
            t = this.vertices;
        for (var n = 0, r = t.length; n < r; n++) e.vertices.push(t[n].clone());
        var i = this.faces;
        for (var n = 0, r = i.length; n < r; n++) e.faces.push(i[n].clone());
        var s = this.faceVertexUvs[0];
        for (var n = 0, r = s.length; n < r; n++) {
            var o = s[n],
                u = [];
            for (var a = 0, f = o.length; a < f; a++) u.push(new THREE.Vector2(o[a].x, o[a].y));
            e.faceVertexUvs[0].push(u);
        }
        return e;
    },
    dispose: function () {
        this.dispatchEvent({ type: "dispose" });
    },
}),
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype),
(THREE.GeometryIdCount = 0),
(THREE.BufferGeometry = function () {
    (this.id = THREE.GeometryIdCount++),
        (this.uuid = THREE.Math.generateUUID()),
        (this.name = ""),
        (this.attributes = {}),
        (this.dynamic = !0),
        (this.offsets = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.hasTangents = !1),
        (this.morphTargets = []);
}),
(THREE.BufferGeometry.prototype = {
    constructor: THREE.BufferGeometry,
    applyMatrix: function (e) {
        var t, n;
        this.attributes.position && (t = this.attributes.position.array), this.attributes.normal && (n = this.attributes.normal.array), t !== undefined && (e.multiplyVector3Array(t), (this.verticesNeedUpdate = !0));
        if (n !== undefined) {
            var r = new THREE.Matrix3().getNormalMatrix(e);
            r.multiplyVector3Array(n), this.normalizeNormals(), (this.normalsNeedUpdate = !0);
        }
    },
    computeBoundingBox: function () {
        this.boundingBox === null && (this.boundingBox = new THREE.Box3());
        var e = this.attributes.position.array;
        if (e) {
            var t = this.boundingBox,
                n,
                r,
                i;
            e.length >= 3 && ((t.min.x = t.max.x = e[0]), (t.min.y = t.max.y = e[1]), (t.min.z = t.max.z = e[2]));
            for (var s = 3, o = e.length; s < o; s += 3)
                (n = e[s]),
                    (r = e[s + 1]),
                    (i = e[s + 2]),
                    n < t.min.x ? (t.min.x = n) : n > t.max.x && (t.max.x = n),
                    r < t.min.y ? (t.min.y = r) : r > t.max.y && (t.max.y = r),
                    i < t.min.z ? (t.min.z = i) : i > t.max.z && (t.max.z = i);
        }
        if (e === undefined || e.length === 0) this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);
    },
    computeBoundingSphere: (function () {
        var e = new THREE.Box3(),
            t = new THREE.Vector3();
        return function () {
            this.boundingSphere === null && (this.boundingSphere = new THREE.Sphere());
            var n = this.attributes.position.array;
            if (n) {
                var r = this.boundingSphere.center;
                for (var i = 0, s = n.length; i < s; i += 3) t.set(n[i], n[i + 1], n[i + 2]), e.addPoint(t);
                e.center(r);
                var o = 0;
                for (var i = 0, s = n.length; i < s; i += 3) t.set(n[i], n[i + 1], n[i + 2]), (o = Math.max(o, r.distanceToSquared(t)));
                this.boundingSphere.radius = Math.sqrt(o);
            }
        };
    })(),
    computeVertexNormals: function () {
        if (this.attributes.position) {
            var e,
                t,
                n,
                r,
                i = this.attributes.position.array.length;
            if (this.attributes.normal === undefined) this.attributes.normal = { itemSize: 3, array: new Float32Array(i) };
            else for (e = 0, t = this.attributes.normal.array.length; e < t; e++) this.attributes.normal.array[e] = 0;
            var s = this.attributes.position.array,
                o = this.attributes.normal.array,
                u,
                a,
                f,
                l,
                c,
                h,
                p = new THREE.Vector3(),
                d = new THREE.Vector3(),
                v = new THREE.Vector3(),
                m = new THREE.Vector3(),
                g = new THREE.Vector3();
            if (this.attributes.index) {
                var y = this.attributes.index.array,
                    b = this.offsets;
                for (n = 0, r = b.length; n < r; ++n) {
                    var w = b[n].start,
                        E = b[n].count,
                        S = b[n].index;
                    for (e = w, t = w + E; e < t; e += 3)
                        (u = S + y[e]),
                            (a = S + y[e + 1]),
                            (f = S + y[e + 2]),
                            (l = s[u * 3]),
                            (c = s[u * 3 + 1]),
                            (h = s[u * 3 + 2]),
                            p.set(l, c, h),
                            (l = s[a * 3]),
                            (c = s[a * 3 + 1]),
                            (h = s[a * 3 + 2]),
                            d.set(l, c, h),
                            (l = s[f * 3]),
                            (c = s[f * 3 + 1]),
                            (h = s[f * 3 + 2]),
                            v.set(l, c, h),
                            m.subVectors(v, d),
                            g.subVectors(p, d),
                            m.cross(g),
                            (o[u * 3] += m.x),
                            (o[u * 3 + 1] += m.y),
                            (o[u * 3 + 2] += m.z),
                            (o[a * 3] += m.x),
                            (o[a * 3 + 1] += m.y),
                            (o[a * 3 + 2] += m.z),
                            (o[f * 3] += m.x),
                            (o[f * 3 + 1] += m.y),
                            (o[f * 3 + 2] += m.z);
                }
            } else
                for (e = 0, t = s.length; e < t; e += 9)
                    (l = s[e]),
                        (c = s[e + 1]),
                        (h = s[e + 2]),
                        p.set(l, c, h),
                        (l = s[e + 3]),
                        (c = s[e + 4]),
                        (h = s[e + 5]),
                        d.set(l, c, h),
                        (l = s[e + 6]),
                        (c = s[e + 7]),
                        (h = s[e + 8]),
                        v.set(l, c, h),
                        m.subVectors(v, d),
                        g.subVectors(p, d),
                        m.cross(g),
                        (o[e] = m.x),
                        (o[e + 1] = m.y),
                        (o[e + 2] = m.z),
                        (o[e + 3] = m.x),
                        (o[e + 4] = m.y),
                        (o[e + 5] = m.z),
                        (o[e + 6] = m.x),
                        (o[e + 7] = m.y),
                        (o[e + 8] = m.z);
            this.normalizeNormals(), (this.normalsNeedUpdate = !0);
        }
    },
    normalizeNormals: function () {
        var e = this.attributes.normal.array,
            t,
            n,
            r,
            i;
        for (var s = 0, o = e.length; s < o; s += 3) (t = e[s]), (n = e[s + 1]), (r = e[s + 2]), (i = 1 / Math.sqrt(t * t + n * n + r * r)), (e[s] *= i), (e[s + 1] *= i), (e[s + 2] *= i);
    },
    computeTangents: function () {
        function F(e, n, i) {
            (l = t[e * 3]),
                (c = t[e * 3 + 1]),
                (h = t[e * 3 + 2]),
                (p = t[n * 3]),
                (d = t[n * 3 + 1]),
                (v = t[n * 3 + 2]),
                (m = t[i * 3]),
                (g = t[i * 3 + 1]),
                (y = t[i * 3 + 2]),
                (b = r[e * 2]),
                (w = r[e * 2 + 1]),
                (E = r[n * 2]),
                (S = r[n * 2 + 1]),
                (x = r[i * 2]),
                (T = r[i * 2 + 1]),
                (N = p - l),
                (C = m - l),
                (k = d - c),
                (L = g - c),
                (A = v - h),
                (O = y - h),
                (M = E - b),
                (_ = x - b),
                (D = S - w),
                (P = T - w),
                (H = 1 / (M * P - _ * D)),
                B.set((P * N - D * C) * H, (P * k - D * L) * H, (P * A - D * O) * H),
                j.set((M * C - _ * N) * H, (M * L - _ * k) * H, (M * O - _ * A) * H),
                u[e].add(B),
                u[n].add(B),
                u[i].add(B),
                a[e].add(j),
                a[n].add(j),
                a[i].add(j);
        }
        function rt(e) {
            (Y.x = n[e * 3]),
                (Y.y = n[e * 3 + 1]),
                (Y.z = n[e * 3 + 2]),
                Z.copy(Y),
                (tt = u[e]),
                Q.copy(tt),
                Q.sub(Y.multiplyScalar(Y.dot(tt))).normalize(),
                G.crossVectors(Z, tt),
                (nt = G.dot(a[e])),
                (et = nt < 0 ? -1 : 1),
                (o[e * 4] = Q.x),
                (o[e * 4 + 1] = Q.y),
                (o[e * 4 + 2] = Q.z),
                (o[e * 4 + 3] = et);
        }
        if (this.attributes.index === undefined || this.attributes.position === undefined || this.attributes.normal === undefined || this.attributes.uv === undefined) {
            console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
            return;
        }
        var e = this.attributes.index.array,
            t = this.attributes.position.array,
            n = this.attributes.normal.array,
            r = this.attributes.uv.array,
            i = t.length / 3;
        if (this.attributes.tangent === undefined) {
            var s = 4 * i;
            this.attributes.tangent = { itemSize: 4, array: new Float32Array(s) };
        }
        var o = this.attributes.tangent.array,
            u = [],
            a = [];
        for (var f = 0; f < i; f++) (u[f] = new THREE.Vector3()), (a[f] = new THREE.Vector3());
        var l,
            c,
            h,
            p,
            d,
            v,
            m,
            g,
            y,
            b,
            w,
            E,
            S,
            x,
            T,
            N,
            C,
            k,
            L,
            A,
            O,
            M,
            _,
            D,
            P,
            H,
            B = new THREE.Vector3(),
            j = new THREE.Vector3(),
            I,
            q,
            R,
            U,
            z,
            W,
            X,
            V = this.offsets;
        for (R = 0, U = V.length; R < U; ++R) {
            var $ = V[R].start,
                J = V[R].count,
                K = V[R].index;
            for (I = $, q = $ + J; I < q; I += 3) (z = K + e[I]), (W = K + e[I + 1]), (X = K + e[I + 2]), F(z, W, X);
        }
        var Q = new THREE.Vector3(),
            G = new THREE.Vector3(),
            Y = new THREE.Vector3(),
            Z = new THREE.Vector3(),
            et,
            tt,
            nt;
        for (R = 0, U = V.length; R < U; ++R) {
            var $ = V[R].start,
                J = V[R].count,
                K = V[R].index;
            for (I = $, q = $ + J; I < q; I += 3) (z = K + e[I]), (W = K + e[I + 1]), (X = K + e[I + 2]), rt(z), rt(W), rt(X);
        }
        (this.hasTangents = !0), (this.tangentsNeedUpdate = !0);
    },
    clone: function () {
        var e = new THREE.BufferGeometry(),
            t = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        for (var n in this.attributes) {
            var r = this.attributes[n],
                i = r.array,
                s = { itemSize: r.itemSize, numItems: r.numItems, array: null };
            for (var o = 0, u = t.length; o < u; o++) {
                var a = t[o];
                if (i instanceof a) {
                    s.array = new a(i);
                    break;
                }
            }
            e.attributes[n] = s;
        }
        for (var o = 0, u = this.offsets.length; o < u; o++) {
            var f = this.offsets[o];
            e.offsets.push({ start: f.start, index: f.index, count: f.count });
        }
        return e;
    },
    dispose: function () {
        this.dispatchEvent({ type: "dispose" });
    },
}),
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype),
(THREE.Camera = function () {
    THREE.Object3D.call(this), (this.matrixWorldInverse = new THREE.Matrix4()), (this.projectionMatrix = new THREE.Matrix4()), (this.projectionMatrixInverse = new THREE.Matrix4());
}),
(THREE.Camera.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.Camera.prototype.lookAt = (function () {
    var e = new THREE.Matrix4();
    return function (t) {
        e.lookAt(this.position, t, this.up), this.quaternion.setFromRotationMatrix(e);
    };
})()),
(THREE.Camera.prototype.clone = function (e) {
    return (
        e === undefined && (e = new THREE.Camera()),
            THREE.Object3D.prototype.clone.call(this, e),
            e.matrixWorldInverse.copy(this.matrixWorldInverse),
            e.projectionMatrix.copy(this.projectionMatrix),
            e.projectionMatrixInverse.copy(this.projectionMatrixInverse),
            e
    );
}),
(THREE.OrthographicCamera = function (e, t, n, r, i, s) {
    THREE.Camera.call(this), (this.left = e), (this.right = t), (this.top = n), (this.bottom = r), (this.near = i !== undefined ? i : 0.1), (this.far = s !== undefined ? s : 2e3), this.updateProjectionMatrix();
}),
(THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype)),
(THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
    this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);
}),
(THREE.OrthographicCamera.prototype.clone = function () {
    var e = new THREE.OrthographicCamera();
    return THREE.Camera.prototype.clone.call(this, e), (e.left = this.left), (e.right = this.right), (e.top = this.top), (e.bottom = this.bottom), (e.near = this.near), (e.far = this.far), e;
}),
(THREE.PerspectiveCamera = function (e, t, n, r) {
    THREE.Camera.call(this), (this.fov = e !== undefined ? e : 50), (this.aspect = t !== undefined ? t : 1), (this.near = n !== undefined ? n : 0.1), (this.far = r !== undefined ? r : 2e3), this.updateProjectionMatrix();
}),
(THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype)),
(THREE.PerspectiveCamera.prototype.setLens = function (e, t) {
    t === undefined && (t = 24), (this.fov = 2 * THREE.Math.radToDeg(Math.atan(t / (e * 2)))), this.updateProjectionMatrix();
}),
(THREE.PerspectiveCamera.prototype.setViewOffset = function (e, t, n, r, i, s) {
    (this.fullWidth = e), (this.fullHeight = t), (this.x = n), (this.y = r), (this.width = i), (this.height = s), this.updateProjectionMatrix();
}),
(THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
    if (this.fullWidth) {
        var e = this.fullWidth / this.fullHeight,
            t = Math.tan(THREE.Math.degToRad(this.fov * 0.5)) * this.near,
            n = -t,
            r = e * n,
            i = e * t,
            s = Math.abs(i - r),
            o = Math.abs(t - n);
        this.projectionMatrix.makeFrustum(r + (this.x * s) / this.fullWidth, r + ((this.x + this.width) * s) / this.fullWidth, t - ((this.y + this.height) * o) / this.fullHeight, t - (this.y * o) / this.fullHeight, this.near, this.far);
    } else this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);
}),
(THREE.PerspectiveCamera.prototype.clone = function () {
    var e = new THREE.PerspectiveCamera();
    return THREE.Camera.prototype.clone.call(this, e), (e.fov = this.fov), (e.aspect = this.aspect), (e.near = this.near), (e.far = this.far), e;
}),
(THREE.Light = function (e) {
    THREE.Object3D.call(this), (this.color = new THREE.Color(e));
}),
(THREE.Light.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.Light.prototype.clone = function (e) {
    return e === undefined && (e = new THREE.Light()), THREE.Object3D.prototype.clone.call(this, e), e.color.copy(this.color), e;
}),
(THREE.AmbientLight = function (e) {
    THREE.Light.call(this, e);
}),
(THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype)),
(THREE.AmbientLight.prototype.clone = function () {
    var e = new THREE.AmbientLight();
    return THREE.Light.prototype.clone.call(this, e), e;
}),
(THREE.AreaLight = function (e, t) {
    THREE.Light.call(this, e),
        (this.normal = new THREE.Vector3(0, -1, 0)),
        (this.right = new THREE.Vector3(1, 0, 0)),
        (this.intensity = t !== undefined ? t : 1),
        (this.width = 1),
        (this.height = 1),
        (this.constantAttenuation = 1.5),
        (this.linearAttenuation = 0.5),
        (this.quadraticAttenuation = 0.1);
}),
(THREE.AreaLight.prototype = Object.create(THREE.Light.prototype)),
(THREE.DirectionalLight = function (e, t) {
    THREE.Light.call(this, e),
        this.position.set(0, 1, 0),
        (this.target = new THREE.Object3D()),
        (this.intensity = t !== undefined ? t : 1),
        (this.castShadow = !1),
        (this.onlyShadow = !1),
        (this.shadowCameraNear = 50),
        (this.shadowCameraFar = 5e3),
        (this.shadowCameraLeft = -500),
        (this.shadowCameraRight = 500),
        (this.shadowCameraTop = 500),
        (this.shadowCameraBottom = -500),
        (this.shadowCameraVisible = !1),
        (this.shadowBias = 0),
        (this.shadowDarkness = 0.5),
        (this.shadowMapWidth = 512),
        (this.shadowMapHeight = 512),
        (this.shadowCascade = !1),
        (this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3)),
        (this.shadowCascadeCount = 2),
        (this.shadowCascadeBias = [0, 0, 0]),
        (this.shadowCascadeWidth = [512, 512, 512]),
        (this.shadowCascadeHeight = [512, 512, 512]),
        (this.shadowCascadeNearZ = [-1, 0.99, 0.998]),
        (this.shadowCascadeFarZ = [0.99, 0.998, 1]),
        (this.shadowCascadeArray = []),
        (this.shadowMap = null),
        (this.shadowMapSize = null),
        (this.shadowCamera = null),
        (this.shadowMatrix = null);
}),
(THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype)),
(THREE.DirectionalLight.prototype.clone = function () {
    var e = new THREE.DirectionalLight();
    return THREE.Light.prototype.clone.call(this, e), (e.target = this.target.clone()), (e.intensity = this.intensity), (e.castShadow = this.castShadow), (e.onlyShadow = this.onlyShadow), e;
}),
(THREE.HemisphereLight = function (e, t, n) {
    THREE.Light.call(this, e), this.position.set(0, 100, 0), (this.groundColor = new THREE.Color(t)), (this.intensity = n !== undefined ? n : 1);
}),
(THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype)),
(THREE.HemisphereLight.prototype.clone = function () {
    var e = new THREE.HemisphereLight();
    return THREE.Light.prototype.clone.call(this, e), e.groundColor.copy(this.groundColor), (e.intensity = this.intensity), e;
}),
(THREE.PointLight = function (e, t, n) {
    THREE.Light.call(this, e), (this.intensity = t !== undefined ? t : 1), (this.distance = n !== undefined ? n : 0);
}),
(THREE.PointLight.prototype = Object.create(THREE.Light.prototype)),
(THREE.PointLight.prototype.clone = function () {
    var e = new THREE.PointLight();
    return THREE.Light.prototype.clone.call(this, e), (e.intensity = this.intensity), (e.distance = this.distance), e;
}),
(THREE.SpotLight = function (e, t, n, r, i) {
    THREE.Light.call(this, e),
        this.position.set(0, 1, 0),
        (this.target = new THREE.Object3D()),
        (this.intensity = t !== undefined ? t : 1),
        (this.distance = n !== undefined ? n : 0),
        (this.angle = r !== undefined ? r : Math.PI / 3),
        (this.exponent = i !== undefined ? i : 10),
        (this.castShadow = !1),
        (this.onlyShadow = !1),
        (this.shadowCameraNear = 50),
        (this.shadowCameraFar = 5e3),
        (this.shadowCameraFov = 50),
        (this.shadowCameraVisible = !1),
        (this.shadowBias = 0),
        (this.shadowDarkness = 0.5),
        (this.shadowMapWidth = 512),
        (this.shadowMapHeight = 512),
        (this.shadowMap = null),
        (this.shadowMapSize = null),
        (this.shadowCamera = null),
        (this.shadowMatrix = null);
}),
(THREE.SpotLight.prototype = Object.create(THREE.Light.prototype)),
(THREE.SpotLight.prototype.clone = function () {
    var e = new THREE.SpotLight();
    return (
        THREE.Light.prototype.clone.call(this, e),
            (e.target = this.target.clone()),
            (e.intensity = this.intensity),
            (e.distance = this.distance),
            (e.angle = this.angle),
            (e.exponent = this.exponent),
            (e.castShadow = this.castShadow),
            (e.onlyShadow = this.onlyShadow),
            e
    );
}),
(THREE.Loader = function (e) {
    (this.showStatus = e), (this.statusDomElement = e ? THREE.Loader.prototype.addStatusElement() : null), (this.onLoadStart = function () {}), (this.onLoadProgress = function () {}), (this.onLoadComplete = function () {});
}),
(THREE.Loader.prototype = {
    constructor: THREE.Loader,
    crossOrigin: "anonymous",
    addStatusElement: function () {
        var e = document.createElement("div");
        return (
            (e.style.position = "absolute"),
                (e.style.right = "0px"),
                (e.style.top = "0px"),
                (e.style.fontSize = "0.8em"),
                (e.style.textAlign = "left"),
                (e.style.background = "rgba(0,0,0,0.25)"),
                (e.style.color = "#fff"),
                (e.style.width = "120px"),
                (e.style.padding = "0.5em 0.5em 0.5em 0.5em"),
                (e.style.zIndex = 1e3),
                (e.innerHTML = "Loading ..."),
                e
        );
    },
    updateProgress: function (e) {
        var t = "Loaded ";
        e.total ? (t += ((100 * e.loaded) / e.total).toFixed(0) + "%") : (t += (e.loaded / 1e3).toFixed(2) + " KB"), (this.statusDomElement.innerHTML = t);
    },
    extractUrlBase: function (e) {
        var t = e.split("/");
        return t.pop(), (t.length < 1 ? "." : t.join("/")) + "/";
    },
    initMaterials: function (e, t) {
        var n = [];
        for (var r = 0; r < e.length; ++r) n[r] = THREE.Loader.prototype.createMaterial(e[r], t);
        return n;
    },
    needsTangents: function (e) {
        for (var t = 0, n = e.length; t < n; t++) {
            var r = e[t];
            if (r instanceof THREE.ShaderMaterial) return !0;
        }
        return !1;
    },
    createMaterial: function (e, t) {
        function r(e) {
            var t = Math.log(e) / Math.LN2;
            return Math.floor(t) == t;
        }
        function i(e) {
            var t = Math.log(e) / Math.LN2;
            return Math.pow(2, Math.round(t));
        }
        function s(e, t) {
            var s = new Image();
            (s.onload = function () {
                if (!r(this.width) || !r(this.height)) {
                    var t = i(this.width),
                        n = i(this.height);
                    (e.image.width = t), (e.image.height = n), e.image.getContext("2d").drawImage(this, 0, 0, t, n);
                } else e.image = this;
                e.needsUpdate = !0;
            }),
                (s.crossOrigin = n.crossOrigin),
                (s.src = t);
        }
        function o(e, n, r, i, o, u, a) {
            var f = /\.dds$/i.test(r),
                l = t + "/" + r;
            if (f) {
                var c = THREE.ImageUtils.loadCompressedTexture(l);
                e[n] = c;
            } else {
                var c = document.createElement("canvas");
                e[n] = new THREE.Texture(c);
            }
            (e[n].sourceFile = r), i && (e[n].repeat.set(i[0], i[1]), i[0] !== 1 && (e[n].wrapS = THREE.RepeatWrapping), i[1] !== 1 && (e[n].wrapT = THREE.RepeatWrapping)), o && e[n].offset.set(o[0], o[1]);
            if (u) {
                var h = { repeat: THREE.RepeatWrapping, mirror: THREE.MirroredRepeatWrapping };
                h[u[0]] !== undefined && (e[n].wrapS = h[u[0]]), h[u[1]] !== undefined && (e[n].wrapT = h[u[1]]);
            }
            a && (e[n].anisotropy = a), f || s(e[n], l);
        }
        function u(e) {
            return ((e[0] * 255) << 16) + ((e[1] * 255) << 8) + e[2] * 255;
        }
        var n = this,
            a = "MeshLambertMaterial",
            f = { color: 15658734, opacity: 1, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: !1 };
        if (e.shading) {
            var l = e.shading.toLowerCase();
            l === "phong" ? (a = "MeshPhongMaterial") : l === "basic" && (a = "MeshBasicMaterial");
        }
        e.blending !== undefined && THREE[e.blending] !== undefined && (f.blending = THREE[e.blending]);
        if (e.transparent !== undefined || e.opacity < 1) f.transparent = e.transparent;
        e.depthTest !== undefined && (f.depthTest = e.depthTest),
        e.depthWrite !== undefined && (f.depthWrite = e.depthWrite),
        e.visible !== undefined && (f.visible = e.visible),
        e.flipSided !== undefined && (f.side = THREE.BackSide),
        e.doubleSided !== undefined && (f.side = THREE.DoubleSide),
        e.wireframe !== undefined && (f.wireframe = e.wireframe),
        e.vertexColors !== undefined && (e.vertexColors === "face" ? (f.vertexColors = THREE.FaceColors) : e.vertexColors && (f.vertexColors = THREE.VertexColors)),
            e.colorDiffuse ? (f.color = u(e.colorDiffuse)) : e.DbgColor && (f.color = e.DbgColor),
        e.colorSpecular && (f.specular = u(e.colorSpecular)),
        e.colorAmbient && (f.ambient = u(e.colorAmbient)),
        e.transparency && (f.opacity = e.transparency),
        e.specularCoef && (f.shininess = e.specularCoef),
        e.mapDiffuse && t && o(f, "map", e.mapDiffuse, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy),
        e.mapLight && t && o(f, "lightMap", e.mapLight, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy),
        e.mapBump && t && o(f, "bumpMap", e.mapBump, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy),
        e.mapNormal && t && o(f, "normalMap", e.mapNormal, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy),
        e.mapSpecular && t && o(f, "specularMap", e.mapSpecular, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy),
        e.mapBumpScale && (f.bumpScale = e.mapBumpScale);
        if (e.mapNormal) {
            var c = THREE.ShaderLib.normalmap,
                h = THREE.UniformsUtils.clone(c.uniforms);
            (h.tNormal.value = f.normalMap),
            e.mapNormalFactor && h.uNormalScale.value.set(e.mapNormalFactor, e.mapNormalFactor),
            f.map && ((h.tDiffuse.value = f.map), (h.enableDiffuse.value = !0)),
            f.specularMap && ((h.tSpecular.value = f.specularMap), (h.enableSpecular.value = !0)),
            f.lightMap && ((h.tAO.value = f.lightMap), (h.enableAO.value = !0)),
                h.uDiffuseColor.value.setHex(f.color),
                h.uSpecularColor.value.setHex(f.specular),
                h.uAmbientColor.value.setHex(f.ambient),
                (h.uShininess.value = f.shininess),
            f.opacity !== undefined && (h.uOpacity.value = f.opacity);
            var p = { fragmentShader: c.fragmentShader, vertexShader: c.vertexShader, uniforms: h, lights: !0, fog: !0 },
                d = new THREE.ShaderMaterial(p);
            f.transparent && (d.transparent = !0);
        } else var d = new THREE[a](f);
        return e.DbgName !== undefined && (d.name = e.DbgName), d;
    },
}),
(THREE.XHRLoader = function (e) {
    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
}),
(THREE.XHRLoader.prototype = {
    constructor: THREE.XHRLoader,
    load: function (e, t, n, r) {
        var i = this,
            s = new XMLHttpRequest();
        t !== undefined &&
        s.addEventListener(
            "load",
            function (n) {
                t(n.target.responseText), i.manager.itemEnd(e);
            },
            !1
        ),
        n !== undefined &&
        s.addEventListener(
            "progress",
            function (e) {
                n(e);
            },
            !1
        ),
        r !== undefined &&
        s.addEventListener(
            "error",
            function (e) {
                r(e);
            },
            !1
        ),
        this.crossOrigin !== undefined && (s.crossOrigin = this.crossOrigin),
            s.open("GET", e, !0),
            s.send(null),
            i.manager.itemStart(e);
    },
    setCrossOrigin: function (e) {
        this.crossOrigin = e;
    },
}),
(THREE.ImageLoader = function (e) {
    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
}),
(THREE.ImageLoader.prototype = {
    constructor: THREE.ImageLoader,
    load: function (e, t, n, r) {
        var i = this,
            s = document.createElement("img");
        return (
            t !== undefined &&
            s.addEventListener(
                "load",
                function (n) {
                    i.manager.itemEnd(e), t(this);
                },
                !1
            ),
            n !== undefined &&
            s.addEventListener(
                "progress",
                function (e) {
                    n(e);
                },
                !1
            ),
            r !== undefined &&
            s.addEventListener(
                "error",
                function (e) {
                    r(e);
                },
                !1
            ),
            this.crossOrigin !== undefined && (s.crossOrigin = this.crossOrigin),
                (s.src = e),
                i.manager.itemStart(e),
                s
        );
    },
    setCrossOrigin: function (e) {
        this.crossOrigin = e;
    },
}),
(THREE.JSONLoader = function (e) {
    THREE.Loader.call(this, e), (this.withCredentials = !1);
}),
(THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype)),
(THREE.JSONLoader.prototype.load = function (e, t, n) {
    var r = this;
    (n = n && typeof n == "string" ? n : this.extractUrlBase(e)), this.onLoadStart(), this.loadAjaxJSON(this, e, t, n);
}),
(THREE.JSONLoader.prototype.loadAjaxJSON = function (e, t, n, r, i) {
    var s = new XMLHttpRequest(),
        o = 0;
    (s.onreadystatechange = function () {
        if (s.readyState === s.DONE)
            if (s.status === 200 || s.status === 0) {
                if (s.responseText) {
                    var u = JSON.parse(s.responseText),
                        a = e.parse(u, r);
                    n(a.geometry, a.materials);
                } else console.warn("THREE.JSONLoader: [" + t + "] seems to be unreachable or file there is empty");
                e.onLoadComplete();
            } else console.error("THREE.JSONLoader: Couldn't load [" + t + "] [" + s.status + "]");
        else
            s.readyState === s.LOADING
                ? i && (o === 0 && (o = s.getResponseHeader("Content-Length")), i({ total: o, loaded: s.responseText.length }))
                : s.readyState === s.HEADERS_RECEIVED && i !== undefined && (o = s.getResponseHeader("Content-Length"));
    }),
        s.open("GET", t, !0),
        (s.withCredentials = this.withCredentials),
        s.send(null);
}),
(THREE.JSONLoader.prototype.parse = function (e, t) {
    function s(t) {
        function n(e, t) {
            return e & (1 << t);
        }
        var i,
            s,
            o,
            u,
            a,
            f,
            l,
            c,
            h,
            p,
            d,
            v,
            m,
            g,
            y,
            b,
            w,
            E,
            S,
            x,
            T,
            N,
            C,
            k,
            L,
            A,
            O,
            M,
            _ = e.faces,
            D = e.vertices,
            P = e.normals,
            H = e.colors,
            B = 0;
        if (e.uvs !== undefined) {
            for (i = 0; i < e.uvs.length; i++) e.uvs[i].length && B++;
            for (i = 0; i < B; i++) r.faceVertexUvs[i] = [];
        }
        (u = 0), (a = D.length);
        while (u < a) (E = new THREE.Vector3()), (E.x = D[u++] * t), (E.y = D[u++] * t), (E.z = D[u++] * t), r.vertices.push(E);
        (u = 0), (a = _.length);
        while (u < a) {
            (p = _[u++]), (d = n(p, 0)), (v = n(p, 1)), (m = n(p, 3)), (g = n(p, 4)), (y = n(p, 5)), (b = n(p, 6)), (w = n(p, 7));
            if (d) {
                (x = new THREE.Face3()),
                    (x.a = _[u]),
                    (x.b = _[u + 1]),
                    (x.c = _[u + 3]),
                    (T = new THREE.Face3()),
                    (T.a = _[u + 1]),
                    (T.b = _[u + 2]),
                    (T.c = _[u + 3]),
                    (u += 4),
                v && ((h = _[u++]), (x.materialIndex = h), (T.materialIndex = h)),
                    (o = r.faces.length);
                if (m)
                    for (i = 0; i < B; i++) {
                        (L = e.uvs[i]), (r.faceVertexUvs[i][o] = []), (r.faceVertexUvs[i][o + 1] = []);
                        for (s = 0; s < 4; s++) (c = _[u++]), (O = L[c * 2]), (M = L[c * 2 + 1]), (A = new THREE.Vector2(O, M)), s !== 2 && r.faceVertexUvs[i][o].push(A), s !== 0 && r.faceVertexUvs[i][o + 1].push(A);
                    }
                g && ((l = _[u++] * 3), x.normal.set(P[l++], P[l++], P[l]), T.normal.copy(x.normal));
                if (y) for (i = 0; i < 4; i++) (l = _[u++] * 3), (k = new THREE.Vector3(P[l++], P[l++], P[l])), i !== 2 && x.vertexNormals.push(k), i !== 0 && T.vertexNormals.push(k);
                b && ((f = _[u++]), (C = H[f]), x.color.setHex(C), T.color.setHex(C));
                if (w) for (i = 0; i < 4; i++) (f = _[u++]), (C = H[f]), i !== 2 && x.vertexColors.push(new THREE.Color(C)), i !== 0 && T.vertexColors.push(new THREE.Color(C));
                r.faces.push(x), r.faces.push(T);
            } else {
                (S = new THREE.Face3()), (S.a = _[u++]), (S.b = _[u++]), (S.c = _[u++]), v && ((h = _[u++]), (S.materialIndex = h)), (o = r.faces.length);
                if (m)
                    for (i = 0; i < B; i++) {
                        (L = e.uvs[i]), (r.faceVertexUvs[i][o] = []);
                        for (s = 0; s < 3; s++) (c = _[u++]), (O = L[c * 2]), (M = L[c * 2 + 1]), (A = new THREE.Vector2(O, M)), r.faceVertexUvs[i][o].push(A);
                    }
                g && ((l = _[u++] * 3), S.normal.set(P[l++], P[l++], P[l]));
                if (y) for (i = 0; i < 3; i++) (l = _[u++] * 3), (k = new THREE.Vector3(P[l++], P[l++], P[l])), S.vertexNormals.push(k);
                b && ((f = _[u++]), S.color.setHex(H[f]));
                if (w) for (i = 0; i < 3; i++) (f = _[u++]), S.vertexColors.push(new THREE.Color(H[f]));
                r.faces.push(S);
            }
        }
    }
    function o() {
        var t, n, i, s, o, u, a, f, l, c;
        if (e.skinWeights) for (t = 0, n = e.skinWeights.length; t < n; t += 2) (i = e.skinWeights[t]), (s = e.skinWeights[t + 1]), (o = 0), (u = 0), r.skinWeights.push(new THREE.Vector4(i, s, o, u));
        if (e.skinIndices) for (t = 0, n = e.skinIndices.length; t < n; t += 2) (a = e.skinIndices[t]), (f = e.skinIndices[t + 1]), (l = 0), (c = 0), r.skinIndices.push(new THREE.Vector4(a, f, l, c));
        (r.bones = e.bones), (r.animation = e.animation);
    }
    function u(t) {
        if (e.morphTargets !== undefined) {
            var n, i, s, o, u, a;
            for (n = 0, i = e.morphTargets.length; n < i; n++) {
                (r.morphTargets[n] = {}), (r.morphTargets[n].name = e.morphTargets[n].name), (r.morphTargets[n].vertices = []), (u = r.morphTargets[n].vertices), (a = e.morphTargets[n].vertices);
                for (s = 0, o = a.length; s < o; s += 3) {
                    var f = new THREE.Vector3();
                    (f.x = a[s] * t), (f.y = a[s + 1] * t), (f.z = a[s + 2] * t), u.push(f);
                }
            }
        }
        if (e.morphColors !== undefined) {
            var n, i, l, c, h, p, d;
            for (n = 0, i = e.morphColors.length; n < i; n++) {
                (r.morphColors[n] = {}), (r.morphColors[n].name = e.morphColors[n].name), (r.morphColors[n].colors = []), (h = r.morphColors[n].colors), (p = e.morphColors[n].colors);
                for (l = 0, c = p.length; l < c; l += 3) (d = new THREE.Color(16755200)), d.setRGB(p[l], p[l + 1], p[l + 2]), h.push(d);
            }
        }
    }
    var n = this,
        r = new THREE.Geometry(),
        i = e.scale !== undefined ? 1 / e.scale : 1;
    s(i), o(), u(i), r.computeCentroids(), r.computeFaceNormals(), r.computeBoundingSphere();
    if (e.materials === undefined) return { geometry: r };
    var a = this.initMaterials(e.materials, t);
    return this.needsTangents(a) && r.computeTangents(), { geometry: r, materials: a };
}),
(THREE.LoadingManager = function (e, t, n) {
    var r = this,
        i = 0,
        s = 0;
    (this.onLoad = e),
        (this.onProgress = t),
        (this.onError = n),
        (this.itemStart = function (e) {
            s++;
        }),
        (this.itemEnd = function (e) {
            i++, r.onProgress !== undefined && r.onProgress(e, i, s), i === s && r.onLoad !== undefined && r.onLoad();
        });
}),
(THREE.DefaultLoadingManager = new THREE.LoadingManager()),
(THREE.BufferGeometryLoader = function (e) {
    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
}),
(THREE.BufferGeometryLoader.prototype = {
    constructor: THREE.BufferGeometryLoader,
    load: function (e, t, n, r) {
        var i = this,
            s = new THREE.XHRLoader();
        s.setCrossOrigin(this.crossOrigin),
            s.load(e, function (e) {
                t(i.parse(JSON.parse(e)));
            });
    },
    setCrossOrigin: function (e) {
        this.crossOrigin = e;
    },
    parse: function (e) {
        var t = new THREE.BufferGeometry(),
            n = e.attributes,
            r = e.offsets,
            i = e.boundingSphere;
        for (var s in n) {
            var o = n[s];
            t.attributes[s] = { itemSize: o.itemSize, array: new self[o.type](o.array) };
        }
        return r !== undefined && (t.offsets = JSON.parse(JSON.stringify(r))), i !== undefined && (t.boundingSphere = new THREE.Sphere(new THREE.Vector3().fromArray(i.center !== undefined ? i.center : [0, 0, 0]), i.radius)), t;
    },
}),
(THREE.GeometryLoader = function (e) {
    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
}),
(THREE.GeometryLoader.prototype = {
    constructor: THREE.GeometryLoader,
    load: function (e, t, n, r) {
        var i = this,
            s = new THREE.XHRLoader();
        s.setCrossOrigin(this.crossOrigin),
            s.load(e, function (e) {
                t(i.parse(JSON.parse(e)));
            });
    },
    setCrossOrigin: function (e) {
        this.crossOrigin = e;
    },
    parse: function (e) {},
}),
(THREE.MaterialLoader = function (e) {
    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
}),
(THREE.MaterialLoader.prototype = {
    constructor: THREE.MaterialLoader,
    load: function (e, t, n, r) {
        var i = this,
            s = new THREE.XHRLoader();
        s.setCrossOrigin(this.crossOrigin),
            s.load(e, function (e) {
                t(i.parse(JSON.parse(e)));
            });
    },
    setCrossOrigin: function (e) {
        this.crossOrigin = e;
    },
    parse: function (e) {
        var t = new THREE[e.type]();
        e.color !== undefined && t.color.setHex(e.color),
        e.ambient !== undefined && t.ambient.setHex(e.ambient),
        e.emissive !== undefined && t.emissive.setHex(e.emissive),
        e.specular !== undefined && t.specular.setHex(e.specular),
        e.shininess !== undefined && (t.shininess = e.shininess),
        e.vertexColors !== undefined && (t.vertexColors = e.vertexColors),
        e.blending !== undefined && (t.blending = e.blending),
        e.opacity !== undefined && (t.opacity = e.opacity),
        e.transparent !== undefined && (t.transparent = e.transparent),
        e.wireframe !== undefined && (t.wireframe = e.wireframe);
        if (e.materials !== undefined) for (var n = 0, r = e.materials.length; n < r; n++) t.materials.push(this.parse(e.materials[n]));
        return t;
    },
}),
(THREE.ObjectLoader = function (e) {
    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
}),
(THREE.ObjectLoader.prototype = {
    constructor: THREE.ObjectLoader,
    load: function (e, t, n, r) {
        var i = this,
            s = new THREE.XHRLoader(i.manager);
        s.setCrossOrigin(this.crossOrigin),
            s.load(e, function (e) {
                t(i.parse(JSON.parse(e)));
            });
    },
    setCrossOrigin: function (e) {
        this.crossOrigin = e;
    },
    parse: function (e) {
        var t = this.parseGeometries(e.geometries),
            n = this.parseMaterials(e.materials),
            r = this.parseObject(e.object, t, n);
        return r;
    },
    parseGeometries: function (e) {
        var t = {};
        if (e !== undefined) {
            var n = new THREE.JSONLoader(),
                r = new THREE.BufferGeometryLoader();
            for (var i = 0, s = e.length; i < s; i++) {
                var o,
                    u = e[i];
                switch (u.type) {
                    case "PlaneGeometry":
                        o = new THREE.PlaneGeometry(u.width, u.height, u.widthSegments, u.heightSegments);
                        break;
                    case "CircleGeometry":
                        o = new THREE.CircleGeometry(u.radius, u.segments);
                        break;
                    case "CubeGeometry":
                        o = new THREE.CubeGeometry(u.width, u.height, u.depth, u.widthSegments, u.heightSegments, u.depthSegments);
                        break;
                    case "CylinderGeometry":
                        o = new THREE.CylinderGeometry(u.radiusTop, u.radiusBottom, u.height, u.radiusSegments, u.heightSegments, u.openEnded);
                        break;
                    case "SphereGeometry":
                        o = new THREE.SphereGeometry(u.radius, u.widthSegments, u.heightSegments, u.phiStart, u.phiLength, u.thetaStart, u.thetaLength);
                        break;
                    case "IcosahedronGeometry":
                        o = new THREE.IcosahedronGeometry(u.radius, u.detail);
                        break;
                    case "TorusGeometry":
                        o = new THREE.TorusGeometry(u.radius, u.tube, u.radialSegments, u.tubularSegments, u.arc);
                        break;
                    case "TorusKnotGeometry":
                        o = new THREE.TorusKnotGeometry(u.radius, u.tube, u.radialSegments, u.tubularSegments, u.p, u.q, u.heightScale);
                        break;
                    case "BufferGeometry":
                        o = r.parse(u.data);
                        break;
                    case "Geometry":
                        o = n.parse(u.data).geometry;
                }
                (o.uuid = u.uuid), u.name !== undefined && (o.name = u.name), (t[u.uuid] = o);
            }
        }
        return t;
    },
    parseMaterials: function (e) {
        var t = {};
        if (e !== undefined) {
            var n = new THREE.MaterialLoader();
            for (var r = 0, i = e.length; r < i; r++) {
                var s = e[r],
                    o = n.parse(s);
                (o.uuid = s.uuid), s.name !== undefined && (o.name = s.name), (t[s.uuid] = o);
            }
        }
        return t;
    },
    parseObject: (function () {
        var e = new THREE.Matrix4();
        return function (t, n, r) {
            var i;
            switch (t.type) {
                case "Scene":
                    i = new THREE.Scene();
                    break;
                case "PerspectiveCamera":
                    i = new THREE.PerspectiveCamera(t.fov, t.aspect, t.near, t.far);
                    break;
                case "OrthographicCamera":
                    i = new THREE.OrthographicCamera(t.left, t.right, t.top, t.bottom, t.near, t.far);
                    break;
                case "AmbientLight":
                    i = new THREE.AmbientLight(t.color);
                    break;
                case "DirectionalLight":
                    i = new THREE.DirectionalLight(t.color, t.intensity);
                    break;
                case "PointLight":
                    i = new THREE.PointLight(t.color, t.intensity, t.distance);
                    break;
                case "SpotLight":
                    i = new THREE.SpotLight(t.color, t.intensity, t.distance, t.angle, t.exponent);
                    break;
                case "HemisphereLight":
                    i = new THREE.HemisphereLight(t.color, t.groundColor, t.intensity);
                    break;
                case "Mesh":
                    var s = n[t.geometry],
                        o = r[t.material];
                    s === undefined && console.error("THREE.ObjectLoader: Undefined geometry " + t.geometry), o === undefined && console.error("THREE.ObjectLoader: Undefined material " + t.material), (i = new THREE.Mesh(s, o));
                    break;
                default:
                    i = new THREE.Object3D();
            }
            (i.uuid = t.uuid),
            t.name !== undefined && (i.name = t.name),
                t.matrix !== undefined
                    ? (e.fromArray(t.matrix), e.decompose(i.position, i.quaternion, i.scale))
                    : (t.position !== undefined && i.position.fromArray(t.position), t.rotation !== undefined && i.rotation.fromArray(t.rotation), t.scale !== undefined && i.scale.fromArray(t.scale)),
            t.visible !== undefined && (i.visible = t.visible),
            t.userData !== undefined && (i.userData = t.userData);
            if (t.children !== undefined) for (var u in t.children) i.add(this.parseObject(t.children[u], n, r));
            return i;
        };
    })(),
}),
(THREE.SceneLoader = function () {
    (this.onLoadStart = function () {}),
        (this.onLoadProgress = function () {}),
        (this.onLoadComplete = function () {}),
        (this.callbackSync = function () {}),
        (this.callbackProgress = function () {}),
        (this.geometryHandlers = {}),
        (this.hierarchyHandlers = {}),
        this.addGeometryHandler("ascii", THREE.JSONLoader);
}),
(THREE.SceneLoader.prototype = {
    constructor: THREE.SceneLoader,
    load: function (e, t, n, r) {
        var i = this,
            s = new THREE.XHRLoader(i.manager);
        s.setCrossOrigin(this.crossOrigin),
            s.load(e, function (n) {
                i.parse(JSON.parse(n), t, e);
            });
    },
    setCrossOrigin: function (e) {
        this.crossOrigin = e;
    },
    addGeometryHandler: function (e, t) {
        this.geometryHandlers[e] = { loaderClass: t };
    },
    addHierarchyHandler: function (e, t) {
        this.hierarchyHandlers[e] = { loaderClass: t };
    },
    parse: function (e, t, n) {
        function k(e, t) {
            return t == "relativeToHTML" ? e : i + "/" + e;
        }
        function L() {
            A(b.scene, E.objects);
        }
        function A(e, t) {
            var n, i, a, f, l, c;
            for (var v in t) {
                var m = b.objects[v],
                    g = t[v];
                if (m === undefined) {
                    if (g.type && g.type in r.hierarchyHandlers) {
                        if (g.loading === undefined) {
                            var y = { type: 1, url: 1, material: 1, position: 1, rotation: 1, scale: 1, visible: 1, children: 1, userData: 1, skin: 1, morph: 1, mirroredLoop: 1, duration: 1 },
                                S = {};
                            for (var x in g) x in y || (S[x] = g[x]);
                            (o = b.materials[g.material]), (g.loading = !0);
                            var T = r.hierarchyHandlers[g.type].loaderObject;
                            T.options ? T.load(k(g.url, E.urlBaseType), D(v, e, o, g)) : T.load(k(g.url, E.urlBaseType), D(v, e, o, g), S);
                        }
                    } else if (g.geometry !== undefined) {
                        s = b.geometries[g.geometry];
                        if (s) {
                            var N = !1;
                            (o = b.materials[g.material]),
                                (N = o instanceof THREE.ShaderMaterial),
                                (a = g.position),
                                (f = g.rotation),
                                (l = g.scale),
                                (n = g.matrix),
                                (c = g.quaternion),
                            g.material || (o = new THREE.MeshFaceMaterial(b.face_materials[g.geometry])),
                            o instanceof THREE.MeshFaceMaterial && o.materials.length === 0 && (o = new THREE.MeshFaceMaterial(b.face_materials[g.geometry]));
                            if (o instanceof THREE.MeshFaceMaterial) for (var C = 0; C < o.materials.length; C++) N = N || o.materials[C] instanceof THREE.ShaderMaterial;
                            N && s.computeTangents(),
                                g.skin
                                    ? (m = new THREE.SkinnedMesh(s, o))
                                    : g.morph
                                    ? ((m = new THREE.MorphAnimMesh(s, o)),
                                    g.duration !== undefined && (m.duration = g.duration),
                                    g.time !== undefined && (m.time = g.time),
                                    g.mirroredLoop !== undefined && (m.mirroredLoop = g.mirroredLoop),
                                    o.morphNormals && s.computeMorphNormals())
                                    : (m = new THREE.Mesh(s, o)),
                                (m.name = v),
                                n
                                    ? ((m.matrixAutoUpdate = !1), m.matrix.set(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9], n[10], n[11], n[12], n[13], n[14], n[15]))
                                    : (m.position.fromArray(a), c ? m.quaternion.fromArray(c) : m.rotation.fromArray(f), m.scale.fromArray(l)),
                                (m.visible = g.visible),
                                (m.castShadow = g.castShadow),
                                (m.receiveShadow = g.receiveShadow),
                                e.add(m),
                                (b.objects[v] = m);
                        }
                    } else
                        g.type === "DirectionalLight" || g.type === "PointLight" || g.type === "AmbientLight"
                            ? ((p = g.color !== undefined ? g.color : 16777215),
                                (d = g.intensity !== undefined ? g.intensity : 1),
                                g.type === "DirectionalLight"
                                    ? ((a = g.direction), (h = new THREE.DirectionalLight(p, d)), h.position.fromArray(a), g.target && (w.push({ object: h, targetName: g.target }), (h.target = null)))
                                    : g.type === "PointLight"
                                    ? ((a = g.position), (i = g.distance), (h = new THREE.PointLight(p, d, i)), h.position.fromArray(a))
                                    : g.type === "AmbientLight" && (h = new THREE.AmbientLight(p)),
                                e.add(h),
                                (h.name = v),
                                (b.lights[v] = h),
                                (b.objects[v] = h))
                            : g.type === "PerspectiveCamera" || g.type === "OrthographicCamera"
                            ? ((a = g.position),
                                (f = g.rotation),
                                (c = g.quaternion),
                                g.type === "PerspectiveCamera"
                                    ? (u = new THREE.PerspectiveCamera(g.fov, g.aspect, g.near, g.far))
                                    : g.type === "OrthographicCamera" && (u = new THREE.OrthographicCamera(g.left, g.right, g.top, g.bottom, g.near, g.far)),
                                (u.name = v),
                                u.position.fromArray(a),
                                c !== undefined ? u.quaternion.fromArray(c) : f !== undefined && u.rotation.fromArray(f),
                                e.add(u),
                                (b.cameras[v] = u),
                                (b.objects[v] = u))
                            : ((a = g.position),
                                (f = g.rotation),
                                (l = g.scale),
                                (c = g.quaternion),
                                (m = new THREE.Object3D()),
                                (m.name = v),
                                m.position.fromArray(a),
                                c ? m.quaternion.fromArray(c) : m.rotation.fromArray(f),
                                m.scale.fromArray(l),
                                (m.visible = g.visible !== undefined ? g.visible : !1),
                                e.add(m),
                                (b.objects[v] = m),
                                (b.empties[v] = m));
                    if (m) {
                        if (g.userData !== undefined)
                            for (var L in g.userData) {
                                var O = g.userData[L];
                                m.userData[L] = O;
                            }
                        if (g.groups !== undefined)
                            for (var C = 0; C < g.groups.length; C++) {
                                var M = g.groups[C];
                                b.groups[M] === undefined && (b.groups[M] = []), b.groups[M].push(v);
                            }
                    }
                }
                m !== undefined && g.children !== undefined && A(m, g.children);
            }
        }
        function O(e, t, n) {
            (b.geometries[n] = e), (b.face_materials[n] = t), L();
        }
        function M(e, t, n, r, i) {
            var s = i.position,
                o = i.rotation,
                u = i.quaternion,
                a = i.scale;
            e.position.fromArray(s),
                u ? e.quaternion.fromArray(u) : e.rotation.fromArray(o),
                e.scale.fromArray(a),
            r &&
            e.traverse(function (e) {
                e.material = r;
            });
            var f = i.visible !== undefined ? i.visible : !0;
            e.traverse(function (e) {
                e.visible = f;
            }),
                n.add(e),
                (e.name = t),
                (b.objects[t] = e),
                L();
        }
        function _(e) {
            return function (t, n) {
                (t.name = e), O(t, n, e), (v -= 1), r.onLoadComplete(), H();
            };
        }
        function D(e, t, n, i) {
            return function (s) {
                var o;
                s.content ? (o = s.content) : s.dae ? (o = s.scene) : (o = s), M(o, e, t, n, i), (v -= 1), r.onLoadComplete(), H();
            };
        }
        function P(e) {
            return function (t, n) {
                (t.name = e), (b.geometries[e] = t), (b.face_materials[e] = n);
            };
        }
        function H() {
            var e = { totalModels: g, totalTextures: y, loadedModels: g - v, loadedTextures: y - m };
            r.callbackProgress(e, b), r.onLoadProgress(), v === 0 && m === 0 && (B(), t(b));
        }
        function B() {
            for (var e = 0; e < w.length; e++) {
                var t = w[e],
                    n = b.objects[t.targetName];
                n ? (t.object.target = n) : ((t.object.target = new THREE.Object3D()), b.scene.add(t.object.target)), (t.object.target.userData.targetInverse = t.object);
            }
        }
        function I(e, t) {
            t(e);
            if (e.children !== undefined) for (var n in e.children) I(e.children[n], t);
        }
        var r = this,
            i = THREE.Loader.prototype.extractUrlBase(n),
            s,
            o,
            u,
            a,
            f,
            l,
            c,
            h,
            p,
            d,
            v,
            m,
            g,
            y,
            b,
            w = [],
            E = e;
        for (var S in this.geometryHandlers) {
            var x = this.geometryHandlers[S].loaderClass;
            this.geometryHandlers[S].loaderObject = new x();
        }
        for (var S in this.hierarchyHandlers) {
            var x = this.hierarchyHandlers[S].loaderClass;
            this.hierarchyHandlers[S].loaderObject = new x();
        }
        (v = 0), (m = 0), (b = { scene: new THREE.Scene(), geometries: {}, face_materials: {}, materials: {}, textures: {}, objects: {}, cameras: {}, lights: {}, fogs: {}, empties: {}, groups: {} });
        if (E.transform) {
            var T = E.transform.position,
                N = E.transform.rotation,
                C = E.transform.scale;
            T && b.scene.position.fromArray(T), N && b.scene.rotation.fromArray(N), C && b.scene.scale.fromArray(C);
            if (T || N || C) b.scene.updateMatrix(), b.scene.updateMatrixWorld();
        }
        var j = function (e) {
                (m -= e), H(), r.onLoadComplete();
            },
            F = function (e) {
                return function () {
                    j(e);
                };
            },
            q,
            R;
        for (q in E.fogs) (R = E.fogs[q]), R.type === "linear" ? (a = new THREE.Fog(0, R.near, R.far)) : R.type === "exp2" && (a = new THREE.FogExp2(0, R.density)), (c = R.color), a.color.setRGB(c[0], c[1], c[2]), (b.fogs[q] = a);
        var U, z;
        for (U in E.geometries) (z = E.geometries[U]), z.type in this.geometryHandlers && ((v += 1), r.onLoadStart());
        for (var W in E.objects)
            I(E.objects[W], function (e) {
                e.type && e.type in r.hierarchyHandlers && ((v += 1), r.onLoadStart());
            });
        g = v;
        for (U in E.geometries) {
            z = E.geometries[U];
            if (z.type === "cube") (s = new THREE.CubeGeometry(z.width, z.height, z.depth, z.widthSegments, z.heightSegments, z.depthSegments)), (s.name = U), (b.geometries[U] = s);
            else if (z.type === "plane") (s = new THREE.PlaneGeometry(z.width, z.height, z.widthSegments, z.heightSegments)), (s.name = U), (b.geometries[U] = s);
            else if (z.type === "sphere") (s = new THREE.SphereGeometry(z.radius, z.widthSegments, z.heightSegments)), (s.name = U), (b.geometries[U] = s);
            else if (z.type === "cylinder") (s = new THREE.CylinderGeometry(z.topRad, z.botRad, z.height, z.radSegs, z.heightSegs)), (s.name = U), (b.geometries[U] = s);
            else if (z.type === "torus") (s = new THREE.TorusGeometry(z.radius, z.tube, z.segmentsR, z.segmentsT)), (s.name = U), (b.geometries[U] = s);
            else if (z.type === "icosahedron") (s = new THREE.IcosahedronGeometry(z.radius, z.subdivisions)), (s.name = U), (b.geometries[U] = s);
            else if (z.type in this.geometryHandlers) {
                var X = {};
                for (var V in z) V !== "type" && V !== "url" && (X[V] = z[V]);
                var $ = this.geometryHandlers[z.type].loaderObject;
                $.load(k(z.url, E.urlBaseType), _(U), X);
            } else if (z.type === "embedded") {
                var J = E.embeds[z.id],
                    K = "";
                J.metadata = E.metadata;
                if (J) {
                    var Q = this.geometryHandlers.ascii.loaderObject,
                        G = Q.parse(J, K);
                    P(U)(G.geometry, G.materials);
                }
            }
        }
        var Y, Z;
        for (Y in E.textures) {
            Z = E.textures[Y];
            if (Z.url instanceof Array) {
                m += Z.url.length;
                for (var et = 0; et < Z.url.length; et++) r.onLoadStart();
            } else (m += 1), r.onLoadStart();
        }
        y = m;
        for (Y in E.textures) {
            (Z = E.textures[Y]), Z.mapping !== undefined && THREE[Z.mapping] !== undefined && (Z.mapping = new THREE[Z.mapping]());
            if (Z.url instanceof Array) {
                var tt = Z.url.length,
                    nt = [];
                for (var rt = 0; rt < tt; rt++) nt[rt] = k(Z.url[rt], E.urlBaseType);
                var it = /\.dds$/i.test(nt[0]);
                it ? (f = THREE.ImageUtils.loadCompressedTextureCube(nt, Z.mapping, F(tt))) : (f = THREE.ImageUtils.loadTextureCube(nt, Z.mapping, F(tt)));
            } else {
                var it = /\.dds$/i.test(Z.url),
                    st = k(Z.url, E.urlBaseType),
                    ot = F(1);
                it ? (f = THREE.ImageUtils.loadCompressedTexture(st, Z.mapping, ot)) : (f = THREE.ImageUtils.loadTexture(st, Z.mapping, ot)),
                THREE[Z.minFilter] !== undefined && (f.minFilter = THREE[Z.minFilter]),
                THREE[Z.magFilter] !== undefined && (f.magFilter = THREE[Z.magFilter]),
                Z.anisotropy && (f.anisotropy = Z.anisotropy),
                Z.repeat && (f.repeat.set(Z.repeat[0], Z.repeat[1]), Z.repeat[0] !== 1 && (f.wrapS = THREE.RepeatWrapping), Z.repeat[1] !== 1 && (f.wrapT = THREE.RepeatWrapping)),
                Z.offset && f.offset.set(Z.offset[0], Z.offset[1]);
                if (Z.wrap) {
                    var ut = { repeat: THREE.RepeatWrapping, mirror: THREE.MirroredRepeatWrapping };
                    ut[Z.wrap[0]] !== undefined && (f.wrapS = ut[Z.wrap[0]]), ut[Z.wrap[1]] !== undefined && (f.wrapT = ut[Z.wrap[1]]);
                }
            }
            b.textures[Y] = f;
        }
        var at, ft, lt;
        for (at in E.materials) {
            ft = E.materials[at];
            for (lt in ft.parameters)
                if (lt === "envMap" || lt === "map" || lt === "lightMap" || lt === "bumpMap") ft.parameters[lt] = b.textures[ft.parameters[lt]];
                else if (lt === "shading") ft.parameters[lt] = ft.parameters[lt] === "flat" ? THREE.FlatShading : THREE.SmoothShading;
                else if (lt === "side") ft.parameters[lt] == "double" ? (ft.parameters[lt] = THREE.DoubleSide) : ft.parameters[lt] == "back" ? (ft.parameters[lt] = THREE.BackSide) : (ft.parameters[lt] = THREE.FrontSide);
                else if (lt === "blending") ft.parameters[lt] = ft.parameters[lt] in THREE ? THREE[ft.parameters[lt]] : THREE.NormalBlending;
                else if (lt === "combine") ft.parameters[lt] = ft.parameters[lt] in THREE ? THREE[ft.parameters[lt]] : THREE.MultiplyOperation;
                else if (lt === "vertexColors") ft.parameters[lt] == "face" ? (ft.parameters[lt] = THREE.FaceColors) : ft.parameters[lt] && (ft.parameters[lt] = THREE.VertexColors);
                else if (lt === "wrapRGB") {
                    var ct = ft.parameters[lt];
                    ft.parameters[lt] = new THREE.Vector3(ct[0], ct[1], ct[2]);
                }
            ft.parameters.opacity !== undefined && ft.parameters.opacity < 1 && (ft.parameters.transparent = !0);
            if (ft.parameters.normalMap) {
                var ht = THREE.ShaderLib.normalmap,
                    pt = THREE.UniformsUtils.clone(ht.uniforms),
                    dt = ft.parameters.color,
                    vt = ft.parameters.specular,
                    mt = ft.parameters.ambient,
                    gt = ft.parameters.shininess;
                (pt.tNormal.value = b.textures[ft.parameters.normalMap]),
                ft.parameters.normalScale && pt.uNormalScale.value.set(ft.parameters.normalScale[0], ft.parameters.normalScale[1]),
                ft.parameters.map && ((pt.tDiffuse.value = ft.parameters.map), (pt.enableDiffuse.value = !0)),
                ft.parameters.envMap && ((pt.tCube.value = ft.parameters.envMap), (pt.enableReflection.value = !0), (pt.uReflectivity.value = ft.parameters.reflectivity)),
                ft.parameters.lightMap && ((pt.tAO.value = ft.parameters.lightMap), (pt.enableAO.value = !0)),
                ft.parameters.specularMap && ((pt.tSpecular.value = b.textures[ft.parameters.specularMap]), (pt.enableSpecular.value = !0)),
                ft.parameters.displacementMap &&
                ((pt.tDisplacement.value = b.textures[ft.parameters.displacementMap]),
                    (pt.enableDisplacement.value = !0),
                    (pt.uDisplacementBias.value = ft.parameters.displacementBias),
                    (pt.uDisplacementScale.value = ft.parameters.displacementScale)),
                    pt.uDiffuseColor.value.setHex(dt),
                    pt.uSpecularColor.value.setHex(vt),
                    pt.uAmbientColor.value.setHex(mt),
                    (pt.uShininess.value = gt),
                ft.parameters.opacity && (pt.uOpacity.value = ft.parameters.opacity);
                var yt = { fragmentShader: ht.fragmentShader, vertexShader: ht.vertexShader, uniforms: pt, lights: !0, fog: !0 };
                o = new THREE.ShaderMaterial(yt);
            } else o = new THREE[ft.type](ft.parameters);
            (o.name = at), (b.materials[at] = o);
        }
        for (at in E.materials) {
            ft = E.materials[at];
            if (ft.parameters.materials) {
                var bt = [];
                for (var rt = 0; rt < ft.parameters.materials.length; rt++) {
                    var wt = ft.parameters.materials[rt];
                    bt.push(b.materials[wt]);
                }
                b.materials[at].materials = bt;
            }
        }
        L(), b.cameras && E.defaults.camera && (b.currentCamera = b.cameras[E.defaults.camera]), b.fogs && E.defaults.fog && (b.scene.fog = b.fogs[E.defaults.fog]), r.callbackSync(b), H();
    },
}),
(THREE.TextureLoader = function (e) {
    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
}),
(THREE.TextureLoader.prototype = {
    constructor: THREE.TextureLoader,
    load: function (e, t, n, r) {
        var i = this,
            s = new THREE.ImageLoader(i.manager);
        s.setCrossOrigin(this.crossOrigin),
            s.load(e, function (e) {
                var n = new THREE.Texture(e);
                (n.needsUpdate = !0), t !== undefined && t(n);
            });
    },
    setCrossOrigin: function (e) {
        this.crossOrigin = e;
    },
}),
(THREE.Material = function () {
    (this.id = THREE.MaterialIdCount++),
        (this.uuid = THREE.Math.generateUUID()),
        (this.name = ""),
        (this.side = THREE.FrontSide),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.blending = THREE.NormalBlending),
        (this.blendSrc = THREE.SrcAlphaFactor),
        (this.blendDst = THREE.OneMinusSrcAlphaFactor),
        (this.blendEquation = THREE.AddEquation),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.alphaTest = 0),
        (this.overdraw = 0),
        (this.visible = !0),
        (this.needsUpdate = !0);
}),
(THREE.Material.prototype = {
    constructor: THREE.Material,
    setValues: function (e) {
        if (e === undefined) return;
        for (var t in e) {
            var n = e[t];
            if (n === undefined) {
                console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                continue;
            }
            if (t in this) {
                var r = this[t];
                r instanceof THREE.Color ? r.set(n) : r instanceof THREE.Vector3 && n instanceof THREE.Vector3 ? r.copy(n) : t == "overdraw" ? (this[t] = Number(n)) : (this[t] = n);
            }
        }
    },
    clone: function (e) {
        return (
            e === undefined && (e = new THREE.Material()),
                (e.name = this.name),
                (e.side = this.side),
                (e.opacity = this.opacity),
                (e.transparent = this.transparent),
                (e.blending = this.blending),
                (e.blendSrc = this.blendSrc),
                (e.blendDst = this.blendDst),
                (e.blendEquation = this.blendEquation),
                (e.depthTest = this.depthTest),
                (e.depthWrite = this.depthWrite),
                (e.polygonOffset = this.polygonOffset),
                (e.polygonOffsetFactor = this.polygonOffsetFactor),
                (e.polygonOffsetUnits = this.polygonOffsetUnits),
                (e.alphaTest = this.alphaTest),
                (e.overdraw = this.overdraw),
                (e.visible = this.visible),
                e
        );
    },
    dispose: function () {
        this.dispatchEvent({ type: "dispose" });
    },
}),
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype),
(THREE.MaterialIdCount = 0),
(THREE.LineBasicMaterial = function (e) {
    THREE.Material.call(this), (this.color = new THREE.Color(16777215)), (this.linewidth = 1), (this.linecap = "round"), (this.linejoin = "round"), (this.vertexColors = !1), (this.fog = !0), this.setValues(e);
}),
(THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype)),
(THREE.LineBasicMaterial.prototype.clone = function () {
    var e = new THREE.LineBasicMaterial();
    return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), (e.linewidth = this.linewidth), (e.linecap = this.linecap), (e.linejoin = this.linejoin), (e.vertexColors = this.vertexColors), (e.fog = this.fog), e;
}),
(THREE.LineDashedMaterial = function (e) {
    THREE.Material.call(this), (this.color = new THREE.Color(16777215)), (this.linewidth = 1), (this.scale = 1), (this.dashSize = 3), (this.gapSize = 1), (this.vertexColors = !1), (this.fog = !0), this.setValues(e);
}),
(THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype)),
(THREE.LineDashedMaterial.prototype.clone = function () {
    var e = new THREE.LineDashedMaterial();
    return (
        THREE.Material.prototype.clone.call(this, e),
            e.color.copy(this.color),
            (e.linewidth = this.linewidth),
            (e.scale = this.scale),
            (e.dashSize = this.dashSize),
            (e.gapSize = this.gapSize),
            (e.vertexColors = this.vertexColors),
            (e.fog = this.fog),
            e
    );
}),
(THREE.MeshBasicMaterial = function (e) {
    THREE.Material.call(this),
        (this.color = new THREE.Color(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.specularMap = null),
        (this.envMap = null),
        (this.combine = THREE.MultiplyOperation),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.fog = !0),
        (this.shading = THREE.SmoothShading),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.vertexColors = THREE.NoColors),
        (this.skinning = !1),
        (this.morphTargets = !1),
        this.setValues(e);
}),
(THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype)),
(THREE.MeshBasicMaterial.prototype.clone = function () {
    var e = new THREE.MeshBasicMaterial();
    return (
        THREE.Material.prototype.clone.call(this, e),
            e.color.copy(this.color),
            (e.map = this.map),
            (e.lightMap = this.lightMap),
            (e.specularMap = this.specularMap),
            (e.envMap = this.envMap),
            (e.combine = this.combine),
            (e.reflectivity = this.reflectivity),
            (e.refractionRatio = this.refractionRatio),
            (e.fog = this.fog),
            (e.shading = this.shading),
            (e.wireframe = this.wireframe),
            (e.wireframeLinewidth = this.wireframeLinewidth),
            (e.wireframeLinecap = this.wireframeLinecap),
            (e.wireframeLinejoin = this.wireframeLinejoin),
            (e.vertexColors = this.vertexColors),
            (e.skinning = this.skinning),
            (e.morphTargets = this.morphTargets),
            e
    );
}),
(THREE.MeshLambertMaterial = function (e) {
    THREE.Material.call(this),
        (this.color = new THREE.Color(16777215)),
        (this.ambient = new THREE.Color(16777215)),
        (this.emissive = new THREE.Color(0)),
        (this.wrapAround = !1),
        (this.wrapRGB = new THREE.Vector3(1, 1, 1)),
        (this.map = null),
        (this.lightMap = null),
        (this.specularMap = null),
        (this.envMap = null),
        (this.combine = THREE.MultiplyOperation),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.fog = !0),
        (this.shading = THREE.SmoothShading),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.vertexColors = THREE.NoColors),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(e);
}),
(THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype)),
(THREE.MeshLambertMaterial.prototype.clone = function () {
    var e = new THREE.MeshLambertMaterial();
    return (
        THREE.Material.prototype.clone.call(this, e),
            e.color.copy(this.color),
            e.ambient.copy(this.ambient),
            e.emissive.copy(this.emissive),
            (e.wrapAround = this.wrapAround),
            e.wrapRGB.copy(this.wrapRGB),
            (e.map = this.map),
            (e.lightMap = this.lightMap),
            (e.specularMap = this.specularMap),
            (e.envMap = this.envMap),
            (e.combine = this.combine),
            (e.reflectivity = this.reflectivity),
            (e.refractionRatio = this.refractionRatio),
            (e.fog = this.fog),
            (e.shading = this.shading),
            (e.wireframe = this.wireframe),
            (e.wireframeLinewidth = this.wireframeLinewidth),
            (e.wireframeLinecap = this.wireframeLinecap),
            (e.wireframeLinejoin = this.wireframeLinejoin),
            (e.vertexColors = this.vertexColors),
            (e.skinning = this.skinning),
            (e.morphTargets = this.morphTargets),
            (e.morphNormals = this.morphNormals),
            e
    );
}),
(THREE.MeshPhongMaterial = function (e) {
    THREE.Material.call(this),
        (this.color = new THREE.Color(16777215)),
        (this.ambient = new THREE.Color(16777215)),
        (this.emissive = new THREE.Color(0)),
        (this.specular = new THREE.Color(1118481)),
        (this.shininess = 30),
        (this.metal = !1),
        (this.perPixel = !0),
        (this.wrapAround = !1),
        (this.wrapRGB = new THREE.Vector3(1, 1, 1)),
        (this.map = null),
        (this.lightMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalScale = new THREE.Vector2(1, 1)),
        (this.specularMap = null),
        (this.envMap = null),
        (this.combine = THREE.MultiplyOperation),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.fog = !0),
        (this.shading = THREE.SmoothShading),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.vertexColors = THREE.NoColors),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(e);
}),
(THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype)),
(THREE.MeshPhongMaterial.prototype.clone = function () {
    var e = new THREE.MeshPhongMaterial();
    return (
        THREE.Material.prototype.clone.call(this, e),
            e.color.copy(this.color),
            e.ambient.copy(this.ambient),
            e.emissive.copy(this.emissive),
            e.specular.copy(this.specular),
            (e.shininess = this.shininess),
            (e.metal = this.metal),
            (e.perPixel = this.perPixel),
            (e.wrapAround = this.wrapAround),
            e.wrapRGB.copy(this.wrapRGB),
            (e.map = this.map),
            (e.lightMap = this.lightMap),
            (e.bumpMap = this.bumpMap),
            (e.bumpScale = this.bumpScale),
            (e.normalMap = this.normalMap),
            e.normalScale.copy(this.normalScale),
            (e.specularMap = this.specularMap),
            (e.envMap = this.envMap),
            (e.combine = this.combine),
            (e.reflectivity = this.reflectivity),
            (e.refractionRatio = this.refractionRatio),
            (e.fog = this.fog),
            (e.shading = this.shading),
            (e.wireframe = this.wireframe),
            (e.wireframeLinewidth = this.wireframeLinewidth),
            (e.wireframeLinecap = this.wireframeLinecap),
            (e.wireframeLinejoin = this.wireframeLinejoin),
            (e.vertexColors = this.vertexColors),
            (e.skinning = this.skinning),
            (e.morphTargets = this.morphTargets),
            (e.morphNormals = this.morphNormals),
            e
    );
}),
(THREE.MeshDepthMaterial = function (e) {
    THREE.Material.call(this), (this.wireframe = !1), (this.wireframeLinewidth = 1), this.setValues(e);
}),
(THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype)),
(THREE.MeshDepthMaterial.prototype.clone = function () {
    var e = new THREE.MeshDepthMaterial();
    return THREE.Material.prototype.clone.call(this, e), (e.wireframe = this.wireframe), (e.wireframeLinewidth = this.wireframeLinewidth), e;
}),
(THREE.MeshNormalMaterial = function (e) {
    THREE.Material.call(this, e), (this.shading = THREE.FlatShading), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.morphTargets = !1), this.setValues(e);
}),
(THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype)),
(THREE.MeshNormalMaterial.prototype.clone = function () {
    var e = new THREE.MeshNormalMaterial();
    return THREE.Material.prototype.clone.call(this, e), (e.shading = this.shading), (e.wireframe = this.wireframe), (e.wireframeLinewidth = this.wireframeLinewidth), e;
}),
(THREE.MeshFaceMaterial = function (e) {
    this.materials = e instanceof Array ? e : [];
}),
(THREE.MeshFaceMaterial.prototype.clone = function () {
    var e = new THREE.MeshFaceMaterial();
    for (var t = 0; t < this.materials.length; t++) e.materials.push(this.materials[t].clone());
    return e;
}),
(THREE.ParticleBasicMaterial = function (e) {
    THREE.Material.call(this), (this.color = new THREE.Color(16777215)), (this.map = null), (this.size = 1), (this.sizeAttenuation = !0), (this.vertexColors = !1), (this.fog = !0), this.setValues(e);
}),
(THREE.ParticleBasicMaterial.prototype = Object.create(THREE.Material.prototype)),
(THREE.ParticleBasicMaterial.prototype.clone = function () {
    var e = new THREE.ParticleBasicMaterial();
    return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), (e.map = this.map), (e.size = this.size), (e.sizeAttenuation = this.sizeAttenuation), (e.vertexColors = this.vertexColors), (e.fog = this.fog), e;
}),
(THREE.ParticleCanvasMaterial = function (e) {
    THREE.Material.call(this), (this.color = new THREE.Color(16777215)), (this.program = function (e, t) {}), this.setValues(e);
}),
(THREE.ParticleCanvasMaterial.prototype = Object.create(THREE.Material.prototype)),
(THREE.ParticleCanvasMaterial.prototype.clone = function () {
    var e = new THREE.ParticleCanvasMaterial();
    return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), (e.program = this.program), e;
}),
(THREE.ShaderMaterial = function (e) {
    THREE.Material.call(this),
        (this.fragmentShader = "void main() {}"),
        (this.vertexShader = "void main() {}"),
        (this.uniforms = {}),
        (this.defines = {}),
        (this.attributes = null),
        (this.shading = THREE.SmoothShading),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.vertexColors = THREE.NoColors),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
        (this.index0AttributeName = "position"),
        this.setValues(e);
}),
(THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype)),
(THREE.ShaderMaterial.prototype.clone = function () {
    var e = new THREE.ShaderMaterial();
    return (
        THREE.Material.prototype.clone.call(this, e),
            (e.fragmentShader = this.fragmentShader),
            (e.vertexShader = this.vertexShader),
            (e.uniforms = THREE.UniformsUtils.clone(this.uniforms)),
            (e.attributes = this.attributes),
            (e.defines = this.defines),
            (e.shading = this.shading),
            (e.wireframe = this.wireframe),
            (e.wireframeLinewidth = this.wireframeLinewidth),
            (e.fog = this.fog),
            (e.lights = this.lights),
            (e.vertexColors = this.vertexColors),
            (e.skinning = this.skinning),
            (e.morphTargets = this.morphTargets),
            (e.morphNormals = this.morphNormals),
            e
    );
}),
(THREE.SpriteMaterial = function (e) {
    THREE.Material.call(this),
        (this.color = new THREE.Color(16777215)),
        (this.map = new THREE.Texture()),
        (this.useScreenCoordinates = !0),
        (this.depthTest = !this.useScreenCoordinates),
        (this.sizeAttenuation = !this.useScreenCoordinates),
        (this.scaleByViewport = !this.sizeAttenuation),
        (this.alignment = THREE.SpriteAlignment.center.clone()),
        (this.fog = !1),
        (this.uvOffset = new THREE.Vector2(0, 0)),
        (this.uvScale = new THREE.Vector2(1, 1)),
        this.setValues(e),
        (e = e || {}),
    e.depthTest === undefined && (this.depthTest = !this.useScreenCoordinates),
    e.sizeAttenuation === undefined && (this.sizeAttenuation = !this.useScreenCoordinates),
    e.scaleByViewport === undefined && (this.scaleByViewport = !this.sizeAttenuation);
}),
(THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype)),
(THREE.SpriteMaterial.prototype.clone = function () {
    var e = new THREE.SpriteMaterial();
    return (
        THREE.Material.prototype.clone.call(this, e),
            e.color.copy(this.color),
            (e.map = this.map),
            (e.useScreenCoordinates = this.useScreenCoordinates),
            (e.sizeAttenuation = this.sizeAttenuation),
            (e.scaleByViewport = this.scaleByViewport),
            e.alignment.copy(this.alignment),
            e.uvOffset.copy(this.uvOffset),
            e.uvScale.copy(this.uvScale),
            (e.fog = this.fog),
            e
    );
}),
(THREE.SpriteAlignment = {}),
(THREE.SpriteAlignment.topLeft = new THREE.Vector2(1, -1)),
(THREE.SpriteAlignment.topCenter = new THREE.Vector2(0, -1)),
(THREE.SpriteAlignment.topRight = new THREE.Vector2(-1, -1)),
(THREE.SpriteAlignment.centerLeft = new THREE.Vector2(1, 0)),
(THREE.SpriteAlignment.center = new THREE.Vector2(0, 0)),
(THREE.SpriteAlignment.centerRight = new THREE.Vector2(-1, 0)),
(THREE.SpriteAlignment.bottomLeft = new THREE.Vector2(1, 1)),
(THREE.SpriteAlignment.bottomCenter = new THREE.Vector2(0, 1)),
(THREE.SpriteAlignment.bottomRight = new THREE.Vector2(-1, 1)),
(THREE.Texture = function (e, t, n, r, i, s, o, u, a) {
    (this.id = THREE.TextureIdCount++),
        (this.uuid = THREE.Math.generateUUID()),
        (this.name = ""),
        (this.image = e),
        (this.mipmaps = []),
        (this.mapping = t !== undefined ? t : new THREE.UVMapping()),
        (this.wrapS = n !== undefined ? n : THREE.ClampToEdgeWrapping),
        (this.wrapT = r !== undefined ? r : THREE.ClampToEdgeWrapping),
        (this.magFilter = i !== undefined ? i : THREE.LinearFilter),
        (this.minFilter = s !== undefined ? s : THREE.LinearMipMapLinearFilter),
        (this.anisotropy = a !== undefined ? a : 1),
        (this.format = o !== undefined ? o : THREE.RGBAFormat),
        (this.type = u !== undefined ? u : THREE.UnsignedByteType),
        (this.offset = new THREE.Vector2(0, 0)),
        (this.repeat = new THREE.Vector2(1, 1)),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.needsUpdate = !1),
        (this.onUpdate = null);
}),
(THREE.Texture.prototype = {
    constructor: THREE.Texture,
    clone: function (e) {
        return (
            e === undefined && (e = new THREE.Texture()),
                (e.image = this.image),
                (e.mipmaps = this.mipmaps.slice(0)),
                (e.mapping = this.mapping),
                (e.wrapS = this.wrapS),
                (e.wrapT = this.wrapT),
                (e.magFilter = this.magFilter),
                (e.minFilter = this.minFilter),
                (e.anisotropy = this.anisotropy),
                (e.format = this.format),
                (e.type = this.type),
                e.offset.copy(this.offset),
                e.repeat.copy(this.repeat),
                (e.generateMipmaps = this.generateMipmaps),
                (e.premultiplyAlpha = this.premultiplyAlpha),
                (e.flipY = this.flipY),
                (e.unpackAlignment = this.unpackAlignment),
                e
        );
    },
    dispose: function () {
        this.dispatchEvent({ type: "dispose" });
    },
}),
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype),
(THREE.TextureIdCount = 0),
(THREE.CompressedTexture = function (e, t, n, r, i, s, o, u, a, f, l) {
    THREE.Texture.call(this, null, s, o, u, a, f, r, i, l), (this.image = { width: t, height: n }), (this.mipmaps = e), (this.generateMipmaps = !1);
}),
(THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype)),
(THREE.CompressedTexture.prototype.clone = function () {
    var e = new THREE.CompressedTexture();
    return THREE.Texture.prototype.clone.call(this, e), e;
}),
(THREE.DataTexture = function (e, t, n, r, i, s, o, u, a, f, l) {
    THREE.Texture.call(this, null, s, o, u, a, f, r, i, l), (this.image = { data: e, width: t, height: n });
}),
(THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype)),
(THREE.DataTexture.prototype.clone = function () {
    var e = new THREE.DataTexture();
    return THREE.Texture.prototype.clone.call(this, e), e;
}),
(THREE.Particle = function (e) {
    THREE.Object3D.call(this), (this.material = e);
}),
(THREE.Particle.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.Particle.prototype.clone = function (e) {
    return e === undefined && (e = new THREE.Particle(this.material)), THREE.Object3D.prototype.clone.call(this, e), e;
}),
(THREE.ParticleSystem = function (e, t) {
    THREE.Object3D.call(this),
        (this.geometry = e !== undefined ? e : new THREE.Geometry()),
        (this.material = t !== undefined ? t : new THREE.ParticleBasicMaterial({ color: Math.random() * 16777215 })),
        (this.sortParticles = !1),
        (this.frustumCulled = !1);
}),
(THREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.ParticleSystem.prototype.clone = function (e) {
    return e === undefined && (e = new THREE.ParticleSystem(this.geometry, this.material)), (e.sortParticles = this.sortParticles), THREE.Object3D.prototype.clone.call(this, e), e;
}),
(THREE.Line = function (e, t, n) {
    THREE.Object3D.call(this),
        (this.geometry = e !== undefined ? e : new THREE.Geometry()),
        (this.material = t !== undefined ? t : new THREE.LineBasicMaterial({ color: Math.random() * 16777215 })),
        (this.type = n !== undefined ? n : THREE.LineStrip);
}),
(THREE.LineStrip = 0),
(THREE.LinePieces = 1),
(THREE.Line.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.Line.prototype.clone = function (e) {
    return e === undefined && (e = new THREE.Line(this.geometry, this.material, this.type)), THREE.Object3D.prototype.clone.call(this, e), e;
}),
(THREE.Mesh = function (e, t) {
    THREE.Object3D.call(this), (this.geometry = e !== undefined ? e : new THREE.Geometry()), (this.material = t !== undefined ? t : new THREE.MeshBasicMaterial({ color: Math.random() * 16777215 })), this.updateMorphTargets();
}),
(THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.Mesh.prototype.updateMorphTargets = function () {
    if (this.geometry.morphTargets.length > 0) {
        (this.morphTargetBase = -1), (this.morphTargetForcedOrder = []), (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (var e = 0, t = this.geometry.morphTargets.length; e < t; e++) this.morphTargetInfluences.push(0), (this.morphTargetDictionary[this.geometry.morphTargets[e].name] = e);
    }
}),
(THREE.Mesh.prototype.getMorphTargetIndexByName = function (e) {
    return this.morphTargetDictionary[e] !== undefined ? this.morphTargetDictionary[e] : (console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + e + " does not exist. Returning 0."), 0);
}),
(THREE.Mesh.prototype.clone = function (e) {
    return e === undefined && (e = new THREE.Mesh(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, e), e;
}),
(THREE.Bone = function (e) {
    THREE.Object3D.call(this), (this.skin = e), (this.skinMatrix = new THREE.Matrix4());
}),
(THREE.Bone.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.Bone.prototype.update = function (e, t) {
    this.matrixAutoUpdate && (t |= this.updateMatrix());
    if (t || this.matrixWorldNeedsUpdate) e ? this.skinMatrix.multiplyMatrices(e, this.matrix) : this.skinMatrix.copy(this.matrix), (this.matrixWorldNeedsUpdate = !1), (t = !0);
    var n,
        r,
        i = this.children.length;
    for (r = 0; r < i; r++) this.children[r].update(this.skinMatrix, t);
}),
(THREE.SkinnedMesh = function (e, t, n) {
    THREE.Mesh.call(this, e, t), (this.useVertexTexture = n !== undefined ? n : !0), (this.identityMatrix = new THREE.Matrix4()), (this.bones = []), (this.boneMatrices = []);
    var r, i, s, o, u, a;
    if (this.geometry && this.geometry.bones !== undefined) {
        for (r = 0; r < this.geometry.bones.length; r++)
            (s = this.geometry.bones[r]),
                (o = s.pos),
                (u = s.rotq),
                (a = s.scl),
                (i = this.addBone()),
                (i.name = s.name),
                i.position.set(o[0], o[1], o[2]),
                i.quaternion.set(u[0], u[1], u[2], u[3]),
                a !== undefined ? i.scale.set(a[0], a[1], a[2]) : i.scale.set(1, 1, 1);
        for (r = 0; r < this.bones.length; r++) (s = this.geometry.bones[r]), (i = this.bones[r]), s.parent === -1 ? this.add(i) : this.bones[s.parent].add(i);
        var f = this.bones.length;
        if (this.useVertexTexture) {
            var l;
            f > 256 ? (l = 64) : f > 64 ? (l = 32) : f > 16 ? (l = 16) : (l = 8),
                (this.boneTextureWidth = l),
                (this.boneTextureHeight = l),
                (this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4)),
                (this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType)),
                (this.boneTexture.minFilter = THREE.NearestFilter),
                (this.boneTexture.magFilter = THREE.NearestFilter),
                (this.boneTexture.generateMipmaps = !1),
                (this.boneTexture.flipY = !1);
        } else this.boneMatrices = new Float32Array(16 * f);
        this.pose();
    }
}),
(THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype)),
(THREE.SkinnedMesh.prototype.addBone = function (e) {
    return e === undefined && (e = new THREE.Bone(this)), this.bones.push(e), e;
}),
(THREE.SkinnedMesh.prototype.updateMatrixWorld = (function () {
    var e = new THREE.Matrix4();
    return function (t) {
        this.matrixAutoUpdate && this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || t) this.parent ? this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) : this.matrixWorld.copy(this.matrix), (this.matrixWorldNeedsUpdate = !1), (t = !0);
        for (var n = 0, r = this.children.length; n < r; n++) {
            var i = this.children[n];
            i instanceof THREE.Bone ? i.update(this.identityMatrix, !1) : i.updateMatrixWorld(!0);
        }
        if (this.boneInverses == undefined) {
            this.boneInverses = [];
            for (var s = 0, o = this.bones.length; s < o; s++) {
                var u = new THREE.Matrix4();
                u.getInverse(this.bones[s].skinMatrix), this.boneInverses.push(u);
            }
        }
        for (var s = 0, o = this.bones.length; s < o; s++) e.multiplyMatrices(this.bones[s].skinMatrix, this.boneInverses[s]), e.flattenToArrayOffset(this.boneMatrices, s * 16);
        this.useVertexTexture && (this.boneTexture.needsUpdate = !0);
    };
})()),
(THREE.SkinnedMesh.prototype.pose = function () {
    this.updateMatrixWorld(!0), this.normalizeSkinWeights();
}),
(THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
    if (this.geometry instanceof THREE.Geometry)
        for (var e = 0; e < this.geometry.skinIndices.length; e++) {
            var t = this.geometry.skinWeights[e],
                n = 1 / t.lengthManhattan();
            n !== Infinity ? t.multiplyScalar(n) : t.set(1);
        }
}),
(THREE.SkinnedMesh.prototype.clone = function (e) {
    return e === undefined && (e = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), THREE.Mesh.prototype.clone.call(this, e), e;
}),
(THREE.MorphAnimMesh = function (e, t) {
    THREE.Mesh.call(this, e, t),
        (this.duration = 1e3),
        (this.mirroredLoop = !1),
        (this.time = 0),
        (this.lastKeyframe = 0),
        (this.currentKeyframe = 0),
        (this.direction = 1),
        (this.directionBackwards = !1),
        this.setFrameRange(0, this.geometry.morphTargets.length - 1);
}),
(THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype)),
(THREE.MorphAnimMesh.prototype.setFrameRange = function (e, t) {
    (this.startKeyframe = e), (this.endKeyframe = t), (this.length = this.endKeyframe - this.startKeyframe + 1);
}),
(THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
    (this.direction = 1), (this.directionBackwards = !1);
}),
(THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
    (this.direction = -1), (this.directionBackwards = !0);
}),
(THREE.MorphAnimMesh.prototype.parseAnimations = function () {
    var e = this.geometry;
    e.animations || (e.animations = {});
    var t,
        n = e.animations,
        r = /([a-z]+)(\d+)/;
    for (var i = 0, s = e.morphTargets.length; i < s; i++) {
        var o = e.morphTargets[i],
            u = o.name.match(r);
        if (u && u.length > 1) {
            var a = u[1],
                f = u[2];
            n[a] || (n[a] = { start: Infinity, end: -Infinity });
            var l = n[a];
            i < l.start && (l.start = i), i > l.end && (l.end = i), t || (t = a);
        }
    }
    e.firstAnimation = t;
}),
(THREE.MorphAnimMesh.prototype.setAnimationLabel = function (e, t, n) {
    this.geometry.animations || (this.geometry.animations = {}), (this.geometry.animations[e] = { start: t, end: n });
}),
(THREE.MorphAnimMesh.prototype.playAnimation = function (e, t) {
    var n = this.geometry.animations[e];
    n ? (this.setFrameRange(n.start, n.end), (this.duration = 1e3 * ((n.end - n.start) / t)), (this.time = 0)) : console.warn("animation[" + e + "] undefined");
}),
(THREE.MorphAnimMesh.prototype.updateAnimation = function (e) {
    var t = this.duration / this.length;
    this.time += this.direction * e;
    if (this.mirroredLoop) {
        if (this.time > this.duration || this.time < 0)
            (this.direction *= -1), this.time > this.duration && ((this.time = this.duration), (this.directionBackwards = !0)), this.time < 0 && ((this.time = 0), (this.directionBackwards = !1));
    } else (this.time = this.time % this.duration), this.time < 0 && (this.time += this.duration);
    var n = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / t), 0, this.length - 1);
    n !== this.currentKeyframe &&
    ((this.morphTargetInfluences[this.lastKeyframe] = 0), (this.morphTargetInfluences[this.currentKeyframe] = 1), (this.morphTargetInfluences[n] = 0), (this.lastKeyframe = this.currentKeyframe), (this.currentKeyframe = n));
    var r = (this.time % t) / t;
    this.directionBackwards && (r = 1 - r), (this.morphTargetInfluences[this.currentKeyframe] = r), (this.morphTargetInfluences[this.lastKeyframe] = 1 - r);
}),
(THREE.MorphAnimMesh.prototype.clone = function (e) {
    return (
        e === undefined && (e = new THREE.MorphAnimMesh(this.geometry, this.material)),
            (e.duration = this.duration),
            (e.mirroredLoop = this.mirroredLoop),
            (e.time = this.time),
            (e.lastKeyframe = this.lastKeyframe),
            (e.currentKeyframe = this.currentKeyframe),
            (e.direction = this.direction),
            (e.directionBackwards = this.directionBackwards),
            THREE.Mesh.prototype.clone.call(this, e),
            e
    );
}),
(THREE.LOD = function () {
    THREE.Object3D.call(this), (this.objects = []);
}),
(THREE.LOD.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.LOD.prototype.addLevel = function (e, t) {
    t === undefined && (t = 0), (t = Math.abs(t));
    for (var n = 0; n < this.objects.length; n++) if (t < this.objects[n].distance) break;
    this.objects.splice(n, 0, { distance: t, object: e }), this.add(e);
}),
(THREE.LOD.prototype.getObjectForDistance = function (e) {
    for (var t = 1, n = this.objects.length; t < n; t++) if (e < this.objects[t].distance) break;
    return this.objects[t - 1].object;
}),
(THREE.LOD.prototype.update = (function () {
    var e = new THREE.Vector3(),
        t = new THREE.Vector3();
    return function (n) {
        if (this.objects.length > 1) {
            e.getPositionFromMatrix(n.matrixWorld), t.getPositionFromMatrix(this.matrixWorld);
            var r = e.distanceTo(t);
            this.objects[0].object.visible = !0;
            for (var i = 1, s = this.objects.length; i < s; i++) {
                if (!(r >= this.objects[i].distance)) break;
                (this.objects[i - 1].object.visible = !1), (this.objects[i].object.visible = !0);
            }
            for (; i < s; i++) this.objects[i].object.visible = !1;
        }
    };
})()),
(THREE.LOD.prototype.clone = function () {}),
(THREE.Sprite = function (e) {
    THREE.Object3D.call(this), (this.material = e !== undefined ? e : new THREE.SpriteMaterial()), (this.rotation3d = this.rotation), (this.rotation = 0);
}),
(THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.Sprite.prototype.updateMatrix = function () {
    this.rotation3d.set(0, 0, this.rotation, this.rotation3d.order), this.quaternion.setFromEuler(this.rotation3d), this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
}),
(THREE.Sprite.prototype.clone = function (e) {
    return e === undefined && (e = new THREE.Sprite(this.material)), THREE.Object3D.prototype.clone.call(this, e), e;
}),
(THREE.Scene = function () {
    THREE.Object3D.call(this), (this.fog = null), (this.overrideMaterial = null), (this.autoUpdate = !0), (this.matrixAutoUpdate = !1), (this.__lights = []), (this.__objectsAdded = []), (this.__objectsRemoved = []);
}),
(THREE.Scene.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.Scene.prototype.__addObject = function (e) {
    if (e instanceof THREE.Light) this.__lights.indexOf(e) === -1 && this.__lights.push(e), e.target && e.target.parent === undefined && this.add(e.target);
    else if (!(e instanceof THREE.Camera || e instanceof THREE.Bone)) {
        this.__objectsAdded.push(e);
        var t = this.__objectsRemoved.indexOf(e);
        t !== -1 && this.__objectsRemoved.splice(t, 1);
    }
    for (var n = 0; n < e.children.length; n++) this.__addObject(e.children[n]);
}),
(THREE.Scene.prototype.__removeObject = function (e) {
    if (e instanceof THREE.Light) {
        var t = this.__lights.indexOf(e);
        t !== -1 && this.__lights.splice(t, 1);
        if (e.shadowCascadeArray) for (var n = 0; n < e.shadowCascadeArray.length; n++) this.__removeObject(e.shadowCascadeArray[n]);
    } else if (!(e instanceof THREE.Camera)) {
        this.__objectsRemoved.push(e);
        var t = this.__objectsAdded.indexOf(e);
        t !== -1 && this.__objectsAdded.splice(t, 1);
    }
    for (var r = 0; r < e.children.length; r++) this.__removeObject(e.children[r]);
}),
(THREE.Scene.prototype.clone = function (e) {
    return (
        e === undefined && (e = new THREE.Scene()),
            THREE.Object3D.prototype.clone.call(this, e),
        this.fog !== null && (e.fog = this.fog.clone()),
        this.overrideMaterial !== null && (e.overrideMaterial = this.overrideMaterial.clone()),
            (e.autoUpdate = this.autoUpdate),
            (e.matrixAutoUpdate = this.matrixAutoUpdate),
            e
    );
}),
(THREE.Fog = function (e, t, n) {
    (this.name = ""), (this.color = new THREE.Color(e)), (this.near = t !== undefined ? t : 1), (this.far = n !== undefined ? n : 1e3);
}),
(THREE.Fog.prototype.clone = function () {
    return new THREE.Fog(this.color.getHex(), this.near, this.far);
}),
(THREE.FogExp2 = function (e, t) {
    (this.name = ""), (this.color = new THREE.Color(e)), (this.density = t !== undefined ? t : 25e-5);
}),
(THREE.FogExp2.prototype.clone = function () {
    return new THREE.FogExp2(this.color.getHex(), this.density);
}),
(THREE.CanvasRenderer = function (e) {
    function xt() {
        ht.setRGB(0, 0, 0), pt.setRGB(0, 0, 0), dt.setRGB(0, 0, 0);
        for (var e = 0, t = s.length; e < t; e++) {
            var n = s[e],
                r = n.color;
            n instanceof THREE.AmbientLight ? ht.add(r) : n instanceof THREE.DirectionalLight ? pt.add(r) : n instanceof THREE.PointLight && dt.add(r);
        }
    }
    function Tt(e, t, n) {
        for (var r = 0, i = s.length; r < i; r++) {
            var o = s[r];
            Q.copy(o.color);
            if (o instanceof THREE.DirectionalLight) {
                var u = vt.getPositionFromMatrix(o.matrixWorld).normalize(),
                    a = t.dot(u);
                if (a <= 0) continue;
                (a *= o.intensity), n.add(Q.multiplyScalar(a));
            } else if (o instanceof THREE.PointLight) {
                var u = vt.getPositionFromMatrix(o.matrixWorld),
                    a = t.dot(vt.subVectors(u, e).normalize());
                if (a <= 0) continue;
                a *= o.distance == 0 ? 1 : 1 - Math.min(e.distanceTo(u) / o.distance, 1);
                if (a == 0) continue;
                (a *= o.intensity), n.add(Q.multiplyScalar(a));
            }
        }
    }
    function Nt(e, t, n) {
        Ht(n.opacity), Bt(n.blending);
        var r, i, s, o, u, a, f;
        if (n instanceof THREE.ParticleBasicMaterial)
            if (n.map === null) {
                (s = t.object.scale.x), (o = t.object.scale.y), (s *= t.scale.x * l), (o *= t.scale.y * c), ct.min.set(e.x - s, e.y - o), ct.max.set(e.x + s, e.y + o);
                if (ft.isIntersectionBox(ct) === !1) {
                    ct.makeEmpty();
                    return;
                }
                Rt(n.color.getStyle()), h.save(), h.translate(e.x, e.y), h.rotate(-t.rotation), h.scale(s, o), h.fillRect(-1, -1, 2, 2), h.restore();
            } else {
                (u = n.map.image), (a = u.width >> 1), (f = u.height >> 1), (s = t.scale.x * l), (o = t.scale.y * c), (r = s * a), (i = o * f), ct.min.set(e.x - r, e.y - i), ct.max.set(e.x + r, e.y + i);
                if (ft.isIntersectionBox(ct) === !1) {
                    ct.makeEmpty();
                    return;
                }
                h.save(), h.translate(e.x, e.y), h.rotate(-t.rotation), h.scale(s, -o), h.translate(-a, -f), h.drawImage(u, 0, 0), h.restore();
            }
        else if (n instanceof THREE.ParticleCanvasMaterial) {
            (r = t.scale.x * l), (i = t.scale.y * c), ct.min.set(e.x - r, e.y - i), ct.max.set(e.x + r, e.y + i);
            if (ft.isIntersectionBox(ct) === !1) {
                ct.makeEmpty();
                return;
            }
            qt(n.color.getStyle()), Rt(n.color.getStyle()), h.save(), h.translate(e.x, e.y), h.rotate(-t.rotation), h.scale(r, i), n.program(h), h.restore();
        }
    }
    function Ct(e, t, n, r) {
        Ht(r.opacity), Bt(r.blending), h.beginPath(), h.moveTo(e.positionScreen.x, e.positionScreen.y), h.lineTo(t.positionScreen.x, t.positionScreen.y);
        if (r instanceof THREE.LineBasicMaterial) {
            jt(r.linewidth), Ft(r.linecap), It(r.linejoin);
            if (r.vertexColors !== THREE.VertexColors) qt(r.color.getStyle());
            else {
                var i = n.vertexColors[0].getStyle(),
                    s = n.vertexColors[1].getStyle();
                if (i === s) qt(i);
                else {
                    try {
                        var o = h.createLinearGradient(e.positionScreen.x, e.positionScreen.y, t.positionScreen.x, t.positionScreen.y);
                        o.addColorStop(0, i), o.addColorStop(1, s);
                    } catch (u) {
                        o = i;
                    }
                    qt(o);
                }
            }
            h.stroke(), ct.expandByScalar(r.linewidth * 2);
        } else r instanceof THREE.LineDashedMaterial && (jt(r.linewidth), Ft(r.linecap), It(r.linejoin), qt(r.color.getStyle()), Ut(r.dashSize, r.gapSize), h.stroke(), ct.expandByScalar(r.linewidth * 2), Ut(null, null));
    }
    function kt(e, r, i, s, o, u, a, f) {
        (n.info.render.vertices += 3),
            n.info.render.faces++,
            Ht(f.opacity),
            Bt(f.blending),
            (M = e.positionScreen.x),
            (_ = e.positionScreen.y),
            (D = r.positionScreen.x),
            (P = r.positionScreen.y),
            (H = i.positionScreen.x),
            (B = i.positionScreen.y),
            Lt(M, _, D, P, H, B);
        if ((f instanceof THREE.MeshLambertMaterial || f instanceof THREE.MeshPhongMaterial) && f.map === null)
            J.copy(f.color),
                K.copy(f.emissive),
            f.vertexColors === THREE.FaceColors && J.multiply(a.color),
                f.wireframe === !1 && f.shading == THREE.SmoothShading && a.vertexNormalsLength == 3
                    ? (W.copy(ht),
                        X.copy(ht),
                        V.copy(ht),
                        Tt(a.v1.positionWorld, a.vertexNormalsModel[0], W),
                        Tt(a.v2.positionWorld, a.vertexNormalsModel[1], X),
                        Tt(a.v3.positionWorld, a.vertexNormalsModel[2], V),
                        W.multiply(J).add(K),
                        X.multiply(J).add(K),
                        V.multiply(J).add(K),
                        $.addColors(X, V).multiplyScalar(0.5),
                        (tt = Dt(W, X, V, $)),
                        _t(M, _, D, P, H, B, 0, 0, 1, 0, 0, 1, tt))
                    : (z.copy(ht), Tt(a.centroidModel, a.normalModel, z), z.multiply(J).add(K), f.wireframe === !0 ? At(z, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : Ot(z));
        else if (f instanceof THREE.MeshBasicMaterial || f instanceof THREE.MeshLambertMaterial || f instanceof THREE.MeshPhongMaterial)
            f.map !== null
                ? f.map.mapping instanceof THREE.UVMapping && ((nt = a.uvs[0]), Mt(M, _, D, P, H, B, nt[s].x, nt[s].y, nt[o].x, nt[o].y, nt[u].x, nt[u].y, f.map))
                : f.envMap !== null
                ? f.envMap.mapping instanceof THREE.SphericalReflectionMapping &&
                (vt.copy(a.vertexNormalsModelView[s]),
                    (rt = 0.5 * vt.x + 0.5),
                    (it = 0.5 * vt.y + 0.5),
                    vt.copy(a.vertexNormalsModelView[o]),
                    (st = 0.5 * vt.x + 0.5),
                    (ot = 0.5 * vt.y + 0.5),
                    vt.copy(a.vertexNormalsModelView[u]),
                    (ut = 0.5 * vt.x + 0.5),
                    (at = 0.5 * vt.y + 0.5),
                    Mt(M, _, D, P, H, B, rt, it, st, ot, ut, at, f.envMap))
                : (z.copy(f.color), f.vertexColors === THREE.FaceColors && z.multiply(a.color), f.wireframe === !0 ? At(z, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : Ot(z));
        else if (f instanceof THREE.MeshDepthMaterial)
            (Z = T.near),
                (et = T.far),
                (W.r = W.g = W.b = 1 - t(e.positionScreen.z * e.positionScreen.w, Z, et)),
                (X.r = X.g = X.b = 1 - t(r.positionScreen.z * r.positionScreen.w, Z, et)),
                (V.r = V.g = V.b = 1 - t(i.positionScreen.z * i.positionScreen.w, Z, et)),
                $.addColors(X, V).multiplyScalar(0.5),
                (tt = Dt(W, X, V, $)),
                _t(M, _, D, P, H, B, 0, 0, 1, 0, 0, 1, tt);
        else if (f instanceof THREE.MeshNormalMaterial) {
            var l;
            f.shading == THREE.FlatShading
                ? ((l = a.normalModelView), z.setRGB(l.x, l.y, l.z).multiplyScalar(0.5).addScalar(0.5), f.wireframe === !0 ? At(z, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : Ot(z))
                : f.shading == THREE.SmoothShading &&
                ((l = a.vertexNormalsModelView[s]),
                    W.setRGB(l.x, l.y, l.z).multiplyScalar(0.5).addScalar(0.5),
                    (l = a.vertexNormalsModelView[o]),
                    X.setRGB(l.x, l.y, l.z).multiplyScalar(0.5).addScalar(0.5),
                    (l = a.vertexNormalsModelView[u]),
                    V.setRGB(l.x, l.y, l.z).multiplyScalar(0.5).addScalar(0.5),
                    $.addColors(X, V).multiplyScalar(0.5),
                    (tt = Dt(W, X, V, $)),
                    _t(M, _, D, P, H, B, 0, 0, 1, 0, 0, 1, tt));
        }
    }
    function Lt(e, t, n, r, i, s) {
        h.beginPath(), h.moveTo(e, t), h.lineTo(n, r), h.lineTo(i, s), h.closePath();
    }
    function At(e, t, n, r) {
        jt(t), Ft(n), It(r), qt(e.getStyle()), h.stroke(), ct.expandByScalar(t * 2);
    }
    function Ot(e) {
        Rt(e.getStyle()), h.fill();
    }
    function Mt(e, t, n, r, i, s, o, u, a, f, l, c, p) {
        if (p instanceof THREE.DataTexture || p.image === undefined || p.image.width == 0) return;
        if (p.needsUpdate === !0) {
            var d = p.wrapS == THREE.RepeatWrapping,
                v = p.wrapT == THREE.RepeatWrapping;
            (G[p.id] = h.createPattern(p.image, d === !0 && v === !0 ? "repeat" : d === !0 && v === !1 ? "repeat-x" : d === !1 && v === !0 ? "repeat-y" : "no-repeat")), (p.needsUpdate = !1);
        }
        G[p.id] === undefined ? Rt("rgba(0,0,0,1)") : Rt(G[p.id]);
        var m,
            g,
            y,
            b,
            w,
            E,
            S,
            x,
            T = p.offset.x / p.repeat.x,
            N = p.offset.y / p.repeat.y,
            C = p.image.width * p.repeat.x,
            k = p.image.height * p.repeat.y;
        (o = (o + T) * C), (u = (1 - u + N) * k), (a = (a + T) * C), (f = (1 - f + N) * k), (l = (l + T) * C), (c = (1 - c + N) * k), (n -= e), (r -= t), (i -= e), (s -= t), (a -= o), (f -= u), (l -= o), (c -= u), (S = a * c - l * f);
        if (S === 0) {
            if (Y[p.id] === undefined) {
                var L = document.createElement("canvas");
                (L.width = p.image.width), (L.height = p.image.height);
                var A = L.getContext("2d");
                A.drawImage(p.image, 0, 0), (Y[p.id] = A.getImageData(0, 0, p.image.width, p.image.height).data);
            }
            var O = Y[p.id],
                M = (Math.floor(o) + Math.floor(u) * p.image.width) * 4;
            z.setRGB(O[M] / 255, O[M + 1] / 255, O[M + 2] / 255), Ot(z);
            return;
        }
        (x = 1 / S),
            (m = (c * n - f * i) * x),
            (g = (c * r - f * s) * x),
            (y = (a * i - l * n) * x),
            (b = (a * s - l * r) * x),
            (w = e - m * o - y * u),
            (E = t - g * o - b * u),
            h.save(),
            h.transform(m, g, y, b, w, E),
            h.fill(),
            h.restore();
    }
    function _t(e, t, n, r, i, s, o, u, a, f, l, c, p) {
        var d,
            v,
            m,
            g,
            y,
            b,
            w,
            E,
            S = p.width - 1,
            x = p.height - 1;
        (o *= S),
            (u *= x),
            (a *= S),
            (f *= x),
            (l *= S),
            (c *= x),
            (n -= e),
            (r -= t),
            (i -= e),
            (s -= t),
            (a -= o),
            (f -= u),
            (l -= o),
            (c -= u),
            (w = a * c - l * f),
            (E = 1 / w),
            (d = (c * n - f * i) * E),
            (v = (c * r - f * s) * E),
            (m = (a * i - l * n) * E),
            (g = (a * s - l * r) * E),
            (y = e - d * o - m * u),
            (b = t - v * o - g * u),
            h.save(),
            h.transform(d, v, m, g, y, b),
            h.clip(),
            h.drawImage(p, 0, 0),
            h.restore();
    }
    function Dt(e, t, n, r) {
        return (
            (bt[0] = (e.r * 255) | 0),
                (bt[1] = (e.g * 255) | 0),
                (bt[2] = (e.b * 255) | 0),
                (bt[4] = (t.r * 255) | 0),
                (bt[5] = (t.g * 255) | 0),
                (bt[6] = (t.b * 255) | 0),
                (bt[8] = (n.r * 255) | 0),
                (bt[9] = (n.g * 255) | 0),
                (bt[10] = (n.b * 255) | 0),
                (bt[12] = (r.r * 255) | 0),
                (bt[13] = (r.g * 255) | 0),
                (bt[14] = (r.b * 255) | 0),
                gt.putImageData(yt, 0, 0),
                Et.drawImage(mt, 0, 0),
                wt
        );
    }
    function Pt(e, t, n) {
        var r = t.x - e.x,
            i = t.y - e.y,
            s = r * r + i * i,
            o;
        if (s === 0) return;
        (o = n / Math.sqrt(s)), (r *= o), (i *= o), (t.x += r), (t.y += i), (e.x -= r), (e.y -= i);
    }
    function Ht(e) {
        v !== e && ((h.globalAlpha = e), (v = e));
    }
    function Bt(e) {
        m !== e &&
        (e === THREE.NormalBlending
            ? (h.globalCompositeOperation = "source-over")
            : e === THREE.AdditiveBlending
                ? (h.globalCompositeOperation = "lighter")
                : e === THREE.SubtractiveBlending && (h.globalCompositeOperation = "darker"),
            (m = e));
    }
    function jt(e) {
        b !== e && ((h.lineWidth = e), (b = e));
    }
    function Ft(e) {
        w !== e && ((h.lineCap = e), (w = e));
    }
    function It(e) {
        E !== e && ((h.lineJoin = e), (E = e));
    }
    function qt(e) {
        g !== e && ((h.strokeStyle = e), (g = e));
    }
    function Rt(e) {
        y !== e && ((h.fillStyle = e), (y = e));
    }
    function Ut(e, t) {
        if (S !== e || x !== t) h.setLineDash([e, t]), (S = e), (x = t);
    }
    console.log("THREE.CanvasRenderer", THREE.REVISION);
    var t = THREE.Math.smoothstep;
    e = e || {};
    var n = this,
        r,
        i,
        s,
        o = new THREE.Projector(),
        u = e.canvas !== undefined ? e.canvas : document.createElement("canvas"),
        a,
        f,
        l,
        c,
        h = u.getContext("2d"),
        p = new THREE.Color(0),
        d = 0,
        v = 1,
        m = 0,
        g = null,
        y = null,
        b = null,
        w = null,
        E = null,
        S = null,
        x = 0,
        T,
        N,
        C,
        k,
        L,
        A = new THREE.RenderableVertex(),
        O = new THREE.RenderableVertex(),
        M,
        _,
        D,
        P,
        H,
        B,
        j,
        F,
        I,
        q,
        R,
        U,
        z = new THREE.Color(),
        W = new THREE.Color(),
        X = new THREE.Color(),
        V = new THREE.Color(),
        $ = new THREE.Color(),
        J = new THREE.Color(),
        K = new THREE.Color(),
        Q = new THREE.Color(),
        G = {},
        Y = {},
        Z,
        et,
        tt,
        nt,
        rt,
        it,
        st,
        ot,
        ut,
        at,
        ft = new THREE.Box2(),
        lt = new THREE.Box2(),
        ct = new THREE.Box2(),
        ht = new THREE.Color(),
        pt = new THREE.Color(),
        dt = new THREE.Color(),
        vt = new THREE.Vector3(),
        mt,
        gt,
        yt,
        bt,
        wt,
        Et,
        St = 16;
    (mt = document.createElement("canvas")),
        (mt.width = mt.height = 2),
        (gt = mt.getContext("2d")),
        (gt.fillStyle = "rgba(0,0,0,1)"),
        gt.fillRect(0, 0, 2, 2),
        (yt = gt.getImageData(0, 0, 2, 2)),
        (bt = yt.data),
        (wt = document.createElement("canvas")),
        (wt.width = wt.height = St),
        (Et = wt.getContext("2d")),
        Et.translate(-St / 2, -St / 2),
        Et.scale(St, St),
        St--,
    h.setLineDash === undefined &&
    (h.mozDash !== undefined
        ? (h.setLineDash = function (e) {
            h.mozDash = e[0] !== null ? e : null;
        })
        : (h.setLineDash = function () {})),
        (this.domElement = u),
        (this.devicePixelRatio = e.devicePixelRatio !== undefined ? e.devicePixelRatio : self.devicePixelRatio !== undefined ? self.devicePixelRatio : 1),
        (this.autoClear = !0),
        (this.sortObjects = !0),
        (this.sortElements = !0),
        (this.info = { render: { vertices: 0, faces: 0 } }),
        (this.supportsVertexTextures = function () {}),
        (this.setFaceCulling = function () {}),
        (this.setSize = function (e, t, n) {
            (a = e * this.devicePixelRatio),
                (f = t * this.devicePixelRatio),
                (l = Math.floor(a / 2)),
                (c = Math.floor(f / 2)),
                (u.width = a),
                (u.height = f),
            this.devicePixelRatio !== 1 && n !== !1 && ((u.style.width = e + "px"), (u.style.height = t + "px")),
                ft.set(new THREE.Vector2(-l, -c), new THREE.Vector2(l, c)),
                lt.set(new THREE.Vector2(-l, -c), new THREE.Vector2(l, c)),
                (v = 1),
                (m = 0),
                (g = null),
                (y = null),
                (b = null),
                (w = null),
                (E = null);
        }),
        (this.setClearColor = function (e, t) {
            p.set(e), (d = t !== undefined ? t : 1), lt.set(new THREE.Vector2(-l, -c), new THREE.Vector2(l, c));
        }),
        (this.setClearColorHex = function (e, t) {
            console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t);
        }),
        (this.getMaxAnisotropy = function () {
            return 0;
        }),
        (this.clear = function () {
            h.setTransform(1, 0, 0, -1, l, c),
            lt.empty() === !1 &&
            (lt.intersect(ft),
                lt.expandByScalar(2),
            d < 1 && h.clearRect(lt.min.x | 0, lt.min.y | 0, (lt.max.x - lt.min.x) | 0, (lt.max.y - lt.min.y) | 0),
            d > 0 &&
            (Bt(THREE.NormalBlending),
                Ht(1),
                Rt("rgba(" + Math.floor(p.r * 255) + "," + Math.floor(p.g * 255) + "," + Math.floor(p.b * 255) + "," + d + ")"),
                h.fillRect(lt.min.x | 0, lt.min.y | 0, (lt.max.x - lt.min.x) | 0, (lt.max.y - lt.min.y) | 0)),
                lt.makeEmpty());
        }),
        (this.render = function (e, t) {
            if (t instanceof THREE.Camera == 0) {
                console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
                return;
            }
            this.autoClear === !0 && this.clear(),
                h.setTransform(1, 0, 0, -1, l, c),
                (n.info.render.vertices = 0),
                (n.info.render.faces = 0),
                (r = o.projectScene(e, t, this.sortObjects, this.sortElements)),
                (i = r.elements),
                (s = r.lights),
                (T = t),
                xt();
            for (var u = 0, a = i.length; u < a; u++) {
                var f = i[u],
                    p = f.material;
                if (p === undefined || p.visible === !1) continue;
                ct.makeEmpty();
                if (f instanceof THREE.RenderableParticle) (N = f), (N.x *= l), (N.y *= c), Nt(N, f, p);
                else if (f instanceof THREE.RenderableLine)
                    (N = f.v1),
                        (C = f.v2),
                        (N.positionScreen.x *= l),
                        (N.positionScreen.y *= c),
                        (C.positionScreen.x *= l),
                        (C.positionScreen.y *= c),
                        ct.setFromPoints([N.positionScreen, C.positionScreen]),
                    ft.isIntersectionBox(ct) === !0 && Ct(N, C, f, p);
                else if (f instanceof THREE.RenderableFace3) {
                    (N = f.v1), (C = f.v2), (k = f.v3);
                    if (N.positionScreen.z < -1 || N.positionScreen.z > 1) continue;
                    if (C.positionScreen.z < -1 || C.positionScreen.z > 1) continue;
                    if (k.positionScreen.z < -1 || k.positionScreen.z > 1) continue;
                    (N.positionScreen.x *= l),
                        (N.positionScreen.y *= c),
                        (C.positionScreen.x *= l),
                        (C.positionScreen.y *= c),
                        (k.positionScreen.x *= l),
                        (k.positionScreen.y *= c),
                    p.overdraw > 0 && (Pt(N.positionScreen, C.positionScreen, p.overdraw), Pt(C.positionScreen, k.positionScreen, p.overdraw), Pt(k.positionScreen, N.positionScreen, p.overdraw)),
                        ct.setFromPoints([N.positionScreen, C.positionScreen, k.positionScreen]),
                    ft.isIntersectionBox(ct) === !0 && kt(N, C, k, 0, 1, 2, f, p);
                }
                lt.union(ct);
            }
            h.setTransform(1, 0, 0, 1, 0, 0);
        });
}),
(THREE.ShaderChunk = {
    fog_pars_fragment: ["#ifdef USE_FOG", "uniform vec3 fogColor;", "#ifdef FOG_EXP2", "uniform float fogDensity;", "#else", "uniform float fogNear;", "uniform float fogFar;", "#endif", "#endif"].join("\n"),
    fog_fragment: [
        "#ifdef USE_FOG",
        "float depth = gl_FragCoord.z / gl_FragCoord.w;",
        "#ifdef FOG_EXP2",
        "const float LOG2 = 1.442695;",
        "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
        "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
        "#else",
        "float fogFactor = smoothstep( fogNear, fogFar, depth );",
        "#endif",
        "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
        "#endif",
    ].join("\n"),
    envmap_pars_fragment: [
        "#ifdef USE_ENVMAP",
        "uniform float reflectivity;",
        "uniform samplerCube envMap;",
        "uniform float flipEnvMap;",
        "uniform int combine;",
        "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
        "uniform bool useRefract;",
        "uniform float refractionRatio;",
        "#else",
        "varying vec3 vReflect;",
        "#endif",
        "#endif",
    ].join("\n"),
    envmap_fragment: [
        "#ifdef USE_ENVMAP",
        "vec3 reflectVec;",
        "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
        "vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",
        "if ( useRefract ) {",
        "reflectVec = refract( cameraToVertex, normal, refractionRatio );",
        "} else { ",
        "reflectVec = reflect( cameraToVertex, normal );",
        "}",
        "#else",
        "reflectVec = vReflect;",
        "#endif",
        "#ifdef DOUBLE_SIDED",
        "float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
        "vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",
        "#else",
        "vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",
        "#endif",
        "#ifdef GAMMA_INPUT",
        "cubeColor.xyz *= cubeColor.xyz;",
        "#endif",
        "if ( combine == 1 ) {",
        "gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );",
        "} else if ( combine == 2 ) {",
        "gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;",
        "} else {",
        "gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );",
        "}",
        "#endif",
    ].join("\n"),
    envmap_pars_vertex: ["#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )", "varying vec3 vReflect;", "uniform float refractionRatio;", "uniform bool useRefract;", "#endif"].join("\n"),
    worldpos_vertex: [
        "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",
        "#ifdef USE_SKINNING",
        "vec4 worldPosition = modelMatrix * skinned;",
        "#endif",
        "#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",
        "vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );",
        "#endif",
        "#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",
        "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
        "#endif",
        "#endif",
    ].join("\n"),
    envmap_vertex: [
        "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",
        "vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;",
        "worldNormal = normalize( worldNormal );",
        "vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",
        "if ( useRefract ) {",
        "vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",
        "} else {",
        "vReflect = reflect( cameraToVertex, worldNormal );",
        "}",
        "#endif",
    ].join("\n"),
    map_particle_pars_fragment: ["#ifdef USE_MAP", "uniform sampler2D map;", "#endif"].join("\n"),
    map_particle_fragment: ["#ifdef USE_MAP", "gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );", "#endif"].join("\n"),
    map_pars_vertex: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )", "varying vec2 vUv;", "uniform vec4 offsetRepeat;", "#endif"].join("\n"),
    map_pars_fragment: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )", "varying vec2 vUv;", "#endif", "#ifdef USE_MAP", "uniform sampler2D map;", "#endif"].join("\n"),
    map_vertex: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )", "vUv = uv * offsetRepeat.zw + offsetRepeat.xy;", "#endif"].join("\n"),
    map_fragment: ["#ifdef USE_MAP", "vec4 texelColor = texture2D( map, vUv );", "#ifdef GAMMA_INPUT", "texelColor.xyz *= texelColor.xyz;", "#endif", "gl_FragColor = gl_FragColor * texelColor;", "#endif"].join("\n"),
    lightmap_pars_fragment: ["#ifdef USE_LIGHTMAP", "varying vec2 vUv2;", "uniform sampler2D lightMap;", "#endif"].join("\n"),
    lightmap_pars_vertex: ["#ifdef USE_LIGHTMAP", "varying vec2 vUv2;", "#endif"].join("\n"),
    lightmap_fragment: ["#ifdef USE_LIGHTMAP", "gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );", "#endif"].join("\n"),
    lightmap_vertex: ["#ifdef USE_LIGHTMAP", "vUv2 = uv2;", "#endif"].join("\n"),
    bumpmap_pars_fragment: [
        "#ifdef USE_BUMPMAP",
        "uniform sampler2D bumpMap;",
        "uniform float bumpScale;",
        "vec2 dHdxy_fwd() {",
        "vec2 dSTdx = dFdx( vUv );",
        "vec2 dSTdy = dFdy( vUv );",
        "float Hll = bumpScale * texture2D( bumpMap, vUv ).x;",
        "float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;",
        "float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;",
        "return vec2( dBx, dBy );",
        "}",
        "vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",
        "vec3 vSigmaX = dFdx( surf_pos );",
        "vec3 vSigmaY = dFdy( surf_pos );",
        "vec3 vN = surf_norm;",
        "vec3 R1 = cross( vSigmaY, vN );",
        "vec3 R2 = cross( vN, vSigmaX );",
        "float fDet = dot( vSigmaX, R1 );",
        "vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
        "return normalize( abs( fDet ) * surf_norm - vGrad );",
        "}",
        "#endif",
    ].join("\n"),
    normalmap_pars_fragment: [
        "#ifdef USE_NORMALMAP",
        "uniform sampler2D normalMap;",
        "uniform vec2 normalScale;",
        "vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",
        "vec3 q0 = dFdx( eye_pos.xyz );",
        "vec3 q1 = dFdy( eye_pos.xyz );",
        "vec2 st0 = dFdx( vUv.st );",
        "vec2 st1 = dFdy( vUv.st );",
        "vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
        "vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
        "vec3 N = normalize( surf_norm );",
        "vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;",
        "mapN.xy = normalScale * mapN.xy;",
        "mat3 tsn = mat3( S, T, N );",
        "return normalize( tsn * mapN );",
        "}",
        "#endif",
    ].join("\n"),
    specularmap_pars_fragment: ["#ifdef USE_SPECULARMAP", "uniform sampler2D specularMap;", "#endif"].join("\n"),
    specularmap_fragment: ["float specularStrength;", "#ifdef USE_SPECULARMAP", "vec4 texelSpecular = texture2D( specularMap, vUv );", "specularStrength = texelSpecular.r;", "#else", "specularStrength = 1.0;", "#endif"].join("\n"),
    lights_lambert_pars_vertex: [
        "uniform vec3 ambient;",
        "uniform vec3 diffuse;",
        "uniform vec3 emissive;",
        "uniform vec3 ambientLightColor;",
        "#if MAX_DIR_LIGHTS > 0",
        "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
        "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
        "#endif",
        "#if MAX_HEMI_LIGHTS > 0",
        "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
        "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
        "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
        "#endif",
        "#if MAX_POINT_LIGHTS > 0",
        "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
        "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
        "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0",
        "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
        "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
        "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
        "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
        "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
        "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
        "#endif",
        "#ifdef WRAP_AROUND",
        "uniform vec3 wrapRGB;",
        "#endif",
    ].join("\n"),
    lights_lambert_vertex: [
        "vLightFront = vec3( 0.0 );",
        "#ifdef DOUBLE_SIDED",
        "vLightBack = vec3( 0.0 );",
        "#endif",
        "transformedNormal = normalize( transformedNormal );",
        "#if MAX_DIR_LIGHTS > 0",
        "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
        "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
        "vec3 dirVector = normalize( lDirection.xyz );",
        "float dotProduct = dot( transformedNormal, dirVector );",
        "vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",
        "#ifdef DOUBLE_SIDED",
        "vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
        "#ifdef WRAP_AROUND",
        "vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
        "#endif",
        "#endif",
        "#ifdef WRAP_AROUND",
        "vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
        "directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );",
        "#ifdef DOUBLE_SIDED",
        "directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );",
        "#endif",
        "#endif",
        "vLightFront += directionalLightColor[ i ] * directionalLightWeighting;",
        "#ifdef DOUBLE_SIDED",
        "vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;",
        "#endif",
        "}",
        "#endif",
        "#if MAX_POINT_LIGHTS > 0",
        "for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
        "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "vec3 lVector = lPosition.xyz - mvPosition.xyz;",
        "float lDistance = 1.0;",
        "if ( pointLightDistance[ i ] > 0.0 )",
        "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
        "lVector = normalize( lVector );",
        "float dotProduct = dot( transformedNormal, lVector );",
        "vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );",
        "#ifdef DOUBLE_SIDED",
        "vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
        "#ifdef WRAP_AROUND",
        "vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
        "#endif",
        "#endif",
        "#ifdef WRAP_AROUND",
        "vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
        "pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );",
        "#ifdef DOUBLE_SIDED",
        "pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );",
        "#endif",
        "#endif",
        "vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;",
        "#ifdef DOUBLE_SIDED",
        "vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;",
        "#endif",
        "}",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0",
        "for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
        "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "vec3 lVector = lPosition.xyz - mvPosition.xyz;",
        "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );",
        "if ( spotEffect > spotLightAngleCos[ i ] ) {",
        "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
        "float lDistance = 1.0;",
        "if ( spotLightDistance[ i ] > 0.0 )",
        "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
        "lVector = normalize( lVector );",
        "float dotProduct = dot( transformedNormal, lVector );",
        "vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );",
        "#ifdef DOUBLE_SIDED",
        "vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
        "#ifdef WRAP_AROUND",
        "vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
        "#endif",
        "#endif",
        "#ifdef WRAP_AROUND",
        "vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
        "spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );",
        "#ifdef DOUBLE_SIDED",
        "spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );",
        "#endif",
        "#endif",
        "vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;",
        "#ifdef DOUBLE_SIDED",
        "vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;",
        "#endif",
        "}",
        "}",
        "#endif",
        "#if MAX_HEMI_LIGHTS > 0",
        "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
        "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
        "vec3 lVector = normalize( lDirection.xyz );",
        "float dotProduct = dot( transformedNormal, lVector );",
        "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
        "float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;",
        "vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
        "#ifdef DOUBLE_SIDED",
        "vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );",
        "#endif",
        "}",
        "#endif",
        "vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;",
        "#ifdef DOUBLE_SIDED",
        "vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;",
        "#endif",
    ].join("\n"),
    lights_phong_pars_vertex: [
        "#ifndef PHONG_PER_PIXEL",
        "#if MAX_POINT_LIGHTS > 0",
        "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
        "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
        "varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0",
        "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
        "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
        "varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",
        "#endif",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
        "varying vec3 vWorldPosition;",
        "#endif",
    ].join("\n"),
    lights_phong_vertex: [
        "#ifndef PHONG_PER_PIXEL",
        "#if MAX_POINT_LIGHTS > 0",
        "for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
        "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "vec3 lVector = lPosition.xyz - mvPosition.xyz;",
        "float lDistance = 1.0;",
        "if ( pointLightDistance[ i ] > 0.0 )",
        "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
        "vPointLight[ i ] = vec4( lVector, lDistance );",
        "}",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0",
        "for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
        "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "vec3 lVector = lPosition.xyz - mvPosition.xyz;",
        "float lDistance = 1.0;",
        "if ( spotLightDistance[ i ] > 0.0 )",
        "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
        "vSpotLight[ i ] = vec4( lVector, lDistance );",
        "}",
        "#endif",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
        "vWorldPosition = worldPosition.xyz;",
        "#endif",
    ].join("\n"),
    lights_phong_pars_fragment: [
        "uniform vec3 ambientLightColor;",
        "#if MAX_DIR_LIGHTS > 0",
        "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
        "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
        "#endif",
        "#if MAX_HEMI_LIGHTS > 0",
        "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
        "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
        "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
        "#endif",
        "#if MAX_POINT_LIGHTS > 0",
        "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
        "#ifdef PHONG_PER_PIXEL",
        "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
        "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
        "#else",
        "varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",
        "#endif",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0",
        "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
        "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
        "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
        "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
        "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
        "#ifdef PHONG_PER_PIXEL",
        "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
        "#else",
        "varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",
        "#endif",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
        "varying vec3 vWorldPosition;",
        "#endif",
        "#ifdef WRAP_AROUND",
        "uniform vec3 wrapRGB;",
        "#endif",
        "varying vec3 vViewPosition;",
        "varying vec3 vNormal;",
    ].join("\n"),
    lights_phong_fragment: [
        "vec3 normal = normalize( vNormal );",
        "vec3 viewPosition = normalize( vViewPosition );",
        "#ifdef DOUBLE_SIDED",
        "normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
        "#endif",
        "#ifdef USE_NORMALMAP",
        "normal = perturbNormal2Arb( -vViewPosition, normal );",
        "#elif defined( USE_BUMPMAP )",
        "normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",
        "#endif",
        "#if MAX_POINT_LIGHTS > 0",
        "vec3 pointDiffuse  = vec3( 0.0 );",
        "vec3 pointSpecular = vec3( 0.0 );",
        "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
        "#ifdef PHONG_PER_PIXEL",
        "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
        "float lDistance = 1.0;",
        "if ( pointLightDistance[ i ] > 0.0 )",
        "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
        "lVector = normalize( lVector );",
        "#else",
        "vec3 lVector = normalize( vPointLight[ i ].xyz );",
        "float lDistance = vPointLight[ i ].w;",
        "#endif",
        "float dotProduct = dot( normal, lVector );",
        "#ifdef WRAP_AROUND",
        "float pointDiffuseWeightFull = max( dotProduct, 0.0 );",
        "float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
        "vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",
        "#else",
        "float pointDiffuseWeight = max( dotProduct, 0.0 );",
        "#endif",
        "pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;",
        "vec3 pointHalfVector = normalize( lVector + viewPosition );",
        "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
        "float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",
        "#ifdef PHYSICALLY_BASED_SHADING",
        "float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
        "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );",
        "pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;",
        "#else",
        "pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;",
        "#endif",
        "}",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0",
        "vec3 spotDiffuse  = vec3( 0.0 );",
        "vec3 spotSpecular = vec3( 0.0 );",
        "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
        "#ifdef PHONG_PER_PIXEL",
        "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
        "float lDistance = 1.0;",
        "if ( spotLightDistance[ i ] > 0.0 )",
        "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
        "lVector = normalize( lVector );",
        "#else",
        "vec3 lVector = normalize( vSpotLight[ i ].xyz );",
        "float lDistance = vSpotLight[ i ].w;",
        "#endif",
        "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",
        "if ( spotEffect > spotLightAngleCos[ i ] ) {",
        "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
        "float dotProduct = dot( normal, lVector );",
        "#ifdef WRAP_AROUND",
        "float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
        "float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
        "vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",
        "#else",
        "float spotDiffuseWeight = max( dotProduct, 0.0 );",
        "#endif",
        "spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;",
        "vec3 spotHalfVector = normalize( lVector + viewPosition );",
        "float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
        "float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",
        "#ifdef PHYSICALLY_BASED_SHADING",
        "float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
        "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );",
        "spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;",
        "#else",
        "spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;",
        "#endif",
        "}",
        "}",
        "#endif",
        "#if MAX_DIR_LIGHTS > 0",
        "vec3 dirDiffuse  = vec3( 0.0 );",
        "vec3 dirSpecular = vec3( 0.0 );",
        "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
        "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
        "vec3 dirVector = normalize( lDirection.xyz );",
        "float dotProduct = dot( normal, dirVector );",
        "#ifdef WRAP_AROUND",
        "float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
        "float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
        "vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",
        "#else",
        "float dirDiffuseWeight = max( dotProduct, 0.0 );",
        "#endif",
        "dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;",
        "vec3 dirHalfVector = normalize( dirVector + viewPosition );",
        "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
        "float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",
        "#ifdef PHYSICALLY_BASED_SHADING",
        "float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
        "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
        "dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",
        "#else",
        "dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;",
        "#endif",
        "}",
        "#endif",
        "#if MAX_HEMI_LIGHTS > 0",
        "vec3 hemiDiffuse  = vec3( 0.0 );",
        "vec3 hemiSpecular = vec3( 0.0 );",
        "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
        "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
        "vec3 lVector = normalize( lDirection.xyz );",
        "float dotProduct = dot( normal, lVector );",
        "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
        "vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
        "hemiDiffuse += diffuse * hemiColor;",
        "vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
        "float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
        "float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",
        "vec3 lVectorGround = -lVector;",
        "vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
        "float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
        "float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",
        "#ifdef PHYSICALLY_BASED_SHADING",
        "float dotProductGround = dot( normal, lVectorGround );",
        "float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
        "vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
        "vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
        "hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",
        "#else",
        "hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;",
        "#endif",
        "}",
        "#endif",
        "vec3 totalDiffuse = vec3( 0.0 );",
        "vec3 totalSpecular = vec3( 0.0 );",
        "#if MAX_DIR_LIGHTS > 0",
        "totalDiffuse += dirDiffuse;",
        "totalSpecular += dirSpecular;",
        "#endif",
        "#if MAX_HEMI_LIGHTS > 0",
        "totalDiffuse += hemiDiffuse;",
        "totalSpecular += hemiSpecular;",
        "#endif",
        "#if MAX_POINT_LIGHTS > 0",
        "totalDiffuse += pointDiffuse;",
        "totalSpecular += pointSpecular;",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0",
        "totalDiffuse += spotDiffuse;",
        "totalSpecular += spotSpecular;",
        "#endif",
        "#ifdef METAL",
        "gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );",
        "#else",
        "gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",
        "#endif",
    ].join("\n"),
    color_pars_fragment: ["#ifdef USE_COLOR", "varying vec3 vColor;", "#endif"].join("\n"),
    color_fragment: ["#ifdef USE_COLOR", "gl_FragColor = gl_FragColor * vec4( vColor, opacity );", "#endif"].join("\n"),
    color_pars_vertex: ["#ifdef USE_COLOR", "varying vec3 vColor;", "#endif"].join("\n"),
    color_vertex: ["#ifdef USE_COLOR", "#ifdef GAMMA_INPUT", "vColor = color * color;", "#else", "vColor = color;", "#endif", "#endif"].join("\n"),
    skinning_pars_vertex: [
        "#ifdef USE_SKINNING",
        "#ifdef BONE_TEXTURE",
        "uniform sampler2D boneTexture;",
        "uniform int boneTextureWidth;",
        "uniform int boneTextureHeight;",
        "mat4 getBoneMatrix( const in float i ) {",
        "float j = i * 4.0;",
        "float x = mod( j, float( boneTextureWidth ) );",
        "float y = floor( j / float( boneTextureWidth ) );",
        "float dx = 1.0 / float( boneTextureWidth );",
        "float dy = 1.0 / float( boneTextureHeight );",
        "y = dy * ( y + 0.5 );",
        "vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
        "vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
        "vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
        "vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",
        "mat4 bone = mat4( v1, v2, v3, v4 );",
        "return bone;",
        "}",
        "#else",
        "uniform mat4 boneGlobalMatrices[ MAX_BONES ];",
        "mat4 getBoneMatrix( const in float i ) {",
        "mat4 bone = boneGlobalMatrices[ int(i) ];",
        "return bone;",
        "}",
        "#endif",
        "#endif",
    ].join("\n"),
    skinbase_vertex: ["#ifdef USE_SKINNING", "mat4 boneMatX = getBoneMatrix( skinIndex.x );", "mat4 boneMatY = getBoneMatrix( skinIndex.y );", "#endif"].join("\n"),
    skinning_vertex: [
        "#ifdef USE_SKINNING",
        "#ifdef USE_MORPHTARGETS",
        "vec4 skinVertex = vec4( morphed, 1.0 );",
        "#else",
        "vec4 skinVertex = vec4( position, 1.0 );",
        "#endif",
        "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
        "skinned 	  += boneMatY * skinVertex * skinWeight.y;",
        "#endif",
    ].join("\n"),
    morphtarget_pars_vertex: ["#ifdef USE_MORPHTARGETS", "#ifndef USE_MORPHNORMALS", "uniform float morphTargetInfluences[ 8 ];", "#else", "uniform float morphTargetInfluences[ 4 ];", "#endif", "#endif"].join("\n"),
    morphtarget_vertex: [
        "#ifdef USE_MORPHTARGETS",
        "vec3 morphed = vec3( 0.0 );",
        "morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
        "morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
        "morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
        "morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",
        "#ifndef USE_MORPHNORMALS",
        "morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
        "morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
        "morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
        "morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",
        "#endif",
        "morphed += position;",
        "#endif",
    ].join("\n"),
    default_vertex: [
        "vec4 mvPosition;",
        "#ifdef USE_SKINNING",
        "mvPosition = modelViewMatrix * skinned;",
        "#endif",
        "#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )",
        "mvPosition = modelViewMatrix * vec4( morphed, 1.0 );",
        "#endif",
        "#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )",
        "mvPosition = modelViewMatrix * vec4( position, 1.0 );",
        "#endif",
        "gl_Position = projectionMatrix * mvPosition;",
    ].join("\n"),
    morphnormal_vertex: [
        "#ifdef USE_MORPHNORMALS",
        "vec3 morphedNormal = vec3( 0.0 );",
        "morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
        "morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
        "morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
        "morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",
        "morphedNormal += normal;",
        "#endif",
    ].join("\n"),
    skinnormal_vertex: [
        "#ifdef USE_SKINNING",
        "mat4 skinMatrix = skinWeight.x * boneMatX;",
        "skinMatrix 	+= skinWeight.y * boneMatY;",
        "#ifdef USE_MORPHNORMALS",
        "vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );",
        "#else",
        "vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );",
        "#endif",
        "#endif",
    ].join("\n"),
    defaultnormal_vertex: [
        "vec3 objectNormal;",
        "#ifdef USE_SKINNING",
        "objectNormal = skinnedNormal.xyz;",
        "#endif",
        "#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )",
        "objectNormal = morphedNormal;",
        "#endif",
        "#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )",
        "objectNormal = normal;",
        "#endif",
        "#ifdef FLIP_SIDED",
        "objectNormal = -objectNormal;",
        "#endif",
        "vec3 transformedNormal = normalMatrix * objectNormal;",
    ].join("\n"),
    shadowmap_pars_fragment: [
        "#ifdef USE_SHADOWMAP",
        "uniform sampler2D shadowMap[ MAX_SHADOWS ];",
        "uniform vec2 shadowMapSize[ MAX_SHADOWS ];",
        "uniform float shadowDarkness[ MAX_SHADOWS ];",
        "uniform float shadowBias[ MAX_SHADOWS ];",
        "varying vec4 vShadowCoord[ MAX_SHADOWS ];",
        "float unpackDepth( const in vec4 rgba_depth ) {",
        "const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
        "float depth = dot( rgba_depth, bit_shift );",
        "return depth;",
        "}",
        "#endif",
    ].join("\n"),
    shadowmap_fragment: [
        "#ifdef USE_SHADOWMAP",
        "#ifdef SHADOWMAP_DEBUG",
        "vec3 frustumColors[3];",
        "frustumColors[0] = vec3( 1.0, 0.5, 0.0 );",
        "frustumColors[1] = vec3( 0.0, 1.0, 0.8 );",
        "frustumColors[2] = vec3( 0.0, 0.5, 1.0 );",
        "#endif",
        "#ifdef SHADOWMAP_CASCADE",
        "int inFrustumCount = 0;",
        "#endif",
        "float fDepth;",
        "vec3 shadowColor = vec3( 1.0 );",
        "for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
        "vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",
        "bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
        "bool inFrustum = all( inFrustumVec );",
        "#ifdef SHADOWMAP_CASCADE",
        "inFrustumCount += int( inFrustum );",
        "bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );",
        "#else",
        "bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",
        "#endif",
        "bool frustumTest = all( frustumTestVec );",
        "if ( frustumTest ) {",
        "shadowCoord.z += shadowBias[ i ];",
        "#if defined( SHADOWMAP_TYPE_PCF )",
        "float shadow = 0.0;",
        "const float shadowDelta = 1.0 / 9.0;",
        "float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
        "float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",
        "float dx0 = -1.25 * xPixelOffset;",
        "float dy0 = -1.25 * yPixelOffset;",
        "float dx1 = 1.25 * xPixelOffset;",
        "float dy1 = 1.25 * yPixelOffset;",
        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
        "shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",
        "#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",
        "float shadow = 0.0;",
        "float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
        "float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",
        "float dx0 = -1.0 * xPixelOffset;",
        "float dy0 = -1.0 * yPixelOffset;",
        "float dx1 = 1.0 * xPixelOffset;",
        "float dy1 = 1.0 * yPixelOffset;",
        "mat3 shadowKernel;",
        "mat3 depthKernel;",
        "depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
        "depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
        "depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
        "depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
        "depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
        "depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
        "depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
        "depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
        "depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
        "vec3 shadowZ = vec3( shadowCoord.z );",
        "shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));",
        "shadowKernel[0] *= vec3(0.25);",
        "shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));",
        "shadowKernel[1] *= vec3(0.25);",
        "shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));",
        "shadowKernel[2] *= vec3(0.25);",
        "vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );",
        "shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
        "shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",
        "vec4 shadowValues;",
        "shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
        "shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
        "shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
        "shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",
        "shadow = dot( shadowValues, vec4( 1.0 ) );",
        "shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",
        "#else",
        "vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
        "float fDepth = unpackDepth( rgbaDepth );",
        "if ( fDepth < shadowCoord.z )",
        "shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );",
        "#endif",
        "}",
        "#ifdef SHADOWMAP_DEBUG",
        "#ifdef SHADOWMAP_CASCADE",
        "if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];",
        "#else",
        "if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];",
        "#endif",
        "#endif",
        "}",
        "#ifdef GAMMA_OUTPUT",
        "shadowColor *= shadowColor;",
        "#endif",
        "gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;",
        "#endif",
    ].join("\n"),
    shadowmap_pars_vertex: ["#ifdef USE_SHADOWMAP", "varying vec4 vShadowCoord[ MAX_SHADOWS ];", "uniform mat4 shadowMatrix[ MAX_SHADOWS ];", "#endif"].join("\n"),
    shadowmap_vertex: ["#ifdef USE_SHADOWMAP", "for( int i = 0; i < MAX_SHADOWS; i ++ ) {", "vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;", "}", "#endif"].join("\n"),
    alphatest_fragment: ["#ifdef ALPHATEST", "if ( gl_FragColor.a < ALPHATEST ) discard;", "#endif"].join("\n"),
    linear_to_gamma_fragment: ["#ifdef GAMMA_OUTPUT", "gl_FragColor.xyz = sqrt( gl_FragColor.xyz );", "#endif"].join("\n"),
}),
(THREE.UniformsUtils = {
    merge: function (e) {
        var t,
            n,
            r,
            i = {};
        for (t = 0; t < e.length; t++) {
            r = this.clone(e[t]);
            for (n in r) i[n] = r[n];
        }
        return i;
    },
    clone: function (e) {
        var t,
            n,
            r,
            i,
            s = {};
        for (t in e) {
            s[t] = {};
            for (n in e[t])
                (i = e[t][n]),
                    i instanceof THREE.Color || i instanceof THREE.Vector2 || i instanceof THREE.Vector3 || i instanceof THREE.Vector4 || i instanceof THREE.Matrix4 || i instanceof THREE.Texture
                        ? (s[t][n] = i.clone())
                        : i instanceof Array
                        ? (s[t][n] = i.slice())
                        : (s[t][n] = i);
        }
        return s;
    },
}),
(THREE.UniformsLib = {
    common: {
        diffuse: { type: "c", value: new THREE.Color(15658734) },
        opacity: { type: "f", value: 1 },
        map: { type: "t", value: null },
        offsetRepeat: { type: "v4", value: new THREE.Vector4(0, 0, 1, 1) },
        lightMap: { type: "t", value: null },
        specularMap: { type: "t", value: null },
        envMap: { type: "t", value: null },
        flipEnvMap: { type: "f", value: -1 },
        useRefract: { type: "i", value: 0 },
        reflectivity: { type: "f", value: 1 },
        refractionRatio: { type: "f", value: 0.98 },
        combine: { type: "i", value: 0 },
        morphTargetInfluences: { type: "f", value: 0 },
    },
    bump: { bumpMap: { type: "t", value: null }, bumpScale: { type: "f", value: 1 } },
    normalmap: { normalMap: { type: "t", value: null }, normalScale: { type: "v2", value: new THREE.Vector2(1, 1) } },
    fog: { fogDensity: { type: "f", value: 25e-5 }, fogNear: { type: "f", value: 1 }, fogFar: { type: "f", value: 2e3 }, fogColor: { type: "c", value: new THREE.Color(16777215) } },
    lights: {
        ambientLightColor: { type: "fv", value: [] },
        directionalLightDirection: { type: "fv", value: [] },
        directionalLightColor: { type: "fv", value: [] },
        hemisphereLightDirection: { type: "fv", value: [] },
        hemisphereLightSkyColor: { type: "fv", value: [] },
        hemisphereLightGroundColor: { type: "fv", value: [] },
        pointLightColor: { type: "fv", value: [] },
        pointLightPosition: { type: "fv", value: [] },
        pointLightDistance: { type: "fv1", value: [] },
        spotLightColor: { type: "fv", value: [] },
        spotLightPosition: { type: "fv", value: [] },
        spotLightDirection: { type: "fv", value: [] },
        spotLightDistance: { type: "fv1", value: [] },
        spotLightAngleCos: { type: "fv1", value: [] },
        spotLightExponent: { type: "fv1", value: [] },
    },
    particle: {
        psColor: { type: "c", value: new THREE.Color(15658734) },
        opacity: { type: "f", value: 1 },
        size: { type: "f", value: 1 },
        scale: { type: "f", value: 1 },
        map: { type: "t", value: null },
        fogDensity: { type: "f", value: 25e-5 },
        fogNear: { type: "f", value: 1 },
        fogFar: { type: "f", value: 2e3 },
        fogColor: { type: "c", value: new THREE.Color(16777215) },
    },
    shadowmap: { shadowMap: { type: "tv", value: [] }, shadowMapSize: { type: "v2v", value: [] }, shadowBias: { type: "fv1", value: [] }, shadowDarkness: { type: "fv1", value: [] }, shadowMatrix: { type: "m4v", value: [] } },
}),
(THREE.ShaderLib = {
    basic: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
        vertexShader: [
            THREE.ShaderChunk.map_pars_vertex,
            THREE.ShaderChunk.lightmap_pars_vertex,
            THREE.ShaderChunk.envmap_pars_vertex,
            THREE.ShaderChunk.color_pars_vertex,
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.skinning_pars_vertex,
            THREE.ShaderChunk.shadowmap_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.map_vertex,
            THREE.ShaderChunk.lightmap_vertex,
            THREE.ShaderChunk.color_vertex,
            THREE.ShaderChunk.skinbase_vertex,
            "#ifdef USE_ENVMAP",
            THREE.ShaderChunk.morphnormal_vertex,
            THREE.ShaderChunk.skinnormal_vertex,
            THREE.ShaderChunk.defaultnormal_vertex,
            "#endif",
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.skinning_vertex,
            THREE.ShaderChunk.default_vertex,
            THREE.ShaderChunk.worldpos_vertex,
            THREE.ShaderChunk.envmap_vertex,
            THREE.ShaderChunk.shadowmap_vertex,
            "}",
        ].join("\n"),
        fragmentShader: [
            "uniform vec3 diffuse;",
            "uniform float opacity;",
            THREE.ShaderChunk.color_pars_fragment,
            THREE.ShaderChunk.map_pars_fragment,
            THREE.ShaderChunk.lightmap_pars_fragment,
            THREE.ShaderChunk.envmap_pars_fragment,
            THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.shadowmap_pars_fragment,
            THREE.ShaderChunk.specularmap_pars_fragment,
            "void main() {",
            "gl_FragColor = vec4( diffuse, opacity );",
            THREE.ShaderChunk.map_fragment,
            THREE.ShaderChunk.alphatest_fragment,
            THREE.ShaderChunk.specularmap_fragment,
            THREE.ShaderChunk.lightmap_fragment,
            THREE.ShaderChunk.color_fragment,
            THREE.ShaderChunk.envmap_fragment,
            THREE.ShaderChunk.shadowmap_fragment,
            THREE.ShaderChunk.linear_to_gamma_fragment,
            THREE.ShaderChunk.fog_fragment,
            "}",
        ].join("\n"),
    },
    lambert: {
        uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib.common,
            THREE.UniformsLib.fog,
            THREE.UniformsLib.lights,
            THREE.UniformsLib.shadowmap,
            { ambient: { type: "c", value: new THREE.Color(16777215) }, emissive: { type: "c", value: new THREE.Color(0) }, wrapRGB: { type: "v3", value: new THREE.Vector3(1, 1, 1) } },
        ]),
        vertexShader: [
            "#define LAMBERT",
            "varying vec3 vLightFront;",
            "#ifdef DOUBLE_SIDED",
            "varying vec3 vLightBack;",
            "#endif",
            THREE.ShaderChunk.map_pars_vertex,
            THREE.ShaderChunk.lightmap_pars_vertex,
            THREE.ShaderChunk.envmap_pars_vertex,
            THREE.ShaderChunk.lights_lambert_pars_vertex,
            THREE.ShaderChunk.color_pars_vertex,
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.skinning_pars_vertex,
            THREE.ShaderChunk.shadowmap_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.map_vertex,
            THREE.ShaderChunk.lightmap_vertex,
            THREE.ShaderChunk.color_vertex,
            THREE.ShaderChunk.morphnormal_vertex,
            THREE.ShaderChunk.skinbase_vertex,
            THREE.ShaderChunk.skinnormal_vertex,
            THREE.ShaderChunk.defaultnormal_vertex,
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.skinning_vertex,
            THREE.ShaderChunk.default_vertex,
            THREE.ShaderChunk.worldpos_vertex,
            THREE.ShaderChunk.envmap_vertex,
            THREE.ShaderChunk.lights_lambert_vertex,
            THREE.ShaderChunk.shadowmap_vertex,
            "}",
        ].join("\n"),
        fragmentShader: [
            "uniform float opacity;",
            "varying vec3 vLightFront;",
            "#ifdef DOUBLE_SIDED",
            "varying vec3 vLightBack;",
            "#endif",
            THREE.ShaderChunk.color_pars_fragment,
            THREE.ShaderChunk.map_pars_fragment,
            THREE.ShaderChunk.lightmap_pars_fragment,
            THREE.ShaderChunk.envmap_pars_fragment,
            THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.shadowmap_pars_fragment,
            THREE.ShaderChunk.specularmap_pars_fragment,
            "void main() {",
            "gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
            THREE.ShaderChunk.map_fragment,
            THREE.ShaderChunk.alphatest_fragment,
            THREE.ShaderChunk.specularmap_fragment,
            "#ifdef DOUBLE_SIDED",
            "if ( gl_FrontFacing )",
            "gl_FragColor.xyz *= vLightFront;",
            "else",
            "gl_FragColor.xyz *= vLightBack;",
            "#else",
            "gl_FragColor.xyz *= vLightFront;",
            "#endif",
            THREE.ShaderChunk.lightmap_fragment,
            THREE.ShaderChunk.color_fragment,
            THREE.ShaderChunk.envmap_fragment,
            THREE.ShaderChunk.shadowmap_fragment,
            THREE.ShaderChunk.linear_to_gamma_fragment,
            THREE.ShaderChunk.fog_fragment,
            "}",
        ].join("\n"),
    },
    phong: {
        uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib.common,
            THREE.UniformsLib.bump,
            THREE.UniformsLib.normalmap,
            THREE.UniformsLib.fog,
            THREE.UniformsLib.lights,
            THREE.UniformsLib.shadowmap,
            {
                ambient: { type: "c", value: new THREE.Color(16777215) },
                emissive: { type: "c", value: new THREE.Color(0) },
                specular: { type: "c", value: new THREE.Color(1118481) },
                shininess: { type: "f", value: 30 },
                wrapRGB: { type: "v3", value: new THREE.Vector3(1, 1, 1) },
            },
        ]),
        vertexShader: [
            "#define PHONG",
            "varying vec3 vViewPosition;",
            "varying vec3 vNormal;",
            THREE.ShaderChunk.map_pars_vertex,
            THREE.ShaderChunk.lightmap_pars_vertex,
            THREE.ShaderChunk.envmap_pars_vertex,
            THREE.ShaderChunk.lights_phong_pars_vertex,
            THREE.ShaderChunk.color_pars_vertex,
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.skinning_pars_vertex,
            THREE.ShaderChunk.shadowmap_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.map_vertex,
            THREE.ShaderChunk.lightmap_vertex,
            THREE.ShaderChunk.color_vertex,
            THREE.ShaderChunk.morphnormal_vertex,
            THREE.ShaderChunk.skinbase_vertex,
            THREE.ShaderChunk.skinnormal_vertex,
            THREE.ShaderChunk.defaultnormal_vertex,
            "vNormal = normalize( transformedNormal );",
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.skinning_vertex,
            THREE.ShaderChunk.default_vertex,
            "vViewPosition = -mvPosition.xyz;",
            THREE.ShaderChunk.worldpos_vertex,
            THREE.ShaderChunk.envmap_vertex,
            THREE.ShaderChunk.lights_phong_vertex,
            THREE.ShaderChunk.shadowmap_vertex,
            "}",
        ].join("\n"),
        fragmentShader: [
            "uniform vec3 diffuse;",
            "uniform float opacity;",
            "uniform vec3 ambient;",
            "uniform vec3 emissive;",
            "uniform vec3 specular;",
            "uniform float shininess;",
            THREE.ShaderChunk.color_pars_fragment,
            THREE.ShaderChunk.map_pars_fragment,
            THREE.ShaderChunk.lightmap_pars_fragment,
            THREE.ShaderChunk.envmap_pars_fragment,
            THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.lights_phong_pars_fragment,
            THREE.ShaderChunk.shadowmap_pars_fragment,
            THREE.ShaderChunk.bumpmap_pars_fragment,
            THREE.ShaderChunk.normalmap_pars_fragment,
            THREE.ShaderChunk.specularmap_pars_fragment,
            "void main() {",
            "gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
            THREE.ShaderChunk.map_fragment,
            THREE.ShaderChunk.alphatest_fragment,
            THREE.ShaderChunk.specularmap_fragment,
            THREE.ShaderChunk.lights_phong_fragment,
            THREE.ShaderChunk.lightmap_fragment,
            THREE.ShaderChunk.color_fragment,
            THREE.ShaderChunk.envmap_fragment,
            THREE.ShaderChunk.shadowmap_fragment,
            THREE.ShaderChunk.linear_to_gamma_fragment,
            THREE.ShaderChunk.fog_fragment,
            "}",
        ].join("\n"),
    },
    particle_basic: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
        vertexShader: [
            "uniform float size;",
            "uniform float scale;",
            THREE.ShaderChunk.color_pars_vertex,
            THREE.ShaderChunk.shadowmap_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.color_vertex,
            "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            "#ifdef USE_SIZEATTENUATION",
            "gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
            "#else",
            "gl_PointSize = size;",
            "#endif",
            "gl_Position = projectionMatrix * mvPosition;",
            THREE.ShaderChunk.worldpos_vertex,
            THREE.ShaderChunk.shadowmap_vertex,
            "}",
        ].join("\n"),
        fragmentShader: [
            "uniform vec3 psColor;",
            "uniform float opacity;",
            THREE.ShaderChunk.color_pars_fragment,
            THREE.ShaderChunk.map_particle_pars_fragment,
            THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.shadowmap_pars_fragment,
            "void main() {",
            "gl_FragColor = vec4( psColor, opacity );",
            THREE.ShaderChunk.map_particle_fragment,
            THREE.ShaderChunk.alphatest_fragment,
            THREE.ShaderChunk.color_fragment,
            THREE.ShaderChunk.shadowmap_fragment,
            THREE.ShaderChunk.fog_fragment,
            "}",
        ].join("\n"),
    },
    dashed: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, { scale: { type: "f", value: 1 }, dashSize: { type: "f", value: 1 }, totalSize: { type: "f", value: 2 } }]),
        vertexShader: [
            "uniform float scale;",
            "attribute float lineDistance;",
            "varying float vLineDistance;",
            THREE.ShaderChunk.color_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.color_vertex,
            "vLineDistance = scale * lineDistance;",
            "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            "gl_Position = projectionMatrix * mvPosition;",
            "}",
        ].join("\n"),
        fragmentShader: [
            "uniform vec3 diffuse;",
            "uniform float opacity;",
            "uniform float dashSize;",
            "uniform float totalSize;",
            "varying float vLineDistance;",
            THREE.ShaderChunk.color_pars_fragment,
            THREE.ShaderChunk.fog_pars_fragment,
            "void main() {",
            "if ( mod( vLineDistance, totalSize ) > dashSize ) {",
            "discard;",
            "}",
            "gl_FragColor = vec4( diffuse, opacity );",
            THREE.ShaderChunk.color_fragment,
            THREE.ShaderChunk.fog_fragment,
            "}",
        ].join("\n"),
    },
    depth: {
        uniforms: { mNear: { type: "f", value: 1 }, mFar: { type: "f", value: 2e3 }, opacity: { type: "f", value: 1 } },
        vertexShader: ["void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
        fragmentShader: [
            "uniform float mNear;",
            "uniform float mFar;",
            "uniform float opacity;",
            "void main() {",
            "float depth = gl_FragCoord.z / gl_FragCoord.w;",
            "float color = 1.0 - smoothstep( mNear, mFar, depth );",
            "gl_FragColor = vec4( vec3( color ), opacity );",
            "}",
        ].join("\n"),
    },
    normal: {
        uniforms: { opacity: { type: "f", value: 1 } },
        vertexShader: [
            "varying vec3 vNormal;",
            THREE.ShaderChunk.morphtarget_pars_vertex,
            "void main() {",
            "vNormal = normalize( normalMatrix * normal );",
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.default_vertex,
            "}",
        ].join("\n"),
        fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", "void main() {", "gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", "}"].join("\n"),
    },
    normalmap: {
        uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib.fog,
            THREE.UniformsLib.lights,
            THREE.UniformsLib.shadowmap,
            {
                enableAO: { type: "i", value: 0 },
                enableDiffuse: { type: "i", value: 0 },
                enableSpecular: { type: "i", value: 0 },
                enableReflection: { type: "i", value: 0 },
                enableDisplacement: { type: "i", value: 0 },
                tDisplacement: { type: "t", value: null },
                tDiffuse: { type: "t", value: null },
                tCube: { type: "t", value: null },
                tNormal: { type: "t", value: null },
                tSpecular: { type: "t", value: null },
                tAO: { type: "t", value: null },
                uNormalScale: { type: "v2", value: new THREE.Vector2(1, 1) },
                uDisplacementBias: { type: "f", value: 0 },
                uDisplacementScale: { type: "f", value: 1 },
                uDiffuseColor: { type: "c", value: new THREE.Color(16777215) },
                uSpecularColor: { type: "c", value: new THREE.Color(1118481) },
                uAmbientColor: { type: "c", value: new THREE.Color(16777215) },
                uShininess: { type: "f", value: 30 },
                uOpacity: { type: "f", value: 1 },
                useRefract: { type: "i", value: 0 },
                uRefractionRatio: { type: "f", value: 0.98 },
                uReflectivity: { type: "f", value: 0.5 },
                uOffset: { type: "v2", value: new THREE.Vector2(0, 0) },
                uRepeat: { type: "v2", value: new THREE.Vector2(1, 1) },
                wrapRGB: { type: "v3", value: new THREE.Vector3(1, 1, 1) },
            },
        ]),
        fragmentShader: [
            "uniform vec3 uAmbientColor;",
            "uniform vec3 uDiffuseColor;",
            "uniform vec3 uSpecularColor;",
            "uniform float uShininess;",
            "uniform float uOpacity;",
            "uniform bool enableDiffuse;",
            "uniform bool enableSpecular;",
            "uniform bool enableAO;",
            "uniform bool enableReflection;",
            "uniform sampler2D tDiffuse;",
            "uniform sampler2D tNormal;",
            "uniform sampler2D tSpecular;",
            "uniform sampler2D tAO;",
            "uniform samplerCube tCube;",
            "uniform vec2 uNormalScale;",
            "uniform bool useRefract;",
            "uniform float uRefractionRatio;",
            "uniform float uReflectivity;",
            "varying vec3 vTangent;",
            "varying vec3 vBinormal;",
            "varying vec3 vNormal;",
            "varying vec2 vUv;",
            "uniform vec3 ambientLightColor;",
            "#if MAX_DIR_LIGHTS > 0",
            "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
            "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
            "#endif",
            "#if MAX_HEMI_LIGHTS > 0",
            "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
            "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
            "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
            "#endif",
            "#if MAX_POINT_LIGHTS > 0",
            "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
            "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
            "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
            "#endif",
            "#if MAX_SPOT_LIGHTS > 0",
            "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
            "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
            "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
            "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
            "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
            "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
            "#endif",
            "#ifdef WRAP_AROUND",
            "uniform vec3 wrapRGB;",
            "#endif",
            "varying vec3 vWorldPosition;",
            "varying vec3 vViewPosition;",
            THREE.ShaderChunk.shadowmap_pars_fragment,
            THREE.ShaderChunk.fog_pars_fragment,
            "void main() {",
            "gl_FragColor = vec4( vec3( 1.0 ), uOpacity );",
            "vec3 specularTex = vec3( 1.0 );",
            "vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
            "normalTex.xy *= uNormalScale;",
            "normalTex = normalize( normalTex );",
            "if( enableDiffuse ) {",
            "#ifdef GAMMA_INPUT",
            "vec4 texelColor = texture2D( tDiffuse, vUv );",
            "texelColor.xyz *= texelColor.xyz;",
            "gl_FragColor = gl_FragColor * texelColor;",
            "#else",
            "gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",
            "#endif",
            "}",
            "if( enableAO ) {",
            "#ifdef GAMMA_INPUT",
            "vec4 aoColor = texture2D( tAO, vUv );",
            "aoColor.xyz *= aoColor.xyz;",
            "gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",
            "#else",
            "gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",
            "#endif",
            "}",
            "if( enableSpecular )",
            "specularTex = texture2D( tSpecular, vUv ).xyz;",
            "mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
            "vec3 finalNormal = tsb * normalTex;",
            "#ifdef FLIP_SIDED",
            "finalNormal = -finalNormal;",
            "#endif",
            "vec3 normal = normalize( finalNormal );",
            "vec3 viewPosition = normalize( vViewPosition );",
            "#if MAX_POINT_LIGHTS > 0",
            "vec3 pointDiffuse = vec3( 0.0 );",
            "vec3 pointSpecular = vec3( 0.0 );",
            "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
            "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
            "vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",
            "float pointDistance = 1.0;",
            "if ( pointLightDistance[ i ] > 0.0 )",
            "pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",
            "pointVector = normalize( pointVector );",
            "#ifdef WRAP_AROUND",
            "float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
            "float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",
            "vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",
            "#else",
            "float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",
            "#endif",
            "pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;",
            "vec3 pointHalfVector = normalize( pointVector + viewPosition );",
            "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
            "float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );",
            "#ifdef PHYSICALLY_BASED_SHADING",
            "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
            "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );",
            "pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",
            "#else",
            "pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;",
            "#endif",
            "}",
            "#endif",
            "#if MAX_SPOT_LIGHTS > 0",
            "vec3 spotDiffuse = vec3( 0.0 );",
            "vec3 spotSpecular = vec3( 0.0 );",
            "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
            "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
            "vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",
            "float spotDistance = 1.0;",
            "if ( spotLightDistance[ i ] > 0.0 )",
            "spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",
            "spotVector = normalize( spotVector );",
            "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",
            "if ( spotEffect > spotLightAngleCos[ i ] ) {",
            "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
            "#ifdef WRAP_AROUND",
            "float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
            "float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",
            "vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",
            "#else",
            "float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",
            "#endif",
            "spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;",
            "vec3 spotHalfVector = normalize( spotVector + viewPosition );",
            "float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
            "float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );",
            "#ifdef PHYSICALLY_BASED_SHADING",
            "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
            "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );",
            "spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",
            "#else",
            "spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;",
            "#endif",
            "}",
            "}",
            "#endif",
            "#if MAX_DIR_LIGHTS > 0",
            "vec3 dirDiffuse = vec3( 0.0 );",
            "vec3 dirSpecular = vec3( 0.0 );",
            "for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",
            "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
            "vec3 dirVector = normalize( lDirection.xyz );",
            "#ifdef WRAP_AROUND",
            "float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
            "float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",
            "vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",
            "#else",
            "float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",
            "#endif",
            "dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;",
            "vec3 dirHalfVector = normalize( dirVector + viewPosition );",
            "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
            "float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );",
            "#ifdef PHYSICALLY_BASED_SHADING",
            "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
            "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
            "dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",
            "#else",
            "dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;",
            "#endif",
            "}",
            "#endif",
            "#if MAX_HEMI_LIGHTS > 0",
            "vec3 hemiDiffuse  = vec3( 0.0 );",
            "vec3 hemiSpecular = vec3( 0.0 );",
            "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
            "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
            "vec3 lVector = normalize( lDirection.xyz );",
            "float dotProduct = dot( normal, lVector );",
            "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
            "vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
            "hemiDiffuse += uDiffuseColor * hemiColor;",
            "vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
            "float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
            "float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );",
            "vec3 lVectorGround = -lVector;",
            "vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
            "float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
            "float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );",
            "#ifdef PHYSICALLY_BASED_SHADING",
            "float dotProductGround = dot( normal, lVectorGround );",
            "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
            "vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
            "vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
            "hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",
            "#else",
            "hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;",
            "#endif",
            "}",
            "#endif",
            "vec3 totalDiffuse = vec3( 0.0 );",
            "vec3 totalSpecular = vec3( 0.0 );",
            "#if MAX_DIR_LIGHTS > 0",
            "totalDiffuse += dirDiffuse;",
            "totalSpecular += dirSpecular;",
            "#endif",
            "#if MAX_HEMI_LIGHTS > 0",
            "totalDiffuse += hemiDiffuse;",
            "totalSpecular += hemiSpecular;",
            "#endif",
            "#if MAX_POINT_LIGHTS > 0",
            "totalDiffuse += pointDiffuse;",
            "totalSpecular += pointSpecular;",
            "#endif",
            "#if MAX_SPOT_LIGHTS > 0",
            "totalDiffuse += spotDiffuse;",
            "totalSpecular += spotSpecular;",
            "#endif",
            "#ifdef METAL",
            "gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );",
            "#else",
            "gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;",
            "#endif",
            "if ( enableReflection ) {",
            "vec3 vReflect;",
            "vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",
            "if ( useRefract ) {",
            "vReflect = refract( cameraToVertex, normal, uRefractionRatio );",
            "} else {",
            "vReflect = reflect( cameraToVertex, normal );",
            "}",
            "vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",
            "#ifdef GAMMA_INPUT",
            "cubeColor.xyz *= cubeColor.xyz;",
            "#endif",
            "gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );",
            "}",
            THREE.ShaderChunk.shadowmap_fragment,
            THREE.ShaderChunk.linear_to_gamma_fragment,
            THREE.ShaderChunk.fog_fragment,
            "}",
        ].join("\n"),
        vertexShader: [
            "attribute vec4 tangent;",
            "uniform vec2 uOffset;",
            "uniform vec2 uRepeat;",
            "uniform bool enableDisplacement;",
            "#ifdef VERTEX_TEXTURES",
            "uniform sampler2D tDisplacement;",
            "uniform float uDisplacementScale;",
            "uniform float uDisplacementBias;",
            "#endif",
            "varying vec3 vTangent;",
            "varying vec3 vBinormal;",
            "varying vec3 vNormal;",
            "varying vec2 vUv;",
            "varying vec3 vWorldPosition;",
            "varying vec3 vViewPosition;",
            THREE.ShaderChunk.skinning_pars_vertex,
            THREE.ShaderChunk.shadowmap_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.skinbase_vertex,
            THREE.ShaderChunk.skinnormal_vertex,
            "#ifdef USE_SKINNING",
            "vNormal = normalize( normalMatrix * skinnedNormal.xyz );",
            "vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
            "vTangent = normalize( normalMatrix * skinnedTangent.xyz );",
            "#else",
            "vNormal = normalize( normalMatrix * normal );",
            "vTangent = normalize( normalMatrix * tangent.xyz );",
            "#endif",
            "vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",
            "vUv = uv * uRepeat + uOffset;",
            "vec3 displacedPosition;",
            "#ifdef VERTEX_TEXTURES",
            "if ( enableDisplacement ) {",
            "vec3 dv = texture2D( tDisplacement, uv ).xyz;",
            "float df = uDisplacementScale * dv.x + uDisplacementBias;",
            "displacedPosition = position + normalize( normal ) * df;",
            "} else {",
            "#ifdef USE_SKINNING",
            "vec4 skinVertex = vec4( position, 1.0 );",
            "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
            "skinned 	  += boneMatY * skinVertex * skinWeight.y;",
            "displacedPosition  = skinned.xyz;",
            "#else",
            "displacedPosition = position;",
            "#endif",
            "}",
            "#else",
            "#ifdef USE_SKINNING",
            "vec4 skinVertex = vec4( position, 1.0 );",
            "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
            "skinned 	  += boneMatY * skinVertex * skinWeight.y;",
            "displacedPosition  = skinned.xyz;",
            "#else",
            "displacedPosition = position;",
            "#endif",
            "#endif",
            "vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
            "vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",
            "gl_Position = projectionMatrix * mvPosition;",
            "vWorldPosition = worldPosition.xyz;",
            "vViewPosition = -mvPosition.xyz;",
            "#ifdef USE_SHADOWMAP",
            "for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
            "vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",
            "}",
            "#endif",
            "}",
        ].join("\n"),
    },
    cube: {
        uniforms: { tCube: { type: "t", value: null }, tFlip: { type: "f", value: -1 } },
        vertexShader: [
            "varying vec3 vWorldPosition;",
            "void main() {",
            "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
            "vWorldPosition = worldPosition.xyz;",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            "}",
        ].join("\n"),
        fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", "void main() {", "gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", "}"].join(
            "\n"
        ),
    },
    depthRGBA: {
        uniforms: {},
        vertexShader: [
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.skinning_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.skinbase_vertex,
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.skinning_vertex,
            THREE.ShaderChunk.default_vertex,
            "}",
        ].join("\n"),
        fragmentShader: [
            "vec4 pack_depth( const in float depth ) {",
            "const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
            "const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
            "vec4 res = fract( depth * bit_shift );",
            "res -= res.xxyz * bit_mask;",
            "return res;",
            "}",
            "void main() {",
            "gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",
            "}",
        ].join("\n"),
    },
}),
(THREE.WebGLRenderer = function (e) {
    function wt(e) {
        (e.__webglVertexBuffer = V.createBuffer()), (e.__webglColorBuffer = V.createBuffer()), l.info.memory.geometries++;
    }
    function Et(e) {
        (e.__webglVertexBuffer = V.createBuffer()), (e.__webglColorBuffer = V.createBuffer()), (e.__webglLineDistanceBuffer = V.createBuffer()), l.info.memory.geometries++;
    }
    function St(e) {
        (e.__webglVertexBuffer = V.createBuffer()),
            (e.__webglNormalBuffer = V.createBuffer()),
            (e.__webglTangentBuffer = V.createBuffer()),
            (e.__webglColorBuffer = V.createBuffer()),
            (e.__webglUVBuffer = V.createBuffer()),
            (e.__webglUV2Buffer = V.createBuffer()),
            (e.__webglSkinIndicesBuffer = V.createBuffer()),
            (e.__webglSkinWeightsBuffer = V.createBuffer()),
            (e.__webglFaceBuffer = V.createBuffer()),
            (e.__webglLineBuffer = V.createBuffer());
        var t, n;
        if (e.numMorphTargets) {
            e.__webglMorphTargetsBuffers = [];
            for (t = 0, n = e.numMorphTargets; t < n; t++) e.__webglMorphTargetsBuffers.push(V.createBuffer());
        }
        if (e.numMorphNormals) {
            e.__webglMorphNormalsBuffers = [];
            for (t = 0, n = e.numMorphNormals; t < n; t++) e.__webglMorphNormalsBuffers.push(V.createBuffer());
        }
        l.info.memory.geometries++;
    }
    function _t(e, t) {
        var n = e.vertices.length,
            r = t.material;
        if (r.attributes) {
            e.__webglCustomAttributesList === undefined && (e.__webglCustomAttributesList = []);
            for (var i in r.attributes) {
                var s = r.attributes[i];
                if (!s.__webglInitialized || s.createUniqueBuffers) {
                    s.__webglInitialized = !0;
                    var o = 1;
                    s.type === "v2" ? (o = 2) : s.type === "v3" ? (o = 3) : s.type === "v4" ? (o = 4) : s.type === "c" && (o = 3),
                        (s.size = o),
                        (s.array = new Float32Array(n * o)),
                        (s.buffer = V.createBuffer()),
                        (s.buffer.belongsToAttribute = i),
                        (s.needsUpdate = !0);
                }
                e.__webglCustomAttributesList.push(s);
            }
        }
    }
    function Dt(e, t) {
        var n = e.vertices.length;
        (e.__vertexArray = new Float32Array(n * 3)), (e.__colorArray = new Float32Array(n * 3)), (e.__sortArray = []), (e.__webglParticleCount = n), _t(e, t);
    }
    function Pt(e, t) {
        var n = e.vertices.length;
        (e.__vertexArray = new Float32Array(n * 3)), (e.__colorArray = new Float32Array(n * 3)), (e.__lineDistanceArray = new Float32Array(n * 1)), (e.__webglLineCount = n), _t(e, t);
    }
    function Ht(e, t) {
        var n = t.geometry,
            r = e.faces3,
            i = r.length * 3,
            s = r.length * 1,
            o = r.length * 3,
            u = Bt(t, e),
            a = qt(u),
            f = Ft(u),
            l = It(u);
        (e.__vertexArray = new Float32Array(i * 3)),
        f && (e.__normalArray = new Float32Array(i * 3)),
        n.hasTangents && (e.__tangentArray = new Float32Array(i * 4)),
        l && (e.__colorArray = new Float32Array(i * 3)),
        a && (n.faceVertexUvs.length > 0 && (e.__uvArray = new Float32Array(i * 2)), n.faceVertexUvs.length > 1 && (e.__uv2Array = new Float32Array(i * 2))),
        t.geometry.skinWeights.length && t.geometry.skinIndices.length && ((e.__skinIndexArray = new Float32Array(i * 4)), (e.__skinWeightArray = new Float32Array(i * 4))),
            (e.__faceArray = new Uint16Array(s * 3)),
            (e.__lineArray = new Uint16Array(o * 2));
        var c, h;
        if (e.numMorphTargets) {
            e.__morphTargetsArrays = [];
            for (c = 0, h = e.numMorphTargets; c < h; c++) e.__morphTargetsArrays.push(new Float32Array(i * 3));
        }
        if (e.numMorphNormals) {
            e.__morphNormalsArrays = [];
            for (c = 0, h = e.numMorphNormals; c < h; c++) e.__morphNormalsArrays.push(new Float32Array(i * 3));
        }
        (e.__webglFaceCount = s * 3), (e.__webglLineCount = o * 2);
        if (u.attributes) {
            e.__webglCustomAttributesList === undefined && (e.__webglCustomAttributesList = []);
            for (var p in u.attributes) {
                var d = u.attributes[p],
                    v = {};
                for (var m in d) v[m] = d[m];
                if (!v.__webglInitialized || v.createUniqueBuffers) {
                    v.__webglInitialized = !0;
                    var g = 1;
                    v.type === "v2" ? (g = 2) : v.type === "v3" ? (g = 3) : v.type === "v4" ? (g = 4) : v.type === "c" && (g = 3),
                        (v.size = g),
                        (v.array = new Float32Array(i * g)),
                        (v.buffer = V.createBuffer()),
                        (v.buffer.belongsToAttribute = p),
                        (d.needsUpdate = !0),
                        (v.__original = d);
                }
                e.__webglCustomAttributesList.push(v);
            }
        }
        e.__inittedArrays = !0;
    }
    function Bt(e, t) {
        return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[t.materialIndex] : e.material;
    }
    function jt(e) {
        return e && e.shading !== undefined && e.shading === THREE.SmoothShading;
    }
    function Ft(e) {
        return (e instanceof THREE.MeshBasicMaterial && !e.envMap) || e instanceof THREE.MeshDepthMaterial ? !1 : jt(e) ? THREE.SmoothShading : THREE.FlatShading;
    }
    function It(e) {
        return e.vertexColors ? e.vertexColors : !1;
    }
    function qt(e) {
        return e.map || e.lightMap || e.bumpMap || e.normalMap || e.specularMap || e instanceof THREE.ShaderMaterial ? !0 : !1;
    }
    function Rt(e) {
        var t, n, r;
        for (t in e.attributes)
            t === "index" ? (r = V.ELEMENT_ARRAY_BUFFER) : (r = V.ARRAY_BUFFER),
                (n = e.attributes[t]),
            n.numItems === undefined && (n.numItems = n.array.length),
                (n.buffer = V.createBuffer()),
                V.bindBuffer(r, n.buffer),
                V.bufferData(r, n.array, V.STATIC_DRAW);
    }
    function Ut(e, t, n) {
        var r,
            i,
            s,
            o,
            u,
            a,
            f = e.vertices,
            l = f.length,
            c = e.colors,
            h = c.length,
            p = e.__vertexArray,
            d = e.__colorArray,
            v = e.__sortArray,
            m = e.verticesNeedUpdate,
            g = e.elementsNeedUpdate,
            y = e.colorsNeedUpdate,
            b = e.__webglCustomAttributesList,
            w,
            E,
            S,
            x,
            T,
            N,
            C;
        if (n.sortParticles) {
            R.copy(q), R.multiply(n.matrixWorld);
            for (r = 0; r < l; r++) (s = f[r]), U.copy(s), U.applyProjection(R), (v[r] = [U.z, r]);
            v.sort(Qt);
            for (r = 0; r < l; r++) (s = f[v[r][1]]), (o = r * 3), (p[o] = s.x), (p[o + 1] = s.y), (p[o + 2] = s.z);
            for (i = 0; i < h; i++) (o = i * 3), (a = c[v[i][1]]), (d[o] = a.r), (d[o + 1] = a.g), (d[o + 2] = a.b);
            if (b)
                for (w = 0, E = b.length; w < E; w++) {
                    C = b[w];
                    if (C.boundTo !== undefined && C.boundTo !== "vertices") continue;
                    (o = 0), (T = C.value.length);
                    if (C.size === 1) for (x = 0; x < T; x++) (u = v[x][1]), (C.array[x] = C.value[u]);
                    else if (C.size === 2) for (x = 0; x < T; x++) (u = v[x][1]), (N = C.value[u]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (o += 2);
                    else if (C.size === 3)
                        if (C.type === "c") for (x = 0; x < T; x++) (u = v[x][1]), (N = C.value[u]), (C.array[o] = N.r), (C.array[o + 1] = N.g), (C.array[o + 2] = N.b), (o += 3);
                        else for (x = 0; x < T; x++) (u = v[x][1]), (N = C.value[u]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (C.array[o + 2] = N.z), (o += 3);
                    else if (C.size === 4) for (x = 0; x < T; x++) (u = v[x][1]), (N = C.value[u]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (C.array[o + 2] = N.z), (C.array[o + 3] = N.w), (o += 4);
                }
        } else {
            if (m) for (r = 0; r < l; r++) (s = f[r]), (o = r * 3), (p[o] = s.x), (p[o + 1] = s.y), (p[o + 2] = s.z);
            if (y) for (i = 0; i < h; i++) (a = c[i]), (o = i * 3), (d[o] = a.r), (d[o + 1] = a.g), (d[o + 2] = a.b);
            if (b)
                for (w = 0, E = b.length; w < E; w++) {
                    C = b[w];
                    if (C.needsUpdate && (C.boundTo === undefined || C.boundTo === "vertices")) {
                        (T = C.value.length), (o = 0);
                        if (C.size === 1) for (x = 0; x < T; x++) C.array[x] = C.value[x];
                        else if (C.size === 2) for (x = 0; x < T; x++) (N = C.value[x]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (o += 2);
                        else if (C.size === 3)
                            if (C.type === "c") for (x = 0; x < T; x++) (N = C.value[x]), (C.array[o] = N.r), (C.array[o + 1] = N.g), (C.array[o + 2] = N.b), (o += 3);
                            else for (x = 0; x < T; x++) (N = C.value[x]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (C.array[o + 2] = N.z), (o += 3);
                        else if (C.size === 4) for (x = 0; x < T; x++) (N = C.value[x]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (C.array[o + 2] = N.z), (C.array[o + 3] = N.w), (o += 4);
                    }
                }
        }
        if (m || n.sortParticles) V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer), V.bufferData(V.ARRAY_BUFFER, p, t);
        if (y || n.sortParticles) V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer), V.bufferData(V.ARRAY_BUFFER, d, t);
        if (b)
            for (w = 0, E = b.length; w < E; w++) {
                C = b[w];
                if (C.needsUpdate || n.sortParticles) V.bindBuffer(V.ARRAY_BUFFER, C.buffer), V.bufferData(V.ARRAY_BUFFER, C.array, t);
            }
    }
    function zt(e, t) {
        var n,
            r,
            i,
            s,
            o,
            u,
            a = e.vertices,
            f = e.colors,
            l = e.lineDistances,
            c = a.length,
            h = f.length,
            p = l.length,
            d = e.__vertexArray,
            v = e.__colorArray,
            m = e.__lineDistanceArray,
            g = e.verticesNeedUpdate,
            y = e.colorsNeedUpdate,
            b = e.lineDistancesNeedUpdate,
            w = e.__webglCustomAttributesList,
            E,
            S,
            x,
            T,
            N,
            C,
            k;
        if (g) {
            for (n = 0; n < c; n++) (s = a[n]), (o = n * 3), (d[o] = s.x), (d[o + 1] = s.y), (d[o + 2] = s.z);
            V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer), V.bufferData(V.ARRAY_BUFFER, d, t);
        }
        if (y) {
            for (r = 0; r < h; r++) (u = f[r]), (o = r * 3), (v[o] = u.r), (v[o + 1] = u.g), (v[o + 2] = u.b);
            V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer), V.bufferData(V.ARRAY_BUFFER, v, t);
        }
        if (b) {
            for (i = 0; i < p; i++) m[i] = l[i];
            V.bindBuffer(V.ARRAY_BUFFER, e.__webglLineDistanceBuffer), V.bufferData(V.ARRAY_BUFFER, m, t);
        }
        if (w)
            for (E = 0, S = w.length; E < S; E++) {
                k = w[E];
                if (k.needsUpdate && (k.boundTo === undefined || k.boundTo === "vertices")) {
                    (o = 0), (N = k.value.length);
                    if (k.size === 1) for (T = 0; T < N; T++) k.array[T] = k.value[T];
                    else if (k.size === 2) for (T = 0; T < N; T++) (C = k.value[T]), (k.array[o] = C.x), (k.array[o + 1] = C.y), (o += 2);
                    else if (k.size === 3)
                        if (k.type === "c") for (T = 0; T < N; T++) (C = k.value[T]), (k.array[o] = C.r), (k.array[o + 1] = C.g), (k.array[o + 2] = C.b), (o += 3);
                        else for (T = 0; T < N; T++) (C = k.value[T]), (k.array[o] = C.x), (k.array[o + 1] = C.y), (k.array[o + 2] = C.z), (o += 3);
                    else if (k.size === 4) for (T = 0; T < N; T++) (C = k.value[T]), (k.array[o] = C.x), (k.array[o + 1] = C.y), (k.array[o + 2] = C.z), (k.array[o + 3] = C.w), (o += 4);
                    V.bindBuffer(V.ARRAY_BUFFER, k.buffer), V.bufferData(V.ARRAY_BUFFER, k.array, t);
                }
            }
    }
    function Wt(e, t, n, r, i) {
        if (!e.__inittedArrays) return;
        var s = Ft(i),
            o = It(i),
            u = qt(i),
            a = s === THREE.SmoothShading,
            f,
            l,
            c,
            h,
            p,
            d,
            v,
            m,
            g,
            y,
            b,
            w,
            E,
            S,
            x,
            T,
            N,
            C,
            k,
            L,
            A,
            O,
            M,
            _,
            D,
            P,
            H,
            B,
            j,
            F,
            I,
            q,
            R,
            U,
            z,
            W,
            X,
            $,
            J,
            K,
            Q,
            G,
            Y,
            Z,
            et,
            tt,
            nt,
            rt,
            it,
            st,
            ot,
            ut,
            at,
            ft,
            lt,
            ct,
            ht,
            pt,
            dt = 0,
            vt = 0,
            mt = 0,
            gt = 0,
            yt = 0,
            bt = 0,
            wt = 0,
            Et = 0,
            St = 0,
            xt = 0,
            Tt = 0,
            Nt = 0,
            Ct = 0,
            kt,
            Lt = e.__vertexArray,
            At = e.__uvArray,
            Ot = e.__uv2Array,
            Mt = e.__normalArray,
            _t = e.__tangentArray,
            Dt = e.__colorArray,
            Pt = e.__skinIndexArray,
            Ht = e.__skinWeightArray,
            Bt = e.__morphTargetsArrays,
            jt = e.__morphNormalsArrays,
            Rt = e.__webglCustomAttributesList,
            Ut,
            zt = e.__faceArray,
            Wt = e.__lineArray,
            Xt = t.geometry,
            Vt = Xt.verticesNeedUpdate,
            $t = Xt.elementsNeedUpdate,
            Jt = Xt.uvsNeedUpdate,
            Kt = Xt.normalsNeedUpdate,
            Qt = Xt.tangentsNeedUpdate,
            Gt = Xt.colorsNeedUpdate,
            Yt = Xt.morphTargetsNeedUpdate,
            Zt = Xt.vertices,
            en = e.faces3,
            tn = Xt.faces,
            nn = Xt.faceVertexUvs[0],
            rn = Xt.faceVertexUvs[1],
            sn = Xt.colors,
            on = Xt.skinIndices,
            un = Xt.skinWeights,
            an = Xt.morphTargets,
            fn = Xt.morphNormals;
        if (Vt) {
            for (f = 0, l = en.length; f < l; f++)
                (h = tn[en[f]]),
                    (E = Zt[h.a]),
                    (S = Zt[h.b]),
                    (x = Zt[h.c]),
                    (Lt[vt] = E.x),
                    (Lt[vt + 1] = E.y),
                    (Lt[vt + 2] = E.z),
                    (Lt[vt + 3] = S.x),
                    (Lt[vt + 4] = S.y),
                    (Lt[vt + 5] = S.z),
                    (Lt[vt + 6] = x.x),
                    (Lt[vt + 7] = x.y),
                    (Lt[vt + 8] = x.z),
                    (vt += 9);
            V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer), V.bufferData(V.ARRAY_BUFFER, Lt, n);
        }
        if (Yt)
            for (ut = 0, at = an.length; ut < at; ut++) {
                Tt = 0;
                for (f = 0, l = en.length; f < l; f++)
                    (ct = en[f]),
                        (h = tn[ct]),
                        (E = an[ut].vertices[h.a]),
                        (S = an[ut].vertices[h.b]),
                        (x = an[ut].vertices[h.c]),
                        (ft = Bt[ut]),
                        (ft[Tt] = E.x),
                        (ft[Tt + 1] = E.y),
                        (ft[Tt + 2] = E.z),
                        (ft[Tt + 3] = S.x),
                        (ft[Tt + 4] = S.y),
                        (ft[Tt + 5] = S.z),
                        (ft[Tt + 6] = x.x),
                        (ft[Tt + 7] = x.y),
                        (ft[Tt + 8] = x.z),
                    i.morphNormals &&
                    (a ? ((ht = fn[ut].vertexNormals[ct]), (A = ht.a), (O = ht.b), (M = ht.c)) : ((A = fn[ut].faceNormals[ct]), (O = A), (M = A)),
                        (lt = jt[ut]),
                        (lt[Tt] = A.x),
                        (lt[Tt + 1] = A.y),
                        (lt[Tt + 2] = A.z),
                        (lt[Tt + 3] = O.x),
                        (lt[Tt + 4] = O.y),
                        (lt[Tt + 5] = O.z),
                        (lt[Tt + 6] = M.x),
                        (lt[Tt + 7] = M.y),
                        (lt[Tt + 8] = M.z)),
                        (Tt += 9);
                V.bindBuffer(V.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[ut]),
                    V.bufferData(V.ARRAY_BUFFER, Bt[ut], n),
                i.morphNormals && (V.bindBuffer(V.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[ut]), V.bufferData(V.ARRAY_BUFFER, jt[ut], n));
            }
        if (un.length) {
            for (f = 0, l = en.length; f < l; f++)
                (h = tn[en[f]]),
                    (j = un[h.a]),
                    (F = un[h.b]),
                    (I = un[h.c]),
                    (Ht[xt] = j.x),
                    (Ht[xt + 1] = j.y),
                    (Ht[xt + 2] = j.z),
                    (Ht[xt + 3] = j.w),
                    (Ht[xt + 4] = F.x),
                    (Ht[xt + 5] = F.y),
                    (Ht[xt + 6] = F.z),
                    (Ht[xt + 7] = F.w),
                    (Ht[xt + 8] = I.x),
                    (Ht[xt + 9] = I.y),
                    (Ht[xt + 10] = I.z),
                    (Ht[xt + 11] = I.w),
                    (R = on[h.a]),
                    (U = on[h.b]),
                    (z = on[h.c]),
                    (Pt[xt] = R.x),
                    (Pt[xt + 1] = R.y),
                    (Pt[xt + 2] = R.z),
                    (Pt[xt + 3] = R.w),
                    (Pt[xt + 4] = U.x),
                    (Pt[xt + 5] = U.y),
                    (Pt[xt + 6] = U.z),
                    (Pt[xt + 7] = U.w),
                    (Pt[xt + 8] = z.x),
                    (Pt[xt + 9] = z.y),
                    (Pt[xt + 10] = z.z),
                    (Pt[xt + 11] = z.w),
                    (xt += 12);
            xt > 0 && (V.bindBuffer(V.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), V.bufferData(V.ARRAY_BUFFER, Pt, n), V.bindBuffer(V.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), V.bufferData(V.ARRAY_BUFFER, Ht, n));
        }
        if (Gt && o) {
            for (f = 0, l = en.length; f < l; f++)
                (h = tn[en[f]]),
                    (m = h.vertexColors),
                    (g = h.color),
                    m.length === 3 && o === THREE.VertexColors ? ((D = m[0]), (P = m[1]), (H = m[2])) : ((D = g), (P = g), (H = g)),
                    (Dt[St] = D.r),
                    (Dt[St + 1] = D.g),
                    (Dt[St + 2] = D.b),
                    (Dt[St + 3] = P.r),
                    (Dt[St + 4] = P.g),
                    (Dt[St + 5] = P.b),
                    (Dt[St + 6] = H.r),
                    (Dt[St + 7] = H.g),
                    (Dt[St + 8] = H.b),
                    (St += 9);
            St > 0 && (V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer), V.bufferData(V.ARRAY_BUFFER, Dt, n));
        }
        if (Qt && Xt.hasTangents) {
            for (f = 0, l = en.length; f < l; f++)
                (h = tn[en[f]]),
                    (y = h.vertexTangents),
                    (N = y[0]),
                    (C = y[1]),
                    (k = y[2]),
                    (_t[wt] = N.x),
                    (_t[wt + 1] = N.y),
                    (_t[wt + 2] = N.z),
                    (_t[wt + 3] = N.w),
                    (_t[wt + 4] = C.x),
                    (_t[wt + 5] = C.y),
                    (_t[wt + 6] = C.z),
                    (_t[wt + 7] = C.w),
                    (_t[wt + 8] = k.x),
                    (_t[wt + 9] = k.y),
                    (_t[wt + 10] = k.z),
                    (_t[wt + 11] = k.w),
                    (wt += 12);
            V.bindBuffer(V.ARRAY_BUFFER, e.__webglTangentBuffer), V.bufferData(V.ARRAY_BUFFER, _t, n);
        }
        if (Kt && s) {
            for (f = 0, l = en.length; f < l; f++) {
                (h = tn[en[f]]), (p = h.vertexNormals), (d = h.normal);
                if (p.length === 3 && a) for (nt = 0; nt < 3; nt++) (it = p[nt]), (Mt[bt] = it.x), (Mt[bt + 1] = it.y), (Mt[bt + 2] = it.z), (bt += 3);
                else for (nt = 0; nt < 3; nt++) (Mt[bt] = d.x), (Mt[bt + 1] = d.y), (Mt[bt + 2] = d.z), (bt += 3);
            }
            V.bindBuffer(V.ARRAY_BUFFER, e.__webglNormalBuffer), V.bufferData(V.ARRAY_BUFFER, Mt, n);
        }
        if (Jt && nn && u) {
            for (f = 0, l = en.length; f < l; f++) {
                (c = en[f]), (b = nn[c]);
                if (b === undefined) continue;
                for (nt = 0; nt < 3; nt++) (st = b[nt]), (At[mt] = st.x), (At[mt + 1] = st.y), (mt += 2);
            }
            mt > 0 && (V.bindBuffer(V.ARRAY_BUFFER, e.__webglUVBuffer), V.bufferData(V.ARRAY_BUFFER, At, n));
        }
        if (Jt && rn && u) {
            for (f = 0, l = en.length; f < l; f++) {
                (c = en[f]), (w = rn[c]);
                if (w === undefined) continue;
                for (nt = 0; nt < 3; nt++) (ot = w[nt]), (Ot[gt] = ot.x), (Ot[gt + 1] = ot.y), (gt += 2);
            }
            gt > 0 && (V.bindBuffer(V.ARRAY_BUFFER, e.__webglUV2Buffer), V.bufferData(V.ARRAY_BUFFER, Ot, n));
        }
        if ($t) {
            for (f = 0, l = en.length; f < l; f++)
                (zt[yt] = dt), (zt[yt + 1] = dt + 1), (zt[yt + 2] = dt + 2), (yt += 3), (Wt[Et] = dt), (Wt[Et + 1] = dt + 1), (Wt[Et + 2] = dt), (Wt[Et + 3] = dt + 2), (Wt[Et + 4] = dt + 1), (Wt[Et + 5] = dt + 2), (Et += 6), (dt += 3);
            V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), V.bufferData(V.ELEMENT_ARRAY_BUFFER, zt, n), V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), V.bufferData(V.ELEMENT_ARRAY_BUFFER, Wt, n);
        }
        if (Rt)
            for (nt = 0, rt = Rt.length; nt < rt; nt++) {
                Ut = Rt[nt];
                if (!Ut.__original.needsUpdate) continue;
                (Nt = 0), (Ct = 0);
                if (Ut.size === 1) {
                    if (Ut.boundTo === undefined || Ut.boundTo === "vertices")
                        for (f = 0, l = en.length; f < l; f++) (h = tn[en[f]]), (Ut.array[Nt] = Ut.value[h.a]), (Ut.array[Nt + 1] = Ut.value[h.b]), (Ut.array[Nt + 2] = Ut.value[h.c]), (Nt += 3);
                    else if (Ut.boundTo === "faces") for (f = 0, l = en.length; f < l; f++) (kt = Ut.value[en[f]]), (Ut.array[Nt] = kt), (Ut.array[Nt + 1] = kt), (Ut.array[Nt + 2] = kt), (Nt += 3);
                } else if (Ut.size === 2) {
                    if (Ut.boundTo === undefined || Ut.boundTo === "vertices")
                        for (f = 0, l = en.length; f < l; f++)
                            (h = tn[en[f]]),
                                (E = Ut.value[h.a]),
                                (S = Ut.value[h.b]),
                                (x = Ut.value[h.c]),
                                (Ut.array[Nt] = E.x),
                                (Ut.array[Nt + 1] = E.y),
                                (Ut.array[Nt + 2] = S.x),
                                (Ut.array[Nt + 3] = S.y),
                                (Ut.array[Nt + 4] = x.x),
                                (Ut.array[Nt + 5] = x.y),
                                (Nt += 6);
                    else if (Ut.boundTo === "faces")
                        for (f = 0, l = en.length; f < l; f++)
                            (kt = Ut.value[en[f]]),
                                (E = kt),
                                (S = kt),
                                (x = kt),
                                (Ut.array[Nt] = E.x),
                                (Ut.array[Nt + 1] = E.y),
                                (Ut.array[Nt + 2] = S.x),
                                (Ut.array[Nt + 3] = S.y),
                                (Ut.array[Nt + 4] = x.x),
                                (Ut.array[Nt + 5] = x.y),
                                (Nt += 6);
                } else if (Ut.size === 3) {
                    var ln;
                    Ut.type === "c" ? (ln = ["r", "g", "b"]) : (ln = ["x", "y", "z"]);
                    if (Ut.boundTo === undefined || Ut.boundTo === "vertices")
                        for (f = 0, l = en.length; f < l; f++)
                            (h = tn[en[f]]),
                                (E = Ut.value[h.a]),
                                (S = Ut.value[h.b]),
                                (x = Ut.value[h.c]),
                                (Ut.array[Nt] = E[ln[0]]),
                                (Ut.array[Nt + 1] = E[ln[1]]),
                                (Ut.array[Nt + 2] = E[ln[2]]),
                                (Ut.array[Nt + 3] = S[ln[0]]),
                                (Ut.array[Nt + 4] = S[ln[1]]),
                                (Ut.array[Nt + 5] = S[ln[2]]),
                                (Ut.array[Nt + 6] = x[ln[0]]),
                                (Ut.array[Nt + 7] = x[ln[1]]),
                                (Ut.array[Nt + 8] = x[ln[2]]),
                                (Nt += 9);
                    else if (Ut.boundTo === "faces")
                        for (f = 0, l = en.length; f < l; f++)
                            (kt = Ut.value[en[f]]),
                                (E = kt),
                                (S = kt),
                                (x = kt),
                                (Ut.array[Nt] = E[ln[0]]),
                                (Ut.array[Nt + 1] = E[ln[1]]),
                                (Ut.array[Nt + 2] = E[ln[2]]),
                                (Ut.array[Nt + 3] = S[ln[0]]),
                                (Ut.array[Nt + 4] = S[ln[1]]),
                                (Ut.array[Nt + 5] = S[ln[2]]),
                                (Ut.array[Nt + 6] = x[ln[0]]),
                                (Ut.array[Nt + 7] = x[ln[1]]),
                                (Ut.array[Nt + 8] = x[ln[2]]),
                                (Nt += 9);
                    else if (Ut.boundTo === "faceVertices")
                        for (f = 0, l = en.length; f < l; f++)
                            (kt = Ut.value[en[f]]),
                                (E = kt[0]),
                                (S = kt[1]),
                                (x = kt[2]),
                                (Ut.array[Nt] = E[ln[0]]),
                                (Ut.array[Nt + 1] = E[ln[1]]),
                                (Ut.array[Nt + 2] = E[ln[2]]),
                                (Ut.array[Nt + 3] = S[ln[0]]),
                                (Ut.array[Nt + 4] = S[ln[1]]),
                                (Ut.array[Nt + 5] = S[ln[2]]),
                                (Ut.array[Nt + 6] = x[ln[0]]),
                                (Ut.array[Nt + 7] = x[ln[1]]),
                                (Ut.array[Nt + 8] = x[ln[2]]),
                                (Nt += 9);
                } else if (Ut.size === 4)
                    if (Ut.boundTo === undefined || Ut.boundTo === "vertices")
                        for (f = 0, l = en.length; f < l; f++)
                            (h = tn[en[f]]),
                                (E = Ut.value[h.a]),
                                (S = Ut.value[h.b]),
                                (x = Ut.value[h.c]),
                                (Ut.array[Nt] = E.x),
                                (Ut.array[Nt + 1] = E.y),
                                (Ut.array[Nt + 2] = E.z),
                                (Ut.array[Nt + 3] = E.w),
                                (Ut.array[Nt + 4] = S.x),
                                (Ut.array[Nt + 5] = S.y),
                                (Ut.array[Nt + 6] = S.z),
                                (Ut.array[Nt + 7] = S.w),
                                (Ut.array[Nt + 8] = x.x),
                                (Ut.array[Nt + 9] = x.y),
                                (Ut.array[Nt + 10] = x.z),
                                (Ut.array[Nt + 11] = x.w),
                                (Nt += 12);
                    else if (Ut.boundTo === "faces")
                        for (f = 0, l = en.length; f < l; f++)
                            (kt = Ut.value[en[f]]),
                                (E = kt),
                                (S = kt),
                                (x = kt),
                                (Ut.array[Nt] = E.x),
                                (Ut.array[Nt + 1] = E.y),
                                (Ut.array[Nt + 2] = E.z),
                                (Ut.array[Nt + 3] = E.w),
                                (Ut.array[Nt + 4] = S.x),
                                (Ut.array[Nt + 5] = S.y),
                                (Ut.array[Nt + 6] = S.z),
                                (Ut.array[Nt + 7] = S.w),
                                (Ut.array[Nt + 8] = x.x),
                                (Ut.array[Nt + 9] = x.y),
                                (Ut.array[Nt + 10] = x.z),
                                (Ut.array[Nt + 11] = x.w),
                                (Nt += 12);
                    else if (Ut.boundTo === "faceVertices")
                        for (f = 0, l = en.length; f < l; f++)
                            (kt = Ut.value[en[f]]),
                                (E = kt[0]),
                                (S = kt[1]),
                                (x = kt[2]),
                                (Ut.array[Nt] = E.x),
                                (Ut.array[Nt + 1] = E.y),
                                (Ut.array[Nt + 2] = E.z),
                                (Ut.array[Nt + 3] = E.w),
                                (Ut.array[Nt + 4] = S.x),
                                (Ut.array[Nt + 5] = S.y),
                                (Ut.array[Nt + 6] = S.z),
                                (Ut.array[Nt + 7] = S.w),
                                (Ut.array[Nt + 8] = x.x),
                                (Ut.array[Nt + 9] = x.y),
                                (Ut.array[Nt + 10] = x.z),
                                (Ut.array[Nt + 11] = x.w),
                                (Nt += 12);
                V.bindBuffer(V.ARRAY_BUFFER, Ut.buffer), V.bufferData(V.ARRAY_BUFFER, Ut.array, n);
            }
        r &&
        (delete e.__inittedArrays,
            delete e.__colorArray,
            delete e.__normalArray,
            delete e.__tangentArray,
            delete e.__uvArray,
            delete e.__uv2Array,
            delete e.__faceArray,
            delete e.__vertexArray,
            delete e.__lineArray,
            delete e.__skinIndexArray,
            delete e.__skinWeightArray);
    }
    function Xt(e, t, n) {
        var r = e.attributes,
            i,
            s;
        for (i in r)
            (s = r[i]),
            s.needsUpdate &&
            (i === "index" ? (V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, s.buffer), V.bufferData(V.ELEMENT_ARRAY_BUFFER, s.array, t)) : (V.bindBuffer(V.ARRAY_BUFFER, s.buffer), V.bufferData(V.ARRAY_BUFFER, s.array, t)),
                (s.needsUpdate = !1)),
            n && !s.dynamic && (s.array = null);
    }
    function Vt(e) {
        F[e] || (V.enableVertexAttribArray(e), (F[e] = !0));
    }
    function $t() {
        for (var e in F) F[e] && (V.disableVertexAttribArray(e), (F[e] = !1));
    }
    function Jt(e, t, n) {
        var r = e.program.attributes;
        n.morphTargetBase !== -1 && r.position >= 0
            ? (V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[n.morphTargetBase]), Vt(r.position), V.vertexAttribPointer(r.position, 3, V.FLOAT, !1, 0, 0))
            : r.position >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, t.__webglVertexBuffer), Vt(r.position), V.vertexAttribPointer(r.position, 3, V.FLOAT, !1, 0, 0));
        if (n.morphTargetForcedOrder.length) {
            var i = 0,
                s = n.morphTargetForcedOrder,
                o = n.morphTargetInfluences;
            while (i < e.numSupportedMorphTargets && i < s.length)
                r["morphTarget" + i] >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[s[i]]), Vt(r["morphTarget" + i]), V.vertexAttribPointer(r["morphTarget" + i], 3, V.FLOAT, !1, 0, 0)),
                r["morphNormal" + i] >= 0 && e.morphNormals && (V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphNormalsBuffers[s[i]]), Vt(r["morphNormal" + i]), V.vertexAttribPointer(r["morphNormal" + i], 3, V.FLOAT, !1, 0, 0)),
                    (n.__webglMorphTargetInfluences[i] = o[s[i]]),
                    i++;
        } else {
            var u,
                a = [],
                o = n.morphTargetInfluences,
                f,
                l = o.length;
            for (f = 0; f < l; f++) (u = o[f]), u > 0 && a.push([u, f]);
            a.length > e.numSupportedMorphTargets ? (a.sort(Qt), (a.length = e.numSupportedMorphTargets)) : a.length > e.numSupportedMorphNormals ? a.sort(Qt) : a.length === 0 && a.push([0, 0]);
            var c,
                i = 0;
            while (i < e.numSupportedMorphTargets)
                a[i]
                    ? ((c = a[i][1]),
                    r["morphTarget" + i] >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[c]), Vt(r["morphTarget" + i]), V.vertexAttribPointer(r["morphTarget" + i], 3, V.FLOAT, !1, 0, 0)),
                    r["morphNormal" + i] >= 0 && e.morphNormals && (V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphNormalsBuffers[c]), Vt(r["morphNormal" + i]), V.vertexAttribPointer(r["morphNormal" + i], 3, V.FLOAT, !1, 0, 0)),
                        (n.__webglMorphTargetInfluences[i] = o[c]))
                    : (n.__webglMorphTargetInfluences[i] = 0),
                    i++;
        }
        e.program.uniforms.morphTargetInfluences !== null && V.uniform1fv(e.program.uniforms.morphTargetInfluences, n.__webglMorphTargetInfluences);
    }
    function Kt(e, t) {
        return e.z !== t.z ? t.z - e.z : e.id - t.id;
    }
    function Qt(e, t) {
        return t[0] - e[0];
    }
    function Gt(e, t, n) {
        if (!e.length) return;
        for (var r = 0, i = e.length; r < i; r++)
            (p = null),
                (g = null),
                (S = -1),
                (C = -1),
                (k = -1),
                (w = -1),
                (E = -1),
                (m = -1),
                (v = -1),
                (W = !0),
                e[r].render(t, n, B, j),
                (p = null),
                (g = null),
                (S = -1),
                (C = -1),
                (k = -1),
                (w = -1),
                (E = -1),
                (m = -1),
                (v = -1),
                (W = !0);
    }
    function Yt(e, t, n, r, i, s, o, u) {
        var a, f, c, h, p, d, v;
        t ? ((p = e.length - 1), (d = -1), (v = -1)) : ((p = 0), (d = e.length), (v = 1));
        for (var m = p; m !== d; m += v) {
            a = e[m];
            if (a.render) {
                (f = a.object), (c = a.buffer);
                if (u) h = u;
                else {
                    h = a[n];
                    if (!h) continue;
                    o && l.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst), l.setDepthTest(h.depthTest), l.setDepthWrite(h.depthWrite), _n(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits);
                }
                l.setMaterialFaces(h), c instanceof THREE.BufferGeometry ? l.renderBufferDirect(r, i, s, h, c, f) : l.renderBuffer(r, i, s, h, c, f);
            }
        }
    }
    function Zt(e, t, n, r, i, s, o) {
        var u, a, f, c;
        for (var h = 0, p = e.length; h < p; h++) {
            (u = e[h]), (a = u.object);
            if (a.visible) {
                if (o) f = o;
                else {
                    f = u[t];
                    if (!f) continue;
                    s && l.setBlending(f.blending, f.blendEquation, f.blendSrc, f.blendDst), l.setDepthTest(f.depthTest), l.setDepthWrite(f.depthWrite), _n(f.polygonOffset, f.polygonOffsetFactor, f.polygonOffsetUnits);
                }
                l.renderImmediateObject(n, r, i, f, a);
            }
        }
    }
    function en(e) {
        var t = e.object,
            n = t.material;
        n.transparent ? ((e.transparent = n), (e.opaque = null)) : ((e.opaque = n), (e.transparent = null));
    }
    function tn(e) {
        var t = e.object,
            n = e.buffer,
            r,
            i,
            s;
        (s = t.material),
            s instanceof THREE.MeshFaceMaterial
                ? ((i = n.materialIndex), (r = s.materials[i]), r.transparent ? ((e.transparent = r), (e.opaque = null)) : ((e.opaque = r), (e.transparent = null)))
                : ((r = s), r && (r.transparent ? ((e.transparent = r), (e.opaque = null)) : ((e.opaque = r), (e.transparent = null))));
    }
    function nn(e, t) {
        var n,
            r,
            i,
            s,
            o,
            u,
            a = {},
            f = e.morphTargets.length,
            l = e.morphNormals.length,
            c = t instanceof THREE.MeshFaceMaterial;
        e.geometryGroups = {};
        for (n = 0, r = e.faces.length; n < r; n++)
            (i = e.faces[n]),
                (s = c ? i.materialIndex : 0),
            a[s] === undefined && (a[s] = { hash: s, counter: 0 }),
                (u = a[s].hash + "_" + a[s].counter),
            e.geometryGroups[u] === undefined && (e.geometryGroups[u] = { faces3: [], materialIndex: s, vertices: 0, numMorphTargets: f, numMorphNormals: l }),
                (o = 3),
            e.geometryGroups[u].vertices + o > 65535 &&
            ((a[s].counter += 1), (u = a[s].hash + "_" + a[s].counter), e.geometryGroups[u] === undefined && (e.geometryGroups[u] = { faces3: [], materialIndex: s, vertices: 0, numMorphTargets: f, numMorphNormals: l })),
                e.geometryGroups[u].faces3.push(n),
                (e.geometryGroups[u].vertices += o);
        e.geometryGroupsList = [];
        for (var h in e.geometryGroups) (e.geometryGroups[h].id = y++), e.geometryGroupsList.push(e.geometryGroups[h]);
    }
    function rn(e, t) {
        var n, r, i, s;
        if (e.__webglInit === undefined) {
            (e.__webglInit = !0),
                (e._modelViewMatrix = new THREE.Matrix4()),
                (e._normalMatrix = new THREE.Matrix3()),
            e.geometry !== undefined && e.geometry.__webglInit === undefined && ((e.geometry.__webglInit = !0), e.geometry.addEventListener("dispose", xt)),
                (r = e.geometry);
            if (r !== undefined)
                if (r instanceof THREE.BufferGeometry) Rt(r);
                else if (e instanceof THREE.Mesh) {
                    (i = e.material), r.geometryGroups === undefined && nn(r, i);
                    for (n in r.geometryGroups)
                        (s = r.geometryGroups[n]),
                        s.__webglVertexBuffer ||
                        (St(s),
                            Ht(s, e),
                            (r.verticesNeedUpdate = !0),
                            (r.morphTargetsNeedUpdate = !0),
                            (r.elementsNeedUpdate = !0),
                            (r.uvsNeedUpdate = !0),
                            (r.normalsNeedUpdate = !0),
                            (r.tangentsNeedUpdate = !0),
                            (r.colorsNeedUpdate = !0));
                } else
                    e instanceof THREE.Line
                        ? r.__webglVertexBuffer || (Et(r), Pt(r, e), (r.verticesNeedUpdate = !0), (r.colorsNeedUpdate = !0), (r.lineDistancesNeedUpdate = !0))
                        : e instanceof THREE.ParticleSystem && (r.__webglVertexBuffer || (wt(r), Dt(r, e), (r.verticesNeedUpdate = !0), (r.colorsNeedUpdate = !0)));
        }
        if (e.__webglActive === undefined) {
            if (e instanceof THREE.Mesh) {
                r = e.geometry;
                if (r instanceof THREE.BufferGeometry) sn(t.__webglObjects, r, e);
                else if (r instanceof THREE.Geometry) for (n in r.geometryGroups) (s = r.geometryGroups[n]), sn(t.__webglObjects, s, e);
            } else
                e instanceof THREE.Line || e instanceof THREE.ParticleSystem
                    ? ((r = e.geometry), sn(t.__webglObjects, r, e))
                    : e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback
                    ? on(t.__webglObjectsImmediate, e)
                    : e instanceof THREE.Sprite
                        ? t.__webglSprites.push(e)
                        : e instanceof THREE.LensFlare && t.__webglFlares.push(e);
            e.__webglActive = !0;
        }
    }
    function sn(e, t, n) {
        e.push({ id: null, buffer: t, object: n, opaque: null, transparent: null, z: 0 });
    }
    function on(e, t) {
        e.push({ id: null, object: t, opaque: null, transparent: null, z: 0 });
    }
    function un(e) {
        var t = e.geometry,
            n,
            r,
            i;
        if (t instanceof THREE.BufferGeometry) Xt(t, V.DYNAMIC_DRAW, !t.dynamic);
        else if (e instanceof THREE.Mesh) {
            for (var s = 0, o = t.geometryGroupsList.length; s < o; s++)
                (n = t.geometryGroupsList[s]),
                    (i = Bt(e, n)),
                t.buffersNeedUpdate && Ht(n, e),
                    (r = i.attributes && an(i)),
                (t.verticesNeedUpdate || t.morphTargetsNeedUpdate || t.elementsNeedUpdate || t.uvsNeedUpdate || t.normalsNeedUpdate || t.colorsNeedUpdate || t.tangentsNeedUpdate || r) && Wt(n, e, V.DYNAMIC_DRAW, !t.dynamic, i);
            (t.verticesNeedUpdate = !1),
                (t.morphTargetsNeedUpdate = !1),
                (t.elementsNeedUpdate = !1),
                (t.uvsNeedUpdate = !1),
                (t.normalsNeedUpdate = !1),
                (t.colorsNeedUpdate = !1),
                (t.tangentsNeedUpdate = !1),
                (t.buffersNeedUpdate = !1),
            i.attributes && fn(i);
        } else
            e instanceof THREE.Line
                ? ((i = Bt(e, t)),
                    (r = i.attributes && an(i)),
                (t.verticesNeedUpdate || t.colorsNeedUpdate || t.lineDistancesNeedUpdate || r) && zt(t, V.DYNAMIC_DRAW),
                    (t.verticesNeedUpdate = !1),
                    (t.colorsNeedUpdate = !1),
                    (t.lineDistancesNeedUpdate = !1),
                i.attributes && fn(i))
                : e instanceof THREE.ParticleSystem &&
                ((i = Bt(e, t)),
                    (r = i.attributes && an(i)),
                (t.verticesNeedUpdate || t.colorsNeedUpdate || e.sortParticles || r) && Ut(t, V.DYNAMIC_DRAW, e),
                    (t.verticesNeedUpdate = !1),
                    (t.colorsNeedUpdate = !1),
                i.attributes && fn(i));
    }
    function an(e) {
        for (var t in e.attributes) if (e.attributes[t].needsUpdate) return !0;
        return !1;
    }
    function fn(e) {
        for (var t in e.attributes) e.attributes[t].needsUpdate = !1;
    }
    function ln(e, t) {
        e instanceof THREE.Mesh || e instanceof THREE.ParticleSystem || e instanceof THREE.Line
            ? cn(t.__webglObjects, e)
            : e instanceof THREE.Sprite
            ? hn(t.__webglSprites, e)
            : e instanceof THREE.LensFlare
                ? hn(t.__webglFlares, e)
                : (e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback) && cn(t.__webglObjectsImmediate, e),
            delete e.__webglActive;
    }
    function cn(e, t) {
        for (var n = e.length - 1; n >= 0; n--) e[n].object === t && e.splice(n, 1);
    }
    function hn(e, t) {
        for (var n = e.length - 1; n >= 0; n--) e[n] === t && e.splice(n, 1);
    }
    function pn(e, t) {
        (e.uniforms = THREE.UniformsUtils.clone(t.uniforms)), (e.vertexShader = t.vertexShader), (e.fragmentShader = t.fragmentShader);
    }
    function dn(e, t, n, r, i) {
        (b = 0), r.needsUpdate && (r.program && Mt(r), l.initMaterial(r, t, n, i), (r.needsUpdate = !1)), r.morphTargets && (i.__webglMorphTargetInfluences || (i.__webglMorphTargetInfluences = new Float32Array(l.maxMorphTargets)));
        var s = !1,
            o = r.program,
            u = o.uniforms,
            a = r.uniforms;
        o !== p && (V.useProgram(o), (p = o), (s = !0)), r.id !== v && ((v = r.id), (s = !0));
        if (s || e !== g) V.uniformMatrix4fv(u.projectionMatrix, !1, e.projectionMatrix.elements), e !== g && (g = e);
        if (r.skinning)
            if (it && i.useVertexTexture) {
                if (u.boneTexture !== null) {
                    var f = Nn();
                    V.uniform1i(u.boneTexture, f), l.setTexture(i.boneTexture, f);
                }
                u.boneTextureWidth !== null && V.uniform1i(u.boneTextureWidth, i.boneTextureWidth), u.boneTextureHeight !== null && V.uniform1i(u.boneTextureHeight, i.boneTextureHeight);
            } else u.boneGlobalMatrices !== null && V.uniformMatrix4fv(u.boneGlobalMatrices, !1, i.boneMatrices);
        if (s) {
            n && r.fog && bn(a, n);
            if (r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r.lights) W && (On(o, t), (W = !1)), Sn(a, X);
            (r instanceof THREE.MeshBasicMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.MeshPhongMaterial) && vn(a, r),
                r instanceof THREE.LineBasicMaterial
                    ? mn(a, r)
                    : r instanceof THREE.LineDashedMaterial
                    ? (mn(a, r), gn(a, r))
                    : r instanceof THREE.ParticleBasicMaterial
                        ? yn(a, r)
                        : r instanceof THREE.MeshPhongMaterial
                            ? wn(a, r)
                            : r instanceof THREE.MeshLambertMaterial
                                ? En(a, r)
                                : r instanceof THREE.MeshDepthMaterial
                                    ? ((a.mNear.value = e.near), (a.mFar.value = e.far), (a.opacity.value = r.opacity))
                                    : r instanceof THREE.MeshNormalMaterial && (a.opacity.value = r.opacity),
            i.receiveShadow && !r._shadowPass && xn(a, t),
                Cn(o, r.uniformsList),
            (r instanceof THREE.ShaderMaterial || r instanceof THREE.MeshPhongMaterial || r.envMap) && u.cameraPosition !== null && (U.getPositionFromMatrix(e.matrixWorld), V.uniform3f(u.cameraPosition, U.x, U.y, U.z)),
            (r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.ShaderMaterial || r.skinning) &&
            u.viewMatrix !== null &&
            V.uniformMatrix4fv(u.viewMatrix, !1, e.matrixWorldInverse.elements);
        }
        return Tn(u, i), u.modelMatrix !== null && V.uniformMatrix4fv(u.modelMatrix, !1, i.matrixWorld.elements), o;
    }
    function vn(e, t) {
        (e.opacity.value = t.opacity),
            l.gammaInput ? e.diffuse.value.copyGammaToLinear(t.color) : (e.diffuse.value = t.color),
            (e.map.value = t.map),
            (e.lightMap.value = t.lightMap),
            (e.specularMap.value = t.specularMap),
        t.bumpMap && ((e.bumpMap.value = t.bumpMap), (e.bumpScale.value = t.bumpScale)),
        t.normalMap && ((e.normalMap.value = t.normalMap), e.normalScale.value.copy(t.normalScale));
        var n;
        t.map ? (n = t.map) : t.specularMap ? (n = t.specularMap) : t.normalMap ? (n = t.normalMap) : t.bumpMap && (n = t.bumpMap);
        if (n !== undefined) {
            var r = n.offset,
                i = n.repeat;
            e.offsetRepeat.value.set(r.x, r.y, i.x, i.y);
        }
        (e.envMap.value = t.envMap),
            (e.flipEnvMap.value = t.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1),
            l.gammaInput ? (e.reflectivity.value = t.reflectivity) : (e.reflectivity.value = t.reflectivity),
            (e.refractionRatio.value = t.refractionRatio),
            (e.combine.value = t.combine),
            (e.useRefract.value = t.envMap && t.envMap.mapping instanceof THREE.CubeRefractionMapping);
    }
    function mn(e, t) {
        (e.diffuse.value = t.color), (e.opacity.value = t.opacity);
    }
    function gn(e, t) {
        (e.dashSize.value = t.dashSize), (e.totalSize.value = t.dashSize + t.gapSize), (e.scale.value = t.scale);
    }
    function yn(e, n) {
        (e.psColor.value = n.color), (e.opacity.value = n.opacity), (e.size.value = n.size), (e.scale.value = t.height / 2), (e.map.value = n.map);
    }
    function bn(e, t) {
        (e.fogColor.value = t.color), t instanceof THREE.Fog ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far)) : t instanceof THREE.FogExp2 && (e.fogDensity.value = t.density);
    }
    function wn(e, t) {
        (e.shininess.value = t.shininess),
            l.gammaInput
                ? (e.ambient.value.copyGammaToLinear(t.ambient), e.emissive.value.copyGammaToLinear(t.emissive), e.specular.value.copyGammaToLinear(t.specular))
                : ((e.ambient.value = t.ambient), (e.emissive.value = t.emissive), (e.specular.value = t.specular)),
        t.wrapAround && e.wrapRGB.value.copy(t.wrapRGB);
    }
    function En(e, t) {
        l.gammaInput ? (e.ambient.value.copyGammaToLinear(t.ambient), e.emissive.value.copyGammaToLinear(t.emissive)) : ((e.ambient.value = t.ambient), (e.emissive.value = t.emissive)), t.wrapAround && e.wrapRGB.value.copy(t.wrapRGB);
    }
    function Sn(e, t) {
        (e.ambientLightColor.value = t.ambient),
            (e.directionalLightColor.value = t.directional.colors),
            (e.directionalLightDirection.value = t.directional.positions),
            (e.pointLightColor.value = t.point.colors),
            (e.pointLightPosition.value = t.point.positions),
            (e.pointLightDistance.value = t.point.distances),
            (e.spotLightColor.value = t.spot.colors),
            (e.spotLightPosition.value = t.spot.positions),
            (e.spotLightDistance.value = t.spot.distances),
            (e.spotLightDirection.value = t.spot.directions),
            (e.spotLightAngleCos.value = t.spot.anglesCos),
            (e.spotLightExponent.value = t.spot.exponents),
            (e.hemisphereLightSkyColor.value = t.hemi.skyColors),
            (e.hemisphereLightGroundColor.value = t.hemi.groundColors),
            (e.hemisphereLightDirection.value = t.hemi.positions);
    }
    function xn(e, t) {
        if (e.shadowMatrix) {
            var n = 0;
            for (var r = 0, i = t.length; r < i; r++) {
                var s = t[r];
                if (!s.castShadow) continue;
                if (s instanceof THREE.SpotLight || (s instanceof THREE.DirectionalLight && !s.shadowCascade))
                    (e.shadowMap.value[n] = s.shadowMap),
                        (e.shadowMapSize.value[n] = s.shadowMapSize),
                        (e.shadowMatrix.value[n] = s.shadowMatrix),
                        (e.shadowDarkness.value[n] = s.shadowDarkness),
                        (e.shadowBias.value[n] = s.shadowBias),
                        n++;
            }
        }
    }
    function Tn(e, t) {
        V.uniformMatrix4fv(e.modelViewMatrix, !1, t._modelViewMatrix.elements), e.normalMatrix && V.uniformMatrix3fv(e.normalMatrix, !1, t._normalMatrix.elements);
    }
    function Nn() {
        var e = b;
        return e >= Y && console.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + Y), (b += 1), e;
    }
    function Cn(e, t) {
        var n, r, i, s, o, u, a, f, c, h, p;
        for (c = 0, h = t.length; c < h; c++) {
            s = e.uniforms[t[c][1]];
            if (!s) continue;
            (n = t[c][0]), (i = n.type), (r = n.value);
            if (i === "i") V.uniform1i(s, r);
            else if (i === "f") V.uniform1f(s, r);
            else if (i === "v2") V.uniform2f(s, r.x, r.y);
            else if (i === "v3") V.uniform3f(s, r.x, r.y, r.z);
            else if (i === "v4") V.uniform4f(s, r.x, r.y, r.z, r.w);
            else if (i === "c") V.uniform3f(s, r.r, r.g, r.b);
            else if (i === "iv1") V.uniform1iv(s, r);
            else if (i === "iv") V.uniform3iv(s, r);
            else if (i === "fv1") V.uniform1fv(s, r);
            else if (i === "fv") V.uniform3fv(s, r);
            else if (i === "v2v") {
                n._array === undefined && (n._array = new Float32Array(2 * r.length));
                for (a = 0, f = r.length; a < f; a++) (p = a * 2), (n._array[p] = r[a].x), (n._array[p + 1] = r[a].y);
                V.uniform2fv(s, n._array);
            } else if (i === "v3v") {
                n._array === undefined && (n._array = new Float32Array(3 * r.length));
                for (a = 0, f = r.length; a < f; a++) (p = a * 3), (n._array[p] = r[a].x), (n._array[p + 1] = r[a].y), (n._array[p + 2] = r[a].z);
                V.uniform3fv(s, n._array);
            } else if (i === "v4v") {
                n._array === undefined && (n._array = new Float32Array(4 * r.length));
                for (a = 0, f = r.length; a < f; a++) (p = a * 4), (n._array[p] = r[a].x), (n._array[p + 1] = r[a].y), (n._array[p + 2] = r[a].z), (n._array[p + 3] = r[a].w);
                V.uniform4fv(s, n._array);
            } else if (i === "m4") n._array === undefined && (n._array = new Float32Array(16)), r.flattenToArray(n._array), V.uniformMatrix4fv(s, !1, n._array);
            else if (i === "m4v") {
                n._array === undefined && (n._array = new Float32Array(16 * r.length));
                for (a = 0, f = r.length; a < f; a++) r[a].flattenToArrayOffset(n._array, a * 16);
                V.uniformMatrix4fv(s, !1, n._array);
            } else if (i === "t") {
                (o = r), (u = Nn()), V.uniform1i(s, u);
                if (!o) continue;
                o.image instanceof Array && o.image.length === 6 ? Un(o, u) : o instanceof THREE.WebGLRenderTargetCube ? zn(o, u) : l.setTexture(o, u);
            } else if (i === "tv") {
                n._array === undefined && (n._array = []);
                for (a = 0, f = n.value.length; a < f; a++) n._array[a] = Nn();
                V.uniform1iv(s, n._array);
                for (a = 0, f = n.value.length; a < f; a++) {
                    (o = n.value[a]), (u = n._array[a]);
                    if (!o) continue;
                    l.setTexture(o, u);
                }
            } else console.warn("THREE.WebGLRenderer: Unknown uniform type: " + i);
        }
    }
    function kn(e, t) {
        e._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, e.matrixWorld), e._normalMatrix.getNormalMatrix(e._modelViewMatrix);
    }
    function Ln(e, t, n, r) {
        (e[t] = n.r * n.r * r), (e[t + 1] = n.g * n.g * r), (e[t + 2] = n.b * n.b * r);
    }
    function An(e, t, n, r) {
        (e[t] = n.r * r), (e[t + 1] = n.g * r), (e[t + 2] = n.b * r);
    }
    function On(e, t) {
        var n,
            r,
            i,
            s,
            o = 0,
            u = 0,
            a = 0,
            f,
            c,
            h,
            p,
            d,
            v,
            m,
            g = X,
            y = g.directional.colors,
            b = g.directional.positions,
            w = g.point.colors,
            E = g.point.positions,
            S = g.point.distances,
            x = g.spot.colors,
            T = g.spot.positions,
            N = g.spot.distances,
            C = g.spot.directions,
            k = g.spot.anglesCos,
            L = g.spot.exponents,
            A = g.hemi.skyColors,
            O = g.hemi.groundColors,
            M = g.hemi.positions,
            _ = 0,
            D = 0,
            P = 0,
            H = 0,
            B = 0,
            j = 0,
            F = 0,
            I = 0,
            q = 0,
            R = 0,
            W = 0,
            V = 0;
        for (n = 0, r = t.length; n < r; n++) {
            i = t[n];
            if (i.onlyShadow) continue;
            (f = i.color), (p = i.intensity), (m = i.distance);
            if (i instanceof THREE.AmbientLight) {
                if (!i.visible) continue;
                l.gammaInput ? ((o += f.r * f.r), (u += f.g * f.g), (a += f.b * f.b)) : ((o += f.r), (u += f.g), (a += f.b));
            } else if (i instanceof THREE.DirectionalLight) {
                B += 1;
                if (!i.visible) continue;
                z.getPositionFromMatrix(i.matrixWorld), U.getPositionFromMatrix(i.target.matrixWorld), z.sub(U), z.normalize();
                if (z.x === 0 && z.y === 0 && z.z === 0) continue;
                (q = _ * 3), (b[q] = z.x), (b[q + 1] = z.y), (b[q + 2] = z.z), l.gammaInput ? Ln(y, q, f, p * p) : An(y, q, f, p), (_ += 1);
            } else if (i instanceof THREE.PointLight) {
                j += 1;
                if (!i.visible) continue;
                (R = D * 3), l.gammaInput ? Ln(w, R, f, p * p) : An(w, R, f, p), U.getPositionFromMatrix(i.matrixWorld), (E[R] = U.x), (E[R + 1] = U.y), (E[R + 2] = U.z), (S[D] = m), (D += 1);
            } else if (i instanceof THREE.SpotLight) {
                F += 1;
                if (!i.visible) continue;
                (W = P * 3),
                    l.gammaInput ? Ln(x, W, f, p * p) : An(x, W, f, p),
                    U.getPositionFromMatrix(i.matrixWorld),
                    (T[W] = U.x),
                    (T[W + 1] = U.y),
                    (T[W + 2] = U.z),
                    (N[P] = m),
                    z.copy(U),
                    U.getPositionFromMatrix(i.target.matrixWorld),
                    z.sub(U),
                    z.normalize(),
                    (C[W] = z.x),
                    (C[W + 1] = z.y),
                    (C[W + 2] = z.z),
                    (k[P] = Math.cos(i.angle)),
                    (L[P] = i.exponent),
                    (P += 1);
            } else if (i instanceof THREE.HemisphereLight) {
                I += 1;
                if (!i.visible) continue;
                z.getPositionFromMatrix(i.matrixWorld), z.normalize();
                if (z.x === 0 && z.y === 0 && z.z === 0) continue;
                (V = H * 3), (M[V] = z.x), (M[V + 1] = z.y), (M[V + 2] = z.z), (c = i.color), (h = i.groundColor), l.gammaInput ? ((d = p * p), Ln(A, V, c, d), Ln(O, V, h, d)) : (An(A, V, c, p), An(O, V, h, p)), (H += 1);
            }
        }
        for (n = _ * 3, r = Math.max(y.length, B * 3); n < r; n++) y[n] = 0;
        for (n = D * 3, r = Math.max(w.length, j * 3); n < r; n++) w[n] = 0;
        for (n = P * 3, r = Math.max(x.length, F * 3); n < r; n++) x[n] = 0;
        for (n = H * 3, r = Math.max(A.length, I * 3); n < r; n++) A[n] = 0;
        for (n = H * 3, r = Math.max(O.length, I * 3); n < r; n++) O[n] = 0;
        (g.directional.length = _), (g.point.length = D), (g.spot.length = P), (g.hemi.length = H), (g.ambient[0] = o), (g.ambient[1] = u), (g.ambient[2] = a);
    }
    function Mn(e) {
        e !== M && (V.lineWidth(e), (M = e));
    }
    function _n(e, t, n) {
        L !== e && (e ? V.enable(V.POLYGON_OFFSET_FILL) : V.disable(V.POLYGON_OFFSET_FILL), (L = e)), e && (A !== t || O !== n) && (V.polygonOffset(t, n), (A = t), (O = n));
    }
    function Dn(e) {
        var t,
            n,
            r = [];
        for (var i in e) {
            t = e[i];
            if (t === !1) continue;
            (n = "#define " + i + " " + t), r.push(n);
        }
        return r.join("\n");
    }
    function Pn(e, t, r, i, s, o, u, a) {
        var f,
            p,
            d,
            v,
            m,
            g = [];
        e ? g.push(e) : (g.push(t), g.push(r));
        for (d in o) g.push(d), g.push(o[d]);
        for (f in u) g.push(f), g.push(u[f]);
        m = g.join();
        for (f = 0, p = c.length; f < p; f++) {
            var y = c[f];
            if (y.code === m) return y.usedTimes++, y.program;
        }
        var b = "SHADOWMAP_TYPE_BASIC";
        u.shadowMapType === THREE.PCFShadowMap ? (b = "SHADOWMAP_TYPE_PCF") : u.shadowMapType === THREE.PCFSoftShadowMap && (b = "SHADOWMAP_TYPE_PCF_SOFT");
        var w = Dn(o);
        v = V.createProgram();
        var E = [
                "precision " + n + " float;",
                "precision " + n + " int;",
                w,
                rt ? "#define VERTEX_TEXTURES" : "",
                l.gammaInput ? "#define GAMMA_INPUT" : "",
                l.gammaOutput ? "#define GAMMA_OUTPUT" : "",
                l.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",
                "#define MAX_DIR_LIGHTS " + u.maxDirLights,
                "#define MAX_POINT_LIGHTS " + u.maxPointLights,
                "#define MAX_SPOT_LIGHTS " + u.maxSpotLights,
                "#define MAX_HEMI_LIGHTS " + u.maxHemiLights,
                "#define MAX_SHADOWS " + u.maxShadows,
                "#define MAX_BONES " + u.maxBones,
                u.map ? "#define USE_MAP" : "",
                u.envMap ? "#define USE_ENVMAP" : "",
                u.lightMap ? "#define USE_LIGHTMAP" : "",
                u.bumpMap ? "#define USE_BUMPMAP" : "",
                u.normalMap ? "#define USE_NORMALMAP" : "",
                u.specularMap ? "#define USE_SPECULARMAP" : "",
                u.vertexColors ? "#define USE_COLOR" : "",
                u.skinning ? "#define USE_SKINNING" : "",
                u.useVertexTexture ? "#define BONE_TEXTURE" : "",
                u.morphTargets ? "#define USE_MORPHTARGETS" : "",
                u.morphNormals ? "#define USE_MORPHNORMALS" : "",
                u.perPixel ? "#define PHONG_PER_PIXEL" : "",
                u.wrapAround ? "#define WRAP_AROUND" : "",
                u.doubleSided ? "#define DOUBLE_SIDED" : "",
                u.flipSided ? "#define FLIP_SIDED" : "",
                u.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                u.shadowMapEnabled ? "#define " + b : "",
                u.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
                u.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",
                u.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                "uniform mat4 modelMatrix;",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;",
                "uniform vec3 cameraPosition;",
                "attribute vec3 position;",
                "attribute vec3 normal;",
                "attribute vec2 uv;",
                "attribute vec2 uv2;",
                "#ifdef USE_COLOR",
                "attribute vec3 color;",
                "#endif",
                "#ifdef USE_MORPHTARGETS",
                "attribute vec3 morphTarget0;",
                "attribute vec3 morphTarget1;",
                "attribute vec3 morphTarget2;",
                "attribute vec3 morphTarget3;",
                "#ifdef USE_MORPHNORMALS",
                "attribute vec3 morphNormal0;",
                "attribute vec3 morphNormal1;",
                "attribute vec3 morphNormal2;",
                "attribute vec3 morphNormal3;",
                "#else",
                "attribute vec3 morphTarget4;",
                "attribute vec3 morphTarget5;",
                "attribute vec3 morphTarget6;",
                "attribute vec3 morphTarget7;",
                "#endif",
                "#endif",
                "#ifdef USE_SKINNING",
                "attribute vec4 skinIndex;",
                "attribute vec4 skinWeight;",
                "#endif",
                "",
            ].join("\n"),
            S = [
                "precision " + n + " float;",
                "precision " + n + " int;",
                u.bumpMap || u.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "",
                w,
                "#define MAX_DIR_LIGHTS " + u.maxDirLights,
                "#define MAX_POINT_LIGHTS " + u.maxPointLights,
                "#define MAX_SPOT_LIGHTS " + u.maxSpotLights,
                "#define MAX_HEMI_LIGHTS " + u.maxHemiLights,
                "#define MAX_SHADOWS " + u.maxShadows,
                u.alphaTest ? "#define ALPHATEST " + u.alphaTest : "",
                l.gammaInput ? "#define GAMMA_INPUT" : "",
                l.gammaOutput ? "#define GAMMA_OUTPUT" : "",
                l.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",
                u.useFog && u.fog ? "#define USE_FOG" : "",
                u.useFog && u.fogExp ? "#define FOG_EXP2" : "",
                u.map ? "#define USE_MAP" : "",
                u.envMap ? "#define USE_ENVMAP" : "",
                u.lightMap ? "#define USE_LIGHTMAP" : "",
                u.bumpMap ? "#define USE_BUMPMAP" : "",
                u.normalMap ? "#define USE_NORMALMAP" : "",
                u.specularMap ? "#define USE_SPECULARMAP" : "",
                u.vertexColors ? "#define USE_COLOR" : "",
                u.metal ? "#define METAL" : "",
                u.perPixel ? "#define PHONG_PER_PIXEL" : "",
                u.wrapAround ? "#define WRAP_AROUND" : "",
                u.doubleSided ? "#define DOUBLE_SIDED" : "",
                u.flipSided ? "#define FLIP_SIDED" : "",
                u.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                u.shadowMapEnabled ? "#define " + b : "",
                u.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
                u.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",
                "uniform mat4 viewMatrix;",
                "uniform vec3 cameraPosition;",
                "",
            ].join("\n"),
            x = Fn("vertex", E + r),
            T = Fn("fragment", S + t);
        V.attachShader(v, x),
            V.attachShader(v, T),
        a && V.bindAttribLocation(v, 0, a),
            V.linkProgram(v),
        V.getProgramParameter(v, V.LINK_STATUS) ||
        (console.error("Could not initialise shader\nVALIDATE_STATUS: " + V.getProgramParameter(v, V.VALIDATE_STATUS) + ", gl error [" + V.getError() + "]"), console.error("Program Info Log: " + V.getProgramInfoLog(v))),
            V.deleteShader(T),
            V.deleteShader(x),
            (v.uniforms = {}),
            (v.attributes = {});
        var N, C, k, L;
        (N = ["viewMatrix", "modelViewMatrix", "projectionMatrix", "normalMatrix", "modelMatrix", "cameraPosition", "morphTargetInfluences"]),
            u.useVertexTexture ? (N.push("boneTexture"), N.push("boneTextureWidth"), N.push("boneTextureHeight")) : N.push("boneGlobalMatrices");
        for (C in i) N.push(C);
        Hn(v, N), (N = ["position", "normal", "uv", "uv2", "tangent", "color", "skinIndex", "skinWeight", "lineDistance"]);
        for (L = 0; L < u.maxMorphTargets; L++) N.push("morphTarget" + L);
        for (L = 0; L < u.maxMorphNormals; L++) N.push("morphNormal" + L);
        for (k in s) N.push(k);
        return Bn(v, N), (v.id = h++), c.push({ program: v, code: m, usedTimes: 1 }), (l.info.memory.programs = c.length), v;
    }
    function Hn(e, t) {
        var n, r, i;
        for (n = 0, r = t.length; n < r; n++) (i = t[n]), (e.uniforms[i] = V.getUniformLocation(e, i));
    }
    function Bn(e, t) {
        var n, r, i;
        for (n = 0, r = t.length; n < r; n++) (i = t[n]), (e.attributes[i] = V.getAttribLocation(e, i));
    }
    function jn(e) {
        var t = e.split("\n");
        for (var n = 0, r = t.length; n < r; n++) t[n] = n + 1 + ": " + t[n];
        return t.join("\n");
    }
    function Fn(e, t) {
        var n;
        return (
            e === "fragment" ? (n = V.createShader(V.FRAGMENT_SHADER)) : e === "vertex" && (n = V.createShader(V.VERTEX_SHADER)),
                V.shaderSource(n, t),
                V.compileShader(n),
                V.getShaderParameter(n, V.COMPILE_STATUS) ? n : (console.error(V.getShaderInfoLog(n)), console.error(jn(t)), null)
        );
    }
    function In(e) {
        return (e & (e - 1)) === 0;
    }
    function qn(e, t, n) {
        n
            ? (V.texParameteri(e, V.TEXTURE_WRAP_S, Jn(t.wrapS)), V.texParameteri(e, V.TEXTURE_WRAP_T, Jn(t.wrapT)), V.texParameteri(e, V.TEXTURE_MAG_FILTER, Jn(t.magFilter)), V.texParameteri(e, V.TEXTURE_MIN_FILTER, Jn(t.minFilter)))
            : (V.texParameteri(e, V.TEXTURE_WRAP_S, V.CLAMP_TO_EDGE),
                V.texParameteri(e, V.TEXTURE_WRAP_T, V.CLAMP_TO_EDGE),
                V.texParameteri(e, V.TEXTURE_MAG_FILTER, $n(t.magFilter)),
                V.texParameteri(e, V.TEXTURE_MIN_FILTER, $n(t.minFilter))),
        Q && t.type !== THREE.FloatType && (t.anisotropy > 1 || t.__oldAnisotropy) && (V.texParameterf(e, Q.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, nt)), (t.__oldAnisotropy = t.anisotropy));
    }
    function Rn(e, t) {
        if (e.width <= t && e.height <= t) return e;
        var n = Math.max(e.width, e.height),
            r = Math.floor((e.width * t) / n),
            i = Math.floor((e.height * t) / n),
            s = document.createElement("canvas");
        (s.width = r), (s.height = i);
        var o = s.getContext("2d");
        return o.drawImage(e, 0, 0, e.width, e.height, 0, 0, r, i), s;
    }
    function Un(e, t) {
        if (e.image.length === 6)
            if (e.needsUpdate) {
                e.image.__webglTextureCube || (e.addEventListener("dispose", Tt), (e.image.__webglTextureCube = V.createTexture()), l.info.memory.textures++),
                    V.activeTexture(V.TEXTURE0 + t),
                    V.bindTexture(V.TEXTURE_CUBE_MAP, e.image.__webglTextureCube),
                    V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, e.flipY);
                var n = e instanceof THREE.CompressedTexture,
                    r = [];
                for (var i = 0; i < 6; i++) l.autoScaleCubemaps && !n ? (r[i] = Rn(e.image[i], tt)) : (r[i] = e.image[i]);
                var s = r[0],
                    o = In(s.width) && In(s.height),
                    u = Jn(e.format),
                    a = Jn(e.type);
                qn(V.TEXTURE_CUBE_MAP, e, o);
                for (var i = 0; i < 6; i++)
                    if (!n) V.texImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, u, u, a, r[i]);
                    else {
                        var f,
                            c = r[i].mipmaps;
                        for (var h = 0, p = c.length; h < p; h++)
                            (f = c[h]),
                                e.format !== THREE.RGBAFormat
                                    ? V.compressedTexImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + i, h, u, f.width, f.height, 0, f.data)
                                    : V.texImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + i, h, u, f.width, f.height, 0, u, a, f.data);
                    }
                e.generateMipmaps && o && V.generateMipmap(V.TEXTURE_CUBE_MAP), (e.needsUpdate = !1), e.onUpdate && e.onUpdate();
            } else V.activeTexture(V.TEXTURE0 + t), V.bindTexture(V.TEXTURE_CUBE_MAP, e.image.__webglTextureCube);
    }
    function zn(e, t) {
        V.activeTexture(V.TEXTURE0 + t), V.bindTexture(V.TEXTURE_CUBE_MAP, e.__webglTexture);
    }
    function Wn(e, t, n) {
        V.bindFramebuffer(V.FRAMEBUFFER, e), V.framebufferTexture2D(V.FRAMEBUFFER, V.COLOR_ATTACHMENT0, n, t.__webglTexture, 0);
    }
    function Xn(e, t) {
        V.bindRenderbuffer(V.RENDERBUFFER, e),
            t.depthBuffer && !t.stencilBuffer
                ? (V.renderbufferStorage(V.RENDERBUFFER, V.DEPTH_COMPONENT16, t.width, t.height), V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_ATTACHMENT, V.RENDERBUFFER, e))
                : t.depthBuffer && t.stencilBuffer
                ? (V.renderbufferStorage(V.RENDERBUFFER, V.DEPTH_STENCIL, t.width, t.height), V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_STENCIL_ATTACHMENT, V.RENDERBUFFER, e))
                : V.renderbufferStorage(V.RENDERBUFFER, V.RGBA4, t.width, t.height);
    }
    function Vn(e) {
        e instanceof THREE.WebGLRenderTargetCube
            ? (V.bindTexture(V.TEXTURE_CUBE_MAP, e.__webglTexture), V.generateMipmap(V.TEXTURE_CUBE_MAP), V.bindTexture(V.TEXTURE_CUBE_MAP, null))
            : (V.bindTexture(V.TEXTURE_2D, e.__webglTexture), V.generateMipmap(V.TEXTURE_2D), V.bindTexture(V.TEXTURE_2D, null));
    }
    function $n(e) {
        return e === THREE.NearestFilter || e === THREE.NearestMipMapNearestFilter || e === THREE.NearestMipMapLinearFilter ? V.NEAREST : V.LINEAR;
    }
    function Jn(e) {
        if (e === THREE.RepeatWrapping) return V.REPEAT;
        if (e === THREE.ClampToEdgeWrapping) return V.CLAMP_TO_EDGE;
        if (e === THREE.MirroredRepeatWrapping) return V.MIRRORED_REPEAT;
        if (e === THREE.NearestFilter) return V.NEAREST;
        if (e === THREE.NearestMipMapNearestFilter) return V.NEAREST_MIPMAP_NEAREST;
        if (e === THREE.NearestMipMapLinearFilter) return V.NEAREST_MIPMAP_LINEAR;
        if (e === THREE.LinearFilter) return V.LINEAR;
        if (e === THREE.LinearMipMapNearestFilter) return V.LINEAR_MIPMAP_NEAREST;
        if (e === THREE.LinearMipMapLinearFilter) return V.LINEAR_MIPMAP_LINEAR;
        if (e === THREE.UnsignedByteType) return V.UNSIGNED_BYTE;
        if (e === THREE.UnsignedShort4444Type) return V.UNSIGNED_SHORT_4_4_4_4;
        if (e === THREE.UnsignedShort5551Type) return V.UNSIGNED_SHORT_5_5_5_1;
        if (e === THREE.UnsignedShort565Type) return V.UNSIGNED_SHORT_5_6_5;
        if (e === THREE.ByteType) return V.BYTE;
        if (e === THREE.ShortType) return V.SHORT;
        if (e === THREE.UnsignedShortType) return V.UNSIGNED_SHORT;
        if (e === THREE.IntType) return V.INT;
        if (e === THREE.UnsignedIntType) return V.UNSIGNED_INT;
        if (e === THREE.FloatType) return V.FLOAT;
        if (e === THREE.AlphaFormat) return V.ALPHA;
        if (e === THREE.RGBFormat) return V.RGB;
        if (e === THREE.RGBAFormat) return V.RGBA;
        if (e === THREE.LuminanceFormat) return V.LUMINANCE;
        if (e === THREE.LuminanceAlphaFormat) return V.LUMINANCE_ALPHA;
        if (e === THREE.AddEquation) return V.FUNC_ADD;
        if (e === THREE.SubtractEquation) return V.FUNC_SUBTRACT;
        if (e === THREE.ReverseSubtractEquation) return V.FUNC_REVERSE_SUBTRACT;
        if (e === THREE.ZeroFactor) return V.ZERO;
        if (e === THREE.OneFactor) return V.ONE;
        if (e === THREE.SrcColorFactor) return V.SRC_COLOR;
        if (e === THREE.OneMinusSrcColorFactor) return V.ONE_MINUS_SRC_COLOR;
        if (e === THREE.SrcAlphaFactor) return V.SRC_ALPHA;
        if (e === THREE.OneMinusSrcAlphaFactor) return V.ONE_MINUS_SRC_ALPHA;
        if (e === THREE.DstAlphaFactor) return V.DST_ALPHA;
        if (e === THREE.OneMinusDstAlphaFactor) return V.ONE_MINUS_DST_ALPHA;
        if (e === THREE.DstColorFactor) return V.DST_COLOR;
        if (e === THREE.OneMinusDstColorFactor) return V.ONE_MINUS_DST_COLOR;
        if (e === THREE.SrcAlphaSaturateFactor) return V.SRC_ALPHA_SATURATE;
        if (G !== undefined) {
            if (e === THREE.RGB_S3TC_DXT1_Format) return G.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (e === THREE.RGBA_S3TC_DXT1_Format) return G.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (e === THREE.RGBA_S3TC_DXT3_Format) return G.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (e === THREE.RGBA_S3TC_DXT5_Format) return G.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        return 0;
    }
    function Kn(e) {
        if (it && e && e.useVertexTexture) return 1024;
        var t = V.getParameter(V.MAX_VERTEX_UNIFORM_VECTORS),
            n = Math.floor((t - 20) / 4),
            r = n;
        return (
            e !== undefined &&
            e instanceof THREE.SkinnedMesh &&
            ((r = Math.min(e.bones.length, r)), r < e.bones.length && console.warn("WebGLRenderer: too many bones - " + e.bones.length + ", this GPU supports just " + r + " (try OpenGL instead of ANGLE)")),
                r
        );
    }
    function Qn(e) {
        var t = 0,
            n = 0,
            r = 0,
            i = 0;
        for (var s = 0, o = e.length; s < o; s++) {
            var u = e[s];
            if (u.onlyShadow) continue;
            u instanceof THREE.DirectionalLight && t++, u instanceof THREE.PointLight && n++, u instanceof THREE.SpotLight && r++, u instanceof THREE.HemisphereLight && i++;
        }
        return { directional: t, point: n, spot: r, hemi: i };
    }
    function Gn(e) {
        var t = 0;
        for (var n = 0, r = e.length; n < r; n++) {
            var i = e[n];
            if (!i.castShadow) continue;
            i instanceof THREE.SpotLight && t++, i instanceof THREE.DirectionalLight && !i.shadowCascade && t++;
        }
        return t;
    }
    function Yn() {
        try {
            var e = { alpha: r, premultipliedAlpha: i, antialias: s, stencil: o, preserveDrawingBuffer: u };
            V = t.getContext("webgl", e) || t.getContext("experimental-webgl", e);
            if (V === null) throw "Error creating WebGL context.";
        } catch (n) {
            console.error(n);
        }
        ($ = V.getExtension("OES_texture_float")),
            (J = V.getExtension("OES_texture_float_linear")),
            (K = V.getExtension("OES_standard_derivatives")),
            (Q = V.getExtension("EXT_texture_filter_anisotropic") || V.getExtension("MOZ_EXT_texture_filter_anisotropic") || V.getExtension("WEBKIT_EXT_texture_filter_anisotropic")),
            (G = V.getExtension("WEBGL_compressed_texture_s3tc") || V.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || V.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")),
        $ || console.log("THREE.WebGLRenderer: Float textures not supported."),
        K || console.log("THREE.WebGLRenderer: Standard derivatives not supported."),
        Q || console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported."),
        G || console.log("THREE.WebGLRenderer: S3TC compressed textures not supported."),
        V.getShaderPrecisionFormat === undefined &&
        (V.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    }
    function Zn() {
        V.clearColor(0, 0, 0, 1),
            V.clearDepth(1),
            V.clearStencil(0),
            V.enable(V.DEPTH_TEST),
            V.depthFunc(V.LEQUAL),
            V.frontFace(V.CCW),
            V.cullFace(V.BACK),
            V.enable(V.CULL_FACE),
            V.enable(V.BLEND),
            V.blendEquation(V.FUNC_ADD),
            V.blendFunc(V.SRC_ALPHA, V.ONE_MINUS_SRC_ALPHA),
            V.clearColor(a.r, a.g, a.b, f);
    }
    console.log("THREE.WebGLRenderer", THREE.REVISION), (e = e || {});
    var t = e.canvas !== undefined ? e.canvas : document.createElement("canvas"),
        n = e.precision !== undefined ? e.precision : "highp",
        r = e.alpha !== undefined ? e.alpha : !0,
        i = e.premultipliedAlpha !== undefined ? e.premultipliedAlpha : !0,
        s = e.antialias !== undefined ? e.antialias : !1,
        o = e.stencil !== undefined ? e.stencil : !0,
        u = e.preserveDrawingBuffer !== undefined ? e.preserveDrawingBuffer : !1,
        a = new THREE.Color(0),
        f = 0;
    (this.domElement = t),
        (this.context = null),
        (this.devicePixelRatio = e.devicePixelRatio !== undefined ? e.devicePixelRatio : self.devicePixelRatio !== undefined ? self.devicePixelRatio : 1),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.autoUpdateObjects = !0),
        (this.gammaInput = !1),
        (this.gammaOutput = !1),
        (this.physicallyBasedShading = !1),
        (this.shadowMapEnabled = !1),
        (this.shadowMapAutoUpdate = !0),
        (this.shadowMapType = THREE.PCFShadowMap),
        (this.shadowMapCullFace = THREE.CullFaceFront),
        (this.shadowMapDebug = !1),
        (this.shadowMapCascade = !1),
        (this.maxMorphTargets = 8),
        (this.maxMorphNormals = 4),
        (this.autoScaleCubemaps = !0),
        (this.renderPluginsPre = []),
        (this.renderPluginsPost = []),
        (this.info = { memory: { programs: 0, geometries: 0, textures: 0 }, render: { calls: 0, vertices: 0, faces: 0, points: 0 } });
    var l = this,
        c = [],
        h = 0,
        p = null,
        d = null,
        v = -1,
        m = null,
        g = null,
        y = 0,
        b = 0,
        w = -1,
        E = -1,
        S = -1,
        x = -1,
        T = -1,
        N = -1,
        C = -1,
        k = -1,
        L = null,
        A = null,
        O = null,
        M = null,
        _ = 0,
        D = 0,
        P = 0,
        H = 0,
        B = 0,
        j = 0,
        F = {},
        I = new THREE.Frustum(),
        q = new THREE.Matrix4(),
        R = new THREE.Matrix4(),
        U = new THREE.Vector3(),
        z = new THREE.Vector3(),
        W = !0,
        X = {
            ambient: [0, 0, 0],
            directional: { length: 0, colors: new Array(), positions: new Array() },
            point: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },
            spot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },
            hemi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() },
        },
        V,
        $,
        J,
        K,
        Q,
        G;
    Yn(), Zn(), (this.context = V);
    var Y = V.getParameter(V.MAX_TEXTURE_IMAGE_UNITS),
        Z = V.getParameter(V.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        et = V.getParameter(V.MAX_TEXTURE_SIZE),
        tt = V.getParameter(V.MAX_CUBE_MAP_TEXTURE_SIZE),
        nt = Q ? V.getParameter(Q.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
        rt = Z > 0,
        it = rt && $,
        st = G ? V.getParameter(V.COMPRESSED_TEXTURE_FORMATS) : [],
        ot = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.HIGH_FLOAT),
        ut = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.MEDIUM_FLOAT),
        at = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.LOW_FLOAT),
        ft = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.HIGH_FLOAT),
        lt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.MEDIUM_FLOAT),
        ct = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.LOW_FLOAT),
        ht = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.HIGH_INT),
        pt = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.MEDIUM_INT),
        dt = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.LOW_INT),
        vt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.HIGH_INT),
        mt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.MEDIUM_INT),
        gt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.LOW_INT),
        yt = ot.precision > 0 && ft.precision > 0,
        bt = ut.precision > 0 && lt.precision > 0;
    n === "highp" && !yt && (bt ? ((n = "mediump"), console.warn("WebGLRenderer: highp not supported, using mediump")) : ((n = "lowp"), console.warn("WebGLRenderer: highp and mediump not supported, using lowp"))),
    n === "mediump" && !bt && ((n = "lowp"), console.warn("WebGLRenderer: mediump not supported, using lowp")),
        (this.getContext = function () {
            return V;
        }),
        (this.supportsVertexTextures = function () {
            return rt;
        }),
        (this.supportsFloatTextures = function () {
            return $;
        }),
        (this.supportsStandardDerivatives = function () {
            return K;
        }),
        (this.supportsCompressedTextureS3TC = function () {
            return G;
        }),
        (this.getMaxAnisotropy = function () {
            return nt;
        }),
        (this.getPrecision = function () {
            return n;
        }),
        (this.setSize = function (e, n, r) {
            (t.width = e * this.devicePixelRatio), (t.height = n * this.devicePixelRatio), this.devicePixelRatio !== 1 && r !== !1 && ((t.style.width = e + "px"), (t.style.height = n + "px")), this.setViewport(0, 0, t.width, t.height);
        }),
        (this.setViewport = function (e, n, r, i) {
            (_ = e !== undefined ? e : 0), (D = n !== undefined ? n : 0), (P = r !== undefined ? r : t.width), (H = i !== undefined ? i : t.height), V.viewport(_, D, P, H);
        }),
        (this.setScissor = function (e, t, n, r) {
            V.scissor(e, t, n, r);
        }),
        (this.enableScissorTest = function (e) {
            e ? V.enable(V.SCISSOR_TEST) : V.disable(V.SCISSOR_TEST);
        }),
        (this.setClearColor = function (e, t) {
            a.set(e), (f = t !== undefined ? t : 1), V.clearColor(a.r, a.g, a.b, f);
        }),
        (this.setClearColorHex = function (e, t) {
            console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t);
        }),
        (this.getClearColor = function () {
            return a;
        }),
        (this.getClearAlpha = function () {
            return f;
        }),
        (this.clear = function (e, t, n) {
            var r = 0;
            if (e === undefined || e) r |= V.COLOR_BUFFER_BIT;
            if (t === undefined || t) r |= V.DEPTH_BUFFER_BIT;
            if (n === undefined || n) r |= V.STENCIL_BUFFER_BIT;
            V.clear(r);
        }),
        (this.clearTarget = function (e, t, n, r) {
            this.setRenderTarget(e), this.clear(t, n, r);
        }),
        (this.addPostPlugin = function (e) {
            e.init(this), this.renderPluginsPost.push(e);
        }),
        (this.addPrePlugin = function (e) {
            e.init(this), this.renderPluginsPre.push(e);
        }),
        (this.updateShadowMap = function (e, t) {
            (p = null), (S = -1), (C = -1), (k = -1), (m = -1), (v = -1), (W = !0), (w = -1), (E = -1), this.shadowMapPlugin.update(e, t);
        });
    var xt = function (e) {
            var t = e.target;
            t.removeEventListener("dispose", xt), Lt(t);
        },
        Tt = function (e) {
            var t = e.target;
            t.removeEventListener("dispose", Tt), At(t), l.info.memory.textures--;
        },
        Nt = function (e) {
            var t = e.target;
            t.removeEventListener("dispose", Nt), Ot(t), l.info.memory.textures--;
        },
        Ct = function (e) {
            var t = e.target;
            t.removeEventListener("dispose", Ct), Mt(t);
        },
        kt = function (e) {
            e.__webglVertexBuffer !== undefined && V.deleteBuffer(e.__webglVertexBuffer),
            e.__webglNormalBuffer !== undefined && V.deleteBuffer(e.__webglNormalBuffer),
            e.__webglTangentBuffer !== undefined && V.deleteBuffer(e.__webglTangentBuffer),
            e.__webglColorBuffer !== undefined && V.deleteBuffer(e.__webglColorBuffer),
            e.__webglUVBuffer !== undefined && V.deleteBuffer(e.__webglUVBuffer),
            e.__webglUV2Buffer !== undefined && V.deleteBuffer(e.__webglUV2Buffer),
            e.__webglSkinIndicesBuffer !== undefined && V.deleteBuffer(e.__webglSkinIndicesBuffer),
            e.__webglSkinWeightsBuffer !== undefined && V.deleteBuffer(e.__webglSkinWeightsBuffer),
            e.__webglFaceBuffer !== undefined && V.deleteBuffer(e.__webglFaceBuffer),
            e.__webglLineBuffer !== undefined && V.deleteBuffer(e.__webglLineBuffer),
            e.__webglLineDistanceBuffer !== undefined && V.deleteBuffer(e.__webglLineDistanceBuffer);
            if (e.__webglCustomAttributesList !== undefined) for (var t in e.__webglCustomAttributesList) V.deleteBuffer(e.__webglCustomAttributesList[t].buffer);
            l.info.memory.geometries--;
        },
        Lt = function (e) {
            e.__webglInit = undefined;
            if (e instanceof THREE.BufferGeometry) {
                var t = e.attributes;
                for (var n in t) t[n].buffer !== undefined && V.deleteBuffer(t[n].buffer);
                l.info.memory.geometries--;
            } else if (e.geometryGroups !== undefined)
                for (var r in e.geometryGroups) {
                    var i = e.geometryGroups[r];
                    if (i.numMorphTargets !== undefined) for (var s = 0, o = i.numMorphTargets; s < o; s++) V.deleteBuffer(i.__webglMorphTargetsBuffers[s]);
                    if (i.numMorphNormals !== undefined) for (var s = 0, o = i.numMorphNormals; s < o; s++) V.deleteBuffer(i.__webglMorphNormalsBuffers[s]);
                    kt(i);
                }
            else kt(e);
        },
        At = function (e) {
            if (e.image && e.image.__webglTextureCube) V.deleteTexture(e.image.__webglTextureCube);
            else {
                if (!e.__webglInit) return;
                (e.__webglInit = !1), V.deleteTexture(e.__webglTexture);
            }
        },
        Ot = function (e) {
            if (!e || !e.__webglTexture) return;
            V.deleteTexture(e.__webglTexture);
            if (e instanceof THREE.WebGLRenderTargetCube) for (var t = 0; t < 6; t++) V.deleteFramebuffer(e.__webglFramebuffer[t]), V.deleteRenderbuffer(e.__webglRenderbuffer[t]);
            else V.deleteFramebuffer(e.__webglFramebuffer), V.deleteRenderbuffer(e.__webglRenderbuffer);
        },
        Mt = function (e) {
            var t = e.program;
            if (t === undefined) return;
            e.program = undefined;
            var n,
                r,
                i,
                s = !1;
            for (n = 0, r = c.length; n < r; n++) {
                i = c[n];
                if (i.program === t) {
                    i.usedTimes--, i.usedTimes === 0 && (s = !0);
                    break;
                }
            }
            if (s === !0) {
                var o = [];
                for (n = 0, r = c.length; n < r; n++) (i = c[n]), i.program !== t && o.push(i);
                (c = o), V.deleteProgram(t), l.info.memory.programs--;
            }
        };
    (this.renderBufferImmediate = function (e, t, n) {
        e.hasPositions && !e.__webglVertexBuffer && (e.__webglVertexBuffer = V.createBuffer()),
        e.hasNormals && !e.__webglNormalBuffer && (e.__webglNormalBuffer = V.createBuffer()),
        e.hasUvs && !e.__webglUvBuffer && (e.__webglUvBuffer = V.createBuffer()),
        e.hasColors && !e.__webglColorBuffer && (e.__webglColorBuffer = V.createBuffer()),
        e.hasPositions &&
        (V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer),
            V.bufferData(V.ARRAY_BUFFER, e.positionArray, V.DYNAMIC_DRAW),
            V.enableVertexAttribArray(t.attributes.position),
            V.vertexAttribPointer(t.attributes.position, 3, V.FLOAT, !1, 0, 0));
        if (e.hasNormals) {
            V.bindBuffer(V.ARRAY_BUFFER, e.__webglNormalBuffer);
            if (n.shading === THREE.FlatShading) {
                var r,
                    i,
                    s,
                    o,
                    u,
                    a,
                    f,
                    l,
                    c,
                    h,
                    p,
                    d,
                    v,
                    m,
                    g = e.count * 3;
                for (m = 0; m < g; m += 9)
                    (v = e.normalArray),
                        (o = v[m]),
                        (f = v[m + 1]),
                        (h = v[m + 2]),
                        (u = v[m + 3]),
                        (l = v[m + 4]),
                        (p = v[m + 5]),
                        (a = v[m + 6]),
                        (c = v[m + 7]),
                        (d = v[m + 8]),
                        (r = (o + u + a) / 3),
                        (i = (f + l + c) / 3),
                        (s = (h + p + d) / 3),
                        (v[m] = r),
                        (v[m + 1] = i),
                        (v[m + 2] = s),
                        (v[m + 3] = r),
                        (v[m + 4] = i),
                        (v[m + 5] = s),
                        (v[m + 6] = r),
                        (v[m + 7] = i),
                        (v[m + 8] = s);
            }
            V.bufferData(V.ARRAY_BUFFER, e.normalArray, V.DYNAMIC_DRAW), V.enableVertexAttribArray(t.attributes.normal), V.vertexAttribPointer(t.attributes.normal, 3, V.FLOAT, !1, 0, 0);
        }
        e.hasUvs &&
        n.map &&
        (V.bindBuffer(V.ARRAY_BUFFER, e.__webglUvBuffer), V.bufferData(V.ARRAY_BUFFER, e.uvArray, V.DYNAMIC_DRAW), V.enableVertexAttribArray(t.attributes.uv), V.vertexAttribPointer(t.attributes.uv, 2, V.FLOAT, !1, 0, 0)),
        e.hasColors &&
        n.vertexColors !== THREE.NoColors &&
        (V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer),
            V.bufferData(V.ARRAY_BUFFER, e.colorArray, V.DYNAMIC_DRAW),
            V.enableVertexAttribArray(t.attributes.color),
            V.vertexAttribPointer(t.attributes.color, 3, V.FLOAT, !1, 0, 0)),
            V.drawArrays(V.TRIANGLES, 0, e.count),
            (e.count = 0);
    }),
        (this.renderBufferDirect = function (e, t, n, r, i, s) {
            if (r.visible === !1) return;
            var o,
                u,
                a,
                f,
                c,
                h,
                p,
                d = dn(e, t, n, r, s),
                v = d.attributes,
                g = i.attributes,
                y = !1,
                b = r.wireframe ? 1 : 0,
                w = i.id * 16777215 + d.id * 2 + b;
            w !== m && ((m = w), (y = !0)), y && $t();
            if (s instanceof THREE.Mesh) {
                var E = g.index;
                if (E) {
                    var S = i.offsets;
                    S.length > 1 && (y = !0);
                    for (var x = 0, T = S.length; x < T; x++) {
                        var N = S[x].index;
                        if (y) {
                            for (c in v)
                                (h = v[c]),
                                    (f = g[c]),
                                h >= 0 &&
                                (f
                                    ? ((p = f.itemSize), V.bindBuffer(V.ARRAY_BUFFER, f.buffer), Vt(h), V.vertexAttribPointer(h, p, V.FLOAT, !1, 0, N * p * 4))
                                    : r.defaultAttributeValues &&
                                    (r.defaultAttributeValues[c].length === 2
                                        ? V.vertexAttrib2fv(h, r.defaultAttributeValues[c])
                                        : r.defaultAttributeValues[c].length === 3 && V.vertexAttrib3fv(h, r.defaultAttributeValues[c])));
                            V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, E.buffer);
                        }
                        V.drawElements(V.TRIANGLES, S[x].count, V.UNSIGNED_SHORT, S[x].start * 2), l.info.render.calls++, (l.info.render.vertices += S[x].count), (l.info.render.faces += S[x].count / 3);
                    }
                } else {
                    if (y)
                        for (c in v) {
                            if (c === "index") continue;
                            (h = v[c]),
                                (f = g[c]),
                            h >= 0 &&
                            (f
                                ? ((p = f.itemSize), V.bindBuffer(V.ARRAY_BUFFER, f.buffer), Vt(h), V.vertexAttribPointer(h, p, V.FLOAT, !1, 0, 0))
                                : r.defaultAttributeValues &&
                                r.defaultAttributeValues[c] &&
                                (r.defaultAttributeValues[c].length === 2 ? V.vertexAttrib2fv(h, r.defaultAttributeValues[c]) : r.defaultAttributeValues[c].length === 3 && V.vertexAttrib3fv(h, r.defaultAttributeValues[c])));
                        }
                    var C = i.attributes.position;
                    V.drawArrays(V.TRIANGLES, 0, C.numItems / 3), l.info.render.calls++, (l.info.render.vertices += C.numItems / 3), (l.info.render.faces += C.numItems / 3 / 3);
                }
            } else if (s instanceof THREE.ParticleSystem) {
                if (y) {
                    for (c in v)
                        (h = v[c]),
                            (f = g[c]),
                        h >= 0 &&
                        (f
                            ? ((p = f.itemSize), V.bindBuffer(V.ARRAY_BUFFER, f.buffer), Vt(h), V.vertexAttribPointer(h, p, V.FLOAT, !1, 0, 0))
                            : r.defaultAttributeValues &&
                            r.defaultAttributeValues[c] &&
                            (r.defaultAttributeValues[c].length === 2 ? V.vertexAttrib2fv(h, r.defaultAttributeValues[c]) : r.defaultAttributeValues[c].length === 3 && V.vertexAttrib3fv(h, r.defaultAttributeValues[c])));
                    var C = g.position;
                    V.drawArrays(V.POINTS, 0, C.numItems / 3), l.info.render.calls++, (l.info.render.points += C.numItems / 3);
                }
            } else if (s instanceof THREE.Line && y) {
                for (c in v)
                    (h = v[c]),
                        (f = g[c]),
                    h >= 0 &&
                    (f
                        ? ((p = f.itemSize), V.bindBuffer(V.ARRAY_BUFFER, f.buffer), Vt(h), V.vertexAttribPointer(h, p, V.FLOAT, !1, 0, 0))
                        : r.defaultAttributeValues &&
                        r.defaultAttributeValues[c] &&
                        (r.defaultAttributeValues[c].length === 2 ? V.vertexAttrib2fv(h, r.defaultAttributeValues[c]) : r.defaultAttributeValues[c].length === 3 && V.vertexAttrib3fv(h, r.defaultAttributeValues[c])));
                var k = s.type === THREE.LineStrip ? V.LINE_STRIP : V.LINES;
                Mn(r.linewidth);
                var C = g.position;
                V.drawArrays(k, 0, C.numItems / 3), l.info.render.calls++, (l.info.render.points += C.numItems);
            }
        }),
        (this.renderBuffer = function (e, t, n, r, i, s) {
            if (r.visible === !1) return;
            var o,
                u,
                a,
                f,
                c,
                h = dn(e, t, n, r, s),
                p = h.attributes,
                d = !1,
                v = r.wireframe ? 1 : 0,
                g = i.id * 16777215 + h.id * 2 + v;
            g !== m && ((m = g), (d = !0)),
            d && $t(),
                !r.morphTargets && p.position >= 0 ? d && (V.bindBuffer(V.ARRAY_BUFFER, i.__webglVertexBuffer), Vt(p.position), V.vertexAttribPointer(p.position, 3, V.FLOAT, !1, 0, 0)) : s.morphTargetBase && Jt(r, i, s);
            if (d) {
                if (i.__webglCustomAttributesList)
                    for (f = 0, c = i.__webglCustomAttributesList.length; f < c; f++)
                        (a = i.__webglCustomAttributesList[f]),
                        p[a.buffer.belongsToAttribute] >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, a.buffer), Vt(p[a.buffer.belongsToAttribute]), V.vertexAttribPointer(p[a.buffer.belongsToAttribute], a.size, V.FLOAT, !1, 0, 0));
                p.color >= 0 &&
                (s.geometry.colors.length > 0 || s.geometry.faces.length > 0
                    ? (V.bindBuffer(V.ARRAY_BUFFER, i.__webglColorBuffer), Vt(p.color), V.vertexAttribPointer(p.color, 3, V.FLOAT, !1, 0, 0))
                    : r.defaultAttributeValues && V.vertexAttrib3fv(p.color, r.defaultAttributeValues.color)),
                p.normal >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, i.__webglNormalBuffer), Vt(p.normal), V.vertexAttribPointer(p.normal, 3, V.FLOAT, !1, 0, 0)),
                p.tangent >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, i.__webglTangentBuffer), Vt(p.tangent), V.vertexAttribPointer(p.tangent, 4, V.FLOAT, !1, 0, 0)),
                p.uv >= 0 &&
                (s.geometry.faceVertexUvs[0]
                    ? (V.bindBuffer(V.ARRAY_BUFFER, i.__webglUVBuffer), Vt(p.uv), V.vertexAttribPointer(p.uv, 2, V.FLOAT, !1, 0, 0))
                    : r.defaultAttributeValues && V.vertexAttrib2fv(p.uv, r.defaultAttributeValues.uv)),
                p.uv2 >= 0 &&
                (s.geometry.faceVertexUvs[1]
                    ? (V.bindBuffer(V.ARRAY_BUFFER, i.__webglUV2Buffer), Vt(p.uv2), V.vertexAttribPointer(p.uv2, 2, V.FLOAT, !1, 0, 0))
                    : r.defaultAttributeValues && V.vertexAttrib2fv(p.uv2, r.defaultAttributeValues.uv2)),
                r.skinning &&
                p.skinIndex >= 0 &&
                p.skinWeight >= 0 &&
                (V.bindBuffer(V.ARRAY_BUFFER, i.__webglSkinIndicesBuffer),
                    Vt(p.skinIndex),
                    V.vertexAttribPointer(p.skinIndex, 4, V.FLOAT, !1, 0, 0),
                    V.bindBuffer(V.ARRAY_BUFFER, i.__webglSkinWeightsBuffer),
                    Vt(p.skinWeight),
                    V.vertexAttribPointer(p.skinWeight, 4, V.FLOAT, !1, 0, 0)),
                p.lineDistance >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, i.__webglLineDistanceBuffer), Vt(p.lineDistance), V.vertexAttribPointer(p.lineDistance, 1, V.FLOAT, !1, 0, 0));
            }
            if (s instanceof THREE.Mesh)
                r.wireframe
                    ? (Mn(r.wireframeLinewidth), d && V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, i.__webglLineBuffer), V.drawElements(V.LINES, i.__webglLineCount, V.UNSIGNED_SHORT, 0))
                    : (d && V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, i.__webglFaceBuffer), V.drawElements(V.TRIANGLES, i.__webglFaceCount, V.UNSIGNED_SHORT, 0)),
                    l.info.render.calls++,
                    (l.info.render.vertices += i.__webglFaceCount),
                    (l.info.render.faces += i.__webglFaceCount / 3);
            else if (s instanceof THREE.Line) {
                var y = s.type === THREE.LineStrip ? V.LINE_STRIP : V.LINES;
                Mn(r.linewidth), V.drawArrays(y, 0, i.__webglLineCount), l.info.render.calls++;
            } else s instanceof THREE.ParticleSystem && (V.drawArrays(V.POINTS, 0, i.__webglParticleCount), l.info.render.calls++, (l.info.render.points += i.__webglParticleCount));
        }),
        (this.render = function (e, t, n, r) {
            if (t instanceof THREE.Camera == 0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return;
            }
            var i,
                s,
                o,
                u,
                a,
                f = e.__lights,
                c = e.fog;
            (v = -1),
                (W = !0),
            e.autoUpdate === !0 && e.updateMatrixWorld(),
            t.parent === undefined && t.updateMatrixWorld(),
                t.matrixWorldInverse.getInverse(t.matrixWorld),
                q.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                I.setFromMatrix(q),
            this.autoUpdateObjects && this.initWebGLObjects(e),
                Gt(this.renderPluginsPre, e, t),
                (l.info.render.calls = 0),
                (l.info.render.vertices = 0),
                (l.info.render.faces = 0),
                (l.info.render.points = 0),
                this.setRenderTarget(n),
            (this.autoClear || r) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil),
                (a = e.__webglObjects);
            for (i = 0, s = a.length; i < s; i++)
                (o = a[i]),
                    (u = o.object),
                    (o.id = i),
                    (o.render = !1),
                u.visible &&
                (!(u instanceof THREE.Mesh || u instanceof THREE.ParticleSystem) || !u.frustumCulled || I.intersectsObject(u)) &&
                (kn(u, t), tn(o), (o.render = !0), this.sortObjects === !0 && (u.renderDepth !== null ? (o.z = u.renderDepth) : (U.getPositionFromMatrix(u.matrixWorld), U.applyProjection(q), (o.z = U.z))));
            this.sortObjects && a.sort(Kt), (a = e.__webglObjectsImmediate);
            for (i = 0, s = a.length; i < s; i++) (o = a[i]), (u = o.object), u.visible && (kn(u, t), en(o));
            if (e.overrideMaterial) {
                var h = e.overrideMaterial;
                this.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst),
                    this.setDepthTest(h.depthTest),
                    this.setDepthWrite(h.depthWrite),
                    _n(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits),
                    Yt(e.__webglObjects, !1, "", t, f, c, !0, h),
                    Zt(e.__webglObjectsImmediate, "", t, f, c, !1, h);
            } else {
                var h = null;
                this.setBlending(THREE.NoBlending),
                    Yt(e.__webglObjects, !0, "opaque", t, f, c, !1, h),
                    Zt(e.__webglObjectsImmediate, "opaque", t, f, c, !1, h),
                    Yt(e.__webglObjects, !1, "transparent", t, f, c, !0, h),
                    Zt(e.__webglObjectsImmediate, "transparent", t, f, c, !0, h);
            }
            Gt(this.renderPluginsPost, e, t), n && n.generateMipmaps && n.minFilter !== THREE.NearestFilter && n.minFilter !== THREE.LinearFilter && Vn(n), this.setDepthTest(!0), this.setDepthWrite(!0);
        }),
        (this.renderImmediateObject = function (e, t, n, r, i) {
            var s = dn(e, t, n, r, i);
            (m = -1),
                l.setMaterialFaces(r),
                i.immediateRenderCallback
                    ? i.immediateRenderCallback(s, V, I)
                    : i.render(function (e) {
                        l.renderBufferImmediate(e, s, r);
                    });
        }),
        (this.initWebGLObjects = function (e) {
            e.__webglObjects || ((e.__webglObjects = []), (e.__webglObjectsImmediate = []), (e.__webglSprites = []), (e.__webglFlares = []));
            while (e.__objectsAdded.length) rn(e.__objectsAdded[0], e), e.__objectsAdded.splice(0, 1);
            while (e.__objectsRemoved.length) ln(e.__objectsRemoved[0], e), e.__objectsRemoved.splice(0, 1);
            for (var t = 0, n = e.__webglObjects.length; t < n; t++) {
                var r = e.__webglObjects[t].object;
                r.__webglInit === undefined && (r.__webglActive !== undefined && ln(r, e), rn(r, e)), un(r);
            }
        }),
        (this.initMaterial = function (e, t, n, r) {
            e.addEventListener("dispose", Ct);
            var i, s, o, u, a, f, l, c, h;
            e instanceof THREE.MeshDepthMaterial
                ? (h = "depth")
                : e instanceof THREE.MeshNormalMaterial
                ? (h = "normal")
                : e instanceof THREE.MeshBasicMaterial
                    ? (h = "basic")
                    : e instanceof THREE.MeshLambertMaterial
                        ? (h = "lambert")
                        : e instanceof THREE.MeshPhongMaterial
                            ? (h = "phong")
                            : e instanceof THREE.LineBasicMaterial
                                ? (h = "basic")
                                : e instanceof THREE.LineDashedMaterial
                                    ? (h = "dashed")
                                    : e instanceof THREE.ParticleBasicMaterial && (h = "particle_basic"),
            h && pn(e, THREE.ShaderLib[h]),
                (f = Qn(t)),
                (c = Gn(t)),
                (l = Kn(r)),
                (a = {
                    map: !!e.map,
                    envMap: !!e.envMap,
                    lightMap: !!e.lightMap,
                    bumpMap: !!e.bumpMap,
                    normalMap: !!e.normalMap,
                    specularMap: !!e.specularMap,
                    vertexColors: e.vertexColors,
                    fog: n,
                    useFog: e.fog,
                    fogExp: n instanceof THREE.FogExp2,
                    sizeAttenuation: e.sizeAttenuation,
                    skinning: e.skinning,
                    maxBones: l,
                    useVertexTexture: it && r && r.useVertexTexture,
                    morphTargets: e.morphTargets,
                    morphNormals: e.morphNormals,
                    maxMorphTargets: this.maxMorphTargets,
                    maxMorphNormals: this.maxMorphNormals,
                    maxDirLights: f.directional,
                    maxPointLights: f.point,
                    maxSpotLights: f.spot,
                    maxHemiLights: f.hemi,
                    maxShadows: c,
                    shadowMapEnabled: this.shadowMapEnabled && r.receiveShadow,
                    shadowMapType: this.shadowMapType,
                    shadowMapDebug: this.shadowMapDebug,
                    shadowMapCascade: this.shadowMapCascade,
                    alphaTest: e.alphaTest,
                    metal: e.metal,
                    perPixel: e.perPixel,
                    wrapAround: e.wrapAround,
                    doubleSided: e.side === THREE.DoubleSide,
                    flipSided: e.side === THREE.BackSide,
                }),
                (e.program = Pn(h, e.fragmentShader, e.vertexShader, e.uniforms, e.attributes, e.defines, a, e.index0AttributeName));
            var p = e.program.attributes;
            if (e.morphTargets) {
                e.numSupportedMorphTargets = 0;
                var d,
                    v = "morphTarget";
                for (u = 0; u < this.maxMorphTargets; u++) (d = v + u), p[d] >= 0 && e.numSupportedMorphTargets++;
            }
            if (e.morphNormals) {
                e.numSupportedMorphNormals = 0;
                var d,
                    v = "morphNormal";
                for (u = 0; u < this.maxMorphNormals; u++) (d = v + u), p[d] >= 0 && e.numSupportedMorphNormals++;
            }
            e.uniformsList = [];
            for (i in e.uniforms) e.uniformsList.push([e.uniforms[i], i]);
        }),
        (this.setFaceCulling = function (e, t) {
            e === THREE.CullFaceNone
                ? V.disable(V.CULL_FACE)
                : (t === THREE.FrontFaceDirectionCW ? V.frontFace(V.CW) : V.frontFace(V.CCW),
                    e === THREE.CullFaceBack ? V.cullFace(V.BACK) : e === THREE.CullFaceFront ? V.cullFace(V.FRONT) : V.cullFace(V.FRONT_AND_BACK),
                    V.enable(V.CULL_FACE));
        }),
        (this.setMaterialFaces = function (e) {
            var t = e.side === THREE.DoubleSide,
                n = e.side === THREE.BackSide;
            w !== t && (t ? V.disable(V.CULL_FACE) : V.enable(V.CULL_FACE), (w = t)), E !== n && (n ? V.frontFace(V.CW) : V.frontFace(V.CCW), (E = n));
        }),
        (this.setDepthTest = function (e) {
            C !== e && (e ? V.enable(V.DEPTH_TEST) : V.disable(V.DEPTH_TEST), (C = e));
        }),
        (this.setDepthWrite = function (e) {
            k !== e && (V.depthMask(e), (k = e));
        }),
        (this.setBlending = function (e, t, n, r) {
            e !== S &&
            (e === THREE.NoBlending
                ? V.disable(V.BLEND)
                : e === THREE.AdditiveBlending
                    ? (V.enable(V.BLEND), V.blendEquation(V.FUNC_ADD), V.blendFunc(V.SRC_ALPHA, V.ONE))
                    : e === THREE.SubtractiveBlending
                        ? (V.enable(V.BLEND), V.blendEquation(V.FUNC_ADD), V.blendFunc(V.ZERO, V.ONE_MINUS_SRC_COLOR))
                        : e === THREE.MultiplyBlending
                            ? (V.enable(V.BLEND), V.blendEquation(V.FUNC_ADD), V.blendFunc(V.ZERO, V.SRC_COLOR))
                            : e === THREE.CustomBlending
                                ? V.enable(V.BLEND)
                                : (V.enable(V.BLEND), V.blendEquationSeparate(V.FUNC_ADD, V.FUNC_ADD), V.blendFuncSeparate(V.SRC_ALPHA, V.ONE_MINUS_SRC_ALPHA, V.ONE, V.ONE_MINUS_SRC_ALPHA)),
                (S = e));
            if (e === THREE.CustomBlending) {
                t !== x && (V.blendEquation(Jn(t)), (x = t));
                if (n !== T || r !== N) V.blendFunc(Jn(n), Jn(r)), (T = n), (N = r);
            } else (x = null), (T = null), (N = null);
        }),
        (this.setTexture = function (e, t) {
            if (e.needsUpdate) {
                e.__webglInit || ((e.__webglInit = !0), e.addEventListener("dispose", Tt), (e.__webglTexture = V.createTexture()), l.info.memory.textures++),
                    V.activeTexture(V.TEXTURE0 + t),
                    V.bindTexture(V.TEXTURE_2D, e.__webglTexture),
                    V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, e.flipY),
                    V.pixelStorei(V.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha),
                    V.pixelStorei(V.UNPACK_ALIGNMENT, e.unpackAlignment);
                var n = e.image,
                    r = In(n.width) && In(n.height),
                    i = Jn(e.format),
                    s = Jn(e.type);
                qn(V.TEXTURE_2D, e, r);
                var o,
                    u = e.mipmaps;
                if (e instanceof THREE.DataTexture)
                    if (u.length > 0 && r) {
                        for (var a = 0, f = u.length; a < f; a++) (o = u[a]), V.texImage2D(V.TEXTURE_2D, a, i, o.width, o.height, 0, i, s, o.data);
                        e.generateMipmaps = !1;
                    } else V.texImage2D(V.TEXTURE_2D, 0, i, n.width, n.height, 0, i, s, n.data);
                else if (e instanceof THREE.CompressedTexture)
                    for (var a = 0, f = u.length; a < f; a++)
                        (o = u[a]), e.format !== THREE.RGBAFormat ? V.compressedTexImage2D(V.TEXTURE_2D, a, i, o.width, o.height, 0, o.data) : V.texImage2D(V.TEXTURE_2D, a, i, o.width, o.height, 0, i, s, o.data);
                else if (u.length > 0 && r) {
                    for (var a = 0, f = u.length; a < f; a++) (o = u[a]), V.texImage2D(V.TEXTURE_2D, a, i, i, s, o);
                    e.generateMipmaps = !1;
                } else V.texImage2D(V.TEXTURE_2D, 0, i, i, s, e.image);
                e.generateMipmaps && r && V.generateMipmap(V.TEXTURE_2D), (e.needsUpdate = !1), e.onUpdate && e.onUpdate();
            } else V.activeTexture(V.TEXTURE0 + t), V.bindTexture(V.TEXTURE_2D, e.__webglTexture);
        }),
        (this.setRenderTarget = function (e) {
            var t = e instanceof THREE.WebGLRenderTargetCube;
            if (e && !e.__webglFramebuffer) {
                e.depthBuffer === undefined && (e.depthBuffer = !0), e.stencilBuffer === undefined && (e.stencilBuffer = !0), e.addEventListener("dispose", Nt), (e.__webglTexture = V.createTexture()), l.info.memory.textures++;
                var n = In(e.width) && In(e.height),
                    r = Jn(e.format),
                    i = Jn(e.type);
                if (t) {
                    (e.__webglFramebuffer = []), (e.__webglRenderbuffer = []), V.bindTexture(V.TEXTURE_CUBE_MAP, e.__webglTexture), qn(V.TEXTURE_CUBE_MAP, e, n);
                    for (var s = 0; s < 6; s++)
                        (e.__webglFramebuffer[s] = V.createFramebuffer()),
                            (e.__webglRenderbuffer[s] = V.createRenderbuffer()),
                            V.texImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, r, e.width, e.height, 0, r, i, null),
                            Wn(e.__webglFramebuffer[s], e, V.TEXTURE_CUBE_MAP_POSITIVE_X + s),
                            Xn(e.__webglRenderbuffer[s], e);
                    n && V.generateMipmap(V.TEXTURE_CUBE_MAP);
                } else
                    (e.__webglFramebuffer = V.createFramebuffer()),
                        e.shareDepthFrom ? (e.__webglRenderbuffer = e.shareDepthFrom.__webglRenderbuffer) : (e.__webglRenderbuffer = V.createRenderbuffer()),
                        V.bindTexture(V.TEXTURE_2D, e.__webglTexture),
                        qn(V.TEXTURE_2D, e, n),
                        V.texImage2D(V.TEXTURE_2D, 0, r, e.width, e.height, 0, r, i, null),
                        Wn(e.__webglFramebuffer, e, V.TEXTURE_2D),
                        e.shareDepthFrom
                            ? e.depthBuffer && !e.stencilBuffer
                            ? V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_ATTACHMENT, V.RENDERBUFFER, e.__webglRenderbuffer)
                            : e.depthBuffer && e.stencilBuffer && V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_STENCIL_ATTACHMENT, V.RENDERBUFFER, e.__webglRenderbuffer)
                            : Xn(e.__webglRenderbuffer, e),
                    n && V.generateMipmap(V.TEXTURE_2D);
                t ? V.bindTexture(V.TEXTURE_CUBE_MAP, null) : V.bindTexture(V.TEXTURE_2D, null), V.bindRenderbuffer(V.RENDERBUFFER, null), V.bindFramebuffer(V.FRAMEBUFFER, null);
            }
            var o, u, a, f, c;
            e ? (t ? (o = e.__webglFramebuffer[e.activeCubeFace]) : (o = e.__webglFramebuffer), (u = e.width), (a = e.height), (f = 0), (c = 0)) : ((o = null), (u = P), (a = H), (f = _), (c = D)),
            o !== d && (V.bindFramebuffer(V.FRAMEBUFFER, o), V.viewport(f, c, u, a), (d = o)),
                (B = u),
                (j = a);
        }),
        (this.shadowMapPlugin = new THREE.ShadowMapPlugin()),
        this.addPrePlugin(this.shadowMapPlugin),
        this.addPostPlugin(new THREE.SpritePlugin()),
        this.addPostPlugin(new THREE.LensFlarePlugin());
}),
(THREE.WebGLRenderTarget = function (e, t, n) {
    (this.width = e),
        (this.height = t),
        (n = n || {}),
        (this.wrapS = n.wrapS !== undefined ? n.wrapS : THREE.ClampToEdgeWrapping),
        (this.wrapT = n.wrapT !== undefined ? n.wrapT : THREE.ClampToEdgeWrapping),
        (this.magFilter = n.magFilter !== undefined ? n.magFilter : THREE.LinearFilter),
        (this.minFilter = n.minFilter !== undefined ? n.minFilter : THREE.LinearMipMapLinearFilter),
        (this.anisotropy = n.anisotropy !== undefined ? n.anisotropy : 1),
        (this.offset = new THREE.Vector2(0, 0)),
        (this.repeat = new THREE.Vector2(1, 1)),
        (this.format = n.format !== undefined ? n.format : THREE.RGBAFormat),
        (this.type = n.type !== undefined ? n.type : THREE.UnsignedByteType),
        (this.depthBuffer = n.depthBuffer !== undefined ? n.depthBuffer : !0),
        (this.stencilBuffer = n.stencilBuffer !== undefined ? n.stencilBuffer : !0),
        (this.generateMipmaps = !0),
        (this.shareDepthFrom = null);
}),
(THREE.WebGLRenderTarget.prototype = {
    constructor: THREE.WebGLRenderTarget,
    clone: function () {
        var e = new THREE.WebGLRenderTarget(this.width, this.height);
        return (
            (e.wrapS = this.wrapS),
                (e.wrapT = this.wrapT),
                (e.magFilter = this.magFilter),
                (e.minFilter = this.minFilter),
                (e.anisotropy = this.anisotropy),
                e.offset.copy(this.offset),
                e.repeat.copy(this.repeat),
                (e.format = this.format),
                (e.type = this.type),
                (e.depthBuffer = this.depthBuffer),
                (e.stencilBuffer = this.stencilBuffer),
                (e.generateMipmaps = this.generateMipmaps),
                (e.shareDepthFrom = this.shareDepthFrom),
                e
        );
    },
    dispose: function () {
        this.dispatchEvent({ type: "dispose" });
    },
}),
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype),
(THREE.WebGLRenderTargetCube = function (e, t, n) {
    THREE.WebGLRenderTarget.call(this, e, t, n), (this.activeCubeFace = 0);
}),
(THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype)),
(THREE.RenderableVertex = function () {
    (this.positionWorld = new THREE.Vector3()), (this.positionScreen = new THREE.Vector4()), (this.visible = !0);
}),
(THREE.RenderableVertex.prototype.copy = function (e) {
    this.positionWorld.copy(e.positionWorld), this.positionScreen.copy(e.positionScreen);
}),
(THREE.RenderableFace3 = function () {
    (this.id = 0),
        (this.v1 = new THREE.RenderableVertex()),
        (this.v2 = new THREE.RenderableVertex()),
        (this.v3 = new THREE.RenderableVertex()),
        (this.centroidModel = new THREE.Vector3()),
        (this.normalModel = new THREE.Vector3()),
        (this.normalModelView = new THREE.Vector3()),
        (this.vertexNormalsLength = 0),
        (this.vertexNormalsModel = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]),
        (this.vertexNormalsModelView = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]),
        (this.color = null),
        (this.material = null),
        (this.uvs = [[]]),
        (this.z = 0);
}),
(THREE.RenderableObject = function () {
    (this.id = 0), (this.object = null), (this.z = 0);
}),
(THREE.RenderableParticle = function () {
    (this.id = 0), (this.object = null), (this.x = 0), (this.y = 0), (this.z = 0), (this.rotation = null), (this.scale = new THREE.Vector2()), (this.material = null);
}),
(THREE.RenderableLine = function () {
    (this.id = 0), (this.v1 = new THREE.RenderableVertex()), (this.v2 = new THREE.RenderableVertex()), (this.vertexColors = [new THREE.Color(), new THREE.Color()]), (this.material = null), (this.z = 0);
}),
(THREE.GeometryUtils = {
    merge: function (e, t, n) {
        var r,
            i,
            s = e.vertices.length,
            o = e.faceVertexUvs[0].length,
            u = t instanceof THREE.Mesh ? t.geometry : t,
            a = e.vertices,
            f = u.vertices,
            l = e.faces,
            c = u.faces,
            h = e.faceVertexUvs[0],
            p = u.faceVertexUvs[0];
        n === undefined && (n = 0), t instanceof THREE.Mesh && (t.matrixAutoUpdate && t.updateMatrix(), (r = t.matrix), (i = new THREE.Matrix3().getNormalMatrix(r)));
        for (var d = 0, v = f.length; d < v; d++) {
            var m = f[d],
                g = m.clone();
            r && g.applyMatrix4(r), a.push(g);
        }
        for (d = 0, v = c.length; d < v; d++) {
            var y = c[d],
                b,
                w,
                E,
                S = y.vertexNormals,
                x = y.vertexColors;
            (b = new THREE.Face3(y.a + s, y.b + s, y.c + s)), b.normal.copy(y.normal), i && b.normal.applyMatrix3(i).normalize();
            for (var T = 0, N = S.length; T < N; T++) (w = S[T].clone()), i && w.applyMatrix3(i).normalize(), b.vertexNormals.push(w);
            b.color.copy(y.color);
            for (var T = 0, N = x.length; T < N; T++) (E = x[T]), b.vertexColors.push(E.clone());
            (b.materialIndex = y.materialIndex + n), b.centroid.copy(y.centroid), r && b.centroid.applyMatrix4(r), l.push(b);
        }
        for (d = 0, v = p.length; d < v; d++) {
            var C = p[d],
                k = [];
            for (var T = 0, N = C.length; T < N; T++) k.push(new THREE.Vector2(C[T].x, C[T].y));
            h.push(k);
        }
    },
    randomPointInTriangle: (function () {
        var e = new THREE.Vector3();
        return function (t, n, r) {
            var i = new THREE.Vector3(),
                s = THREE.Math.random16(),
                o = THREE.Math.random16();
            s + o > 1 && ((s = 1 - s), (o = 1 - o));
            var u = 1 - s - o;
            return i.copy(t), i.multiplyScalar(s), e.copy(n), e.multiplyScalar(o), i.add(e), e.copy(r), e.multiplyScalar(u), i.add(e), i;
        };
    })(),
    randomPointInFace: function (e, t, n) {
        var r, i, s, o;
        return (r = t.vertices[e.a]), (i = t.vertices[e.b]), (s = t.vertices[e.c]), THREE.GeometryUtils.randomPointInTriangle(r, i, s);
    },
    randomPointsInGeometry: function (e, t) {
        function p(e) {
            function t(n, r) {
                if (r < n) return n;
                var i = n + Math.floor((r - n) / 2);
                return a[i] > e ? t(n, i - 1) : a[i] < e ? t(i + 1, r) : i;
            }
            var n = t(0, a.length - 1);
            return n;
        }
        var n,
            r,
            i = e.faces,
            s = e.vertices,
            o = i.length,
            u = 0,
            a = [],
            f,
            l,
            c,
            h;
        for (r = 0; r < o; r++) (n = i[r]), (f = s[n.a]), (l = s[n.b]), (c = s[n.c]), (n._area = THREE.GeometryUtils.triangleArea(f, l, c)), (u += n._area), (a[r] = u);
        var d,
            v,
            m = [],
            g = {};
        for (r = 0; r < t; r++) (d = THREE.Math.random16() * u), (v = p(d)), (m[r] = THREE.GeometryUtils.randomPointInFace(i[v], e, !0)), g[v] ? (g[v] += 1) : (g[v] = 1);
        return m;
    },
    triangleArea: (function () {
        var e = new THREE.Vector3(),
            t = new THREE.Vector3();
        return function (n, r, i) {
            return e.subVectors(r, n), t.subVectors(i, n), e.cross(t), 0.5 * e.length();
        };
    })(),
    center: function (e) {
        e.computeBoundingBox();
        var t = e.boundingBox,
            n = new THREE.Vector3();
        return n.addVectors(t.min, t.max), n.multiplyScalar(-0.5), e.applyMatrix(new THREE.Matrix4().makeTranslation(n.x, n.y, n.z)), e.computeBoundingBox(), n;
    },
    triangulateQuads: function (e) {
        var t,
            n,
            r,
            i,
            s = [],
            o = [];
        for (t = 0, n = e.faceVertexUvs.length; t < n; t++) o[t] = [];
        for (t = 0, n = e.faces.length; t < n; t++) {
            var u = e.faces[t];
            s.push(u);
            for (r = 0, i = e.faceVertexUvs.length; r < i; r++) o[r].push(e.faceVertexUvs[r][t]);
        }
        (e.faces = s), (e.faceVertexUvs = o), e.computeCentroids(), e.computeFaceNormals(), e.computeVertexNormals(), e.hasTangents && e.computeTangents();
    },
}),
(THREE.ImageUtils = {
    crossOrigin: "anonymous",
    loadTexture: function (e, t, n, r) {
        var i = new THREE.ImageLoader();
        i.crossOrigin = this.crossOrigin;
        var s = new THREE.Texture(undefined, t),
            o = i.load(e, function () {
                (s.needsUpdate = !0), n && n(s);
            });
        return (s.image = o), (s.sourceFile = e), s;
    },
    loadCompressedTexture: function (e, t, n, r) {
        var i = new THREE.CompressedTexture();
        i.mapping = t;
        var s = new XMLHttpRequest();
        return (
            (s.onload = function () {
                var e = s.response,
                    t = THREE.ImageUtils.parseDDS(e, !0);
                (i.format = t.format), (i.mipmaps = t.mipmaps), (i.image.width = t.width), (i.image.height = t.height), (i.generateMipmaps = !1), (i.needsUpdate = !0), n && n(i);
            }),
                (s.onerror = r),
                s.open("GET", e, !0),
                (s.responseType = "arraybuffer"),
                s.send(null),
                i
        );
    },
    loadTextureCube: function (e, t, n, r) {
        var i = [];
        i.loadCount = 0;
        var s = new THREE.Texture();
        (s.image = i), t !== undefined && (s.mapping = t), (s.flipY = !1);
        for (var o = 0, u = e.length; o < u; ++o) {
            var a = new Image();
            (i[o] = a),
                (a.onload = function () {
                    (i.loadCount += 1), i.loadCount === 6 && ((s.needsUpdate = !0), n && n(s));
                }),
                (a.onerror = r),
                (a.crossOrigin = this.crossOrigin),
                (a.src = e[o]);
        }
        return s;
    },
    loadCompressedTextureCube: function (e, t, n, r) {
        var i = [];
        i.loadCount = 0;
        var s = new THREE.CompressedTexture();
        (s.image = i), t !== undefined && (s.mapping = t), (s.flipY = !1), (s.generateMipmaps = !1);
        var o = function (e, t) {
            return function () {
                var r = e.response,
                    o = THREE.ImageUtils.parseDDS(r, !0);
                (t.format = o.format), (t.mipmaps = o.mipmaps), (t.width = o.width), (t.height = o.height), (i.loadCount += 1), i.loadCount === 6 && ((s.format = o.format), (s.needsUpdate = !0), n && n(s));
            };
        };
        if (e instanceof Array)
            for (var u = 0, a = e.length; u < a; ++u) {
                var f = {};
                i[u] = f;
                var l = new XMLHttpRequest();
                (l.onload = o(l, f)), (l.onerror = r);
                var c = e[u];
                l.open("GET", c, !0), (l.responseType = "arraybuffer"), l.send(null);
            }
        else {
            var c = e,
                l = new XMLHttpRequest();
            (l.onload = function () {
                var e = l.response,
                    t = THREE.ImageUtils.parseDDS(e, !0);
                if (t.isCubemap) {
                    var r = t.mipmaps.length / t.mipmapCount;
                    for (var o = 0; o < r; o++) {
                        i[o] = { mipmaps: [] };
                        for (var u = 0; u < t.mipmapCount; u++) i[o].mipmaps.push(t.mipmaps[o * t.mipmapCount + u]), (i[o].format = t.format), (i[o].width = t.width), (i[o].height = t.height);
                    }
                    (s.format = t.format), (s.needsUpdate = !0), n && n(s);
                }
            }),
                (l.onerror = r),
                l.open("GET", c, !0),
                (l.responseType = "arraybuffer"),
                l.send(null);
        }
        return s;
    },
    loadDDSTexture: function (e, t, n, r) {
        var i = [];
        i.loadCount = 0;
        var s = new THREE.CompressedTexture();
        (s.image = i), t !== undefined && (s.mapping = t), (s.flipY = !1), (s.generateMipmaps = !1);
        var o = new XMLHttpRequest();
        return (
            (o.onload = function () {
                var e = o.response,
                    t = THREE.ImageUtils.parseDDS(e, !0);
                if (t.isCubemap) {
                    var r = t.mipmaps.length / t.mipmapCount;
                    for (var u = 0; u < r; u++) {
                        i[u] = { mipmaps: [] };
                        for (var a = 0; a < t.mipmapCount; a++) i[u].mipmaps.push(t.mipmaps[u * t.mipmapCount + a]), (i[u].format = t.format), (i[u].width = t.width), (i[u].height = t.height);
                    }
                } else (s.image.width = t.width), (s.image.height = t.height), (s.mipmaps = t.mipmaps);
                (s.format = t.format), (s.needsUpdate = !0), n && n(s);
            }),
                (o.onerror = r),
                o.open("GET", e, !0),
                (o.responseType = "arraybuffer"),
                o.send(null),
                s
        );
    },
    parseDDS: function (e, t) {
        function A(e) {
            return e.charCodeAt(0) + (e.charCodeAt(1) << 8) + (e.charCodeAt(2) << 16) + (e.charCodeAt(3) << 24);
        }
        function O(e) {
            return String.fromCharCode(e & 255, (e >> 8) & 255, (e >> 16) & 255, (e >> 24) & 255);
        }
        function M(e, t, n, r) {
            var i = n * r * 4,
                s = new Uint8Array(e, t, i),
                o = new Uint8Array(i),
                u = 0,
                a = 0;
            for (var f = 0; f < r; f++)
                for (var l = 0; l < n; l++) {
                    var c = s[a];
                    a++;
                    var h = s[a];
                    a++;
                    var p = s[a];
                    a++;
                    var d = s[a];
                    a++, (o[u] = p), u++, (o[u] = h), u++, (o[u] = c), u++, (o[u] = d), u++;
                }
            return o;
        }
        var n = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 },
            r = 542327876,
            i = 1,
            s = 2,
            o = 4,
            u = 8,
            a = 4096,
            f = 131072,
            l = 524288,
            c = 8388608,
            h = 8,
            p = 4194304,
            d = 4096,
            v = 512,
            m = 1024,
            g = 2048,
            y = 4096,
            b = 8192,
            w = 16384,
            E = 32768,
            S = 2097152,
            x = 1,
            T = 2,
            N = 4,
            C = 64,
            k = 512,
            L = 131072,
            _ = A("DXT1"),
            D = A("DXT3"),
            P = A("DXT5"),
            H = 31,
            B = 0,
            j = 1,
            F = 2,
            I = 3,
            q = 4,
            R = 7,
            U = 20,
            z = 21,
            W = 22,
            X = 23,
            V = 24,
            $ = 25,
            J = 26,
            K = 27,
            Q = 28,
            G = 29,
            Y = 30,
            Z = new Int32Array(e, 0, H);
        if (Z[B] !== r) return console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"), n;
        if (!Z[U] & N) return console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"), n;
        var et,
            tt = Z[z],
            nt = !1;
        switch (tt) {
            case _:
                (et = 8), (n.format = THREE.RGB_S3TC_DXT1_Format);
                break;
            case D:
                (et = 16), (n.format = THREE.RGBA_S3TC_DXT3_Format);
                break;
            case P:
                (et = 16), (n.format = THREE.RGBA_S3TC_DXT5_Format);
                break;
            default:
                if (!(Z[W] == 32 && Z[X] & 16711680 && Z[V] & 65280 && Z[$] & 255 && Z[J] & 4278190080)) return console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ", O(tt)), n;
                (nt = !0), (et = 64), (n.format = THREE.RGBAFormat);
        }
        (n.mipmapCount = 1), Z[F] & f && t !== !1 && (n.mipmapCount = Math.max(1, Z[R])), (n.isCubemap = Z[Q] & v ? !0 : !1), (n.width = Z[q]), (n.height = Z[I]);
        var rt = Z[j] + 4,
            it = n.width,
            st = n.height,
            ot = n.isCubemap ? 6 : 1;
        for (var ut = 0; ut < ot; ut++) {
            for (var at = 0; at < n.mipmapCount; at++) {
                if (nt)
                    var ft = M(e, rt, it, st),
                        lt = ft.length;
                else
                    var lt = (((Math.max(4, it) / 4) * Math.max(4, st)) / 4) * et,
                        ft = new Uint8Array(e, rt, lt);
                var ct = { data: ft, width: it, height: st };
                n.mipmaps.push(ct), (rt += lt), (it = Math.max(it * 0.5, 1)), (st = Math.max(st * 0.5, 1));
            }
            (it = n.width), (st = n.height);
        }
        return n;
    },
    getNormalMap: function (e, t) {
        var n = function (e, t) {
                return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
            },
            r = function (e, t) {
                return [e[0] - t[0], e[1] - t[1], e[2] - t[2]];
            },
            i = function (e) {
                var t = Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
                return [e[0] / t, e[1] / t, e[2] / t];
            };
        t |= 1;
        var s = e.width,
            o = e.height,
            u = document.createElement("canvas");
        (u.width = s), (u.height = o);
        var a = u.getContext("2d");
        a.drawImage(e, 0, 0);
        var f = a.getImageData(0, 0, s, o).data,
            l = a.createImageData(s, o),
            c = l.data;
        for (var h = 0; h < s; h++)
            for (var p = 0; p < o; p++) {
                var d = p - 1 < 0 ? 0 : p - 1,
                    v = p + 1 > o - 1 ? o - 1 : p + 1,
                    m = h - 1 < 0 ? 0 : h - 1,
                    g = h + 1 > s - 1 ? s - 1 : h + 1,
                    y = [],
                    b = [0, 0, (f[(p * s + h) * 4] / 255) * t];
                y.push([-1, 0, (f[(p * s + m) * 4] / 255) * t]),
                    y.push([-1, -1, (f[(d * s + m) * 4] / 255) * t]),
                    y.push([0, -1, (f[(d * s + h) * 4] / 255) * t]),
                    y.push([1, -1, (f[(d * s + g) * 4] / 255) * t]),
                    y.push([1, 0, (f[(p * s + g) * 4] / 255) * t]),
                    y.push([1, 1, (f[(v * s + g) * 4] / 255) * t]),
                    y.push([0, 1, (f[(v * s + h) * 4] / 255) * t]),
                    y.push([-1, 1, (f[(v * s + m) * 4] / 255) * t]);
                var w = [],
                    E = y.length;
                for (var S = 0; S < E; S++) {
                    var x = y[S],
                        T = y[(S + 1) % E];
                    (x = r(x, b)), (T = r(T, b)), w.push(i(n(x, T)));
                }
                var N = [0, 0, 0];
                for (var S = 0; S < w.length; S++) (N[0] += w[S][0]), (N[1] += w[S][1]), (N[2] += w[S][2]);
                (N[0] /= w.length), (N[1] /= w.length), (N[2] /= w.length);
                var C = (p * s + h) * 4;
                (c[C] = (((N[0] + 1) / 2) * 255) | 0), (c[C + 1] = (((N[1] + 1) / 2) * 255) | 0), (c[C + 2] = (N[2] * 255) | 0), (c[C + 3] = 255);
            }
        return a.putImageData(l, 0, 0), u;
    },
    generateDataTexture: function (e, t, n) {
        var r = e * t,
            i = new Uint8Array(3 * r),
            s = Math.floor(n.r * 255),
            o = Math.floor(n.g * 255),
            u = Math.floor(n.b * 255);
        for (var a = 0; a < r; a++) (i[a * 3] = s), (i[a * 3 + 1] = o), (i[a * 3 + 2] = u);
        var f = new THREE.DataTexture(i, e, t, THREE.RGBFormat);
        return (f.needsUpdate = !0), f;
    },
}),
(THREE.SceneUtils = {
    createMultiMaterialObject: function (e, t) {
        var n = new THREE.Object3D();
        for (var r = 0, i = t.length; r < i; r++) n.add(new THREE.Mesh(e, t[r]));
        return n;
    },
    detach: function (e, t, n) {
        e.applyMatrix(t.matrixWorld), t.remove(e), n.add(e);
    },
    attach: function (e, t, n) {
        var r = new THREE.Matrix4();
        r.getInverse(n.matrixWorld), e.applyMatrix(r), t.remove(e), n.add(e);
    },
}),
(THREE.FontUtils = {
    faces: {},
    face: "helvetiker",
    weight: "normal",
    style: "normal",
    size: 150,
    divisions: 10,
    getFace: function () {
        return this.faces[this.face][this.weight][this.style];
    },
    loadFace: function (e) {
        var t = e.familyName.toLowerCase(),
            n = this;
        (n.faces[t] = n.faces[t] || {}), (n.faces[t][e.cssFontWeight] = n.faces[t][e.cssFontWeight] || {}), (n.faces[t][e.cssFontWeight][e.cssFontStyle] = e);
        var r = (n.faces[t][e.cssFontWeight][e.cssFontStyle] = e);
        return e;
    },
    drawText: function (e) {
        var t = [],
            n = [],
            r,
            i,
            s = this.getFace(),
            o = this.size / s.resolution,
            u = 0,
            a = String(e).split(""),
            f = a.length,
            l = [];
        for (r = 0; r < f; r++) {
            var c = new THREE.Path(),
                h = this.extractGlyphPoints(a[r], s, o, u, c);
            (u += h.offset), l.push(h.path);
        }
        var p = u / 2;
        return { paths: l, offset: p };
    },
    extractGlyphPoints: function (e, t, n, r, i) {
        var s = [],
            o,
            u,
            a,
            f,
            l,
            c,
            h,
            p,
            d,
            v,
            m,
            g,
            y,
            b,
            w,
            E,
            S,
            x,
            T,
            N = t.glyphs[e] || t.glyphs["?"];
        if (!N) return;
        if (N.o) {
            (f = N._cachedOutline || (N._cachedOutline = N.o.split(" "))), (c = f.length), (h = n), (p = n);
            for (o = 0; o < c; ) {
                l = f[o++];
                switch (l) {
                    case "m":
                        (d = f[o++] * h + r), (v = f[o++] * p), i.moveTo(d, v);
                        break;
                    case "l":
                        (d = f[o++] * h + r), (v = f[o++] * p), i.lineTo(d, v);
                        break;
                    case "q":
                        (m = f[o++] * h + r), (g = f[o++] * p), (w = f[o++] * h + r), (E = f[o++] * p), i.quadraticCurveTo(w, E, m, g), (T = s[s.length - 1]);
                        if (T) {
                            (y = T.x), (b = T.y);
                            for (u = 1, a = this.divisions; u <= a; u++) var C = u / a, k = THREE.Shape.Utils.b2(C, y, w, m), L = THREE.Shape.Utils.b2(C, b, E, g);
                        }
                        break;
                    case "b":
                        (m = f[o++] * h + r), (g = f[o++] * p), (w = f[o++] * h + r), (E = f[o++] * -p), (S = f[o++] * h + r), (x = f[o++] * -p), i.bezierCurveTo(m, g, w, E, S, x), (T = s[s.length - 1]);
                        if (T) {
                            (y = T.x), (b = T.y);
                            for (u = 1, a = this.divisions; u <= a; u++) var C = u / a, k = THREE.Shape.Utils.b3(C, y, w, S, m), L = THREE.Shape.Utils.b3(C, b, E, x, g);
                        }
                }
            }
        }
        return { offset: N.ha * n, path: i };
    },
}),
(THREE.FontUtils.generateShapes = function (e, t) {
    t = t || {};
    var n = t.size !== undefined ? t.size : 100,
        r = t.curveSegments !== undefined ? t.curveSegments : 4,
        i = t.font !== undefined ? t.font : "helvetiker",
        s = t.weight !== undefined ? t.weight : "normal",
        o = t.style !== undefined ? t.style : "normal";
    (THREE.FontUtils.size = n), (THREE.FontUtils.divisions = r), (THREE.FontUtils.face = i), (THREE.FontUtils.weight = s), (THREE.FontUtils.style = o);
    var u = THREE.FontUtils.drawText(e),
        a = u.paths,
        f = [];
    for (var l = 0, c = a.length; l < c; l++) Array.prototype.push.apply(f, a[l].toShapes());
    return f;
}),
(function (e) {
    var t = 1e-10,
        n = function (e, t) {
            var n = e.length;
            if (n < 3) return null;
            var s = [],
                o = [],
                u = [],
                a,
                f,
                l;
            if (r(e) > 0) for (f = 0; f < n; f++) o[f] = f;
            else for (f = 0; f < n; f++) o[f] = n - 1 - f;
            var c = n,
                h = 2 * c;
            for (f = c - 1; c > 2; ) {
                if (h-- <= 0) return console.log("Warning, unable to triangulate polygon!"), t ? u : s;
                (a = f), c <= a && (a = 0), (f = a + 1), c <= f && (f = 0), (l = f + 1), c <= l && (l = 0);
                if (i(e, a, f, l, c, o)) {
                    var p, d, v, m, g;
                    (p = o[a]), (d = o[f]), (v = o[l]), s.push([e[p], e[d], e[v]]), u.push([o[a], o[f], o[l]]);
                    for (m = f, g = f + 1; g < c; m++, g++) o[m] = o[g];
                    c--, (h = 2 * c);
                }
            }
            return t ? u : s;
        },
        r = function (e) {
            var t = e.length,
                n = 0;
            for (var r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
            return n * 0.5;
        },
        i = function (e, n, r, i, s, o) {
            var u, a, f, l, c, h, p, d, v;
            (a = e[o[n]].x), (f = e[o[n]].y), (l = e[o[r]].x), (c = e[o[r]].y), (h = e[o[i]].x), (p = e[o[i]].y);
            if (t > (l - a) * (p - f) - (c - f) * (h - a)) return !1;
            var m, g, y, b, w, E, S, x, T, N, C, k, L, A, O;
            (m = h - l), (g = p - c), (y = a - h), (b = f - p), (w = l - a), (E = c - f);
            for (u = 0; u < s; u++) {
                if (u === n || u === r || u === i) continue;
                (d = e[o[u]].x), (v = e[o[u]].y), (S = d - a), (x = v - f), (T = d - l), (N = v - c), (C = d - h), (k = v - p), (O = m * N - g * T), (L = w * x - E * S), (A = y * k - b * C);
                if (O >= -t && A >= -t && L >= -t) return !1;
            }
            return !0;
        };
    return (e.Triangulate = n), (e.Triangulate.area = r), e;
})(THREE.FontUtils),
(self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace }),
(THREE.typeface_js = self._typeface_js),
(THREE.Curve = function () {}),
(THREE.Curve.prototype.getPoint = function (e) {
    return console.log("Warning, getPoint() not implemented!"), null;
}),
(THREE.Curve.prototype.getPointAt = function (e) {
    var t = this.getUtoTmapping(e);
    return this.getPoint(t);
}),
(THREE.Curve.prototype.getPoints = function (e) {
    e || (e = 5);
    var t,
        n = [];
    for (t = 0; t <= e; t++) n.push(this.getPoint(t / e));
    return n;
}),
(THREE.Curve.prototype.getSpacedPoints = function (e) {
    e || (e = 5);
    var t,
        n = [];
    for (t = 0; t <= e; t++) n.push(this.getPointAt(t / e));
    return n;
}),
(THREE.Curve.prototype.getLength = function () {
    var e = this.getLengths();
    return e[e.length - 1];
}),
(THREE.Curve.prototype.getLengths = function (e) {
    e || (e = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
    if (this.cacheArcLengths && this.cacheArcLengths.length == e + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = !1;
    var t = [],
        n,
        r = this.getPoint(0),
        i,
        s = 0;
    t.push(0);
    for (i = 1; i <= e; i++) (n = this.getPoint(i / e)), (s += n.distanceTo(r)), t.push(s), (r = n);
    return (this.cacheArcLengths = t), t;
}),
(THREE.Curve.prototype.updateArcLengths = function () {
    (this.needsUpdate = !0), this.getLengths();
}),
(THREE.Curve.prototype.getUtoTmapping = function (e, t) {
    var n = this.getLengths(),
        r = 0,
        i = n.length,
        s;
    t ? (s = t) : (s = e * n[i - 1]);
    var o = 0,
        u = i - 1,
        a;
    while (o <= u) {
        (r = Math.floor(o + (u - o) / 2)), (a = n[r] - s);
        if (a < 0) {
            o = r + 1;
            continue;
        }
        if (a > 0) {
            u = r - 1;
            continue;
        }
        u = r;
        break;
    }
    r = u;
    if (n[r] == s) {
        var f = r / (i - 1);
        return f;
    }
    var l = n[r],
        c = n[r + 1],
        h = c - l,
        p = (s - l) / h,
        f = (r + p) / (i - 1);
    return f;
}),
(THREE.Curve.prototype.getTangent = function (e) {
    var t = 1e-4,
        n = e - t,
        r = e + t;
    n < 0 && (n = 0), r > 1 && (r = 1);
    var i = this.getPoint(n),
        s = this.getPoint(r),
        o = s.clone().sub(i);
    return o.normalize();
}),
(THREE.Curve.prototype.getTangentAt = function (e) {
    var t = this.getUtoTmapping(e);
    return this.getTangent(t);
}),
(THREE.Curve.Utils = {
    tangentQuadraticBezier: function (e, t, n, r) {
        return 2 * (1 - e) * (n - t) + 2 * e * (r - n);
    },
    tangentCubicBezier: function (e, t, n, r, i) {
        return -3 * t * (1 - e) * (1 - e) + 3 * n * (1 - e) * (1 - e) - 6 * e * n * (1 - e) + 6 * e * r * (1 - e) - 3 * e * e * r + 3 * e * e * i;
    },
    tangentSpline: function (e, t, n, r, i) {
        var s = 6 * e * e - 6 * e,
            o = 3 * e * e - 4 * e + 1,
            u = -6 * e * e + 6 * e,
            a = 3 * e * e - 2 * e;
        return s + o + u + a;
    },
    interpolate: function (e, t, n, r, i) {
        var s = (n - e) * 0.5,
            o = (r - t) * 0.5,
            u = i * i,
            a = i * u;
        return (2 * t - 2 * n + s + o) * a + (-3 * t + 3 * n - 2 * s - o) * u + s * i + t;
    },
}),
(THREE.Curve.create = function (e, t) {
    return (e.prototype = Object.create(THREE.Curve.prototype)), (e.prototype.getPoint = t), e;
}),
(THREE.CurvePath = function () {
    (this.curves = []), (this.bends = []), (this.autoClose = !1);
}),
(THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype)),
(THREE.CurvePath.prototype.add = function (e) {
    this.curves.push(e);
}),
(THREE.CurvePath.prototype.checkConnection = function () {}),
(THREE.CurvePath.prototype.closePath = function () {
    var e = this.curves[0].getPoint(0),
        t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new THREE.LineCurve(t, e));
}),
(THREE.CurvePath.prototype.getPoint = function (e) {
    var t = e * this.getLength(),
        n = this.getCurveLengths(),
        r = 0,
        i,
        s;
    while (r < n.length) {
        if (n[r] >= t) {
            (i = n[r] - t), (s = this.curves[r]);
            var o = 1 - i / s.getLength();
            return s.getPointAt(o);
        }
        r++;
    }
    return null;
}),
(THREE.CurvePath.prototype.getLength = function () {
    var e = this.getCurveLengths();
    return e[e.length - 1];
}),
(THREE.CurvePath.prototype.getCurveLengths = function () {
    if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
    var e = [],
        t = 0,
        n,
        r = this.curves.length;
    for (n = 0; n < r; n++) (t += this.curves[n].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
}),
(THREE.CurvePath.prototype.getBoundingBox = function () {
    var e = this.getPoints(),
        t,
        n,
        r,
        i,
        s,
        o;
    (t = n = Number.NEGATIVE_INFINITY), (i = s = Number.POSITIVE_INFINITY);
    var u,
        a,
        f,
        l,
        c = e[0] instanceof THREE.Vector3;
    l = c ? new THREE.Vector3() : new THREE.Vector2();
    for (a = 0, f = e.length; a < f; a++) (u = e[a]), u.x > t ? (t = u.x) : u.x < i && (i = u.x), u.y > n ? (n = u.y) : u.y < s && (s = u.y), c && (u.z > r ? (r = u.z) : u.z < o && (o = u.z)), l.add(u);
    var h = { minX: i, minY: s, maxX: t, maxY: n, centroid: l.divideScalar(f) };
    return c && ((h.maxZ = r), (h.minZ = o)), h;
}),
(THREE.CurvePath.prototype.createPointsGeometry = function (e) {
    var t = this.getPoints(e, !0);
    return this.createGeometry(t);
}),
(THREE.CurvePath.prototype.createSpacedPointsGeometry = function (e) {
    var t = this.getSpacedPoints(e, !0);
    return this.createGeometry(t);
}),
(THREE.CurvePath.prototype.createGeometry = function (e) {
    var t = new THREE.Geometry();
    for (var n = 0; n < e.length; n++) t.vertices.push(new THREE.Vector3(e[n].x, e[n].y, e[n].z || 0));
    return t;
}),
(THREE.CurvePath.prototype.addWrapPath = function (e) {
    this.bends.push(e);
}),
(THREE.CurvePath.prototype.getTransformedPoints = function (e, t) {
    var n = this.getPoints(e),
        r,
        i;
    t || (t = this.bends);
    for (r = 0, i = t.length; r < i; r++) n = this.getWrapPoints(n, t[r]);
    return n;
}),
(THREE.CurvePath.prototype.getTransformedSpacedPoints = function (e, t) {
    var n = this.getSpacedPoints(e),
        r,
        i;
    t || (t = this.bends);
    for (r = 0, i = t.length; r < i; r++) n = this.getWrapPoints(n, t[r]);
    return n;
}),
(THREE.CurvePath.prototype.getWrapPoints = function (e, t) {
    var n = this.getBoundingBox(),
        r,
        i,
        s,
        o,
        u,
        a;
    for (r = 0, i = e.length; r < i; r++) {
        (s = e[r]), (o = s.x), (u = s.y), (a = o / n.maxX), (a = t.getUtoTmapping(a, o));
        var f = t.getPoint(a),
            l = t.getNormalVector(a).multiplyScalar(u);
        (s.x = f.x + l.x), (s.y = f.y + l.y);
    }
    return e;
}),
(THREE.Gyroscope = function () {
    THREE.Object3D.call(this);
}),
(THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.Gyroscope.prototype.updateMatrixWorld = function (e) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || e)
        this.parent
            ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld),
                this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject),
                this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld))
            : this.matrixWorld.copy(this.matrix),
            (this.matrixWorldNeedsUpdate = !1),
            (e = !0);
    for (var t = 0, n = this.children.length; t < n; t++) this.children[t].updateMatrixWorld(e);
}),
(THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3()),
(THREE.Gyroscope.prototype.translationObject = new THREE.Vector3()),
(THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion()),
(THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion()),
(THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3()),
(THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3()),
(THREE.Path = function (e) {
    THREE.CurvePath.call(this), (this.actions = []), e && this.fromPoints(e);
}),
(THREE.Path.prototype = Object.create(THREE.CurvePath.prototype)),
(THREE.PathActions = { MOVE_TO: "moveTo", LINE_TO: "lineTo", QUADRATIC_CURVE_TO: "quadraticCurveTo", BEZIER_CURVE_TO: "bezierCurveTo", CSPLINE_THRU: "splineThru", ARC: "arc", ELLIPSE: "ellipse" }),
(THREE.Path.prototype.fromPoints = function (e) {
    this.moveTo(e[0].x, e[0].y);
    for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
}),
(THREE.Path.prototype.moveTo = function (e, t) {
    var n = Array.prototype.slice.call(arguments);
    this.actions.push({ action: THREE.PathActions.MOVE_TO, args: n });
}),
(THREE.Path.prototype.lineTo = function (e, t) {
    var n = Array.prototype.slice.call(arguments),
        r = this.actions[this.actions.length - 1].args,
        i = r[r.length - 2],
        s = r[r.length - 1],
        o = new THREE.LineCurve(new THREE.Vector2(i, s), new THREE.Vector2(e, t));
    this.curves.push(o), this.actions.push({ action: THREE.PathActions.LINE_TO, args: n });
}),
(THREE.Path.prototype.quadraticCurveTo = function (e, t, n, r) {
    var i = Array.prototype.slice.call(arguments),
        s = this.actions[this.actions.length - 1].args,
        o = s[s.length - 2],
        u = s[s.length - 1],
        a = new THREE.QuadraticBezierCurve(new THREE.Vector2(o, u), new THREE.Vector2(e, t), new THREE.Vector2(n, r));
    this.curves.push(a), this.actions.push({ action: THREE.PathActions.QUADRATIC_CURVE_TO, args: i });
}),
(THREE.Path.prototype.bezierCurveTo = function (e, t, n, r, i, s) {
    var o = Array.prototype.slice.call(arguments),
        u = this.actions[this.actions.length - 1].args,
        a = u[u.length - 2],
        f = u[u.length - 1],
        l = new THREE.CubicBezierCurve(new THREE.Vector2(a, f), new THREE.Vector2(e, t), new THREE.Vector2(n, r), new THREE.Vector2(i, s));
    this.curves.push(l), this.actions.push({ action: THREE.PathActions.BEZIER_CURVE_TO, args: o });
}),
(THREE.Path.prototype.splineThru = function (e) {
    var t = Array.prototype.slice.call(arguments),
        n = this.actions[this.actions.length - 1].args,
        r = n[n.length - 2],
        i = n[n.length - 1],
        s = [new THREE.Vector2(r, i)];
    Array.prototype.push.apply(s, e);
    var o = new THREE.SplineCurve(s);
    this.curves.push(o), this.actions.push({ action: THREE.PathActions.CSPLINE_THRU, args: t });
}),
(THREE.Path.prototype.arc = function (e, t, n, r, i, s) {
    var o = this.actions[this.actions.length - 1].args,
        u = o[o.length - 2],
        a = o[o.length - 1];
    this.absarc(e + u, t + a, n, r, i, s);
}),
(THREE.Path.prototype.absarc = function (e, t, n, r, i, s) {
    this.absellipse(e, t, n, n, r, i, s);
}),
(THREE.Path.prototype.ellipse = function (e, t, n, r, i, s, o) {
    var u = this.actions[this.actions.length - 1].args,
        a = u[u.length - 2],
        f = u[u.length - 1];
    this.absellipse(e + a, t + f, n, r, i, s, o);
}),
(THREE.Path.prototype.absellipse = function (e, t, n, r, i, s, o) {
    var u = Array.prototype.slice.call(arguments),
        a = new THREE.EllipseCurve(e, t, n, r, i, s, o);
    this.curves.push(a);
    var f = a.getPoint(1);
    u.push(f.x), u.push(f.y), this.actions.push({ action: THREE.PathActions.ELLIPSE, args: u });
}),
(THREE.Path.prototype.getSpacedPoints = function (e, t) {
    e || (e = 40);
    var n = [];
    for (var r = 0; r < e; r++) n.push(this.getPoint(r / e));
    return n;
}),
(THREE.Path.prototype.getPoints = function (e, t) {
    if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(e, t);
    e = e || 12;
    var n = [],
        r,
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g,
        y,
        b,
        w;
    for (r = 0, i = this.actions.length; r < i; r++) {
        (s = this.actions[r]), (o = s.action), (u = s.args);
        switch (o) {
            case THREE.PathActions.MOVE_TO:
                n.push(new THREE.Vector2(u[0], u[1]));
                break;
            case THREE.PathActions.LINE_TO:
                n.push(new THREE.Vector2(u[0], u[1]));
                break;
            case THREE.PathActions.QUADRATIC_CURVE_TO:
                (a = u[2]), (f = u[3]), (h = u[0]), (p = u[1]), n.length > 0 ? ((m = n[n.length - 1]), (d = m.x), (v = m.y)) : ((m = this.actions[r - 1].args), (d = m[m.length - 2]), (v = m[m.length - 1]));
                for (g = 1; g <= e; g++) (y = g / e), (b = THREE.Shape.Utils.b2(y, d, h, a)), (w = THREE.Shape.Utils.b2(y, v, p, f)), n.push(new THREE.Vector2(b, w));
                break;
            case THREE.PathActions.BEZIER_CURVE_TO:
                (a = u[4]), (f = u[5]), (h = u[0]), (p = u[1]), (l = u[2]), (c = u[3]), n.length > 0 ? ((m = n[n.length - 1]), (d = m.x), (v = m.y)) : ((m = this.actions[r - 1].args), (d = m[m.length - 2]), (v = m[m.length - 1]));
                for (g = 1; g <= e; g++) (y = g / e), (b = THREE.Shape.Utils.b3(y, d, h, l, a)), (w = THREE.Shape.Utils.b3(y, v, p, c, f)), n.push(new THREE.Vector2(b, w));
                break;
            case THREE.PathActions.CSPLINE_THRU:
                m = this.actions[r - 1].args;
                var E = new THREE.Vector2(m[m.length - 2], m[m.length - 1]),
                    S = [E],
                    x = e * u[0].length;
                S = S.concat(u[0]);
                var T = new THREE.SplineCurve(S);
                for (g = 1; g <= x; g++) n.push(T.getPointAt(g / x));
                break;
            case THREE.PathActions.ARC:
                var N = u[0],
                    C = u[1],
                    k = u[2],
                    L = u[3],
                    A = u[4],
                    O = !!u[5],
                    M = A - L,
                    _,
                    D = e * 2;
                for (g = 1; g <= D; g++) (y = g / D), O || (y = 1 - y), (_ = L + y * M), (b = N + k * Math.cos(_)), (w = C + k * Math.sin(_)), n.push(new THREE.Vector2(b, w));
                break;
            case THREE.PathActions.ELLIPSE:
                var N = u[0],
                    C = u[1],
                    P = u[2],
                    H = u[3],
                    L = u[4],
                    A = u[5],
                    O = !!u[6],
                    M = A - L,
                    _,
                    D = e * 2;
                for (g = 1; g <= D; g++) (y = g / D), O || (y = 1 - y), (_ = L + y * M), (b = N + P * Math.cos(_)), (w = C + H * Math.sin(_)), n.push(new THREE.Vector2(b, w));
        }
    }
    var B = n[n.length - 1],
        j = 1e-10;
    return Math.abs(B.x - n[0].x) < j && Math.abs(B.y - n[0].y) < j && n.splice(n.length - 1, 1), t && n.push(n[0]), n;
}),
(THREE.Path.prototype.toShapes = function (e) {
    var t,
        n,
        r,
        i,
        s,
        o = [],
        u = new THREE.Path();
    for (t = 0, n = this.actions.length; t < n; t++) (r = this.actions[t]), (s = r.args), (i = r.action), i == THREE.PathActions.MOVE_TO && u.actions.length != 0 && (o.push(u), (u = new THREE.Path())), u[i].apply(u, s);
    u.actions.length != 0 && o.push(u);
    if (o.length == 0) return [];
    var a,
        f,
        l,
        c = [];
    if (o.length == 1) return (f = o[0]), (l = new THREE.Shape()), (l.actions = f.actions), (l.curves = f.curves), c.push(l), c;
    var h = !THREE.Shape.Utils.isClockWise(o[0].getPoints());
    h = e ? !h : h;
    if (h) {
        l = new THREE.Shape();
        for (t = 0, n = o.length; t < n; t++) (f = o[t]), (a = THREE.Shape.Utils.isClockWise(f.getPoints())), (a = e ? !a : a), a ? ((l.actions = f.actions), (l.curves = f.curves), c.push(l), (l = new THREE.Shape())) : l.holes.push(f);
    } else {
        l = undefined;
        for (t = 0, n = o.length; t < n; t++)
            (f = o[t]), (a = THREE.Shape.Utils.isClockWise(f.getPoints())), (a = e ? !a : a), a ? (l && c.push(l), (l = new THREE.Shape()), (l.actions = f.actions), (l.curves = f.curves)) : l.holes.push(f);
        c.push(l);
    }
    return c;
}),
(THREE.Shape = function () {
    THREE.Path.apply(this, arguments), (this.holes = []);
}),
(THREE.Shape.prototype = Object.create(THREE.Path.prototype)),
(THREE.Shape.prototype.extrude = function (e) {
    var t = new THREE.ExtrudeGeometry(this, e);
    return t;
}),
(THREE.Shape.prototype.makeGeometry = function (e) {
    var t = new THREE.ShapeGeometry(this, e);
    return t;
}),
(THREE.Shape.prototype.getPointsHoles = function (e) {
    var t,
        n = this.holes.length,
        r = [];
    for (t = 0; t < n; t++) r[t] = this.holes[t].getTransformedPoints(e, this.bends);
    return r;
}),
(THREE.Shape.prototype.getSpacedPointsHoles = function (e) {
    var t,
        n = this.holes.length,
        r = [];
    for (t = 0; t < n; t++) r[t] = this.holes[t].getTransformedSpacedPoints(e, this.bends);
    return r;
}),
(THREE.Shape.prototype.extractAllPoints = function (e) {
    return { shape: this.getTransformedPoints(e), holes: this.getPointsHoles(e) };
}),
(THREE.Shape.prototype.extractPoints = function (e) {
    return this.useSpacedPoints ? this.extractAllSpacedPoints(e) : this.extractAllPoints(e);
}),
(THREE.Shape.prototype.extractAllSpacedPoints = function (e) {
    return { shape: this.getTransformedSpacedPoints(e), holes: this.getSpacedPointsHoles(e) };
}),
(THREE.Shape.Utils = {
    removeHoles: function (e, t) {
        var n = e.concat(),
            r = n.concat(),
            i,
            s,
            o,
            u,
            a,
            f,
            l,
            c,
            h,
            p,
            d,
            v,
            m,
            g,
            y,
            b,
            w,
            E,
            S,
            x,
            T = [];
        for (h = 0; h < t.length; h++) {
            (d = t[h]), Array.prototype.push.apply(r, d), (v = Number.POSITIVE_INFINITY);
            for (p = 0; p < d.length; p++) {
                y = d[p];
                var N = [];
                for (g = 0; g < n.length; g++) (b = n[g]), (m = y.distanceToSquared(b)), N.push(m), m < v && ((v = m), (a = p), (f = g));
            }
            (i = f - 1 >= 0 ? f - 1 : n.length - 1), (o = a - 1 >= 0 ? a - 1 : d.length - 1);
            var C = [d[a], n[f], n[i]],
                k = THREE.FontUtils.Triangulate.area(C),
                L = [d[a], d[o], n[f]],
                A = THREE.FontUtils.Triangulate.area(L),
                O = 1,
                M = -1,
                _ = f,
                D = a;
            (f += O), (a += M), f < 0 && (f += n.length), (f %= n.length), a < 0 && (a += d.length), (a %= d.length), (i = f - 1 >= 0 ? f - 1 : n.length - 1), (o = a - 1 >= 0 ? a - 1 : d.length - 1), (C = [d[a], n[f], n[i]]);
            var P = THREE.FontUtils.Triangulate.area(C);
            L = [d[a], d[o], n[f]];
            var H = THREE.FontUtils.Triangulate.area(L);
            k + A > P + H && ((f = _), (a = D), f < 0 && (f += n.length), (f %= n.length), a < 0 && (a += d.length), (a %= d.length), (i = f - 1 >= 0 ? f - 1 : n.length - 1), (o = a - 1 >= 0 ? a - 1 : d.length - 1)),
                (w = n.slice(0, f)),
                (E = n.slice(f)),
                (S = d.slice(a)),
                (x = d.slice(0, a));
            var B = [d[a], n[f], n[i]],
                j = [d[a], d[o], n[f]];
            T.push(B), T.push(j), (n = w.concat(S).concat(x).concat(E));
        }
        return { shape: n, isolatedPts: T, allpoints: r };
    },
    triangulateShape: function (e, t) {
        var n = THREE.Shape.Utils.removeHoles(e, t),
            r = n.shape,
            i = n.allpoints,
            s = n.isolatedPts,
            o = THREE.FontUtils.Triangulate(r, !1),
            u,
            a,
            f,
            l,
            c,
            h,
            p = {},
            d = {};
        for (u = 0, a = i.length; u < a; u++) (c = i[u].x + ":" + i[u].y), p[c] !== undefined && console.log("Duplicate point", c), (p[c] = u);
        for (u = 0, a = o.length; u < a; u++) {
            l = o[u];
            for (f = 0; f < 3; f++) (c = l[f].x + ":" + l[f].y), (h = p[c]), h !== undefined && (l[f] = h);
        }
        for (u = 0, a = s.length; u < a; u++) {
            l = s[u];
            for (f = 0; f < 3; f++) (c = l[f].x + ":" + l[f].y), (h = p[c]), h !== undefined && (l[f] = h);
        }
        return o.concat(s);
    },
    isClockWise: function (e) {
        return THREE.FontUtils.Triangulate.area(e) < 0;
    },
    b2p0: function (e, t) {
        var n = 1 - e;
        return n * n * t;
    },
    b2p1: function (e, t) {
        return 2 * (1 - e) * e * t;
    },
    b2p2: function (e, t) {
        return e * e * t;
    },
    b2: function (e, t, n, r) {
        return this.b2p0(e, t) + this.b2p1(e, n) + this.b2p2(e, r);
    },
    b3p0: function (e, t) {
        var n = 1 - e;
        return n * n * n * t;
    },
    b3p1: function (e, t) {
        var n = 1 - e;
        return 3 * n * n * e * t;
    },
    b3p2: function (e, t) {
        var n = 1 - e;
        return 3 * n * e * e * t;
    },
    b3p3: function (e, t) {
        return e * e * e * t;
    },
    b3: function (e, t, n, r, i) {
        return this.b3p0(e, t) + this.b3p1(e, n) + this.b3p2(e, r) + this.b3p3(e, i);
    },
}),
(THREE.LineCurve = function (e, t) {
    (this.v1 = e), (this.v2 = t);
}),
(THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype)),
(THREE.LineCurve.prototype.getPoint = function (e) {
    var t = this.v2.clone().sub(this.v1);
    return t.multiplyScalar(e).add(this.v1), t;
}),
(THREE.LineCurve.prototype.getPointAt = function (e) {
    return this.getPoint(e);
}),
(THREE.LineCurve.prototype.getTangent = function (e) {
    var t = this.v2.clone().sub(this.v1);
    return t.normalize();
}),
(THREE.QuadraticBezierCurve = function (e, t, n) {
    (this.v0 = e), (this.v1 = t), (this.v2 = n);
}),
(THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype)),
(THREE.QuadraticBezierCurve.prototype.getPoint = function (e) {
    var t, n;
    return (t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x)), (n = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y)), new THREE.Vector2(t, n);
}),
(THREE.QuadraticBezierCurve.prototype.getTangent = function (e) {
    var t, n;
    (t = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.x, this.v1.x, this.v2.x)), (n = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.y, this.v1.y, this.v2.y));
    var r = new THREE.Vector2(t, n);
    return r.normalize(), r;
}),
(THREE.CubicBezierCurve = function (e, t, n, r) {
    (this.v0 = e), (this.v1 = t), (this.v2 = n), (this.v3 = r);
}),
(THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype)),
(THREE.CubicBezierCurve.prototype.getPoint = function (e) {
    var t, n;
    return (t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x)), (n = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y)), new THREE.Vector2(t, n);
}),
(THREE.CubicBezierCurve.prototype.getTangent = function (e) {
    var t, n;
    (t = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x)), (n = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
    var r = new THREE.Vector2(t, n);
    return r.normalize(), r;
}),
(THREE.SplineCurve = function (e) {
    this.points = e == undefined ? [] : e;
}),
(THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype)),
(THREE.SplineCurve.prototype.getPoint = function (e) {
    var t = new THREE.Vector2(),
        n = [],
        r = this.points,
        i,
        s,
        o;
    return (
        (i = (r.length - 1) * e),
            (s = Math.floor(i)),
            (o = i - s),
            (n[0] = s == 0 ? s : s - 1),
            (n[1] = s),
            (n[2] = s > r.length - 2 ? r.length - 1 : s + 1),
            (n[3] = s > r.length - 3 ? r.length - 1 : s + 2),
            (t.x = THREE.Curve.Utils.interpolate(r[n[0]].x, r[n[1]].x, r[n[2]].x, r[n[3]].x, o)),
            (t.y = THREE.Curve.Utils.interpolate(r[n[0]].y, r[n[1]].y, r[n[2]].y, r[n[3]].y, o)),
            t
    );
}),
(THREE.EllipseCurve = function (e, t, n, r, i, s, o) {
    (this.aX = e), (this.aY = t), (this.xRadius = n), (this.yRadius = r), (this.aStartAngle = i), (this.aEndAngle = s), (this.aClockwise = o);
}),
(THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype)),
(THREE.EllipseCurve.prototype.getPoint = function (e) {
    var t,
        n = this.aEndAngle - this.aStartAngle;
    n < 0 && (n += Math.PI * 2), n > Math.PI * 2 && (n -= Math.PI * 2), this.aClockwise === !0 ? (t = this.aEndAngle + (1 - e) * (Math.PI * 2 - n)) : (t = this.aStartAngle + e * n);
    var r = this.aX + this.xRadius * Math.cos(t),
        i = this.aY + this.yRadius * Math.sin(t);
    return new THREE.Vector2(r, i);
}),
(THREE.ArcCurve = function (e, t, n, r, i, s) {
    THREE.EllipseCurve.call(this, e, t, n, n, r, i, s);
}),
(THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype)),
(THREE.LineCurve3 = THREE.Curve.create(
    function (e, t) {
        (this.v1 = e), (this.v2 = t);
    },
    function (e) {
        var t = new THREE.Vector3();
        return t.subVectors(this.v2, this.v1), t.multiplyScalar(e), t.add(this.v1), t;
    }
)),
(THREE.QuadraticBezierCurve3 = THREE.Curve.create(
    function (e, t, n) {
        (this.v0 = e), (this.v1 = t), (this.v2 = n);
    },
    function (e) {
        var t, n, r;
        return (t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x)), (n = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y)), (r = THREE.Shape.Utils.b2(e, this.v0.z, this.v1.z, this.v2.z)), new THREE.Vector3(t, n, r);
    }
)),
(THREE.CubicBezierCurve3 = THREE.Curve.create(
    function (e, t, n, r) {
        (this.v0 = e), (this.v1 = t), (this.v2 = n), (this.v3 = r);
    },
    function (e) {
        var t, n, r;
        return (
            (t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x)),
                (n = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y)),
                (r = THREE.Shape.Utils.b3(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z)),
                new THREE.Vector3(t, n, r)
        );
    }
)),
(THREE.SplineCurve3 = THREE.Curve.create(
    function (e) {
        this.points = e == undefined ? [] : e;
    },
    function (e) {
        var t = new THREE.Vector3(),
            n = [],
            r = this.points,
            i,
            s,
            o;
        (i = (r.length - 1) * e), (s = Math.floor(i)), (o = i - s), (n[0] = s == 0 ? s : s - 1), (n[1] = s), (n[2] = s > r.length - 2 ? r.length - 1 : s + 1), (n[3] = s > r.length - 3 ? r.length - 1 : s + 2);
        var u = r[n[0]],
            a = r[n[1]],
            f = r[n[2]],
            l = r[n[3]];
        return (t.x = THREE.Curve.Utils.interpolate(u.x, a.x, f.x, l.x, o)), (t.y = THREE.Curve.Utils.interpolate(u.y, a.y, f.y, l.y, o)), (t.z = THREE.Curve.Utils.interpolate(u.z, a.z, f.z, l.z, o)), t;
    }
)),
(THREE.ClosedSplineCurve3 = THREE.Curve.create(
    function (e) {
        this.points = e == undefined ? [] : e;
    },
    function (e) {
        var t = new THREE.Vector3(),
            n = [],
            r = this.points,
            i,
            s,
            o;
        return (
            (i = (r.length - 0) * e),
                (s = Math.floor(i)),
                (o = i - s),
                (s += s > 0 ? 0 : (Math.floor(Math.abs(s) / r.length) + 1) * r.length),
                (n[0] = (s - 1) % r.length),
                (n[1] = s % r.length),
                (n[2] = (s + 1) % r.length),
                (n[3] = (s + 2) % r.length),
                (t.x = THREE.Curve.Utils.interpolate(r[n[0]].x, r[n[1]].x, r[n[2]].x, r[n[3]].x, o)),
                (t.y = THREE.Curve.Utils.interpolate(r[n[0]].y, r[n[1]].y, r[n[2]].y, r[n[3]].y, o)),
                (t.z = THREE.Curve.Utils.interpolate(r[n[0]].z, r[n[1]].z, r[n[2]].z, r[n[3]].z, o)),
                t
        );
    }
)),
(THREE.AnimationHandler = (function () {
    var e = [],
        t = {},
        n = {};
    (n.update = function (t) {
        for (var n = 0; n < e.length; n++) e[n].update(t);
    }),
        (n.addToUpdate = function (t) {
            e.indexOf(t) === -1 && e.push(t);
        }),
        (n.removeFromUpdate = function (t) {
            var n = e.indexOf(t);
            n !== -1 && e.splice(n, 1);
        }),
        (n.add = function (e) {
            t[e.name] !== undefined && console.log("THREE.AnimationHandler.add: Warning! " + e.name + " already exists in library. Overwriting."), (t[e.name] = e), i(e);
        }),
        (n.get = function (e) {
            if (typeof e == "string") return t[e] ? t[e] : (console.log("THREE.AnimationHandler.get: Couldn't find animation " + e), null);
        }),
        (n.parse = function (e) {
            var t = [];
            if (e instanceof THREE.SkinnedMesh) for (var n = 0; n < e.bones.length; n++) t.push(e.bones[n]);
            else r(e, t);
            return t;
        });
    var r = function (e, t) {
            t.push(e);
            for (var n = 0; n < e.children.length; n++) r(e.children[n], t);
        },
        i = function (e) {
            if (e.initialized === !0) return;
            for (var t = 0; t < e.hierarchy.length; t++) {
                for (var n = 0; n < e.hierarchy[t].keys.length; n++) {
                    e.hierarchy[t].keys[n].time < 0 && (e.hierarchy[t].keys[n].time = 0);
                    if (e.hierarchy[t].keys[n].rot !== undefined && !(e.hierarchy[t].keys[n].rot instanceof THREE.Quaternion)) {
                        var r = e.hierarchy[t].keys[n].rot;
                        e.hierarchy[t].keys[n].rot = new THREE.Quaternion(r[0], r[1], r[2], r[3]);
                    }
                }
                if (e.hierarchy[t].keys.length && e.hierarchy[t].keys[0].morphTargets !== undefined) {
                    var i = {};
                    for (var n = 0; n < e.hierarchy[t].keys.length; n++)
                        for (var s = 0; s < e.hierarchy[t].keys[n].morphTargets.length; s++) {
                            var o = e.hierarchy[t].keys[n].morphTargets[s];
                            i[o] = -1;
                        }
                    e.hierarchy[t].usedMorphTargets = i;
                    for (var n = 0; n < e.hierarchy[t].keys.length; n++) {
                        var u = {};
                        for (var o in i) {
                            for (var s = 0; s < e.hierarchy[t].keys[n].morphTargets.length; s++)
                                if (e.hierarchy[t].keys[n].morphTargets[s] === o) {
                                    u[o] = e.hierarchy[t].keys[n].morphTargetsInfluences[s];
                                    break;
                                }
                            s === e.hierarchy[t].keys[n].morphTargets.length && (u[o] = 0);
                        }
                        e.hierarchy[t].keys[n].morphTargetsInfluences = u;
                    }
                }
                for (var n = 1; n < e.hierarchy[t].keys.length; n++) e.hierarchy[t].keys[n].time === e.hierarchy[t].keys[n - 1].time && (e.hierarchy[t].keys.splice(n, 1), n--);
                for (var n = 0; n < e.hierarchy[t].keys.length; n++) e.hierarchy[t].keys[n].index = n;
            }
            var a = parseInt(e.length * e.fps, 10);
            (e.JIT = {}), (e.JIT.hierarchy = []);
            for (var t = 0; t < e.hierarchy.length; t++) e.JIT.hierarchy.push(new Array(a));
            e.initialized = !0;
        };
    return (n.LINEAR = 0), (n.CATMULLROM = 1), (n.CATMULLROM_FORWARD = 2), n;
})()),
(THREE.Animation = function (e, t, n) {
    (this.root = e),
        (this.data = THREE.AnimationHandler.get(t)),
        (this.hierarchy = THREE.AnimationHandler.parse(e)),
        (this.currentTime = 0),
        (this.timeScale = 1),
        (this.isPlaying = !1),
        (this.isPaused = !0),
        (this.loop = !0),
        (this.interpolationType = n !== undefined ? n : THREE.AnimationHandler.LINEAR),
        (this.points = []),
        (this.target = new THREE.Vector3());
}),
(THREE.Animation.prototype.play = function (e, t) {
    if (this.isPlaying === !1) {
        (this.isPlaying = !0), (this.loop = e !== undefined ? e : !0), (this.currentTime = t !== undefined ? t : 0);
        var n,
            r = this.hierarchy.length,
            i;
        for (n = 0; n < r; n++) {
            (i = this.hierarchy[n]),
                (i.matrixAutoUpdate = !0),
            i.animationCache === undefined &&
            ((i.animationCache = {}),
                (i.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 }),
                (i.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 }),
                (i.animationCache.originalMatrix = i instanceof THREE.Bone ? i.skinMatrix : i.matrix));
            var s = i.animationCache.prevKey,
                o = i.animationCache.nextKey;
            (s.pos = this.data.hierarchy[n].keys[0]),
                (s.rot = this.data.hierarchy[n].keys[0]),
                (s.scl = this.data.hierarchy[n].keys[0]),
                (o.pos = this.getNextKeyWith("pos", n, 1)),
                (o.rot = this.getNextKeyWith("rot", n, 1)),
                (o.scl = this.getNextKeyWith("scl", n, 1));
        }
        this.update(0);
    }
    (this.isPaused = !1), THREE.AnimationHandler.addToUpdate(this);
}),
(THREE.Animation.prototype.pause = function () {
    this.isPaused === !0 ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this), (this.isPaused = !this.isPaused);
}),
(THREE.Animation.prototype.stop = function () {
    (this.isPlaying = !1), (this.isPaused = !1), THREE.AnimationHandler.removeFromUpdate(this);
}),
(THREE.Animation.prototype.update = function (e) {
    if (this.isPlaying === !1) return;
    var t = ["pos", "rot", "scl"],
        n,
        r,
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h = this.data.JIT.hierarchy,
        p,
        d,
        v,
        m,
        g;
    (this.currentTime += e * this.timeScale), (d = this.currentTime), (p = this.currentTime = this.currentTime % this.data.length), (c = parseInt(Math.min(p * this.data.fps, this.data.length * this.data.fps), 10));
    for (var y = 0, b = this.hierarchy.length; y < b; y++) {
        (f = this.hierarchy[y]), (l = f.animationCache);
        for (var w = 0; w < 3; w++) {
            (n = t[w]), (u = l.prevKey[n]), (a = l.nextKey[n]);
            if (a.time <= d) {
                if (p < d) {
                    if (!this.loop) {
                        this.stop();
                        return;
                    }
                    (u = this.data.hierarchy[y].keys[0]), (a = this.getNextKeyWith(n, y, 1));
                    while (a.time < p) (u = a), (a = this.getNextKeyWith(n, y, a.index + 1));
                } else
                    do (u = a), (a = this.getNextKeyWith(n, y, a.index + 1));
                    while (a.time < p);
                (l.prevKey[n] = u), (l.nextKey[n] = a);
            }
            (f.matrixAutoUpdate = !0), (f.matrixWorldNeedsUpdate = !0), (r = (p - u.time) / (a.time - u.time)), (s = u[n]), (o = a[n]);
            if (r < 0 || r > 1) console.log("THREE.Animation.update: Warning! Scale out of bounds:" + r + " on bone " + y), (r = r < 0 ? 0 : 1);
            if (n === "pos") {
                i = f.position;
                if (this.interpolationType === THREE.AnimationHandler.LINEAR) (i.x = s[0] + (o[0] - s[0]) * r), (i.y = s[1] + (o[1] - s[1]) * r), (i.z = s[2] + (o[2] - s[2]) * r);
                else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD)
                    (this.points[0] = this.getPrevKeyWith("pos", y, u.index - 1).pos),
                        (this.points[1] = s),
                        (this.points[2] = o),
                        (this.points[3] = this.getNextKeyWith("pos", y, a.index + 1).pos),
                        (r = r * 0.33 + 0.33),
                        (v = this.interpolateCatmullRom(this.points, r)),
                        (i.x = v[0]),
                        (i.y = v[1]),
                        (i.z = v[2]),
                    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD &&
                    ((m = this.interpolateCatmullRom(this.points, r * 1.01)),
                        this.target.set(m[0], m[1], m[2]),
                        this.target.sub(i),
                        (this.target.y = 0),
                        this.target.normalize(),
                        (g = Math.atan2(this.target.x, this.target.z)),
                        f.rotation.set(0, g, 0));
            } else n === "rot" ? THREE.Quaternion.slerp(s, o, f.quaternion, r) : n === "scl" && ((i = f.scale), (i.x = s[0] + (o[0] - s[0]) * r), (i.y = s[1] + (o[1] - s[1]) * r), (i.z = s[2] + (o[2] - s[2]) * r));
        }
    }
}),
(THREE.Animation.prototype.interpolateCatmullRom = function (e, t) {
    var n = [],
        r = [],
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c,
        h;
    return (
        (i = (e.length - 1) * t),
            (s = Math.floor(i)),
            (o = i - s),
            (n[0] = s === 0 ? s : s - 1),
            (n[1] = s),
            (n[2] = s > e.length - 2 ? s : s + 1),
            (n[3] = s > e.length - 3 ? s : s + 2),
            (f = e[n[0]]),
            (l = e[n[1]]),
            (c = e[n[2]]),
            (h = e[n[3]]),
            (u = o * o),
            (a = o * u),
            (r[0] = this.interpolate(f[0], l[0], c[0], h[0], o, u, a)),
            (r[1] = this.interpolate(f[1], l[1], c[1], h[1], o, u, a)),
            (r[2] = this.interpolate(f[2], l[2], c[2], h[2], o, u, a)),
            r
    );
}),
(THREE.Animation.prototype.interpolate = function (e, t, n, r, i, s, o) {
    var u = (n - e) * 0.5,
        a = (r - t) * 0.5;
    return (2 * (t - n) + u + a) * o + (-3 * (t - n) - 2 * u - a) * s + u * i + t;
}),
(THREE.Animation.prototype.getNextKeyWith = function (e, t, n) {
    var r = this.data.hierarchy[t].keys;
    this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? (n = n < r.length - 1 ? n : r.length - 1) : (n %= r.length);
    for (; n < r.length; n++) if (r[n][e] !== undefined) return r[n];
    return this.data.hierarchy[t].keys[0];
}),
(THREE.Animation.prototype.getPrevKeyWith = function (e, t, n) {
    var r = this.data.hierarchy[t].keys;
    this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? (n = n > 0 ? n : 0) : (n = n >= 0 ? n : n + r.length);
    for (; n >= 0; n--) if (r[n][e] !== undefined) return r[n];
    return this.data.hierarchy[t].keys[r.length - 1];
}),
(THREE.KeyFrameAnimation = function (e, t, n) {
    (this.root = e),
        (this.data = THREE.AnimationHandler.get(t)),
        (this.hierarchy = THREE.AnimationHandler.parse(e)),
        (this.currentTime = 0),
        (this.timeScale = 0.001),
        (this.isPlaying = !1),
        (this.isPaused = !0),
        (this.loop = !0),
        (this.JITCompile = n !== undefined ? n : !0);
    for (var r = 0, i = this.hierarchy.length; r < i; r++) {
        var s = this.data.hierarchy[r].keys,
            o = this.data.hierarchy[r].sids,
            u = this.hierarchy[r];
        if (s.length && o) {
            for (var a = 0; a < o.length; a++) {
                var f = o[a],
                    l = this.getNextKeyWith(f, r, 0);
                l && l.apply(f);
            }
            (u.matrixAutoUpdate = !1), this.data.hierarchy[r].node.updateMatrix(), (u.matrixWorldNeedsUpdate = !0);
        }
    }
}),
(THREE.KeyFrameAnimation.prototype.play = function (e, t) {
    if (!this.isPlaying) {
        (this.isPlaying = !0), (this.loop = e !== undefined ? e : !0), (this.currentTime = t !== undefined ? t : 0), (this.startTimeMs = t), (this.startTime = 1e7), (this.endTime = -this.startTime);
        var n,
            r = this.hierarchy.length,
            i,
            s;
        for (n = 0; n < r; n++) {
            (i = this.hierarchy[n]),
                (s = this.data.hierarchy[n]),
            s.animationCache === undefined && ((s.animationCache = {}), (s.animationCache.prevKey = null), (s.animationCache.nextKey = null), (s.animationCache.originalMatrix = i instanceof THREE.Bone ? i.skinMatrix : i.matrix));
            var o = this.data.hierarchy[n].keys;
            o.length && ((s.animationCache.prevKey = o[0]), (s.animationCache.nextKey = o[1]), (this.startTime = Math.min(o[0].time, this.startTime)), (this.endTime = Math.max(o[o.length - 1].time, this.endTime)));
        }
        this.update(0);
    }
    (this.isPaused = !1), THREE.AnimationHandler.addToUpdate(this);
}),
(THREE.KeyFrameAnimation.prototype.pause = function () {
    this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this), (this.isPaused = !this.isPaused);
}),
(THREE.KeyFrameAnimation.prototype.stop = function () {
    (this.isPlaying = !1), (this.isPaused = !1), THREE.AnimationHandler.removeFromUpdate(this);
    for (var e = 0; e < this.data.hierarchy.length; e++) {
        var t = this.hierarchy[e],
            n = this.data.hierarchy[e];
        if (n.animationCache !== undefined) {
            var r = n.animationCache.originalMatrix;
            t instanceof THREE.Bone ? (r.copy(t.skinMatrix), (t.skinMatrix = r)) : (r.copy(t.matrix), (t.matrix = r)), delete n.animationCache;
        }
    }
}),
(THREE.KeyFrameAnimation.prototype.update = function (e) {
    if (!this.isPlaying) return;
    var t,
        n,
        r,
        i,
        s,
        o = this.data.JIT.hierarchy,
        u,
        a,
        f;
    (this.currentTime += e * this.timeScale),
        (a = this.currentTime),
        (u = this.currentTime = this.currentTime % this.data.length),
    u < this.startTimeMs && (u = this.currentTime = this.startTimeMs + u),
        (s = parseInt(Math.min(u * this.data.fps, this.data.length * this.data.fps), 10)),
        (f = u < a);
    if (f && !this.loop) {
        for (var l = 0, c = this.hierarchy.length; l < c; l++) {
            var h = this.data.hierarchy[l].keys,
                p = this.data.hierarchy[l].sids,
                d = h.length - 1,
                v = this.hierarchy[l];
            if (h.length) {
                for (var m = 0; m < p.length; m++) {
                    var g = p[m],
                        y = this.getPrevKeyWith(g, l, d);
                    y && y.apply(g);
                }
                this.data.hierarchy[l].node.updateMatrix(), (v.matrixWorldNeedsUpdate = !0);
            }
        }
        this.stop();
        return;
    }
    if (u < this.startTime) return;
    for (var l = 0, c = this.hierarchy.length; l < c; l++) {
        (r = this.hierarchy[l]), (i = this.data.hierarchy[l]);
        var h = i.keys,
            b = i.animationCache;
        if (this.JITCompile && o[l][s] !== undefined) r instanceof THREE.Bone ? ((r.skinMatrix = o[l][s]), (r.matrixWorldNeedsUpdate = !1)) : ((r.matrix = o[l][s]), (r.matrixWorldNeedsUpdate = !0));
        else if (h.length) {
            this.JITCompile && b && (r instanceof THREE.Bone ? (r.skinMatrix = b.originalMatrix) : (r.matrix = b.originalMatrix)), (t = b.prevKey), (n = b.nextKey);
            if (t && n) {
                if (n.time <= a) {
                    if (f && this.loop) {
                        (t = h[0]), (n = h[1]);
                        while (n.time < u) (t = n), (n = h[t.index + 1]);
                    } else if (!f) {
                        var w = h.length - 1;
                        while (n.time < u && n.index !== w) (t = n), (n = h[t.index + 1]);
                    }
                    (b.prevKey = t), (b.nextKey = n);
                }
                n.time >= u ? t.interpolate(n, u) : t.interpolate(n, n.time);
            }
            this.data.hierarchy[l].node.updateMatrix(), (r.matrixWorldNeedsUpdate = !0);
        }
    }
    if (this.JITCompile && o[0][s] === undefined) {
        this.hierarchy[0].updateMatrixWorld(!0);
        for (var l = 0; l < this.hierarchy.length; l++) this.hierarchy[l] instanceof THREE.Bone ? (o[l][s] = this.hierarchy[l].skinMatrix.clone()) : (o[l][s] = this.hierarchy[l].matrix.clone());
    }
}),
(THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (e, t, n) {
    var r = this.data.hierarchy[t].keys;
    n %= r.length;
    for (; n < r.length; n++) if (r[n].hasTarget(e)) return r[n];
    return r[0];
}),
(THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (e, t, n) {
    var r = this.data.hierarchy[t].keys;
    n = n >= 0 ? n : n + r.length;
    for (; n >= 0; n--) if (r[n].hasTarget(e)) return r[n];
    return r[r.length - 1];
}),
(THREE.CubeCamera = function (e, t, n) {
    THREE.Object3D.call(this);
    var r = 90,
        i = 1,
        s = new THREE.PerspectiveCamera(r, i, e, t);
    s.up.set(0, -1, 0), s.lookAt(new THREE.Vector3(1, 0, 0)), this.add(s);
    var o = new THREE.PerspectiveCamera(r, i, e, t);
    o.up.set(0, -1, 0), o.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(o);
    var u = new THREE.PerspectiveCamera(r, i, e, t);
    u.up.set(0, 0, 1), u.lookAt(new THREE.Vector3(0, 1, 0)), this.add(u);
    var a = new THREE.PerspectiveCamera(r, i, e, t);
    a.up.set(0, 0, -1), a.lookAt(new THREE.Vector3(0, -1, 0)), this.add(a);
    var f = new THREE.PerspectiveCamera(r, i, e, t);
    f.up.set(0, -1, 0), f.lookAt(new THREE.Vector3(0, 0, 1)), this.add(f);
    var l = new THREE.PerspectiveCamera(r, i, e, t);
    l.up.set(0, -1, 0),
        l.lookAt(new THREE.Vector3(0, 0, -1)),
        this.add(l),
        (this.renderTarget = new THREE.WebGLRenderTargetCube(n, n, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter })),
        (this.updateCubeMap = function (e, t) {
            var n = this.renderTarget,
                r = n.generateMipmaps;
            (n.generateMipmaps = !1),
                (n.activeCubeFace = 0),
                e.render(t, s, n),
                (n.activeCubeFace = 1),
                e.render(t, o, n),
                (n.activeCubeFace = 2),
                e.render(t, u, n),
                (n.activeCubeFace = 3),
                e.render(t, a, n),
                (n.activeCubeFace = 4),
                e.render(t, f, n),
                (n.generateMipmaps = r),
                (n.activeCubeFace = 5),
                e.render(t, l, n);
        });
}),
(THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.CombinedCamera = function (e, t, n, r, i, s, o) {
    THREE.Camera.call(this),
        (this.fov = n),
        (this.left = -e / 2),
        (this.right = e / 2),
        (this.top = t / 2),
        (this.bottom = -t / 2),
        (this.cameraO = new THREE.OrthographicCamera(e / -2, e / 2, t / 2, t / -2, s, o)),
        (this.cameraP = new THREE.PerspectiveCamera(n, e / t, r, i)),
        (this.zoom = 1),
        this.toPerspective();
    var u = e / t;
}),
(THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype)),
(THREE.CombinedCamera.prototype.toPerspective = function () {
    (this.near = this.cameraP.near),
        (this.far = this.cameraP.far),
        (this.cameraP.fov = this.fov / this.zoom),
        this.cameraP.updateProjectionMatrix(),
        (this.projectionMatrix = this.cameraP.projectionMatrix),
        (this.inPerspectiveMode = !0),
        (this.inOrthographicMode = !1);
}),
(THREE.CombinedCamera.prototype.toOrthographic = function () {
    var e = this.fov,
        t = this.cameraP.aspect,
        n = this.cameraP.near,
        r = this.cameraP.far,
        i = (n + r) / 2,
        s = Math.tan(e / 2) * i,
        o = 2 * s,
        u = o * t,
        a = u / 2;
    (s /= this.zoom),
        (a /= this.zoom),
        (this.cameraO.left = -a),
        (this.cameraO.right = a),
        (this.cameraO.top = s),
        (this.cameraO.bottom = -s),
        this.cameraO.updateProjectionMatrix(),
        (this.near = this.cameraO.near),
        (this.far = this.cameraO.far),
        (this.projectionMatrix = this.cameraO.projectionMatrix),
        (this.inPerspectiveMode = !1),
        (this.inOrthographicMode = !0);
}),
(THREE.CombinedCamera.prototype.setSize = function (e, t) {
    (this.cameraP.aspect = e / t), (this.left = -e / 2), (this.right = e / 2), (this.top = t / 2), (this.bottom = -t / 2);
}),
(THREE.CombinedCamera.prototype.setFov = function (e) {
    (this.fov = e), this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
}),
(THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {
    this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(), this.toOrthographic());
}),
(THREE.CombinedCamera.prototype.setLens = function (e, t) {
    t === undefined && (t = 24);
    var n = 2 * THREE.Math.radToDeg(Math.atan(t / (e * 2)));
    return this.setFov(n), n;
}),
(THREE.CombinedCamera.prototype.setZoom = function (e) {
    (this.zoom = e), this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
}),
(THREE.CombinedCamera.prototype.toFrontView = function () {
    (this.rotation.x = 0), (this.rotation.y = 0), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
}),
(THREE.CombinedCamera.prototype.toBackView = function () {
    (this.rotation.x = 0), (this.rotation.y = Math.PI), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
}),
(THREE.CombinedCamera.prototype.toLeftView = function () {
    (this.rotation.x = 0), (this.rotation.y = -Math.PI / 2), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
}),
(THREE.CombinedCamera.prototype.toRightView = function () {
    (this.rotation.x = 0), (this.rotation.y = Math.PI / 2), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
}),
(THREE.CombinedCamera.prototype.toTopView = function () {
    (this.rotation.x = -Math.PI / 2), (this.rotation.y = 0), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
}),
(THREE.CombinedCamera.prototype.toBottomView = function () {
    (this.rotation.x = Math.PI / 2), (this.rotation.y = 0), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
}),
(THREE.CircleGeometry = function (e, t, n, r) {
    THREE.Geometry.call(this), (this.radius = e = e || 50), (this.segments = t = t !== undefined ? Math.max(3, t) : 8), (this.thetaStart = n = n !== undefined ? n : 0), (this.thetaLength = r = r !== undefined ? r : Math.PI * 2);
    var i,
        s = [],
        o = new THREE.Vector3(),
        u = new THREE.Vector2(0.5, 0.5);
    this.vertices.push(o), s.push(u);
    for (i = 0; i <= t; i++) {
        var a = new THREE.Vector3(),
            f = n + (i / t) * r;
        (a.x = e * Math.cos(f)), (a.y = e * Math.sin(f)), this.vertices.push(a), s.push(new THREE.Vector2((a.x / e + 1) / 2, (a.y / e + 1) / 2));
    }
    var l = new THREE.Vector3(0, 0, 1);
    for (i = 1; i <= t; i++) {
        var c = i,
            h = i + 1,
            p = 0;
        this.faces.push(new THREE.Face3(c, h, p, [l, l, l])), this.faceVertexUvs[0].push([s[i], s[i + 1], u]);
    }
    this.computeCentroids(), this.computeFaceNormals(), (this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), e));
}),
(THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.CubeGeometry = function (e, t, n, r, i, s) {
    function l(e, t, n, r, i, s, u, a) {
        var f,
            l,
            c,
            h = o.widthSegments,
            p = o.heightSegments,
            d = i / 2,
            v = s / 2,
            m = o.vertices.length;
        if ((e === "x" && t === "y") || (e === "y" && t === "x")) f = "z";
        else if ((e === "x" && t === "z") || (e === "z" && t === "x")) (f = "y"), (p = o.depthSegments);
        else if ((e === "z" && t === "y") || (e === "y" && t === "z")) (f = "x"), (h = o.depthSegments);
        var g = h + 1,
            y = p + 1,
            b = i / h,
            w = s / p,
            E = new THREE.Vector3();
        E[f] = u > 0 ? 1 : -1;
        for (c = 0; c < y; c++)
            for (l = 0; l < g; l++) {
                var S = new THREE.Vector3();
                (S[e] = (l * b - d) * n), (S[t] = (c * w - v) * r), (S[f] = u), o.vertices.push(S);
            }
        for (c = 0; c < p; c++)
            for (l = 0; l < h; l++) {
                var x = l + g * c,
                    T = l + g * (c + 1),
                    N = l + 1 + g * (c + 1),
                    C = l + 1 + g * c,
                    k = new THREE.Vector2(l / h, 1 - c / p),
                    L = new THREE.Vector2(l / h, 1 - (c + 1) / p),
                    A = new THREE.Vector2((l + 1) / h, 1 - (c + 1) / p),
                    O = new THREE.Vector2((l + 1) / h, 1 - c / p),
                    M = new THREE.Face3(x + m, T + m, C + m);
                M.normal.copy(E),
                    M.vertexNormals.push(E.clone(), E.clone(), E.clone()),
                    (M.materialIndex = a),
                    o.faces.push(M),
                    o.faceVertexUvs[0].push([k, L, O]),
                    (M = new THREE.Face3(T + m, N + m, C + m)),
                    M.normal.copy(E),
                    M.vertexNormals.push(E.clone(), E.clone(), E.clone()),
                    (M.materialIndex = a),
                    o.faces.push(M),
                    o.faceVertexUvs[0].push([L.clone(), A, O.clone()]);
            }
    }
    THREE.Geometry.call(this);
    var o = this;
    (this.width = e), (this.height = t), (this.depth = n), (this.widthSegments = r || 1), (this.heightSegments = i || 1), (this.depthSegments = s || 1);
    var u = this.width / 2,
        a = this.height / 2,
        f = this.depth / 2;
    l("z", "y", -1, -1, this.depth, this.height, u, 0),
        l("z", "y", 1, -1, this.depth, this.height, -u, 1),
        l("x", "z", 1, 1, this.width, this.depth, a, 2),
        l("x", "z", 1, -1, this.width, this.depth, -a, 3),
        l("x", "y", 1, -1, this.width, this.height, f, 4),
        l("x", "y", -1, -1, this.width, this.height, -f, 5),
        this.computeCentroids(),
        this.mergeVertices();
}),
(THREE.CubeGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.CylinderGeometry = function (e, t, n, r, i, s) {
    THREE.Geometry.call(this),
        (this.radiusTop = e = e !== undefined ? e : 20),
        (this.radiusBottom = t = t !== undefined ? t : 20),
        (this.height = n = n !== undefined ? n : 100),
        (this.radialSegments = r = r || 8),
        (this.heightSegments = i = i || 1),
        (this.openEnded = s = s !== undefined ? s : !1);
    var o = n / 2,
        u,
        a,
        f = [],
        l = [];
    for (a = 0; a <= i; a++) {
        var c = [],
            h = [],
            p = a / i,
            d = p * (t - e) + e;
        for (u = 0; u <= r; u++) {
            var v = u / r,
                m = new THREE.Vector3();
            (m.x = d * Math.sin(v * Math.PI * 2)), (m.y = -p * n + o), (m.z = d * Math.cos(v * Math.PI * 2)), this.vertices.push(m), c.push(this.vertices.length - 1), h.push(new THREE.Vector2(v, 1 - p));
        }
        f.push(c), l.push(h);
    }
    var g = (t - e) / n,
        y,
        b;
    for (u = 0; u < r; u++) {
        e !== 0 ? ((y = this.vertices[f[0][u]].clone()), (b = this.vertices[f[0][u + 1]].clone())) : ((y = this.vertices[f[1][u]].clone()), (b = this.vertices[f[1][u + 1]].clone())),
            y.setY(Math.sqrt(y.x * y.x + y.z * y.z) * g).normalize(),
            b.setY(Math.sqrt(b.x * b.x + b.z * b.z) * g).normalize();
        for (a = 0; a < i; a++) {
            var w = f[a][u],
                E = f[a + 1][u],
                S = f[a + 1][u + 1],
                x = f[a][u + 1],
                T = y.clone(),
                N = y.clone(),
                C = b.clone(),
                k = b.clone(),
                L = l[a][u].clone(),
                A = l[a + 1][u].clone(),
                O = l[a + 1][u + 1].clone(),
                M = l[a][u + 1].clone();
            this.faces.push(new THREE.Face3(w, E, x, [T, N, k])), this.faceVertexUvs[0].push([L, A, M]), this.faces.push(new THREE.Face3(E, S, x, [N, C, k])), this.faceVertexUvs[0].push([A, O, M]);
        }
    }
    if (s === !1 && e > 0) {
        this.vertices.push(new THREE.Vector3(0, o, 0));
        for (u = 0; u < r; u++) {
            var w = f[0][u],
                E = f[0][u + 1],
                S = this.vertices.length - 1,
                T = new THREE.Vector3(0, 1, 0),
                N = new THREE.Vector3(0, 1, 0),
                C = new THREE.Vector3(0, 1, 0),
                L = l[0][u].clone(),
                A = l[0][u + 1].clone(),
                O = new THREE.Vector2(A.u, 0);
            this.faces.push(new THREE.Face3(w, E, S, [T, N, C])), this.faceVertexUvs[0].push([L, A, O]);
        }
    }
    if (s === !1 && t > 0) {
        this.vertices.push(new THREE.Vector3(0, -o, 0));
        for (u = 0; u < r; u++) {
            var w = f[a][u + 1],
                E = f[a][u],
                S = this.vertices.length - 1,
                T = new THREE.Vector3(0, -1, 0),
                N = new THREE.Vector3(0, -1, 0),
                C = new THREE.Vector3(0, -1, 0),
                L = l[a][u + 1].clone(),
                A = l[a][u].clone(),
                O = new THREE.Vector2(A.u, 1);
            this.faces.push(new THREE.Face3(w, E, S, [T, N, C])), this.faceVertexUvs[0].push([L, A, O]);
        }
    }
    this.computeCentroids(), this.computeFaceNormals();
}),
(THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.ExtrudeGeometry = function (e, t) {
    if (typeof e == "undefined") {
        e = [];
        return;
    }
    THREE.Geometry.call(this), (e = e instanceof Array ? e : [e]), (this.shapebb = e[e.length - 1].getBoundingBox()), this.addShapeList(e, t), this.computeCentroids(), this.computeFaceNormals();
}),
(THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.ExtrudeGeometry.prototype.addShapeList = function (e, t) {
    var n = e.length;
    for (var r = 0; r < n; r++) {
        var i = e[r];
        this.addShape(i, t);
    }
}),
(THREE.ExtrudeGeometry.prototype.addShape = function (e, t) {
    function _(e, t, n) {
        return t || console.log("die"), t.clone().multiplyScalar(n).add(e);
    }
    function W(e, t, n) {
        return V(e, t, n);
    }
    function X(e, t, n) {
        var r = Math.atan2(t.y - e.y, t.x - e.x),
            i = Math.atan2(n.y - e.y, n.x - e.x);
        r > i && (i += Math.PI * 2);
        var s = (r + i) / 2,
            o = -Math.cos(s),
            u = -Math.sin(s),
            a = new THREE.Vector2(o, u);
        return a;
    }
    function V(e, t, n) {
        var r = THREE.ExtrudeGeometry.__v1,
            i = THREE.ExtrudeGeometry.__v2,
            s = THREE.ExtrudeGeometry.__v3,
            o = THREE.ExtrudeGeometry.__v4,
            u = THREE.ExtrudeGeometry.__v5,
            a = THREE.ExtrudeGeometry.__v6,
            f,
            l,
            c,
            h,
            p,
            d;
        return (
            r.set(e.x - t.x, e.y - t.y),
                i.set(e.x - n.x, e.y - n.y),
                (f = r.normalize()),
                (l = i.normalize()),
                s.set(-f.y, f.x),
                o.set(l.y, -l.x),
                u.copy(e).add(s),
                a.copy(e).add(o),
                u.equals(a)
                    ? o.clone()
                    : (u.copy(t).add(s),
                        a.copy(n).add(o),
                        (c = f.dot(o)),
                        (h = a.sub(u).dot(o)),
                    c === 0 && (console.log("Either infinite or no solutions!"), h === 0 ? console.log("Its finite solutions.") : console.log("Too bad, no solutions.")),
                        (p = h / c),
                        p < 0 ? X(e, t, n) : ((d = f.multiplyScalar(p).add(u)), d.sub(e).clone()))
        );
    }
    function st() {
        if (o) {
            var e = 0,
                t = F * e;
            for (J = 0; J < q; J++) (I = O[J]), ft(I[2] + t, I[1] + t, I[0] + t, !0);
            (e = a + s * 2), (t = F * e);
            for (J = 0; J < q; J++) (I = O[J]), ft(I[0] + t, I[1] + t, I[2] + t, !1);
        } else {
            for (J = 0; J < q; J++) (I = O[J]), ft(I[2], I[1], I[0], !0);
            for (J = 0; J < q; J++) (I = O[J]), ft(I[0] + F * a, I[1] + F * a, I[2] + F * a, !1);
        }
    }
    function ot() {
        var e = 0;
        ut(M, e), (e += M.length);
        for (E = 0, S = L.length; E < S; E++) (w = L[E]), ut(w, e), (e += w.length);
    }
    function ut(e, t) {
        var n, r;
        J = e.length;
        while (--J >= 0) {
            (n = J), (r = J - 1), r < 0 && (r = e.length - 1);
            var i = 0,
                o = a + s * 2;
            for (i = 0; i < o; i++) {
                var u = F * i,
                    f = F * (i + 1),
                    l = t + n + u,
                    c = t + r + u,
                    h = t + r + f,
                    p = t + n + f;
                lt(l, c, h, p, e, i, o, n, r);
            }
        }
    }
    function at(e, t, n) {
        x.vertices.push(new THREE.Vector3(e, t, n));
    }
    function ft(n, r, i, s) {
        (n += N), (r += N), (i += N), x.faces.push(new THREE.Face3(n, r, i, null, null, h));
        var o = s ? d.generateBottomUV(x, e, t, n, r, i) : d.generateTopUV(x, e, t, n, r, i);
        x.faceVertexUvs[0].push(o);
    }
    function lt(n, r, i, s, o, u, a, f, l) {
        (n += N), (r += N), (i += N), (s += N), x.faces.push(new THREE.Face3(n, r, s, null, null, p)), x.faces.push(new THREE.Face3(r, i, s, null, null, p));
        var c = d.generateSideWallUV(x, e, o, t, n, r, i, s, u, a, f, l);
        x.faceVertexUvs[0].push([c[0], c[1], c[3]]), x.faceVertexUvs[0].push([c[1], c[2], c[3]]);
    }
    var n = t.amount !== undefined ? t.amount : 100,
        r = t.bevelThickness !== undefined ? t.bevelThickness : 6,
        i = t.bevelSize !== undefined ? t.bevelSize : r - 2,
        s = t.bevelSegments !== undefined ? t.bevelSegments : 3,
        o = t.bevelEnabled !== undefined ? t.bevelEnabled : !0,
        u = t.curveSegments !== undefined ? t.curveSegments : 12,
        a = t.steps !== undefined ? t.steps : 1,
        f = t.extrudePath,
        l,
        c = !1,
        h = t.material,
        p = t.extrudeMaterial,
        d = t.UVGenerator !== undefined ? t.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator,
        v = this.shapebb,
        m,
        g,
        y,
        b;
    f && ((l = f.getSpacedPoints(a)), (c = !0), (o = !1), (m = t.frames !== undefined ? t.frames : new THREE.TubeGeometry.FrenetFrames(f, a, !1)), (g = new THREE.Vector3()), (y = new THREE.Vector3()), (b = new THREE.Vector3())),
    o || ((s = 0), (r = 0), (i = 0));
    var w,
        E,
        S,
        x = this,
        T = [],
        N = this.vertices.length,
        C = e.extractPoints(u),
        k = C.shape,
        L = C.holes,
        A = !THREE.Shape.Utils.isClockWise(k);
    if (A) {
        k = k.reverse();
        for (E = 0, S = L.length; E < S; E++) (w = L[E]), THREE.Shape.Utils.isClockWise(w) && (L[E] = w.reverse());
        A = !1;
    }
    var O = THREE.Shape.Utils.triangulateShape(k, L),
        M = k;
    for (E = 0, S = L.length; E < S; E++) (w = L[E]), (k = k.concat(w));
    var D,
        P,
        H,
        B,
        j,
        F = k.length,
        I,
        q = O.length,
        R,
        U = M.length,
        z = 180 / Math.PI,
        $ = [];
    for (var J = 0, K = M.length, Q = K - 1, G = J + 1; J < K; J++, Q++, G++) {
        Q === K && (Q = 0), G === K && (G = 0);
        var Y = M[J],
            Z = M[Q],
            et = M[G];
        $[J] = W(M[J], M[Q], M[G]);
    }
    var tt = [],
        nt,
        rt = $.concat();
    for (E = 0, S = L.length; E < S; E++) {
        (w = L[E]), (nt = []);
        for (J = 0, K = w.length, Q = K - 1, G = J + 1; J < K; J++, Q++, G++) Q === K && (Q = 0), G === K && (G = 0), (nt[J] = W(w[J], w[Q], w[G]));
        tt.push(nt), (rt = rt.concat(nt));
    }
    for (D = 0; D < s; D++) {
        (H = D / s), (B = r * (1 - H)), (P = i * Math.sin((H * Math.PI) / 2));
        for (J = 0, K = M.length; J < K; J++) (j = _(M[J], $[J], P)), at(j.x, j.y, -B);
        for (E = 0, S = L.length; E < S; E++) {
            (w = L[E]), (nt = tt[E]);
            for (J = 0, K = w.length; J < K; J++) (j = _(w[J], nt[J], P)), at(j.x, j.y, -B);
        }
    }
    P = i;
    for (J = 0; J < F; J++) (j = o ? _(k[J], rt[J], P) : k[J]), c ? (y.copy(m.normals[0]).multiplyScalar(j.x), g.copy(m.binormals[0]).multiplyScalar(j.y), b.copy(l[0]).add(y).add(g), at(b.x, b.y, b.z)) : at(j.x, j.y, 0);
    var it;
    for (it = 1; it <= a; it++)
        for (J = 0; J < F; J++)
            (j = o ? _(k[J], rt[J], P) : k[J]), c ? (y.copy(m.normals[it]).multiplyScalar(j.x), g.copy(m.binormals[it]).multiplyScalar(j.y), b.copy(l[it]).add(y).add(g), at(b.x, b.y, b.z)) : at(j.x, j.y, (n / a) * it);
    for (D = s - 1; D >= 0; D--) {
        (H = D / s), (B = r * (1 - H)), (P = i * Math.sin((H * Math.PI) / 2));
        for (J = 0, K = M.length; J < K; J++) (j = _(M[J], $[J], P)), at(j.x, j.y, n + B);
        for (E = 0, S = L.length; E < S; E++) {
            (w = L[E]), (nt = tt[E]);
            for (J = 0, K = w.length; J < K; J++) (j = _(w[J], nt[J], P)), c ? at(j.x, j.y + l[a - 1].y, l[a - 1].x + B) : at(j.x, j.y, n + B);
        }
    }
    st(), ot();
}),
(THREE.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function (e, t, n, r, i, s) {
        var o = e.vertices[r].x,
            u = e.vertices[r].y,
            a = e.vertices[i].x,
            f = e.vertices[i].y,
            l = e.vertices[s].x,
            c = e.vertices[s].y;
        return [new THREE.Vector2(o, u), new THREE.Vector2(a, f), new THREE.Vector2(l, c)];
    },
    generateBottomUV: function (e, t, n, r, i, s) {
        return this.generateTopUV(e, t, n, r, i, s);
    },
    generateSideWallUV: function (e, t, n, r, i, s, o, u, a, f, l, c) {
        var h = e.vertices[i].x,
            p = e.vertices[i].y,
            d = e.vertices[i].z,
            v = e.vertices[s].x,
            m = e.vertices[s].y,
            g = e.vertices[s].z,
            y = e.vertices[o].x,
            b = e.vertices[o].y,
            w = e.vertices[o].z,
            E = e.vertices[u].x,
            S = e.vertices[u].y,
            x = e.vertices[u].z;
        return Math.abs(p - m) < 0.01
            ? [new THREE.Vector2(h, 1 - d), new THREE.Vector2(v, 1 - g), new THREE.Vector2(y, 1 - w), new THREE.Vector2(E, 1 - x)]
            : [new THREE.Vector2(p, 1 - d), new THREE.Vector2(m, 1 - g), new THREE.Vector2(b, 1 - w), new THREE.Vector2(S, 1 - x)];
    },
}),
(THREE.ExtrudeGeometry.__v1 = new THREE.Vector2()),
(THREE.ExtrudeGeometry.__v2 = new THREE.Vector2()),
(THREE.ExtrudeGeometry.__v3 = new THREE.Vector2()),
(THREE.ExtrudeGeometry.__v4 = new THREE.Vector2()),
(THREE.ExtrudeGeometry.__v5 = new THREE.Vector2()),
(THREE.ExtrudeGeometry.__v6 = new THREE.Vector2()),
(THREE.ShapeGeometry = function (e, t) {
    THREE.Geometry.call(this), e instanceof Array == 0 && (e = [e]), (this.shapebb = e[e.length - 1].getBoundingBox()), this.addShapeList(e, t), this.computeCentroids(), this.computeFaceNormals();
}),
(THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.ShapeGeometry.prototype.addShapeList = function (e, t) {
    for (var n = 0, r = e.length; n < r; n++) this.addShape(e[n], t);
    return this;
}),
(THREE.ShapeGeometry.prototype.addShape = function (e, t) {
    t === undefined && (t = {});
    var n = t.curveSegments !== undefined ? t.curveSegments : 12,
        r = t.material,
        i = t.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : t.UVGenerator,
        s = this.shapebb,
        o,
        u,
        a,
        f,
        l = this.vertices.length,
        c = e.extractPoints(n),
        h = c.shape,
        p = c.holes,
        d = !THREE.Shape.Utils.isClockWise(h);
    if (d) {
        h = h.reverse();
        for (o = 0, u = p.length; o < u; o++) (a = p[o]), THREE.Shape.Utils.isClockWise(a) && (p[o] = a.reverse());
        d = !1;
    }
    var v = THREE.Shape.Utils.triangulateShape(h, p),
        m = h;
    for (o = 0, u = p.length; o < u; o++) (a = p[o]), (h = h.concat(a));
    var g,
        y = h.length,
        b,
        w = v.length,
        E,
        S = m.length;
    for (o = 0; o < y; o++) (g = h[o]), this.vertices.push(new THREE.Vector3(g.x, g.y, 0));
    for (o = 0; o < w; o++) {
        b = v[o];
        var x = b[0] + l,
            T = b[1] + l,
            N = b[2] + l;
        this.faces.push(new THREE.Face3(x, T, N, null, null, r)), this.faceVertexUvs[0].push(i.generateBottomUV(this, e, t, x, T, N));
    }
}),
(THREE.LatheGeometry = function (e, t, n, r) {
    THREE.Geometry.call(this), (t = t || 12), (n = n || 0), (r = r || 2 * Math.PI);
    var i = 1 / (e.length - 1),
        s = 1 / t;
    for (var o = 0, u = t; o <= u; o++) {
        var a = n + o * s * r,
            f = Math.cos(a),
            l = Math.sin(a);
        for (var c = 0, h = e.length; c < h; c++) {
            var p = e[c],
                d = new THREE.Vector3();
            (d.x = f * p.x - l * p.y), (d.y = l * p.x + f * p.y), (d.z = p.z), this.vertices.push(d);
        }
    }
    var v = e.length;
    for (var o = 0, u = t; o < u; o++)
        for (var c = 0, h = e.length - 1; c < h; c++) {
            var m = c + v * o,
                g = m,
                y = m + v,
                f = m + 1 + v,
                b = m + 1,
                w = o * s,
                E = c * i,
                S = w + s,
                x = E + i;
            this.faces.push(new THREE.Face3(g, y, b)),
                this.faceVertexUvs[0].push([new THREE.Vector2(w, E), new THREE.Vector2(S, E), new THREE.Vector2(w, x)]),
                this.faces.push(new THREE.Face3(y, f, b)),
                this.faceVertexUvs[0].push([new THREE.Vector2(S, E), new THREE.Vector2(S, x), new THREE.Vector2(w, x)]);
        }
    this.mergeVertices(), this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals();
}),
(THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.PlaneGeometry = function (e, t, n, r) {
    THREE.Geometry.call(this), (this.width = e), (this.height = t), (this.widthSegments = n || 1), (this.heightSegments = r || 1);
    var i,
        s,
        o = e / 2,
        u = t / 2,
        a = this.widthSegments,
        f = this.heightSegments,
        l = a + 1,
        c = f + 1,
        h = this.width / a,
        p = this.height / f,
        d = new THREE.Vector3(0, 0, 1);
    for (s = 0; s < c; s++)
        for (i = 0; i < l; i++) {
            var v = i * h - o,
                m = s * p - u;
            this.vertices.push(new THREE.Vector3(v, -m, 0));
        }
    for (s = 0; s < f; s++)
        for (i = 0; i < a; i++) {
            var g = i + l * s,
                y = i + l * (s + 1),
                b = i + 1 + l * (s + 1),
                w = i + 1 + l * s,
                E = new THREE.Vector2(i / a, 1 - s / f),
                S = new THREE.Vector2(i / a, 1 - (s + 1) / f),
                x = new THREE.Vector2((i + 1) / a, 1 - (s + 1) / f),
                T = new THREE.Vector2((i + 1) / a, 1 - s / f),
                N = new THREE.Face3(g, y, w);
            N.normal.copy(d),
                N.vertexNormals.push(d.clone(), d.clone(), d.clone()),
                this.faces.push(N),
                this.faceVertexUvs[0].push([E, S, T]),
                (N = new THREE.Face3(y, b, w)),
                N.normal.copy(d),
                N.vertexNormals.push(d.clone(), d.clone(), d.clone()),
                this.faces.push(N),
                this.faceVertexUvs[0].push([S.clone(), x, T.clone()]);
        }
    this.computeCentroids();
}),
(THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.RingGeometry = function (e, t, n, r, i, s) {
    THREE.Geometry.call(this), (e = e || 0), (t = t || 50), (i = i !== undefined ? i : 0), (s = s !== undefined ? s : Math.PI * 2), (n = n !== undefined ? Math.max(3, n) : 8), (r = r !== undefined ? Math.max(3, r) : 8);
    var o,
        u,
        a = [],
        f = e,
        l = (t - e) / r;
    for (o = 0; o <= r; o++) {
        for (u = 0; u <= n; u++) {
            var c = new THREE.Vector3(),
                h = i + (u / n) * s;
            (c.x = f * Math.cos(h)), (c.y = f * Math.sin(h)), this.vertices.push(c), a.push(new THREE.Vector2((c.x / f + 1) / 2, -(c.y / f + 1) / 2 + 1));
        }
        f += l;
    }
    var p = new THREE.Vector3(0, 0, 1);
    for (o = 0; o < r; o++) {
        var d = o * n;
        for (u = 0; u <= n; u++) {
            var h = u + d,
                v = h + o,
                m = h + n + o,
                g = h + n + 1 + o;
            this.faces.push(new THREE.Face3(v, m, g, [p, p, p])),
                this.faceVertexUvs[0].push([a[v], a[m], a[g]]),
                (v = h + o),
                (m = h + n + 1 + o),
                (g = h + 1 + o),
                this.faces.push(new THREE.Face3(v, m, g, [p, p, p])),
                this.faceVertexUvs[0].push([a[v], a[m], a[g]]);
        }
    }
    this.computeCentroids(), this.computeFaceNormals(), (this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), f));
}),
(THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.SphereGeometry = function (e, t, n, r, i, s, o) {
    THREE.Geometry.call(this),
        (this.radius = e = e || 50),
        (this.widthSegments = t = Math.max(3, Math.floor(t) || 8)),
        (this.heightSegments = n = Math.max(2, Math.floor(n) || 6)),
        (this.phiStart = r = r !== undefined ? r : 0),
        (this.phiLength = i = i !== undefined ? i : Math.PI * 2),
        (this.thetaStart = s = s !== undefined ? s : 0),
        (this.thetaLength = o = o !== undefined ? o : Math.PI);
    var u,
        a,
        f = [],
        l = [];
    for (a = 0; a <= n; a++) {
        var c = [],
            h = [];
        for (u = 0; u <= t; u++) {
            var p = u / t,
                d = a / n,
                v = new THREE.Vector3();
            (v.x = -e * Math.cos(r + p * i) * Math.sin(s + d * o)),
                (v.y = e * Math.cos(s + d * o)),
                (v.z = e * Math.sin(r + p * i) * Math.sin(s + d * o)),
                this.vertices.push(v),
                c.push(this.vertices.length - 1),
                h.push(new THREE.Vector2(p, 1 - d));
        }
        f.push(c), l.push(h);
    }
    for (a = 0; a < this.heightSegments; a++)
        for (u = 0; u < this.widthSegments; u++) {
            var m = f[a][u + 1],
                g = f[a][u],
                y = f[a + 1][u],
                b = f[a + 1][u + 1],
                w = this.vertices[m].clone().normalize(),
                E = this.vertices[g].clone().normalize(),
                S = this.vertices[y].clone().normalize(),
                x = this.vertices[b].clone().normalize(),
                T = l[a][u + 1].clone(),
                N = l[a][u].clone(),
                C = l[a + 1][u].clone(),
                k = l[a + 1][u + 1].clone();
            Math.abs(this.vertices[m].y) === this.radius
                ? (this.faces.push(new THREE.Face3(m, y, b, [w, S, x])), this.faceVertexUvs[0].push([T, C, k]))
                : Math.abs(this.vertices[y].y) === this.radius
                ? (this.faces.push(new THREE.Face3(m, g, y, [w, E, S])), this.faceVertexUvs[0].push([T, N, C]))
                : (this.faces.push(new THREE.Face3(m, g, b, [w, E, x])), this.faceVertexUvs[0].push([T, N, k]), this.faces.push(new THREE.Face3(g, y, b, [E, S, x])), this.faceVertexUvs[0].push([N.clone(), C, k.clone()]));
        }
    this.computeCentroids(), this.computeFaceNormals(), (this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), e));
}),
(THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.TextGeometry = function (e, t) {
    t = t || {};
    var n = THREE.FontUtils.generateShapes(e, t);
    (t.amount = t.height !== undefined ? t.height : 50),
    t.bevelThickness === undefined && (t.bevelThickness = 10),
    t.bevelSize === undefined && (t.bevelSize = 8),
    t.bevelEnabled === undefined && (t.bevelEnabled = !1),
        THREE.ExtrudeGeometry.call(this, n, t);
}),
(THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype)),
(THREE.TorusGeometry = function (e, t, n, r, i) {
    THREE.Geometry.call(this);
    var s = this;
    (this.radius = e || 100), (this.tube = t || 40), (this.radialSegments = n || 8), (this.tubularSegments = r || 6), (this.arc = i || Math.PI * 2);
    var o = new THREE.Vector3(),
        u = [],
        a = [];
    for (var f = 0; f <= this.radialSegments; f++)
        for (var l = 0; l <= this.tubularSegments; l++) {
            var c = (l / this.tubularSegments) * this.arc,
                h = (f / this.radialSegments) * Math.PI * 2;
            (o.x = this.radius * Math.cos(c)), (o.y = this.radius * Math.sin(c));
            var p = new THREE.Vector3();
            (p.x = (this.radius + this.tube * Math.cos(h)) * Math.cos(c)),
                (p.y = (this.radius + this.tube * Math.cos(h)) * Math.sin(c)),
                (p.z = this.tube * Math.sin(h)),
                this.vertices.push(p),
                u.push(new THREE.Vector2(l / this.tubularSegments, f / this.radialSegments)),
                a.push(p.clone().sub(o).normalize());
        }
    for (var f = 1; f <= this.radialSegments; f++)
        for (var l = 1; l <= this.tubularSegments; l++) {
            var d = (this.tubularSegments + 1) * f + l - 1,
                v = (this.tubularSegments + 1) * (f - 1) + l - 1,
                m = (this.tubularSegments + 1) * (f - 1) + l,
                g = (this.tubularSegments + 1) * f + l,
                y = new THREE.Face3(d, v, g, [a[d], a[v], a[g]]);
            y.normal.add(a[d]),
                y.normal.add(a[v]),
                y.normal.add(a[g]),
                y.normal.normalize(),
                this.faces.push(y),
                this.faceVertexUvs[0].push([u[d].clone(), u[v].clone(), u[g].clone()]),
                (y = new THREE.Face3(v, m, g, [a[v], a[m], a[g]])),
                y.normal.add(a[v]),
                y.normal.add(a[m]),
                y.normal.add(a[g]),
                y.normal.normalize(),
                this.faces.push(y),
                this.faceVertexUvs[0].push([u[v].clone(), u[m].clone(), u[g].clone()]);
        }
    this.computeCentroids();
}),
(THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.TorusKnotGeometry = function (e, t, n, r, i, s, o) {
    function O(e, t, n, r, i) {
        var s = Math.cos(e),
            o = Math.sin(e),
            u = (t / n) * e,
            a = Math.cos(u),
            f = r * (2 + a) * 0.5 * s,
            l = r * (2 + a) * o * 0.5,
            c = i * r * Math.sin(u) * 0.5;
        return new THREE.Vector3(f, l, c);
    }
    THREE.Geometry.call(this);
    var u = this;
    (this.radius = e || 100), (this.tube = t || 40), (this.radialSegments = n || 64), (this.tubularSegments = r || 8), (this.p = i || 2), (this.q = s || 3), (this.heightScale = o || 1), (this.grid = new Array(this.radialSegments));
    var a = new THREE.Vector3(),
        f = new THREE.Vector3(),
        l = new THREE.Vector3();
    for (var c = 0; c < this.radialSegments; ++c) {
        this.grid[c] = new Array(this.tubularSegments);
        var h = (c / this.radialSegments) * 2 * this.p * Math.PI,
            p = O(h, this.q, this.p, this.radius, this.heightScale),
            d = O(h + 0.01, this.q, this.p, this.radius, this.heightScale);
        a.subVectors(d, p), f.addVectors(d, p), l.crossVectors(a, f), f.crossVectors(l, a), l.normalize(), f.normalize();
        for (var v = 0; v < this.tubularSegments; ++v) {
            var m = (v / this.tubularSegments) * 2 * Math.PI,
                g = -this.tube * Math.cos(m),
                y = this.tube * Math.sin(m),
                b = new THREE.Vector3();
            (b.x = p.x + g * f.x + y * l.x), (b.y = p.y + g * f.y + y * l.y), (b.z = p.z + g * f.z + y * l.z), (this.grid[c][v] = u.vertices.push(b) - 1);
        }
    }
    for (var c = 0; c < this.radialSegments; ++c)
        for (var v = 0; v < this.tubularSegments; ++v) {
            var w = (c + 1) % this.radialSegments,
                E = (v + 1) % this.tubularSegments,
                S = this.grid[c][v],
                x = this.grid[w][v],
                T = this.grid[w][E],
                N = this.grid[c][E],
                C = new THREE.Vector2(c / this.radialSegments, v / this.tubularSegments),
                k = new THREE.Vector2((c + 1) / this.radialSegments, v / this.tubularSegments),
                L = new THREE.Vector2((c + 1) / this.radialSegments, (v + 1) / this.tubularSegments),
                A = new THREE.Vector2(c / this.radialSegments, (v + 1) / this.tubularSegments);
            this.faces.push(new THREE.Face3(S, x, N)), this.faceVertexUvs[0].push([C, k, A]), this.faces.push(new THREE.Face3(x, T, N)), this.faceVertexUvs[0].push([k.clone(), L, A.clone()]);
        }
    this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals();
}),
(THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.TubeGeometry = function (e, t, n, r, i) {
    function F(e, t, n) {
        return s.vertices.push(new THREE.Vector3(e, t, n)) - 1;
    }
    THREE.Geometry.call(this), (this.path = e), (this.segments = t || 64), (this.radius = n || 1), (this.radialSegments = r || 8), (this.closed = i || !1), (this.grid = []);
    var s = this,
        o,
        u,
        a,
        f = this.segments + 1,
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g,
        y,
        b,
        w,
        E = new THREE.Vector3(),
        S,
        x,
        T,
        N,
        C,
        k,
        L,
        A,
        O,
        M,
        _,
        D,
        P = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed),
        H = P.tangents,
        B = P.normals,
        j = P.binormals;
    (this.tangents = H), (this.normals = B), (this.binormals = j);
    for (S = 0; S < f; S++) {
        (this.grid[S] = []), (m = S / (f - 1)), (w = e.getPointAt(m)), (o = H[S]), (u = B[S]), (a = j[S]);
        for (x = 0; x < this.radialSegments; x++)
            (g = (x / this.radialSegments) * 2 * Math.PI),
                (y = -this.radius * Math.cos(g)),
                (b = this.radius * Math.sin(g)),
                E.copy(w),
                (E.x += y * u.x + b * a.x),
                (E.y += y * u.y + b * a.y),
                (E.z += y * u.z + b * a.z),
                (this.grid[S][x] = F(E.x, E.y, E.z));
    }
    for (S = 0; S < this.segments; S++)
        for (x = 0; x < this.radialSegments; x++)
            (T = this.closed ? (S + 1) % this.segments : S + 1),
                (N = (x + 1) % this.radialSegments),
                (C = this.grid[S][x]),
                (k = this.grid[T][x]),
                (L = this.grid[T][N]),
                (A = this.grid[S][N]),
                (O = new THREE.Vector2(S / this.segments, x / this.radialSegments)),
                (M = new THREE.Vector2((S + 1) / this.segments, x / this.radialSegments)),
                (_ = new THREE.Vector2((S + 1) / this.segments, (x + 1) / this.radialSegments)),
                (D = new THREE.Vector2(S / this.segments, (x + 1) / this.radialSegments)),
                this.faces.push(new THREE.Face3(C, k, A)),
                this.faceVertexUvs[0].push([O, M, D]),
                this.faces.push(new THREE.Face3(k, L, A)),
                this.faceVertexUvs[0].push([M.clone(), _, D.clone()]);
    this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals();
}),
(THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.TubeGeometry.FrenetFrames = function (e, t, n) {
    function E(e) {
        (u[0] = new THREE.Vector3()), (a[0] = new THREE.Vector3()), e === undefined && (e = new THREE.Vector3(0, 0, 1)), u[0].crossVectors(e, o[0]).normalize(), a[0].crossVectors(o[0], u[0]).normalize();
    }
    function S() {
        var t = e.getTangentAt(p);
        (u[0] = new THREE.Vector3().subVectors(t, o[0]).normalize()), (a[0] = new THREE.Vector3().crossVectors(o[0], u[0])), u[0].crossVectors(a[0], o[0]).normalize(), a[0].crossVectors(o[0], u[0]).normalize();
    }
    function x() {
        (u[0] = new THREE.Vector3()),
            (a[0] = new THREE.Vector3()),
            (d = Number.MAX_VALUE),
            (v = Math.abs(o[0].x)),
            (m = Math.abs(o[0].y)),
            (g = Math.abs(o[0].z)),
        v <= d && ((d = v), i.set(1, 0, 0)),
        m <= d && ((d = m), i.set(0, 1, 0)),
        g <= d && i.set(0, 0, 1),
            f.crossVectors(o[0], i).normalize(),
            u[0].crossVectors(o[0], f),
            a[0].crossVectors(o[0], u[0]);
    }
    var r = new THREE.Vector3(),
        i = new THREE.Vector3(),
        s = new THREE.Vector3(),
        o = [],
        u = [],
        a = [],
        f = new THREE.Vector3(),
        l = new THREE.Matrix4(),
        c = t + 1,
        h,
        p = 1e-4,
        d,
        v,
        m,
        g,
        y,
        b,
        w;
    (this.tangents = o), (this.normals = u), (this.binormals = a);
    for (y = 0; y < c; y++) (b = y / (c - 1)), (o[y] = e.getTangentAt(b)), o[y].normalize();
    x();
    for (y = 1; y < c; y++)
        (u[y] = u[y - 1].clone()),
            (a[y] = a[y - 1].clone()),
            f.crossVectors(o[y - 1], o[y]),
        f.length() > p && (f.normalize(), (h = Math.acos(THREE.Math.clamp(o[y - 1].dot(o[y]), -1, 1))), u[y].applyMatrix4(l.makeRotationAxis(f, h))),
            a[y].crossVectors(o[y], u[y]);
    if (n) {
        (h = Math.acos(THREE.Math.clamp(u[0].dot(u[c - 1]), -1, 1))), (h /= c - 1), o[0].dot(f.crossVectors(u[0], u[c - 1])) > 0 && (h = -h);
        for (y = 1; y < c; y++) u[y].applyMatrix4(l.makeRotationAxis(o[y], h * y)), a[y].crossVectors(o[y], u[y]);
    }
}),
(THREE.PolyhedronGeometry = function (e, t, n, r) {
    function b(e) {
        var t = e.normalize().clone();
        t.index = i.vertices.push(t) - 1;
        var n = S(e) / 2 / Math.PI + 0.5,
            r = x(e) / Math.PI + 0.5;
        return (t.uv = new THREE.Vector2(n, 1 - r)), t;
    }
    function w(e, t, n) {
        var r = new THREE.Face3(e.index, t.index, n.index, [e.clone(), t.clone(), n.clone()]);
        r.centroid.add(e).add(t).add(n).divideScalar(3), i.faces.push(r);
        var s = S(r.centroid);
        i.faceVertexUvs[0].push([T(e.uv, e, s), T(t.uv, t, s), T(n.uv, n, s)]);
    }
    function E(e, t) {
        var n = Math.pow(2, t),
            r = Math.pow(4, t),
            s = b(i.vertices[e.a]),
            o = b(i.vertices[e.b]),
            u = b(i.vertices[e.c]),
            a = [];
        for (var f = 0; f <= n; f++) {
            a[f] = [];
            var l = b(s.clone().lerp(u, f / n)),
                c = b(o.clone().lerp(u, f / n)),
                h = n - f;
            for (var p = 0; p <= h; p++) p == 0 && f == n ? (a[f][p] = l) : (a[f][p] = b(l.clone().lerp(c, p / h)));
        }
        for (var f = 0; f < n; f++)
            for (var p = 0; p < 2 * (n - f) - 1; p++) {
                var d = Math.floor(p / 2);
                p % 2 == 0 ? w(a[f][d + 1], a[f + 1][d], a[f][d]) : w(a[f][d + 1], a[f + 1][d + 1], a[f + 1][d]);
            }
    }
    function S(e) {
        return Math.atan2(e.z, -e.x);
    }
    function x(e) {
        return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z));
    }
    function T(e, t, n) {
        return n < 0 && e.x === 1 && (e = new THREE.Vector2(e.x - 1, e.y)), t.x === 0 && t.z === 0 && (e = new THREE.Vector2(n / 2 / Math.PI + 0.5, e.y)), e.clone();
    }
    THREE.Geometry.call(this), (n = n || 1), (r = r || 0);
    var i = this;
    for (var s = 0, o = e.length; s < o; s++) b(new THREE.Vector3(e[s][0], e[s][1], e[s][2]));
    var u = [],
        a = this.vertices,
        f = [];
    for (var s = 0, o = t.length; s < o; s++) {
        var l = a[t[s][0]],
            c = a[t[s][1]],
            h = a[t[s][2]];
        f[s] = new THREE.Face3(l.index, c.index, h.index, [l.clone(), c.clone(), h.clone()]);
    }
    for (var s = 0, o = f.length; s < o; s++) E(f[s], r);
    for (var s = 0, o = this.faceVertexUvs[0].length; s < o; s++) {
        var p = this.faceVertexUvs[0][s],
            d = p[0].x,
            v = p[1].x,
            m = p[2].x,
            g = Math.max(d, Math.max(v, m)),
            y = Math.min(d, Math.min(v, m));
        g > 0.9 && y < 0.1 && (d < 0.2 && (p[0].x += 1), v < 0.2 && (p[1].x += 1), m < 0.2 && (p[2].x += 1));
    }
    for (var s = 0, o = this.vertices.length; s < o; s++) this.vertices[s].multiplyScalar(n);
    this.mergeVertices(), this.computeCentroids(), this.computeFaceNormals(), (this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), n));
}),
(THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.IcosahedronGeometry = function (e, t) {
    (this.radius = e), (this.detail = t);
    var n = (1 + Math.sqrt(5)) / 2,
        r = [
            [-1, n, 0],
            [1, n, 0],
            [-1, -n, 0],
            [1, -n, 0],
            [0, -1, n],
            [0, 1, n],
            [0, -1, -n],
            [0, 1, -n],
            [n, 0, -1],
            [n, 0, 1],
            [-n, 0, -1],
            [-n, 0, 1],
        ],
        i = [
            [0, 11, 5],
            [0, 5, 1],
            [0, 1, 7],
            [0, 7, 10],
            [0, 10, 11],
            [1, 5, 9],
            [5, 11, 4],
            [11, 10, 2],
            [10, 7, 6],
            [7, 1, 8],
            [3, 9, 4],
            [3, 4, 2],
            [3, 2, 6],
            [3, 6, 8],
            [3, 8, 9],
            [4, 9, 5],
            [2, 4, 11],
            [6, 2, 10],
            [8, 6, 7],
            [9, 8, 1],
        ];
    THREE.PolyhedronGeometry.call(this, r, i, e, t);
}),
(THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.OctahedronGeometry = function (e, t) {
    var n = [
            [1, 0, 0],
            [-1, 0, 0],
            [0, 1, 0],
            [0, -1, 0],
            [0, 0, 1],
            [0, 0, -1],
        ],
        r = [
            [0, 2, 4],
            [0, 4, 3],
            [0, 3, 5],
            [0, 5, 2],
            [1, 2, 5],
            [1, 5, 3],
            [1, 3, 4],
            [1, 4, 2],
        ];
    THREE.PolyhedronGeometry.call(this, n, r, e, t);
}),
(THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.TetrahedronGeometry = function (e, t) {
    var n = [
            [1, 1, 1],
            [-1, -1, 1],
            [-1, 1, -1],
            [1, -1, -1],
        ],
        r = [
            [2, 1, 0],
            [0, 3, 2],
            [1, 3, 0],
            [2, 3, 1],
        ];
    THREE.PolyhedronGeometry.call(this, n, r, e, t);
}),
(THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.ParametricGeometry = function (e, t, n) {
    THREE.Geometry.call(this);
    var r = this.vertices,
        i = this.faces,
        s = this.faceVertexUvs[0],
        o,
        u,
        a,
        f,
        l,
        c,
        h = n + 1,
        p = t + 1;
    for (o = 0; o <= n; o++) {
        c = o / n;
        for (a = 0; a <= t; a++) (l = a / t), (f = e(l, c)), r.push(f);
    }
    var d, v, m, g, y, b, w, E;
    for (o = 0; o < n; o++)
        for (a = 0; a < t; a++)
            (d = o * p + a),
                (v = o * p + a + 1),
                (m = (o + 1) * p + a + 1),
                (g = (o + 1) * p + a),
                (y = new THREE.Vector2(a / t, o / n)),
                (b = new THREE.Vector2((a + 1) / t, o / n)),
                (w = new THREE.Vector2((a + 1) / t, (o + 1) / n)),
                (E = new THREE.Vector2(a / t, (o + 1) / n)),
                i.push(new THREE.Face3(d, v, g)),
                s.push([y, b, E]),
                i.push(new THREE.Face3(v, m, g)),
                s.push([b.clone(), w, E.clone()]);
    this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals();
}),
(THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype)),
(THREE.AxisHelper = function (e) {
    e = e || 1;
    var t = new THREE.Geometry();
    t.vertices.push(new THREE.Vector3(), new THREE.Vector3(e, 0, 0), new THREE.Vector3(), new THREE.Vector3(0, e, 0), new THREE.Vector3(), new THREE.Vector3(0, 0, e)),
        t.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));
    var n = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
    THREE.Line.call(this, t, n, THREE.LinePieces);
}),
(THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype)),
(THREE.ArrowHelper = function (e, t, n, r) {
    THREE.Object3D.call(this), r === undefined && (r = 16776960), n === undefined && (n = 1), (this.position = t);
    var i = new THREE.Geometry();
    i.vertices.push(new THREE.Vector3(0, 0, 0)), i.vertices.push(new THREE.Vector3(0, 1, 0)), (this.line = new THREE.Line(i, new THREE.LineBasicMaterial({ color: r }))), (this.line.matrixAutoUpdate = !1), this.add(this.line);
    var s = new THREE.CylinderGeometry(0, 0.05, 0.25, 5, 1);
    s.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.875, 0)),
        (this.cone = new THREE.Mesh(s, new THREE.MeshBasicMaterial({ color: r }))),
        (this.cone.matrixAutoUpdate = !1),
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(n);
}),
(THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.ArrowHelper.prototype.setDirection = (function () {
    var e = new THREE.Vector3(),
        t;
    return function (n) {
        n.y > 0.99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -0.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), (t = Math.acos(n.y)), this.quaternion.setFromAxisAngle(e, t));
    };
})()),
(THREE.ArrowHelper.prototype.setLength = function (e) {
    this.scale.set(e, e, e);
}),
(THREE.ArrowHelper.prototype.setColor = function (e) {
    this.line.material.color.setHex(e), this.cone.material.color.setHex(e);
}),
(THREE.BoxHelper = function (e) {
    var t = [
        new THREE.Vector3(1, 1, 1),
        new THREE.Vector3(-1, 1, 1),
        new THREE.Vector3(-1, -1, 1),
        new THREE.Vector3(1, -1, 1),
        new THREE.Vector3(1, 1, -1),
        new THREE.Vector3(-1, 1, -1),
        new THREE.Vector3(-1, -1, -1),
        new THREE.Vector3(1, -1, -1),
    ];
    this.vertices = t;
    var n = new THREE.Geometry();
    n.vertices.push(t[0], t[1], t[1], t[2], t[2], t[3], t[3], t[0], t[4], t[5], t[5], t[6], t[6], t[7], t[7], t[4], t[0], t[4], t[1], t[5], t[2], t[6], t[3], t[7]),
        THREE.Line.call(this, n, new THREE.LineBasicMaterial({ color: 16776960 }), THREE.LinePieces),
    e !== undefined && this.update(e);
}),
(THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype)),
(THREE.BoxHelper.prototype.update = function (e) {
    var t = e.geometry;
    t.boundingBox === null && t.computeBoundingBox();
    var n = t.boundingBox.min,
        r = t.boundingBox.max,
        i = this.vertices;
    i[0].set(r.x, r.y, r.z),
        i[1].set(n.x, r.y, r.z),
        i[2].set(n.x, n.y, r.z),
        i[3].set(r.x, n.y, r.z),
        i[4].set(r.x, r.y, n.z),
        i[5].set(n.x, r.y, n.z),
        i[6].set(n.x, n.y, n.z),
        i[7].set(r.x, n.y, n.z),
        this.geometry.computeBoundingSphere(),
        (this.geometry.verticesNeedUpdate = !0),
        (this.matrixAutoUpdate = !1),
        (this.matrixWorld = e.matrixWorld);
}),
(THREE.BoundingBoxHelper = function (e, t) {
    var n = t || 8947848;
    (this.object = e), (this.box = new THREE.Box3()), THREE.Mesh.call(this, new THREE.CubeGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: n, wireframe: !0 }));
}),
(THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype)),
(THREE.BoundingBoxHelper.prototype.update = function () {
    this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position);
}),
(THREE.CameraHelper = function (e) {
    function f(e, t, n) {
        l(e, n), l(t, n);
    }
    function l(e, n) {
        t.vertices.push(new THREE.Vector3()), t.colors.push(new THREE.Color(n)), r[e] === undefined && (r[e] = []), r[e].push(t.vertices.length - 1);
    }
    var t = new THREE.Geometry(),
        n = new THREE.LineBasicMaterial({ color: 16777215, vertexColors: THREE.FaceColors }),
        r = {},
        i = 16755200,
        s = 16711680,
        o = 43775,
        u = 16777215,
        a = 3355443;
    f("n1", "n2", i),
        f("n2", "n4", i),
        f("n4", "n3", i),
        f("n3", "n1", i),
        f("f1", "f2", i),
        f("f2", "f4", i),
        f("f4", "f3", i),
        f("f3", "f1", i),
        f("n1", "f1", i),
        f("n2", "f2", i),
        f("n3", "f3", i),
        f("n4", "f4", i),
        f("p", "n1", s),
        f("p", "n2", s),
        f("p", "n3", s),
        f("p", "n4", s),
        f("u1", "u2", o),
        f("u2", "u3", o),
        f("u3", "u1", o),
        f("c", "t", u),
        f("p", "c", a),
        f("cn1", "cn2", a),
        f("cn3", "cn4", a),
        f("cf1", "cf2", a),
        f("cf3", "cf4", a),
        THREE.Line.call(this, t, n, THREE.LinePieces),
        (this.camera = e),
        (this.matrixWorld = e.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.pointMap = r),
        this.update();
}),
(THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype)),
(THREE.CameraHelper.prototype.update = (function () {
    var e = new THREE.Vector3(),
        t = new THREE.Camera(),
        n = new THREE.Projector();
    return function () {
        function o(i, s, o, u) {
            e.set(s, o, u), n.unprojectVector(e, t);
            var a = r.pointMap[i];
            if (a !== undefined) for (var f = 0, l = a.length; f < l; f++) r.geometry.vertices[a[f]].copy(e);
        }
        var r = this,
            i = 1,
            s = 1;
        t.projectionMatrix.copy(this.camera.projectionMatrix),
            o("c", 0, 0, -1),
            o("t", 0, 0, 1),
            o("n1", -i, -s, -1),
            o("n2", i, -s, -1),
            o("n3", -i, s, -1),
            o("n4", i, s, -1),
            o("f1", -i, -s, 1),
            o("f2", i, -s, 1),
            o("f3", -i, s, 1),
            o("f4", i, s, 1),
            o("u1", i * 0.7, s * 1.1, -1),
            o("u2", -i * 0.7, s * 1.1, -1),
            o("u3", 0, s * 2, -1),
            o("cf1", -i, 0, 1),
            o("cf2", i, 0, 1),
            o("cf3", 0, -s, 1),
            o("cf4", 0, s, 1),
            o("cn1", -i, 0, -1),
            o("cn2", i, 0, -1),
            o("cn3", 0, -s, -1),
            o("cn4", 0, s, -1),
            (this.geometry.verticesNeedUpdate = !0);
    };
})()),
(THREE.DirectionalLightHelper = function (e, t) {
    THREE.Object3D.call(this), (this.light = e), this.light.updateMatrixWorld(), (this.matrixWorld = e.matrixWorld), (this.matrixAutoUpdate = !1);
    var n = new THREE.PlaneGeometry(t, t),
        r = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 });
    r.color.copy(this.light.color).multiplyScalar(this.light.intensity),
        (this.lightPlane = new THREE.Mesh(n, r)),
        this.add(this.lightPlane),
        (n = new THREE.Geometry()),
        n.vertices.push(new THREE.Vector3()),
        n.vertices.push(new THREE.Vector3()),
        n.computeLineDistances(),
        (r = new THREE.LineBasicMaterial({ fog: !1 })),
        r.color.copy(this.light.color).multiplyScalar(this.light.intensity),
        (this.targetLine = new THREE.Line(n, r)),
        this.add(this.targetLine),
        this.update();
}),
(THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.DirectionalLightHelper.prototype.dispose = function () {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
}),
(THREE.DirectionalLightHelper.prototype.update = (function () {
    var e = new THREE.Vector3();
    return function () {
        e.getPositionFromMatrix(this.light.matrixWorld).negate(),
            this.lightPlane.lookAt(e),
            this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity),
            this.targetLine.geometry.vertices[1].copy(e),
            (this.targetLine.geometry.verticesNeedUpdate = !0),
            this.targetLine.material.color.copy(this.lightPlane.material.color);
    };
})()),
(THREE.FaceNormalsHelper = function (e, t, n, r) {
    (this.object = e), (this.size = t || 1);
    var i = n || 16776960,
        s = r || 1,
        o = new THREE.Geometry(),
        u = this.object.geometry.faces;
    for (var a = 0, f = u.length; a < f; a++) o.vertices.push(new THREE.Vector3()), o.vertices.push(new THREE.Vector3());
    THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: i, linewidth: s }), THREE.LinePieces), (this.matrixAutoUpdate = !1), (this.normalMatrix = new THREE.Matrix3()), this.update();
}),
(THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype)),
(THREE.FaceNormalsHelper.prototype.update = (function (e) {
    var t = new THREE.Vector3();
    return function (e) {
        this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var n = this.geometry.vertices,
            r = this.object.geometry.faces,
            i = this.object.matrixWorld;
        for (var s = 0, o = r.length; s < o; s++) {
            var u = r[s];
            t.copy(u.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
            var a = 2 * s;
            n[a].copy(u.centroid).applyMatrix4(i), n[a + 1].addVectors(n[a], t);
        }
        return (this.geometry.verticesNeedUpdate = !0), this;
    };
})()),
(THREE.GridHelper = function (e, t) {
    var n = new THREE.Geometry(),
        r = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
    (this.color1 = new THREE.Color(4473924)), (this.color2 = new THREE.Color(8947848));
    for (var i = -e; i <= e; i += t) {
        n.vertices.push(new THREE.Vector3(-e, 0, i), new THREE.Vector3(e, 0, i), new THREE.Vector3(i, 0, -e), new THREE.Vector3(i, 0, e));
        var s = i === 0 ? this.color1 : this.color2;
        n.colors.push(s, s, s, s);
    }
    THREE.Line.call(this, n, r, THREE.LinePieces);
}),
(THREE.GridHelper.prototype = Object.create(THREE.Line.prototype)),
(THREE.GridHelper.prototype.setColors = function (e, t) {
    this.color1.set(e), this.color2.set(t), (this.geometry.colorsNeedUpdate = !0);
}),
(THREE.HemisphereLightHelper = function (e, t, n, r) {
    THREE.Object3D.call(this), (this.light = e), this.light.updateMatrixWorld(), (this.matrixWorld = e.matrixWorld), (this.matrixAutoUpdate = !1), (this.colors = [new THREE.Color(), new THREE.Color()]);
    var i = new THREE.SphereGeometry(t, 4, 2);
    i.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
    for (var s = 0, o = 8; s < o; s++) i.faces[s].color = this.colors[s < 4 ? 0 : 1];
    var u = new THREE.MeshBasicMaterial({ vertexColors: THREE.FaceColors, wireframe: !0 });
    (this.lightSphere = new THREE.Mesh(i, u)), this.add(this.lightSphere), this.update();
}),
(THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.HemisphereLightHelper.prototype.dispose = function () {
    this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose();
}),
(THREE.HemisphereLightHelper.prototype.update = (function () {
    var e = new THREE.Vector3();
    return function () {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity),
            this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity),
            this.lightSphere.lookAt(e.getPositionFromMatrix(this.light.matrixWorld).negate()),
            (this.lightSphere.geometry.colorsNeedUpdate = !0);
    };
})()),
(THREE.PointLightHelper = function (e, t) {
    (this.light = e), this.light.updateMatrixWorld();
    var n = new THREE.SphereGeometry(t, 4, 2),
        r = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 });
    r.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, n, r), (this.matrixWorld = this.light.matrixWorld), (this.matrixAutoUpdate = !1);
}),
(THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype)),
(THREE.PointLightHelper.prototype.dispose = function () {
    this.geometry.dispose(), this.material.dispose();
}),
(THREE.PointLightHelper.prototype.update = function () {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
}),
(THREE.SpotLightHelper = function (e) {
    THREE.Object3D.call(this), (this.light = e), this.light.updateMatrixWorld(), (this.matrixWorld = e.matrixWorld), (this.matrixAutoUpdate = !1);
    var t = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
    t.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0)), t.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
    var n = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 });
    (this.cone = new THREE.Mesh(t, n)), this.add(this.cone), this.update();
}),
(THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.SpotLightHelper.prototype.dispose = function () {
    this.cone.geometry.dispose(), this.cone.material.dispose();
}),
(THREE.SpotLightHelper.prototype.update = (function () {
    var e = new THREE.Vector3(),
        t = new THREE.Vector3();
    return function () {
        var n = this.light.distance ? this.light.distance : 1e4,
            r = n * Math.tan(this.light.angle);
        this.cone.scale.set(r, r, n),
            e.getPositionFromMatrix(this.light.matrixWorld),
            t.getPositionFromMatrix(this.light.target.matrixWorld),
            this.cone.lookAt(t.sub(e)),
            this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
})()),
(THREE.VertexNormalsHelper = function (e, t, n, r) {
    (this.object = e), (this.size = t || 1);
    var i = n || 16711680,
        s = r || 1,
        o = new THREE.Geometry(),
        u = e.geometry.vertices,
        a = e.geometry.faces;
    for (var f = 0, l = a.length; f < l; f++) {
        var c = a[f];
        for (var h = 0, p = c.vertexNormals.length; h < p; h++) o.vertices.push(new THREE.Vector3()), o.vertices.push(new THREE.Vector3());
    }
    THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: i, linewidth: s }), THREE.LinePieces), (this.matrixAutoUpdate = !1), (this.normalMatrix = new THREE.Matrix3()), this.update();
}),
(THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype)),
(THREE.VertexNormalsHelper.prototype.update = (function (e) {
    var t = new THREE.Vector3();
    return function (e) {
        var n = ["a", "b", "c", "d"];
        this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var r = this.geometry.vertices,
            i = this.object.geometry.vertices,
            s = this.object.geometry.faces,
            o = this.object.matrixWorld,
            u = 0;
        for (var a = 0, f = s.length; a < f; a++) {
            var l = s[a];
            for (var c = 0, h = l.vertexNormals.length; c < h; c++) {
                var p = l[n[c]],
                    d = i[p],
                    v = l.vertexNormals[c];
                r[u].copy(d).applyMatrix4(o), t.copy(v).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), t.add(r[u]), (u += 1), r[u].copy(t), (u += 1);
            }
        }
        return (this.geometry.verticesNeedUpdate = !0), this;
    };
})()),
(THREE.VertexTangentsHelper = function (e, t, n, r) {
    (this.object = e), (this.size = t || 1);
    var i = n || 255,
        s = r || 1,
        o = new THREE.Geometry(),
        u = e.geometry.vertices,
        a = e.geometry.faces;
    for (var f = 0, l = a.length; f < l; f++) {
        var c = a[f];
        for (var h = 0, p = c.vertexTangents.length; h < p; h++) o.vertices.push(new THREE.Vector3()), o.vertices.push(new THREE.Vector3());
    }
    THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: i, linewidth: s }), THREE.LinePieces), (this.matrixAutoUpdate = !1), this.update();
}),
(THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype)),
(THREE.VertexTangentsHelper.prototype.update = (function (e) {
    var t = new THREE.Vector3();
    return function (e) {
        var n = ["a", "b", "c", "d"];
        this.object.updateMatrixWorld(!0);
        var r = this.geometry.vertices,
            i = this.object.geometry.vertices,
            s = this.object.geometry.faces,
            o = this.object.matrixWorld,
            u = 0;
        for (var a = 0, f = s.length; a < f; a++) {
            var l = s[a];
            for (var c = 0, h = l.vertexTangents.length; c < h; c++) {
                var p = l[n[c]],
                    d = i[p],
                    v = l.vertexTangents[c];
                r[u].copy(d).applyMatrix4(o), t.copy(v).transformDirection(o).multiplyScalar(this.size), t.add(r[u]), (u += 1), r[u].copy(t), (u += 1);
            }
        }
        return (this.geometry.verticesNeedUpdate = !0), this;
    };
})()),
(THREE.WireframeHelper = function (e) {
    var t = [0, 0],
        n = {},
        r = function (e, t) {
            return e - t;
        },
        i = ["a", "b", "c", "d"],
        s = new THREE.Geometry(),
        o = e.geometry.vertices,
        u = e.geometry.faces;
    for (var a = 0, f = u.length; a < f; a++) {
        var l = u[a];
        for (var c = 0; c < 3; c++) {
            (t[0] = l[i[c]]), (t[1] = l[i[(c + 1) % 3]]), t.sort(r);
            var h = t.toString();
            n[h] === undefined && (s.vertices.push(o[t[0]]), s.vertices.push(o[t[1]]), (n[h] = !0));
        }
    }
    THREE.Line.call(this, s, new THREE.LineBasicMaterial({ color: 16777215 }), THREE.LinePieces), (this.matrixAutoUpdate = !1), (this.matrixWorld = e.matrixWorld);
}),
(THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype)),
(THREE.ImmediateRenderObject = function () {
    THREE.Object3D.call(this), (this.render = function (e) {});
}),
(THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.LensFlare = function (e, t, n, r, i) {
    THREE.Object3D.call(this), (this.lensFlares = []), (this.positionScreen = new THREE.Vector3()), (this.customUpdateCallback = undefined), e !== undefined && this.add(e, t, n, r, i);
}),
(THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype)),
(THREE.LensFlare.prototype.add = function (e, t, n, r, i, s) {
    t === undefined && (t = -1),
    n === undefined && (n = 0),
    s === undefined && (s = 1),
    i === undefined && (i = new THREE.Color(16777215)),
    r === undefined && (r = THREE.NormalBlending),
        (n = Math.min(n, Math.max(0, n))),
        this.lensFlares.push({ texture: e, size: t, distance: n, x: 0, y: 0, z: 0, scale: 1, rotation: 1, opacity: s, color: i, blending: r });
}),
(THREE.LensFlare.prototype.updateLensFlares = function () {
    var e,
        t = this.lensFlares.length,
        n,
        r = -this.positionScreen.x * 2,
        i = -this.positionScreen.y * 2;
    for (e = 0; e < t; e++)
        (n = this.lensFlares[e]), (n.x = this.positionScreen.x + r * n.distance), (n.y = this.positionScreen.y + i * n.distance), (n.wantedRotation = n.x * Math.PI * 0.25), (n.rotation += (n.wantedRotation - n.rotation) * 0.25);
}),
(THREE.MorphBlendMesh = function (e, t) {
    THREE.Mesh.call(this, e, t), (this.animationsMap = {}), (this.animationsList = []);
    var n = this.geometry.morphTargets.length,
        r = "__default",
        i = 0,
        s = n - 1,
        o = n / 1;
    this.createAnimation(r, i, s, o), this.setAnimationWeight(r, 1);
}),
(THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype)),
(THREE.MorphBlendMesh.prototype.createAnimation = function (e, t, n, r) {
    var i = { startFrame: t, endFrame: n, length: n - t + 1, fps: r, duration: (n - t) / r, lastFrame: 0, currentFrame: 0, active: !1, time: 0, direction: 1, weight: 1, directionBackwards: !1, mirroredLoop: !1 };
    (this.animationsMap[e] = i), this.animationsList.push(i);
}),
(THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (e) {
    var t = /([a-z]+)(\d+)/,
        n,
        r = {},
        i = this.geometry;
    for (var s = 0, o = i.morphTargets.length; s < o; s++) {
        var u = i.morphTargets[s],
            a = u.name.match(t);
        if (a && a.length > 1) {
            var f = a[1],
                l = a[2];
            r[f] || (r[f] = { start: Infinity, end: -Infinity });
            var c = r[f];
            s < c.start && (c.start = s), s > c.end && (c.end = s), n || (n = f);
        }
    }
    for (var f in r) {
        var c = r[f];
        this.createAnimation(f, c.start, c.end, e);
    }
    this.firstAnimation = n;
}),
(THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (e) {
    var t = this.animationsMap[e];
    t && ((t.direction = 1), (t.directionBackwards = !1));
}),
(THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (e) {
    var t = this.animationsMap[e];
    t && ((t.direction = -1), (t.directionBackwards = !0));
}),
(THREE.MorphBlendMesh.prototype.setAnimationFPS = function (e, t) {
    var n = this.animationsMap[e];
    n && ((n.fps = t), (n.duration = (n.end - n.start) / n.fps));
}),
(THREE.MorphBlendMesh.prototype.setAnimationDuration = function (e, t) {
    var n = this.animationsMap[e];
    n && ((n.duration = t), (n.fps = (n.end - n.start) / n.duration));
}),
(THREE.MorphBlendMesh.prototype.setAnimationWeight = function (e, t) {
    var n = this.animationsMap[e];
    n && (n.weight = t);
}),
(THREE.MorphBlendMesh.prototype.setAnimationTime = function (e, t) {
    var n = this.animationsMap[e];
    n && (n.time = t);
}),
(THREE.MorphBlendMesh.prototype.getAnimationTime = function (e) {
    var t = 0,
        n = this.animationsMap[e];
    return n && (t = n.time), t;
}),
(THREE.MorphBlendMesh.prototype.getAnimationDuration = function (e) {
    var t = -1,
        n = this.animationsMap[e];
    return n && (t = n.duration), t;
}),
(THREE.MorphBlendMesh.prototype.playAnimation = function (e) {
    var t = this.animationsMap[e];
    t ? ((t.time = 0), (t.active = !0)) : console.warn("animation[" + e + "] undefined");
}),
(THREE.MorphBlendMesh.prototype.stopAnimation = function (e) {
    var t = this.animationsMap[e];
    t && (t.active = !1);
}),
(THREE.MorphBlendMesh.prototype.update = function (e) {
    for (var t = 0, n = this.animationsList.length; t < n; t++) {
        var r = this.animationsList[t];
        if (!r.active) continue;
        var i = r.duration / r.length;
        r.time += r.direction * e;
        if (r.mirroredLoop) {
            if (r.time > r.duration || r.time < 0) (r.direction *= -1), r.time > r.duration && ((r.time = r.duration), (r.directionBackwards = !0)), r.time < 0 && ((r.time = 0), (r.directionBackwards = !1));
        } else (r.time = r.time % r.duration), r.time < 0 && (r.time += r.duration);
        var s = r.startFrame + THREE.Math.clamp(Math.floor(r.time / i), 0, r.length - 1),
            o = r.weight;
        s !== r.currentFrame && ((this.morphTargetInfluences[r.lastFrame] = 0), (this.morphTargetInfluences[r.currentFrame] = 1 * o), (this.morphTargetInfluences[s] = 0), (r.lastFrame = r.currentFrame), (r.currentFrame = s));
        var u = (r.time % i) / i;
        r.directionBackwards && (u = 1 - u), (this.morphTargetInfluences[r.currentFrame] = u * o), (this.morphTargetInfluences[r.lastFrame] = (1 - u) * o);
    }
}),
(THREE.LensFlarePlugin = function () {
    function i(t, n) {
        var r = e.createProgram(),
            i = e.createShader(e.FRAGMENT_SHADER),
            s = e.createShader(e.VERTEX_SHADER),
            o = "precision " + n + " float;\n";
        return e.shaderSource(i, o + t.fragmentShader), e.shaderSource(s, o + t.vertexShader), e.compileShader(i), e.compileShader(s), e.attachShader(r, i), e.attachShader(r, s), e.linkProgram(r), r;
    }
    var e,
        t,
        n,
        r = {};
    (this.init = function (s) {
        (e = s.context), (t = s), (n = s.getPrecision()), (r.vertices = new Float32Array(16)), (r.faces = new Uint16Array(6));
        var o = 0;
        (r.vertices[o++] = -1),
            (r.vertices[o++] = -1),
            (r.vertices[o++] = 0),
            (r.vertices[o++] = 0),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = -1),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = 0),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = -1),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = 0),
            (r.vertices[o++] = 1),
            (o = 0),
            (r.faces[o++] = 0),
            (r.faces[o++] = 1),
            (r.faces[o++] = 2),
            (r.faces[o++] = 0),
            (r.faces[o++] = 2),
            (r.faces[o++] = 3),
            (r.vertexBuffer = e.createBuffer()),
            (r.elementBuffer = e.createBuffer()),
            e.bindBuffer(e.ARRAY_BUFFER, r.vertexBuffer),
            e.bufferData(e.ARRAY_BUFFER, r.vertices, e.STATIC_DRAW),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r.elementBuffer),
            e.bufferData(e.ELEMENT_ARRAY_BUFFER, r.faces, e.STATIC_DRAW),
            (r.tempTexture = e.createTexture()),
            (r.occlusionTexture = e.createTexture()),
            e.bindTexture(e.TEXTURE_2D, r.tempTexture),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGB, 16, 16, 0, e.RGB, e.UNSIGNED_BYTE, null),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.bindTexture(e.TEXTURE_2D, r.occlusionTexture),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 16, 16, 0, e.RGBA, e.UNSIGNED_BYTE, null),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS) <= 0
                ? ((r.hasVertexTexture = !1), (r.program = i(THREE.ShaderFlares.lensFlare, n)))
                : ((r.hasVertexTexture = !0), (r.program = i(THREE.ShaderFlares.lensFlareVertexTexture, n))),
            (r.attributes = {}),
            (r.uniforms = {}),
            (r.attributes.vertex = e.getAttribLocation(r.program, "position")),
            (r.attributes.uv = e.getAttribLocation(r.program, "uv")),
            (r.uniforms.renderType = e.getUniformLocation(r.program, "renderType")),
            (r.uniforms.map = e.getUniformLocation(r.program, "map")),
            (r.uniforms.occlusionMap = e.getUniformLocation(r.program, "occlusionMap")),
            (r.uniforms.opacity = e.getUniformLocation(r.program, "opacity")),
            (r.uniforms.color = e.getUniformLocation(r.program, "color")),
            (r.uniforms.scale = e.getUniformLocation(r.program, "scale")),
            (r.uniforms.rotation = e.getUniformLocation(r.program, "rotation")),
            (r.uniforms.screenPosition = e.getUniformLocation(r.program, "screenPosition"));
    }),
        (this.render = function (n, i, s, o) {
            var u = n.__webglFlares,
                a = u.length;
            if (!a) return;
            var f = new THREE.Vector3(),
                l = o / s,
                c = s * 0.5,
                h = o * 0.5,
                p = 16 / o,
                d = new THREE.Vector2(p * l, p),
                v = new THREE.Vector3(1, 1, 0),
                m = new THREE.Vector2(1, 1),
                g = r.uniforms,
                y = r.attributes;
            e.useProgram(r.program),
                e.enableVertexAttribArray(r.attributes.vertex),
                e.enableVertexAttribArray(r.attributes.uv),
                e.uniform1i(g.occlusionMap, 0),
                e.uniform1i(g.map, 1),
                e.bindBuffer(e.ARRAY_BUFFER, r.vertexBuffer),
                e.vertexAttribPointer(y.vertex, 2, e.FLOAT, !1, 16, 0),
                e.vertexAttribPointer(y.uv, 2, e.FLOAT, !1, 16, 8),
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r.elementBuffer),
                e.disable(e.CULL_FACE),
                e.depthMask(!1);
            var b, w, E, S, x;
            for (b = 0; b < a; b++) {
                (p = 16 / o),
                    d.set(p * l, p),
                    (S = u[b]),
                    f.set(S.matrixWorld.elements[12], S.matrixWorld.elements[13], S.matrixWorld.elements[14]),
                    f.applyMatrix4(i.matrixWorldInverse),
                    f.applyProjection(i.projectionMatrix),
                    v.copy(f),
                    (m.x = v.x * c + c),
                    (m.y = v.y * h + h);
                if (r.hasVertexTexture || (m.x > 0 && m.x < s && m.y > 0 && m.y < o)) {
                    e.activeTexture(e.TEXTURE1),
                        e.bindTexture(e.TEXTURE_2D, r.tempTexture),
                        e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGB, m.x - 8, m.y - 8, 16, 16, 0),
                        e.uniform1i(g.renderType, 0),
                        e.uniform2f(g.scale, d.x, d.y),
                        e.uniform3f(g.screenPosition, v.x, v.y, v.z),
                        e.disable(e.BLEND),
                        e.enable(e.DEPTH_TEST),
                        e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                        e.activeTexture(e.TEXTURE0),
                        e.bindTexture(e.TEXTURE_2D, r.occlusionTexture),
                        e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, m.x - 8, m.y - 8, 16, 16, 0),
                        e.uniform1i(g.renderType, 1),
                        e.disable(e.DEPTH_TEST),
                        e.activeTexture(e.TEXTURE1),
                        e.bindTexture(e.TEXTURE_2D, r.tempTexture),
                        e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                        S.positionScreen.copy(v),
                        S.customUpdateCallback ? S.customUpdateCallback(S) : S.updateLensFlares(),
                        e.uniform1i(g.renderType, 2),
                        e.enable(e.BLEND);
                    for (w = 0, E = S.lensFlares.length; w < E; w++)
                        (x = S.lensFlares[w]),
                        x.opacity > 0.001 &&
                        x.scale > 0.001 &&
                        ((v.x = x.x),
                            (v.y = x.y),
                            (v.z = x.z),
                            (p = (x.size * x.scale) / o),
                            (d.x = p * l),
                            (d.y = p),
                            e.uniform3f(g.screenPosition, v.x, v.y, v.z),
                            e.uniform2f(g.scale, d.x, d.y),
                            e.uniform1f(g.rotation, x.rotation),
                            e.uniform1f(g.opacity, x.opacity),
                            e.uniform3f(g.color, x.color.r, x.color.g, x.color.b),
                            t.setBlending(x.blending, x.blendEquation, x.blendSrc, x.blendDst),
                            t.setTexture(x.texture, 1),
                            e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
                }
            }
            e.enable(e.CULL_FACE), e.enable(e.DEPTH_TEST), e.depthMask(!0);
        });
}),
(THREE.ShadowMapPlugin = function () {
    function c(e, t) {
        var n = new THREE.DirectionalLight();
        (n.isVirtual = !0),
            (n.onlyShadow = !0),
            (n.castShadow = !0),
            (n.shadowCameraNear = e.shadowCameraNear),
            (n.shadowCameraFar = e.shadowCameraFar),
            (n.shadowCameraLeft = e.shadowCameraLeft),
            (n.shadowCameraRight = e.shadowCameraRight),
            (n.shadowCameraBottom = e.shadowCameraBottom),
            (n.shadowCameraTop = e.shadowCameraTop),
            (n.shadowCameraVisible = e.shadowCameraVisible),
            (n.shadowDarkness = e.shadowDarkness),
            (n.shadowBias = e.shadowCascadeBias[t]),
            (n.shadowMapWidth = e.shadowCascadeWidth[t]),
            (n.shadowMapHeight = e.shadowCascadeHeight[t]),
            (n.pointsWorld = []),
            (n.pointsFrustum = []);
        var r = n.pointsWorld,
            i = n.pointsFrustum;
        for (var s = 0; s < 8; s++) (r[s] = new THREE.Vector3()), (i[s] = new THREE.Vector3());
        var o = e.shadowCascadeNearZ[t],
            u = e.shadowCascadeFarZ[t];
        return i[0].set(-1, -1, o), i[1].set(1, -1, o), i[2].set(-1, 1, o), i[3].set(1, 1, o), i[4].set(-1, -1, u), i[5].set(1, -1, u), i[6].set(-1, 1, u), i[7].set(1, 1, u), n;
    }
    function h(e, t) {
        var n = e.shadowCascadeArray[t];
        n.position.copy(e.position), n.target.position.copy(e.target.position), n.lookAt(n.target), (n.shadowCameraVisible = e.shadowCameraVisible), (n.shadowDarkness = e.shadowDarkness), (n.shadowBias = e.shadowCascadeBias[t]);
        var r = e.shadowCascadeNearZ[t],
            i = e.shadowCascadeFarZ[t],
            s = n.pointsFrustum;
        (s[0].z = r), (s[1].z = r), (s[2].z = r), (s[3].z = r), (s[4].z = i), (s[5].z = i), (s[6].z = i), (s[7].z = i);
    }
    function p(e, t) {
        var n = t.shadowCamera,
            r = t.pointsFrustum,
            i = t.pointsWorld;
        a.set(Infinity, Infinity, Infinity), f.set(-Infinity, -Infinity, -Infinity);
        for (var s = 0; s < 8; s++) {
            var o = i[s];
            o.copy(r[s]),
                THREE.ShadowMapPlugin.__projector.unprojectVector(o, e),
                o.applyMatrix4(n.matrixWorldInverse),
            o.x < a.x && (a.x = o.x),
            o.x > f.x && (f.x = o.x),
            o.y < a.y && (a.y = o.y),
            o.y > f.y && (f.y = o.y),
            o.z < a.z && (a.z = o.z),
            o.z > f.z && (f.z = o.z);
        }
        (n.left = a.x), (n.right = f.x), (n.top = f.y), (n.bottom = a.y), n.updateProjectionMatrix();
    }
    function d(e) {
        return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[0] : e.material;
    }
    var e,
        t,
        n,
        r,
        i,
        s,
        o = new THREE.Frustum(),
        u = new THREE.Matrix4(),
        a = new THREE.Vector3(),
        f = new THREE.Vector3(),
        l = new THREE.Vector3();
    (this.init = function (o) {
        (e = o.context), (t = o);
        var u = THREE.ShaderLib.depthRGBA,
            a = THREE.UniformsUtils.clone(u.uniforms);
        (n = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a })),
            (r = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, morphTargets: !0 })),
            (i = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, skinning: !0 })),
            (s = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, morphTargets: !0, skinning: !0 })),
            (n._shadowPass = !0),
            (r._shadowPass = !0),
            (i._shadowPass = !0),
            (s._shadowPass = !0);
    }),
        (this.render = function (e, n) {
            if (!t.shadowMapEnabled || !t.shadowMapAutoUpdate) return;
            this.update(e, n);
        }),
        (this.update = function (a, f) {
            var v,
                m,
                g,
                y,
                b,
                w,
                E,
                S,
                x,
                T,
                N,
                C,
                k,
                L,
                A,
                O = [],
                M = 0,
                _ = null;
            e.clearColor(1, 1, 1, 1), e.disable(e.BLEND), e.enable(e.CULL_FACE), e.frontFace(e.CCW), t.shadowMapCullFace === THREE.CullFaceFront ? e.cullFace(e.FRONT) : e.cullFace(e.BACK), t.setDepthTest(!0);
            for (v = 0, m = a.__lights.length; v < m; v++) {
                L = a.__lights[v];
                if (!L.castShadow) continue;
                if (L instanceof THREE.DirectionalLight && L.shadowCascade)
                    for (b = 0; b < L.shadowCascadeCount; b++) {
                        var D;
                        if (!L.shadowCascadeArray[b]) {
                            (D = c(L, b)), (D.originalCamera = f);
                            var P = new THREE.Gyroscope();
                            (P.position = L.shadowCascadeOffset), P.add(D), P.add(D.target), f.add(P), (L.shadowCascadeArray[b] = D), console.log("Created virtualLight", D);
                        } else D = L.shadowCascadeArray[b];
                        h(L, b), (O[M] = D), M++;
                    }
                else (O[M] = L), M++;
            }
            for (v = 0, m = O.length; v < m; v++) {
                L = O[v];
                if (!L.shadowMap) {
                    var H = THREE.LinearFilter;
                    t.shadowMapType === THREE.PCFSoftShadowMap && (H = THREE.NearestFilter);
                    var B = { minFilter: H, magFilter: H, format: THREE.RGBAFormat };
                    (L.shadowMap = new THREE.WebGLRenderTarget(L.shadowMapWidth, L.shadowMapHeight, B)), (L.shadowMapSize = new THREE.Vector2(L.shadowMapWidth, L.shadowMapHeight)), (L.shadowMatrix = new THREE.Matrix4());
                }
                if (!L.shadowCamera) {
                    if (L instanceof THREE.SpotLight) L.shadowCamera = new THREE.PerspectiveCamera(L.shadowCameraFov, L.shadowMapWidth / L.shadowMapHeight, L.shadowCameraNear, L.shadowCameraFar);
                    else {
                        if (!(L instanceof THREE.DirectionalLight)) {
                            console.error("Unsupported light type for shadow");
                            continue;
                        }
                        L.shadowCamera = new THREE.OrthographicCamera(L.shadowCameraLeft, L.shadowCameraRight, L.shadowCameraTop, L.shadowCameraBottom, L.shadowCameraNear, L.shadowCameraFar);
                    }
                    a.add(L.shadowCamera), a.autoUpdate === !0 && a.updateMatrixWorld();
                }
                L.shadowCameraVisible && !L.cameraHelper && ((L.cameraHelper = new THREE.CameraHelper(L.shadowCamera)), L.shadowCamera.add(L.cameraHelper)),
                L.isVirtual && D.originalCamera == f && p(f, L),
                    (w = L.shadowMap),
                    (E = L.shadowMatrix),
                    (S = L.shadowCamera),
                    S.position.getPositionFromMatrix(L.matrixWorld),
                    l.getPositionFromMatrix(L.target.matrixWorld),
                    S.lookAt(l),
                    S.updateMatrixWorld(),
                    S.matrixWorldInverse.getInverse(S.matrixWorld),
                L.cameraHelper && (L.cameraHelper.visible = L.shadowCameraVisible),
                L.shadowCameraVisible && L.cameraHelper.update(),
                    E.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
                    E.multiply(S.projectionMatrix),
                    E.multiply(S.matrixWorldInverse),
                    u.multiplyMatrices(S.projectionMatrix, S.matrixWorldInverse),
                    o.setFromMatrix(u),
                    t.setRenderTarget(w),
                    t.clear(),
                    (A = a.__webglObjects);
                for (g = 0, y = A.length; g < y; g++)
                    (C = A[g]),
                        (k = C.object),
                        (C.render = !1),
                    k.visible &&
                    k.castShadow &&
                    (!(k instanceof THREE.Mesh || k instanceof THREE.ParticleSystem) || !k.frustumCulled || o.intersectsObject(k)) &&
                    (k._modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, k.matrixWorld), (C.render = !0));
                var j, F, I;
                for (g = 0, y = A.length; g < y; g++)
                    (C = A[g]),
                    C.render &&
                    ((k = C.object),
                        (T = C.buffer),
                        (j = d(k)),
                        (F = k.geometry.morphTargets.length > 0 && j.morphTargets),
                        (I = k instanceof THREE.SkinnedMesh && j.skinning),
                        k.customDepthMaterial ? (N = k.customDepthMaterial) : I ? (N = F ? s : i) : F ? (N = r) : (N = n),
                        T instanceof THREE.BufferGeometry ? t.renderBufferDirect(S, a.__lights, _, N, T, k) : t.renderBuffer(S, a.__lights, _, N, T, k));
                A = a.__webglObjectsImmediate;
                for (g = 0, y = A.length; g < y; g++) (C = A[g]), (k = C.object), k.visible && k.castShadow && (k._modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, k.matrixWorld), t.renderImmediateObject(S, a.__lights, _, n, k));
            }
            var q = t.getClearColor(),
                R = t.getClearAlpha();
            e.clearColor(q.r, q.g, q.b, R), e.enable(e.BLEND), t.shadowMapCullFace === THREE.CullFaceFront && e.cullFace(e.BACK);
        });
}),
(THREE.ShadowMapPlugin.__projector = new THREE.Projector()),
(THREE.SpritePlugin = function () {
    function i(t, n) {
        var r = e.createProgram(),
            i = e.createShader(e.FRAGMENT_SHADER),
            s = e.createShader(e.VERTEX_SHADER),
            o = "precision " + n + " float;\n";
        return e.shaderSource(i, o + t.fragmentShader), e.shaderSource(s, o + t.vertexShader), e.compileShader(i), e.compileShader(s), e.attachShader(r, i), e.attachShader(r, s), e.linkProgram(r), r;
    }
    function s(e, t) {
        return e.z !== t.z ? t.z - e.z : t.id - e.id;
    }
    var e,
        t,
        n,
        r = {};
    (this.init = function (s) {
        (e = s.context), (t = s), (n = s.getPrecision()), (r.vertices = new Float32Array(16)), (r.faces = new Uint16Array(6));
        var o = 0;
        (r.vertices[o++] = -1),
            (r.vertices[o++] = -1),
            (r.vertices[o++] = 0),
            (r.vertices[o++] = 0),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = -1),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = 0),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = -1),
            (r.vertices[o++] = 1),
            (r.vertices[o++] = 0),
            (r.vertices[o++] = 1),
            (o = 0),
            (r.faces[o++] = 0),
            (r.faces[o++] = 1),
            (r.faces[o++] = 2),
            (r.faces[o++] = 0),
            (r.faces[o++] = 2),
            (r.faces[o++] = 3),
            (r.vertexBuffer = e.createBuffer()),
            (r.elementBuffer = e.createBuffer()),
            e.bindBuffer(e.ARRAY_BUFFER, r.vertexBuffer),
            e.bufferData(e.ARRAY_BUFFER, r.vertices, e.STATIC_DRAW),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r.elementBuffer),
            e.bufferData(e.ELEMENT_ARRAY_BUFFER, r.faces, e.STATIC_DRAW),
            (r.program = i(THREE.ShaderSprite.sprite, n)),
            (r.attributes = {}),
            (r.uniforms = {}),
            (r.attributes.position = e.getAttribLocation(r.program, "position")),
            (r.attributes.uv = e.getAttribLocation(r.program, "uv")),
            (r.uniforms.uvOffset = e.getUniformLocation(r.program, "uvOffset")),
            (r.uniforms.uvScale = e.getUniformLocation(r.program, "uvScale")),
            (r.uniforms.rotation = e.getUniformLocation(r.program, "rotation")),
            (r.uniforms.scale = e.getUniformLocation(r.program, "scale")),
            (r.uniforms.alignment = e.getUniformLocation(r.program, "alignment")),
            (r.uniforms.color = e.getUniformLocation(r.program, "color")),
            (r.uniforms.map = e.getUniformLocation(r.program, "map")),
            (r.uniforms.opacity = e.getUniformLocation(r.program, "opacity")),
            (r.uniforms.useScreenCoordinates = e.getUniformLocation(r.program, "useScreenCoordinates")),
            (r.uniforms.sizeAttenuation = e.getUniformLocation(r.program, "sizeAttenuation")),
            (r.uniforms.screenPosition = e.getUniformLocation(r.program, "screenPosition")),
            (r.uniforms.modelViewMatrix = e.getUniformLocation(r.program, "modelViewMatrix")),
            (r.uniforms.projectionMatrix = e.getUniformLocation(r.program, "projectionMatrix")),
            (r.uniforms.fogType = e.getUniformLocation(r.program, "fogType")),
            (r.uniforms.fogDensity = e.getUniformLocation(r.program, "fogDensity")),
            (r.uniforms.fogNear = e.getUniformLocation(r.program, "fogNear")),
            (r.uniforms.fogFar = e.getUniformLocation(r.program, "fogFar")),
            (r.uniforms.fogColor = e.getUniformLocation(r.program, "fogColor")),
            (r.uniforms.alphaTest = e.getUniformLocation(r.program, "alphaTest"));
    }),
        (this.render = function (n, i, o, u) {
            var a = n.__webglSprites,
                f = a.length;
            if (!f) return;
            var l = r.attributes,
                c = r.uniforms,
                h = u / o,
                p = o * 0.5,
                d = u * 0.5;
            e.useProgram(r.program),
                e.enableVertexAttribArray(l.position),
                e.enableVertexAttribArray(l.uv),
                e.disable(e.CULL_FACE),
                e.enable(e.BLEND),
                e.bindBuffer(e.ARRAY_BUFFER, r.vertexBuffer),
                e.vertexAttribPointer(l.position, 2, e.FLOAT, !1, 16, 0),
                e.vertexAttribPointer(l.uv, 2, e.FLOAT, !1, 16, 8),
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r.elementBuffer),
                e.uniformMatrix4fv(c.projectionMatrix, !1, i.projectionMatrix.elements),
                e.activeTexture(e.TEXTURE0),
                e.uniform1i(c.map, 0);
            var v = 0,
                m = 0,
                g = n.fog;
            g
                ? (e.uniform3f(c.fogColor, g.color.r, g.color.g, g.color.b),
                    g instanceof THREE.Fog
                        ? (e.uniform1f(c.fogNear, g.near), e.uniform1f(c.fogFar, g.far), e.uniform1i(c.fogType, 1), (v = 1), (m = 1))
                        : g instanceof THREE.FogExp2 && (e.uniform1f(c.fogDensity, g.density), e.uniform1i(c.fogType, 2), (v = 2), (m = 2)))
                : (e.uniform1i(c.fogType, 0), (v = 0), (m = 0));
            var y,
                b,
                w,
                E,
                S,
                x,
                T = [];
            for (y = 0; y < f; y++) {
                (b = a[y]), (w = b.material);
                if (!b.visible || w.opacity === 0) continue;
                w.useScreenCoordinates ? (b.z = -b.position.z) : (b._modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, b.matrixWorld), (b.z = -b._modelViewMatrix.elements[14]));
            }
            a.sort(s);
            for (y = 0; y < f; y++) {
                (b = a[y]), (w = b.material);
                if (!b.visible || w.opacity === 0) continue;
                w.map &&
                w.map.image &&
                w.map.image.width &&
                (e.uniform1f(c.alphaTest, w.alphaTest),
                    w.useScreenCoordinates === !0
                        ? (e.uniform1i(c.useScreenCoordinates, 1),
                            e.uniform3f(c.screenPosition, (b.position.x * t.devicePixelRatio - p) / p, (d - b.position.y * t.devicePixelRatio) / d, Math.max(0, Math.min(1, b.position.z))),
                            (T[0] = t.devicePixelRatio),
                            (T[1] = t.devicePixelRatio))
                        : (e.uniform1i(c.useScreenCoordinates, 0), e.uniform1i(c.sizeAttenuation, w.sizeAttenuation ? 1 : 0), e.uniformMatrix4fv(c.modelViewMatrix, !1, b._modelViewMatrix.elements), (T[0] = 1), (T[1] = 1)),
                    n.fog && w.fog ? (x = m) : (x = 0),
                v !== x && (e.uniform1i(c.fogType, x), (v = x)),
                    (S = 1 / (w.scaleByViewport ? u : 1)),
                    (T[0] *= S * h * b.scale.x),
                    (T[1] *= S * b.scale.y),
                    e.uniform2f(c.uvScale, w.uvScale.x, w.uvScale.y),
                    e.uniform2f(c.uvOffset, w.uvOffset.x, w.uvOffset.y),
                    e.uniform2f(c.alignment, w.alignment.x, w.alignment.y),
                    e.uniform1f(c.opacity, w.opacity),
                    e.uniform3f(c.color, w.color.r, w.color.g, w.color.b),
                    e.uniform1f(c.rotation, b.rotation),
                    e.uniform2fv(c.scale, T),
                    t.setBlending(w.blending, w.blendEquation, w.blendSrc, w.blendDst),
                    t.setDepthTest(w.depthTest),
                    t.setDepthWrite(w.depthWrite),
                    t.setTexture(w.map, 0),
                    e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
            }
            e.enable(e.CULL_FACE);
        });
}),
(THREE.DepthPassPlugin = function () {
    function a(e) {
        return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[0] : e.material;
    }
    (this.enabled = !1), (this.renderTarget = null);
    var e,
        t,
        n,
        r,
        i,
        s,
        o = new THREE.Frustum(),
        u = new THREE.Matrix4();
    (this.init = function (o) {
        (e = o.context), (t = o);
        var u = THREE.ShaderLib.depthRGBA,
            a = THREE.UniformsUtils.clone(u.uniforms);
        (n = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a })),
            (r = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, morphTargets: !0 })),
            (i = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, skinning: !0 })),
            (s = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, morphTargets: !0, skinning: !0 })),
            (n._shadowPass = !0),
            (r._shadowPass = !0),
            (i._shadowPass = !0),
            (s._shadowPass = !0);
    }),
        (this.render = function (e, t) {
            if (!this.enabled) return;
            this.update(e, t);
        }),
        (this.update = function (f, l) {
            var c,
                h,
                p,
                d,
                v,
                m,
                g,
                y,
                b,
                w,
                E,
                S,
                x = null;
            e.clearColor(1, 1, 1, 1),
                e.disable(e.BLEND),
                t.setDepthTest(!0),
            f.autoUpdate === !0 && f.updateMatrixWorld(),
                l.matrixWorldInverse.getInverse(l.matrixWorld),
                u.multiplyMatrices(l.projectionMatrix, l.matrixWorldInverse),
                o.setFromMatrix(u),
                t.setRenderTarget(this.renderTarget),
                t.clear(),
                (S = f.__webglObjects);
            for (p = 0, d = S.length; p < d; p++)
                (b = S[p]),
                    (w = b.object),
                    (b.render = !1),
                w.visible &&
                (!(w instanceof THREE.Mesh || w instanceof THREE.ParticleSystem) || !w.frustumCulled || o.intersectsObject(w)) &&
                (w._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, w.matrixWorld), (b.render = !0));
            var T, N, C;
            for (p = 0, d = S.length; p < d; p++) {
                b = S[p];
                if (b.render) {
                    (w = b.object), (g = b.buffer);
                    if (w instanceof THREE.ParticleSystem && !w.customDepthMaterial) continue;
                    (T = a(w)),
                    T && t.setMaterialFaces(w.material),
                        (N = w.geometry.morphTargets.length > 0 && T.morphTargets),
                        (C = w instanceof THREE.SkinnedMesh && T.skinning),
                        w.customDepthMaterial ? (y = w.customDepthMaterial) : C ? (y = N ? s : i) : N ? (y = r) : (y = n),
                        g instanceof THREE.BufferGeometry ? t.renderBufferDirect(l, f.__lights, x, y, g, w) : t.renderBuffer(l, f.__lights, x, y, g, w);
                }
            }
            S = f.__webglObjectsImmediate;
            for (p = 0, d = S.length; p < d; p++) (b = S[p]), (w = b.object), w.visible && (w._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, w.matrixWorld), t.renderImmediateObject(l, f.__lights, x, n, w));
            var k = t.getClearColor(),
                L = t.getClearAlpha();
            e.clearColor(k.r, k.g, k.b, L), e.enable(e.BLEND);
        });
}),
(THREE.ShaderFlares = {
    lensFlareVertexTexture: {
        vertexShader: [
            "uniform lowp int renderType;",
            "uniform vec3 screenPosition;",
            "uniform vec2 scale;",
            "uniform float rotation;",
            "uniform sampler2D occlusionMap;",
            "attribute vec2 position;",
            "attribute vec2 uv;",
            "varying vec2 vUV;",
            "varying float vVisibility;",
            "void main() {",
            "vUV = uv;",
            "vec2 pos = position;",
            "if( renderType == 2 ) {",
            "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
            "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
            "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
            "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
            "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
            "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
            "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
            "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
            "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
            "vVisibility =        visibility.r / 9.0;",
            "vVisibility *= 1.0 - visibility.g / 9.0;",
            "vVisibility *=       visibility.b / 9.0;",
            "vVisibility *= 1.0 - visibility.a / 9.0;",
            "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
            "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
            "}",
            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
            "}",
        ].join("\n"),
        fragmentShader: [
            "uniform lowp int renderType;",
            "uniform sampler2D map;",
            "uniform float opacity;",
            "uniform vec3 color;",
            "varying vec2 vUV;",
            "varying float vVisibility;",
            "void main() {",
            "if( renderType == 0 ) {",
            "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
            "} else if( renderType == 1 ) {",
            "gl_FragColor = texture2D( map, vUV );",
            "} else {",
            "vec4 texture = texture2D( map, vUV );",
            "texture.a *= opacity * vVisibility;",
            "gl_FragColor = texture;",
            "gl_FragColor.rgb *= color;",
            "}",
            "}",
        ].join("\n"),
    },
    lensFlare: {
        vertexShader: [
            "uniform lowp int renderType;",
            "uniform vec3 screenPosition;",
            "uniform vec2 scale;",
            "uniform float rotation;",
            "attribute vec2 position;",
            "attribute vec2 uv;",
            "varying vec2 vUV;",
            "void main() {",
            "vUV = uv;",
            "vec2 pos = position;",
            "if( renderType == 2 ) {",
            "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
            "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
            "}",
            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
            "}",
        ].join("\n"),
        fragmentShader: [
            "precision mediump float;",
            "uniform lowp int renderType;",
            "uniform sampler2D map;",
            "uniform sampler2D occlusionMap;",
            "uniform float opacity;",
            "uniform vec3 color;",
            "varying vec2 vUV;",
            "void main() {",
            "if( renderType == 0 ) {",
            "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",
            "} else if( renderType == 1 ) {",
            "gl_FragColor = texture2D( map, vUV );",
            "} else {",
            "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
            "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
            "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
            "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
            "visibility = ( 1.0 - visibility / 4.0 );",
            "vec4 texture = texture2D( map, vUV );",
            "texture.a *= opacity * visibility;",
            "gl_FragColor = texture;",
            "gl_FragColor.rgb *= color;",
            "}",
            "}",
        ].join("\n"),
    },
}),
(THREE.ShaderSprite = {
    sprite: {
        vertexShader: [
            "uniform int useScreenCoordinates;",
            "uniform int sizeAttenuation;",
            "uniform vec3 screenPosition;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform float rotation;",
            "uniform vec2 scale;",
            "uniform vec2 alignment;",
            "uniform vec2 uvOffset;",
            "uniform vec2 uvScale;",
            "attribute vec2 position;",
            "attribute vec2 uv;",
            "varying vec2 vUV;",
            "void main() {",
            "vUV = uvOffset + uv * uvScale;",
            "vec2 alignedPosition = position + alignment;",
            "vec2 rotatedPosition;",
            "rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;",
            "rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;",
            "vec4 finalPosition;",
            "if( useScreenCoordinates != 0 ) {",
            "finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );",
            "} else {",
            "finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );",
            "finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );",
            "}",
            "gl_Position = finalPosition;",
            "}",
        ].join("\n"),
        fragmentShader: [
            "uniform vec3 color;",
            "uniform sampler2D map;",
            "uniform float opacity;",
            "uniform int fogType;",
            "uniform vec3 fogColor;",
            "uniform float fogDensity;",
            "uniform float fogNear;",
            "uniform float fogFar;",
            "uniform float alphaTest;",
            "varying vec2 vUV;",
            "void main() {",
            "vec4 texture = texture2D( map, vUV );",
            "if ( texture.a < alphaTest ) discard;",
            "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );",
            "if ( fogType > 0 ) {",
            "float depth = gl_FragCoord.z / gl_FragCoord.w;",
            "float fogFactor = 0.0;",
            "if ( fogType == 1 ) {",
            "fogFactor = smoothstep( fogNear, fogFar, depth );",
            "} else {",
            "const float LOG2 = 1.442695;",
            "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
            "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
            "}",
            "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
            "}",
            "}",
        ].join("\n"),
    },
}),
define("three", (function (e) {
    return function () {
        var t, n;
        return t || e.THREE;
    };
})(this)),
(THREE.OrbitControls = function (e, t) {
    function E() {
        return ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed;
    }
    function S() {
        return Math.pow(0.95, n.zoomSpeed);
    }
    function x(e) {
        if (n.enabled === !1) return;
        e.preventDefault();
        if (e.button === 0) {
            if (n.noRotate === !0) return;
            (b = y.ROTATE), i.set(e.clientX, e.clientY);
        } else if (e.button === 1) {
            if (n.noZoom === !0) return;
            (b = y.DOLLY), l.set(e.clientX, e.clientY);
        } else if (e.button === 2) {
            if (n.noPan === !0) return;
            (b = y.PAN), u.set(e.clientX, e.clientY);
        }
        n.domElement.addEventListener("mousemove", T, !1), n.domElement.addEventListener("mouseup", N, !1);
    }
    function T(e) {
        if (n.enabled === !1) return;
        e.preventDefault();
        var t = n.domElement === document ? n.domElement.body : n.domElement;
        if (b === y.ROTATE) {
            if (n.noRotate === !0) return;
            s.set(e.clientX, e.clientY), o.subVectors(s, i), n.rotateLeft(((2 * Math.PI * o.x) / t.clientWidth) * n.rotateSpeed), n.rotateUp(((2 * Math.PI * o.y) / t.clientHeight) * n.rotateSpeed), i.copy(s);
        } else if (b === y.DOLLY) {
            if (n.noZoom === !0) return;
            c.set(e.clientX, e.clientY), h.subVectors(c, l), h.y > 0 ? n.dollyIn() : n.dollyOut(), l.copy(c);
        } else if (b === y.PAN) {
            if (n.noPan === !0) return;
            a.set(e.clientX, e.clientY), f.subVectors(a, u), n.pan(f), u.copy(a);
        }
        n.update();
    }
    function N() {
        if (n.enabled === !1) return;
        n.domElement.removeEventListener("mousemove", T, !1), n.domElement.removeEventListener("mouseup", N, !1), (b = y.NONE);
    }
    function C(e) {
        if (n.enabled === !1 || n.noZoom === !0) return;
        var t = 0;
        e.wheelDelta ? (t = e.wheelDelta) : e.detail && (t = -e.detail), t > 0 ? n.dollyOut() : n.dollyIn();
    }
    function k(e) {
        if (n.enabled === !1) return;
        if (n.noKeys === !0) return;
        if (n.noPan === !0) return;
        var t = !1;
        switch (e.keyCode) {
            case n.keys.UP:
                n.pan(new THREE.Vector2(0, n.keyPanSpeed)), (t = !0);
                break;
            case n.keys.BOTTOM:
                n.pan(new THREE.Vector2(0, -n.keyPanSpeed)), (t = !0);
                break;
            case n.keys.LEFT:
                n.pan(new THREE.Vector2(n.keyPanSpeed, 0)), (t = !0);
                break;
            case n.keys.RIGHT:
                n.pan(new THREE.Vector2(-n.keyPanSpeed, 0)), (t = !0);
        }
        t && n.update();
    }
    function L(e) {
        if (n.enabled === !1) return;
        switch (e.touches.length) {
            case 1:
                if (n.noRotate === !0) return;
                (b = y.TOUCH_ROTATE), i.set(e.touches[0].pageX, e.touches[0].pageY);
                break;
            case 2:
                if (n.noZoom === !0) return;
                b = y.TOUCH_DOLLY;
                var t = e.touches[0].pageX - e.touches[1].pageX,
                    r = e.touches[0].pageY - e.touches[1].pageY,
                    s = Math.sqrt(t * t + r * r);
                l.set(0, s);
                break;
            case 3:
                if (n.noPan === !0) return;
                (b = y.TOUCH_PAN), u.set(e.touches[0].pageX, e.touches[0].pageY);
                break;
            default:
                b = y.NONE;
        }
    }
    function A(e) {
        if (n.enabled === !1) return;
        e.preventDefault(), e.stopPropagation();
        var t = n.domElement === document ? n.domElement.body : n.domElement;
        switch (e.touches.length) {
            case 1:
                if (n.noRotate === !0) return;
                if (b !== y.TOUCH_ROTATE) return;
                s.set(e.touches[0].pageX, e.touches[0].pageY), o.subVectors(s, i), n.rotateLeft(((2 * Math.PI * o.x) / t.clientWidth) * n.rotateSpeed), n.rotateUp(((2 * Math.PI * o.y) / t.clientHeight) * n.rotateSpeed), i.copy(s);
                break;
            case 2:
                if (n.noZoom === !0) return;
                if (b !== y.TOUCH_DOLLY) return;
                var r = e.touches[0].pageX - e.touches[1].pageX,
                    p = e.touches[0].pageY - e.touches[1].pageY,
                    d = Math.sqrt(r * r + p * p);
                c.set(0, d), h.subVectors(c, l), h.y > 0 ? n.dollyOut() : n.dollyIn(), l.copy(c);
                break;
            case 3:
                if (n.noPan === !0) return;
                if (b !== y.TOUCH_PAN) return;
                a.set(e.touches[0].pageX, e.touches[0].pageY), f.subVectors(a, u), n.pan(f), u.copy(a);
                break;
            default:
                b = y.NONE;
        }
    }
    function O() {
        if (n.enabled === !1) return;
        b = y.NONE;
    }
    (this.object = e),
        (this.domElement = t !== undefined ? t : document),
        (this.enabled = !0),
        (this.target = new THREE.Vector3()),
        (this.center = this.target),
        (this.noZoom = !1),
        (this.zoomSpeed = 1),
        (this.minDistance = 0),
        (this.maxDistance = Infinity),
        (this.noRotate = !1),
        (this.rotateSpeed = 1),
        (this.noPan = !1),
        (this.keyPanSpeed = 7),
        (this.autoRotate = !1),
        (this.autoRotateSpeed = 2),
        (this.minPolarAngle = 0),
        (this.maxPolarAngle = Math.PI),
        (this.noKeys = !1),
        (this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 });
    var n = this,
        r = 1e-6,
        i = new THREE.Vector2(),
        s = new THREE.Vector2(),
        o = new THREE.Vector2(),
        u = new THREE.Vector2(),
        a = new THREE.Vector2(),
        f = new THREE.Vector2(),
        l = new THREE.Vector2(),
        c = new THREE.Vector2(),
        h = new THREE.Vector2(),
        p = 0,
        d = 0,
        v = 1,
        m = new THREE.Vector3(),
        g = new THREE.Vector3(),
        y = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 },
        b = y.NONE,
        w = { type: "change" };
    (this.rotateLeft = function (e) {
        e === undefined && (e = E()), (d -= e);
    }),
        (this.rotateUp = function (e) {
            e === undefined && (e = E()), (p -= e);
        }),
        (this.panLeft = function (e) {
            var t = new THREE.Vector3(),
                n = this.object.matrix.elements;
            t.set(n[0], n[1], n[2]), t.multiplyScalar(-e), m.add(t);
        }),
        (this.panUp = function (e) {
            var t = new THREE.Vector3(),
                n = this.object.matrix.elements;
            t.set(n[4], n[5], n[6]), t.multiplyScalar(e), m.add(t);
        }),
        (this.pan = function (e) {
            var t = n.domElement === document ? n.domElement.body : n.domElement;
            if (n.object.fov !== undefined) {
                var r = n.object.position,
                    i = r.clone().sub(n.target),
                    s = i.length();
                (s *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)), n.panLeft((2 * e.x * s) / t.clientHeight), n.panUp((2 * e.y * s) / t.clientHeight);
            } else
                n.object.top !== undefined
                    ? (n.panLeft((e.x * (n.object.right - n.object.left)) / t.clientWidth), n.panUp((e.y * (n.object.top - n.object.bottom)) / t.clientHeight))
                    : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
        }),
        (this.dollyIn = function (e) {
            e === undefined && (e = S()), (v /= e);
        }),
        (this.dollyOut = function (e) {
            e === undefined && (e = S()), (v *= e);
        }),
        (this.update = function () {
            var e = this.object.position,
                t = e.clone().sub(this.target),
                n = Math.atan2(t.x, t.z),
                i = Math.atan2(Math.sqrt(t.x * t.x + t.z * t.z), t.y);
            this.autoRotate && this.rotateLeft(E()), (n += d), (i += p), (i = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, i))), (i = Math.max(r, Math.min(Math.PI - r, i)));
            var s = t.length() * v;
            (s = Math.max(this.minDistance, Math.min(this.maxDistance, s))),
                this.target.add(m),
                (t.x = s * Math.sin(i) * Math.sin(n)),
                (t.y = s * Math.cos(i)),
                (t.z = s * Math.sin(i) * Math.cos(n)),
                e.copy(this.target).add(t),
                this.object.lookAt(this.target),
                (d = 0),
                (p = 0),
                (v = 1),
                m.set(0, 0, 0),
            g.distanceTo(this.object.position) > 0 && (this.dispatchEvent(w), g.copy(this.object.position));
        }),
        this.domElement.addEventListener(
            "contextmenu",
            function (e) {
                e.preventDefault();
            },
            !1
        ),
        this.domElement.addEventListener("mousedown", x, !1),
        this.domElement.addEventListener("mousewheel", C, !1),
        this.domElement.addEventListener("DOMMouseScroll", C, !1),
        this.domElement.addEventListener("keydown", k, !1),
        this.domElement.addEventListener("touchstart", L, !1),
        this.domElement.addEventListener("touchend", O, !1),
        this.domElement.addEventListener("touchmove", A, !1);
}),
(THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype)),
define("orbitcontrols", ["three"], function () {}),
(THREE.EffectComposer = function (e, t) {
    this.renderer = e;
    if (t === undefined) {
        var n = WIDTH || 1,
            r = HEIGHT || 1,
            i = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: !1 };
        t = new THREE.WebGLRenderTarget(n, r, i);
    }
    (this.renderTarget1 = t),
        (this.renderTarget2 = t.clone()),
        (this.writeBuffer = this.renderTarget1),
        (this.readBuffer = this.renderTarget2),
        (this.passes = []),
    THREE.CopyShader === undefined && console.error("THREE.EffectComposer relies on THREE.CopyShader"),
        (this.copyPass = new THREE.ShaderPass(THREE.CopyShader));
}),
(THREE.EffectComposer.prototype = {
    swapBuffers: function () {
        var e = this.readBuffer;
        (this.readBuffer = this.writeBuffer), (this.writeBuffer = e);
    },
    addPass: function (e) {
        this.passes.push(e);
    },
    insertPass: function (e, t) {
        this.passes.splice(t, 0, e);
    },
    render: function (e) {
        (this.writeBuffer = this.renderTarget1), (this.readBuffer = this.renderTarget2);
        var t = !1,
            n,
            r,
            i = this.passes.length;
        for (r = 0; r < i; r++) {
            n = this.passes[r];
            if (!n.enabled) continue;
            n.render(this.renderer, this.writeBuffer, this.readBuffer, e, t);
            if (n.needsSwap) {
                if (t) {
                    var s = this.renderer.context;
                    s.stencilFunc(s.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), s.stencilFunc(s.EQUAL, 1, 4294967295);
                }
                this.swapBuffers();
            }
            n instanceof THREE.MaskPass ? (t = !0) : n instanceof THREE.ClearMaskPass && (t = !1);
        }
    },
    reset: function (e) {
        e === undefined && ((e = this.renderTarget1.clone()), (e.width = WIDTH), (e.height = HEIGHT)),
            (this.renderTarget1 = e),
            (this.renderTarget2 = e.clone()),
            (this.writeBuffer = this.renderTarget1),
            (this.readBuffer = this.renderTarget2);
    },
    setSize: function (e, t) {
        var n = this.renderTarget1.clone();
        (n.width = e), (n.height = t), this.reset(n);
    },
}),
(THREE.EffectComposer.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1)),
(THREE.EffectComposer.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null)),
(THREE.EffectComposer.scene = new THREE.Scene()),
THREE.EffectComposer.scene.add(THREE.EffectComposer.quad),
(THREE.RenderPass = function (e, t, n, r, i) {
    (this.scene = e),
        (this.camera = t),
        (this.overrideMaterial = n),
        (this.clearColor = r),
        (this.clearAlpha = i !== undefined ? i : 1),
        (this.oldClearColor = new THREE.Color()),
        (this.oldClearAlpha = 1),
        (this.enabled = !0),
        (this.clear = !0),
        (this.needsSwap = !1);
}),
(THREE.RenderPass.prototype = {
    render: function (e, t, n, r) {
        (this.scene.overrideMaterial = this.overrideMaterial),
        this.clearColor && (this.oldClearColor.copy(e.getClearColor()), (this.oldClearAlpha = e.getClearAlpha()), e.setClearColor(this.clearColor, this.clearAlpha)),
            e.render(this.scene, this.camera, n, this.clear),
        this.clearColor && e.setClearColor(this.oldClearColor, this.oldClearAlpha),
            (this.scene.overrideMaterial = null);
    },
}),
(THREE.ShaderPass = function (e, t) {
    (this.textureID = t !== undefined ? t : "tDiffuse"),
        (this.uniforms = THREE.UniformsUtils.clone(e.uniforms)),
        (this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })),
        (this.renderToScreen = !1),
        (this.enabled = !0),
        (this.needsSwap = !0),
        (this.clear = !1);
}),
(THREE.ShaderPass.prototype = {
    render: function (e, t, n, r) {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n),
            (THREE.EffectComposer.quad.material = this.material),
            this.renderToScreen ? e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera) : e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, t, this.clear);
    },
}),
(THREE.MaskPass = function (e, t) {
    (this.scene = e), (this.camera = t), (this.enabled = !0), (this.clear = !0), (this.needsSwap = !1), (this.inverse = !1);
}),
(THREE.MaskPass.prototype = {
    render: function (e, t, n, r) {
        var i = e.context;
        i.colorMask(!1, !1, !1, !1), i.depthMask(!1);
        var s, o;
        this.inverse ? ((s = 0), (o = 1)) : ((s = 1), (o = 0)),
            i.enable(i.STENCIL_TEST),
            i.stencilOp(i.REPLACE, i.REPLACE, i.REPLACE),
            i.stencilFunc(i.ALWAYS, s, 4294967295),
            i.clearStencil(o),
            e.render(this.scene, this.camera, n, this.clear),
            e.render(this.scene, this.camera, t, this.clear),
            i.colorMask(!0, !0, !0, !0),
            i.depthMask(!0),
            i.stencilFunc(i.EQUAL, 1, 4294967295),
            i.stencilOp(i.KEEP, i.KEEP, i.KEEP);
    },
}),
(THREE.ClearMaskPass = function () {
    this.enabled = !0;
}),
(THREE.ClearMaskPass.prototype = {
    render: function (e, t, n, r) {
        var i = e.context;
        i.disable(i.STENCIL_TEST);
    },
}),
(THREE.BloomPass = function (e, t, n, r) {
    (e = e !== undefined ? e : 1), (t = t !== undefined ? t : 25), (n = n !== undefined ? n : 4), (r = r !== undefined ? r : 256);
    var i = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
    (this.renderTargetX = new THREE.WebGLRenderTarget(r, r, i)), (this.renderTargetY = new THREE.WebGLRenderTarget(r, r, i)), THREE.CopyShader === undefined && console.error("THREE.BloomPass relies on THREE.CopyShader");
    var s = THREE.CopyShader;
    (this.copyUniforms = THREE.UniformsUtils.clone(s.uniforms)),
        (this.copyUniforms.opacity.value = e),
        (this.materialCopy = new THREE.ShaderMaterial({ uniforms: this.copyUniforms, vertexShader: s.vertexShader, fragmentShader: s.fragmentShader, blending: THREE.AdditiveBlending, transparent: !0 })),
    THREE.ConvolutionShader === undefined && console.error("THREE.BloomPass relies on THREE.ConvolutionShader");
    var o = THREE.ConvolutionShader;
    (this.convolutionUniforms = THREE.UniformsUtils.clone(o.uniforms)),
        (this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurx),
        (this.convolutionUniforms.cKernel.value = THREE.ConvolutionShader.buildKernel(n)),
        (this.materialConvolution = new THREE.ShaderMaterial({
            uniforms: this.convolutionUniforms,
            vertexShader: o.vertexShader,
            fragmentShader: o.fragmentShader,
            defines: { KERNEL_SIZE_FLOAT: t.toFixed(1), KERNEL_SIZE_INT: t.toFixed(0) },
        })),
        (this.enabled = !0),
        (this.needsSwap = !1),
        (this.clear = !1);
}),
(THREE.BloomPass.prototype = {
    render: function (e, t, n, r, i) {
        i && e.context.disable(e.context.STENCIL_TEST),
            (THREE.EffectComposer.quad.material = this.materialConvolution),
            (this.convolutionUniforms.tDiffuse.value = n),
            (this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurX),
            e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetX, !0),
            (this.convolutionUniforms.tDiffuse.value = this.renderTargetX),
            (this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurY),
            e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetY, !0),
            (THREE.EffectComposer.quad.material = this.materialCopy),
            (this.copyUniforms.tDiffuse.value = this.renderTargetY),
        i && e.context.enable(e.context.STENCIL_TEST),
            e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, n, this.clear);
    },
}),
(THREE.BloomPass.blurX = new THREE.Vector2(0.001953125, 0)),
(THREE.BloomPass.blurY = new THREE.Vector2(0, 0.001953125)),
(THREE.SavePass = function (e) {
    THREE.CopyShader === undefined && console.error("THREE.SavePass relies on THREE.CopyShader");
    var t = THREE.CopyShader;
    (this.textureID = "tDiffuse"),
        (this.uniforms = THREE.UniformsUtils.clone(t.uniforms)),
        (this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader })),
        (this.renderTarget = e),
    this.renderTarget === undefined &&
    ((this.renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: !1 }),
        (this.renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, this.renderTargetParameters))),
        (this.enabled = !0),
        (this.needsSwap = !1),
        (this.clear = !1);
}),
(THREE.SavePass.prototype = {
    render: function (e, t, n, r) {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n), (THREE.EffectComposer.quad.material = this.material), e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTarget, this.clear);
    },
}),
(THREE.NormalBlendPass = function (e, t) {
    var n = THREE.NormalBlendShader;
    (this.target1 = e),
        (this.target2 = t),
        (this.uniforms = THREE.UniformsUtils.clone(n.uniforms)),
        (this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: n.vertexShader, fragmentShader: n.fragmentShader })),
        (this.renderToScreen = !1),
        (this.enabled = !0),
        (this.needsSwap = !0),
        (this.clear = !1);
}),
(THREE.NormalBlendPass.prototype = {
    render: function (e, t, n, r) {
        (this.uniforms.tDiffuse1.value = this.target1),
            (this.uniforms.tDiffuse2.value = this.target2),
            (THREE.EffectComposer.quad.material = this.material),
            e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, t, this.clear);
    },
}),
(THREE.AdditiveBlendPass = function (e, t, n) {
    var r = THREE.AdditiveBlendShader;
    (this.target1 = e),
        (this.target2 = t),
        (this.opacity = n),
        (this.uniforms = THREE.UniformsUtils.clone(r.uniforms)),
        (this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: r.vertexShader, fragmentShader: r.fragmentShader })),
        (this.renderToScreen = !1),
        (this.enabled = !0),
        (this.needsSwap = !0),
        (this.clear = !1);
}),
(THREE.AdditiveBlendPass.prototype = {
    render: function (e, t, n, r) {
        (this.uniforms.tDiffuse1.value = this.target1 || n),
            (this.uniforms.tDiffuse2.value = this.target2),
            (this.uniforms.opacity.value = this.opacity),
            (THREE.EffectComposer.quad.material = this.material),
            e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, t, this.clear);
    },
}),
(THREE.CopyPass = function (e) {
    var t = THREE.CopyShader;
    (this.target = e),
        (this.uniforms = THREE.UniformsUtils.clone(t.uniforms)),
        (this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader })),
        (this.renderToScreen = !1),
        (this.enabled = !0),
        (this.needsSwap = !0),
        (this.clear = !1);
}),
(THREE.CopyPass.prototype = {
    render: function (e, t, n, r) {
        (this.uniforms.tDiffuse.value = this.target || n), (THREE.EffectComposer.quad.material = this.material), e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, t, this.clear);
    },
}),
define("effectcomposer", ["three"], function () {}),
(THREE.CopyShader = {
    uniforms: { tDiffuse: { type: "t", value: null }, opacity: { type: "f", value: 1 } },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n"),
}),
(THREE.RGBShiftShader = {
    uniforms: { tDiffuse: { type: "t", value: null }, amount: { type: "f", value: 0.005 }, angle: { type: "f", value: 0 } },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform float amount;",
        "uniform float angle;",
        "varying vec2 vUv;",
        "void main() {",
        "vec2 offset = amount * vec2( cos(angle), sin(angle));",
        "vec4 cr = texture2D(tDiffuse, vUv + offset);",
        "vec4 cga = texture2D(tDiffuse, vUv);",
        "vec4 cb = texture2D(tDiffuse, vUv - offset);",
        "gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",
        "}",
    ].join("\n"),
}),
(THREE.ConvolutionShader = {
    defines: { KERNEL_SIZE_FLOAT: "25.0", KERNEL_SIZE_INT: "25" },
    uniforms: { tDiffuse: { type: "t", value: null }, uImageIncrement: { type: "v2", value: new THREE.Vector2(0.001953125, 0) }, cKernel: { type: "fv1", value: [] } },
    vertexShader: [
        "uniform vec2 uImageIncrement;",
        "varying vec2 vUv;",
        "void main() {",
        "vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;",
        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
        "}",
    ].join("\n"),
    fragmentShader: [
        "uniform float cKernel[ KERNEL_SIZE_INT ];",
        "uniform sampler2D tDiffuse;",
        "uniform vec2 uImageIncrement;",
        "varying vec2 vUv;",
        "void main() {",
        "vec2 imageCoord = vUv;",
        "vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );",
        "for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {",
        "sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];",
        "imageCoord += uImageIncrement;",
        "}",
        "gl_FragColor = sum;",
        "}",
    ].join("\n"),
    buildKernel: function (e) {
        function t(e, t) {
            return Math.exp(-(e * e) / (2 * t * t));
        }
        var n,
            r,
            i,
            s,
            o = 25,
            u = 2 * Math.ceil(e * 3) + 1;
        u > o && (u = o), (s = (u - 1) * 0.5), (r = new Array(u)), (i = 0);
        for (n = 0; n < u; ++n) (r[n] = t(n - s, e)), (i += r[n]);
        for (n = 0; n < u; ++n) r[n] /= i;
        return r;
    },
}),
(THREE.FXAAShader = {
    uniforms: { tDiffuse: { type: "t", value: null }, resolution: { type: "v2", value: new THREE.Vector2(1 / 1024, 1 / 512) } },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform vec2 resolution;",
        "varying vec2 vUv;",
        "#define FXAA_REDUCE_MIN   (1.0/128.0)",
        "#define FXAA_REDUCE_MUL   (1.0/8.0)",
        "#define FXAA_SPAN_MAX     8.0",
        "void main() {",
        "vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;",
        "vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;",
        "vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;",
        "vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;",
        "vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );",
        "vec3 rgbM  = rgbaM.xyz;",
        "float opacity  = rgbaM.w;",
        "vec3 luma = vec3( 0.299, 0.587, 0.114 );",
        "float lumaNW = dot( rgbNW, luma );",
        "float lumaNE = dot( rgbNE, luma );",
        "float lumaSW = dot( rgbSW, luma );",
        "float lumaSE = dot( rgbSE, luma );",
        "float lumaM  = dot( rgbM,  luma );",
        "float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
        "float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",
        "vec2 dir;",
        "dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
        "dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",
        "float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",
        "float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
        "dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
        "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
        "dir * rcpDirMin)) * resolution;",
        "vec3 rgbA = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz;",
        "rgbA += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz;",
        "rgbA *= 0.5;",
        "vec3 rgbB = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz;",
        "rgbB += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz;",
        "rgbB *= 0.25;",
        "rgbB += rgbA * 0.5;",
        "float lumaB = dot( rgbB, luma );",
        "if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",
        "gl_FragColor = vec4( rgbA, opacity );",
        "} else {",
        "gl_FragColor = vec4( rgbB, opacity );",
        "}",
        "}",
    ].join("\n"),
}),
(THREE.HorizontalDofShader = {
    uniforms: { tDiffuse: { type: "t", value: null }, tDepth: { type: "t", value: null }, h: { type: "f", value: 1 / 512 } },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform sampler2D tDepth;",
        "uniform float h;",
        "varying vec2 vUv;",
        "void main() {",
        "vec4 sum = vec4( 0.0 );",
        "float depth = clamp(texture2D(tDepth, vUv.xy).r - 0.5, 0.0, 0.5) / 0.5;",
        "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;",
        "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;",
        "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;",
        "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
        "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;",
        "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;",
        "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;",
        "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;",
        "vec4 diffuse = texture2D(tDiffuse, vUv.xy);",
        "vec4 color = mix(sum, diffuse, depth);",
        "gl_FragColor = color;",
        "}",
    ].join("\n"),
}),
(THREE.VerticalDofShader = {
    uniforms: { tDiffuse: { type: "t", value: null }, tDepth: { type: "t", value: null }, v: { type: "f", value: 1 / 512 } },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform sampler2D tDepth;",
        "uniform float v;",
        "varying vec2 vUv;",
        "void main() {",
        "vec4 sum = vec4( 0.0 );",
        "float depth = clamp(texture2D(tDepth, vUv.xy).r - 0.5, 0.0, 0.5) / 0.5;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;",
        "vec4 diffuse = texture2D(tDiffuse, vUv.xy);",
        "vec4 color = mix(sum, diffuse, depth);",
        "gl_FragColor = color;",
        "}",
    ].join("\n"),
}),
(THREE.HorizontalBlurShader = {
    uniforms: { tDiffuse: { type: "t", value: null }, h: { type: "f", value: 1 / 512 } },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform float h;",
        "varying vec2 vUv;",
        "void main() {",
        "vec4 sum = vec4( 0.0 );",
        "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;",
        "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;",
        "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;",
        "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
        "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;",
        "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;",
        "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;",
        "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;",
        "gl_FragColor = sum;",
        "}",
    ].join("\n"),
}),
(THREE.VerticalBlurShader = {
    uniforms: { tDiffuse: { type: "t", value: null }, v: { type: "f", value: 1 / 512 } },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform float v;",
        "varying vec2 vUv;",
        "void main() {",
        "vec4 sum = vec4( 0.0 );",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;",
        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;",
        "gl_FragColor = sum;",
        "}",
    ].join("\n"),
}),
(THREE.NormalBlendShader = {
    uniforms: { tDiffuse1: { type: "t", value: null }, tDiffuse2: { type: "t", value: null } },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
        "uniform sampler2D tDiffuse1;",
        "uniform sampler2D tDiffuse2;",
        "varying vec2 vUv;",
        "void main() {",
        "vec4 texel1 = texture2D( tDiffuse1, vUv );",
        "vec4 texel2 = texture2D( tDiffuse2, vUv );",
        "gl_FragColor = mix( texel1, texel2, texel2.a );",
        "}",
    ].join("\n"),
}),
(THREE.AdditiveBlendShader = {
    uniforms: { tDiffuse1: { type: "t", value: null }, tDiffuse2: { type: "t", value: null }, opacity: { type: "f", value: 1 } },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
        "uniform sampler2D tDiffuse1;",
        "uniform sampler2D tDiffuse2;",
        "uniform float opacity;",
        "varying vec2 vUv;",
        "void main() {",
        "vec4 texel1 = texture2D( tDiffuse1, vUv );",
        "vec4 texel2 = texture2D( tDiffuse2, vUv );",
        "gl_FragColor = texel1 + texel2 * opacity;",
        "}",
    ].join("\n"),
}),
(THREE.StrokeShader = {
    uniforms: { tDiffuse: { type: "t", value: null }, h: { type: "f", value: 1 / 512 }, cells: { type: "v2v", value: [] } },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform float h;",
        "uniform vec2 cells[8];",
        "const float PI = 3.14159265358979323846264;",
        "varying vec2 vUv;",
        "void main() {",
        "vec4 color = vec4( 0.0 );",
        "gl_FragColor = color;",
        "for (int i = 0; i < 8; i++) {",
        "vec2 pos = cells[i] * h;",
        "vec4 texel = texture2D(tDiffuse, vUv + pos);",
        "if (texel.g > 0.0) {",
        "gl_FragColor = vec4(0.0236, 0.58, 0.467, 1.0);",
        "break;",
        "}",
        "}",
        "}",
    ].join("\n"),
}),
(THREE.BlendShader = {
    uniforms: { tDiffuse: { type: "t", value: null }, tDiffuse2: { type: "t", value: null } },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform sampler2D tDiffuse2;",
        "varying vec2 vUv;",
        "void main() {",
        "vec4 texel1 = texture2D( tDiffuse, vUv );",
        "vec4 texel2 = texture2D( tDiffuse2, vUv );",
        "gl_FragColor = texel1;",
        "if (texel2.g > 0.0) {",
        "gl_FragColor = texel2;",
        "}",
        "}",
    ].join("\n"),
}),
define("compositingshaders", ["three"], function () {}),
define("neons/app", ["class", "./objects", "./textures", "./models", "./neons", "orbitcontrols", "effectcomposer", "compositingshaders"], function (e, t, n, r, i) {
    var s = e.extend({
        initialize: function (e) {
            (this.name = "neons"),
                (this.description = '#01  Based on <a target="_blank" href="http://vimeo.com/49241313">Bitsweep</a> by Beeple'),
                (this.renderer = e.renderer),
                (this.container = e.container),
                (this.clock = new THREE.Clock(!1)),
                (this.compositing = e.enableCompositing);
        },
        initWorld: function () {
            $.when(n.loadAll(), r.loadAll()).done(
                _.bind(function () {
                    (this.world = new i({ renderer: this.renderer })),
                        this.world.initHelpers(),
                        this.world.toggleHelpers(),
                        this.initCompositing(),
                        this.world.on(
                            "started",
                            _.bind(function () {
                                this.trigger("ready");
                            }, this)
                        );
                }, this)
            );
        },
        initCompositing: function () {
            (this.composer = new THREE.EffectComposer(this.renderer)), this.world.setupCompositing(this.composer);
            var e = new THREE.ShaderPass(THREE.CopyShader);
            (e.renderToScreen = !0), this.composer.addPass(e);
        },
        render: function () {
            this.compositing && this.composer ? this.composer.render(this.clock.getDelta()) : this.renderer.render(this.world.scene, this.world.camera);
        },
        update: function () {
            var e = this.clock.getDelta(),
                t = this.clock.getElapsedTime();
            this.paused || (requestAnimationFrame(this.update.bind(this)), this.stats && this.stats.begin(), this.world.update(t, e), this.render(), this.stats && this.stats.end());
        },
        pause: function () {
            this.clock.stop(), (this.paused = !0);
        },
        resume: function () {
            this.clock.start(), (this.paused = !1);
        },
        toggleGUIMode: function () {
            this.stats && this.datGUI && ($(this.stats.domElement).toggle(), $(this.datGUI.domElement).toggle());
        },
        resize: function (e, t) {
            this.world.setAspectRatio(e / t);
        },
    });
    return s;
}),
define("canyon/objects", [], function () {
    var e = {};
    return (
        (e.createGrid = function (e) {
            var e = _.extend({ size: 100, step: 10, color: 0, opacity: 0.2, linewidth: 1, heights: [] }, e),
                t = new THREE.Geometry(),
                n = e.size;
            for (var r = -n; r <= n; r += e.step) t.vertices.push(new THREE.Vector3(-n, 0, r)), t.vertices.push(new THREE.Vector3(n, 0, r)), t.vertices.push(new THREE.Vector3(r, 0, -n)), t.vertices.push(new THREE.Vector3(r, 0, n));
            if (!e.material) var i = new THREE.LineBasicMaterial({ color: e.color, opacity: e.opacity, linewidth: e.linewidth });
            else var i = e.material;
            var s = new THREE.Line(t, i);
            return (s.type = THREE.LinePieces), s;
        }),
            (e.createPlaneGrid = function (e) {
                var t = new THREE.Geometry(),
                    n = e.plane;
                for (var r = 0; r < 64; r++)
                    for (var i = 0; i < 64; i++) {
                        var s = i + r * 64,
                            o = n.geometry.vertices[s];
                        t.vertices.push(o.clone()), i !== 0 && i !== 63 && t.vertices.push(o.clone());
                    }
                for (var i = 0; i < 64; i++)
                    for (var r = 0; r < 64; r++) {
                        var s = i + r * 64,
                            o = n.geometry.vertices[s];
                        t.vertices.push(o.clone()), r !== 0 && r !== 63 && t.vertices.push(o.clone());
                    }
                if (!e.material) var u = new THREE.LineBasicMaterial({ color: e.color, opacity: e.opacity, linewidth: e.linewidth });
                else var u = e.material;
                var a = new THREE.Line(t, u);
                return (a.type = THREE.LinePieces), a;
            }),
            (e.createCross = function (e) {
                var e = _.extend({ size: 10, color: 0 }, e),
                    t = e.size,
                    n = new THREE.Mesh(new THREE.PlaneGeometry(t, t, 1, 1), null);
                return n;
            }),
            e
    );
}),
define("canyon/textures", ["../textureloader"], function (e) {
    var t = "textures/canyon/",
        n = { blackcircle: "black-sprite.png", terrain: "displacement.png" },
        r = new e({ files: n, path: t });
    return { loadAll: r.loadAllFiles.bind(r), get: r.getById.bind(r) };
}),
define("canyon/shaders/shader", ["three", "../../class"], function (e, t) {
    var n = t.extend({
        initialize: function () {
            (this.uniforms = e.UniformsUtils.clone(this.uniforms)),
                (this.material = new e.ShaderMaterial({
                    attributes: this.attributes || {},
                    defines: _.clone(this.defines) || {},
                    uniforms: e.UniformsUtils.clone(this.uniforms) || {},
                    vertexShader: this.vertexShader,
                    fragmentShader: this.fragmentShader,
                }));
        },
    });
    return n;
}),
define("text", {
    load: function (e) {
        throw new Error("Dynamic load not allowed: " + e);
    },
}),
define("text!canyon/shaders/vertex/terrain.vs", [], function () {
    return "varying vec2 vUv;\nvarying vec4 worldCoord;\n\nvoid main() {\n  vUv = uv;\n  worldCoord = vec4(position, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
}),
define("text!canyon/shaders/fragment/terrain.fs", [], function () {
    return "varying vec4 worldCoord;\n\nuniform vec3 color1;\nuniform vec3 color2;\nuniform float beamPosition;\nuniform float wHeight;\nuniform vec3 lineColor1;\nuniform vec3 lineColor2;\n\nconst float brightness = BRIGHTNESS;\nconst float groundPos = GROUND_POS;\nconst float lineThickness = LINE_THICKNESS;\nconst float midPoint = MIDPOINT;\nconst float beamWidth = BEAM_WIDTH;\nconst float beamBrightness = BEAM_BRIGHTNESS;\n\nvoid main() {\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n  gl_FragColor = vec4(vec3(0.0), 1.0);\n\n  #ifdef NORMAL_MODE\n    float d = depth / 500.0;\n    float yModifier = 1.4 - (gl_FragCoord.y / wHeight);\n    vec3 color = mix(color1 * yModifier, color2, d);\n    float beamFar = beamPosition + (beamWidth / 2.0);\n    float beamNear = beamPosition - (beamWidth / 2.0);\n    float beam = 0.0;\n\n    if (depth < beamFar && depth > beamNear) {\n      beam = clamp(beamBrightness - (depth / 2000.0), 0.0, 1.0);\n    }\n\n    gl_FragColor = vec4(color + vec3(beam), 1.0);\n  #endif\n\n  // draw a line at ground level\n  if (worldCoord.z < (groundPos + (lineThickness / 2.0)) && worldCoord.z > (groundPos - (lineThickness / 2.0))) {\n    vec3 color = mix(lineColor1, lineColor2, clamp(depth / midPoint, 0.0, 1.0));\n\n    gl_FragColor = vec4(color, 1.0);\n  }\n}";
}),
define("canyon/shaders/terrain", ["./shader", "text!./vertex/terrain.vs", "text!./fragment/terrain.fs"], function (e, t, n) {
    var r = e.extend({
        BEAM_SPEED: 125,
        vertexShader: t,
        fragmentShader: n,
        defines: { NORMAL_MODE: "", BRIGHTNESS: "0.25", GROUND_POS: "10.0", LINE_THICKNESS: "0.3", MIDPOINT: "300.0", BEAM_WIDTH: "50.0", BEAM_BRIGHTNESS: "0.25" },
        uniforms: {
            color1: { type: "c", value: new THREE.Color(994137) },
            color2: { type: "c", value: new THREE.Color(0) },
            beamPosition: { type: "f", value: 0 },
            wHeight: { type: "f", value: HEIGHT },
            lineColor1: { type: "c", value: new THREE.Color(1496519) },
            lineColor2: { type: "c", value: new THREE.Color(431223) },
        },
        initialize: function (t) {
            e.prototype.initialize.call(this), t && t.beamWidth && (this.material.uniforms.beamWidth.value = t.beamWidth);
        },
        animateBeam: function (e) {
            (this.material.uniforms.beamPosition.value += e * this.BEAM_SPEED), this.material.uniforms.beamPosition.value > 400 && (this.material.uniforms.beamPosition.value = 0);
        },
        update: function (e) {
            this.animateBeam(e);
        },
    });
    return r;
}),
define("text!canyon/shaders/vertex/grid.vs", [], function () {
    return "void main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
}),
define("text!canyon/shaders/fragment/grid.fs", [], function () {
    return "uniform vec3 color1;\nuniform vec3 color2;\nuniform float midpoint;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\n\nvoid main() {\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n  vec3 color = mix(color1, color2, clamp(depth / midpoint, 0.0, 1.0));\n\n  gl_FragColor = vec4(color, 1.0);\n}";
}),
define("canyon/shaders/grid", ["./shader", "text!./vertex/grid.vs", "text!./fragment/grid.fs"], function (e, t, n) {
    var r = e.extend({
        vertexShader: t,
        fragmentShader: n,
        uniforms: {
            color1: { type: "c", value: new THREE.Color(1496519) },
            color2: { type: "c", value: new THREE.Color(431223) },
            midpoint: { type: "f", value: 300 },
            fogColor: { type: "c", value: new THREE.Color(0) },
            fogDensity: { type: "f", value: 25e-5 },
            fogNear: { type: "f", value: 1 },
            fogFar: { type: "f", value: 2e3 },
        },
        initialize: function (t) {
            e.prototype.initialize.call(this), THREE.LineBasicMaterial.call(this.material), (this.material.linewidth = t.thickLines ? Math.ceil(WIDTH / 500) : 1);
        },
    });
    return r;
}),
define("canyon/landscape", ["./objects", "./textures", "./shaders/terrain", "./shaders/grid"], function (e, t, n, r) {
    function i(i) {
        var o = new THREE.Object3D();
        o.terrainShader = new n();
        var u = o.terrainShader.material,
            a = (this.ground = new THREE.Mesh(new THREE.PlaneGeometry(1e3, 3e3, 1, 1), u));
        (a.name = "ground"), (a.rotation.x = -Math.PI / 2), a.position.set(0, 0, -1e3), o.add(a);
        var f = (this.peaks = new THREE.Mesh(new THREE.PlaneGeometry(1e3, 1e3, 63, 63), u));
        (f.name = "peaks"), (f.position.y = -10), (f.rotation.x = -Math.PI / 2), o.add(f);
        var l = (this.peaks2 = f.clone());
        (l.name = "peaks2"), l.position.set(0, -10, -1e3), o.add(l);
        var c = (this.peaks2 = f.clone());
        (c.name = "peaks3"), c.position.set(0, -10, -2e3), o.add(c);
        var h = new r({ thickLines: i.thickLines }),
            p = (this.groundGrid = e.createGrid({ size: 500, step: 4e3 / 63, opacity: 1, color: 3915433, material: h.material }));
        (p.name = "groundGrid"), p.position.set(10, 0.1, 0), o.add(p);
        var d = (this.groundGrid2 = p.clone());
        (d.name = "groundGrid2"), d.position.set(10, 0.1, -1e3), o.add(d);
        var v = (this.groundGrid3 = p.clone());
        v.position.set(10, 0.1, -2e3), (v.name = "groundGrid3"), o.add(v);
        var m = t.get("terrain").image,
            g = document.createElement("canvas");
        (g.width = 64), (g.height = 64);
        var y = g.getContext("2d");
        y.drawImage(m, 0, 0, g.width, g.height);
        var b = y.getImageData(0, 0, g.width, g.height),
            w = [];
        for (var E = 0; E < b.height; E++) for (var S = 0; S < b.width; S++) w.push(s(b, S, E));
        var x = 250;
        _.each(f.geometry.vertices, function (e, t) {
            e.z = (w[t] / 255) * x;
        }),
            (f.geometry.dynamic = !0),
            (f.geometry.verticesNeedUpdate = !0),
            f.geometry.computeFaceNormals(),
            (f.geometry.normalsNeedUpdate = !0);
        var T = e.createPlaneGrid({ plane: f, material: h.material });
        return (
            (T.position.y = -0.25),
                (T.position.z = 0.15),
                f.add(T),
                _.each(f.children, function (e) {
                    l.add(e.clone());
                }),
                _.each(f.children, function (e) {
                    c.add(e.clone());
                }),
                o
        );
    }
    function s(e, t, n) {
        var r = (n * e.width + t) * 4;
        return e.data[r];
    }
    return i;
}),
define("text!canyon/shaders/vertex/basic.vs", [], function () {
    return "varying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
}),
define("text!canyon/shaders/fragment/sky.fs", [], function () {
    return "varying vec2 vUv;\n\nvec3 color = vec3(0.0);\n\nuniform float aspect;\n\n// Gradient\nuniform float midpoint;\nuniform vec3 color1;\nuniform vec3 color2;\n\n// Lines\nuniform float offset;\nuniform float offsetY;\nuniform float screenHeight;\n\n// Circles\nconst int MAX_CIRCLES = 20;\nuniform vec2 centers[MAX_CIRCLES];\nuniform float radii[MAX_CIRCLES];\nuniform vec3 colors[MAX_CIRCLES];\nuniform int alive[MAX_CIRCLES];\nuniform vec2 circleOffset;\n\nvoid drawGradient() {\n  float bottom = midpoint - 0.1;\n  float top = midpoint + 0.15;\n\n  if (vUv.y < bottom) {\n    color = color1;\n  } else if (vUv.y > top) {\n    color = color2;\n  } else {\n    float height = top - bottom;\n    color = mix(color1, color2, (vUv.y - bottom) / height);\n  }\n}\n\nvoid drawLines() {\n  const float spread = 35.0;\n  const float maxThickness = 15.0;\n  const float minThickness = 4.0;\n  const float darkenFactor = 1.4;\n\n  float y = 1.0 - vUv.y + offsetY;\n  float lineHeight = max(maxThickness * y, minThickness);\n\n  if (mod(gl_FragCoord.y + offset - (offsetY * screenHeight), spread) < lineHeight) {\n    color -= color * (y - offsetY) * darkenFactor;\n  }\n}\n\nvoid drawCircles() {\n  float border = 0.001; // border smoothing length\n\n  for (int i = 0; i < MAX_CIRCLES; i++) {\n\n    if (alive[i] == 0) {\n      continue;\n    }\n\n    float r = radii[i]; // circle radius\n    vec3 c = colors[i]; // circle color\n    vec2 uv = vec2(vUv.x * aspect, vUv.y);\n    vec2 center = vec2(centers[i].x * aspect, centers[i].y) + circleOffset;\n    float dc = distance(uv, center); // distance from circle center\n    float db = r - dc; // distance from border\n\n    if (dc < r + border) {\n      if (db > border) {\n        color = c;\n      } else {\n        float t = 0.0;\n        t = clamp(db / border, 0.0, 1.0); // smooth border\n        color = mix(color, c, t);\n      }\n    }\n  }\n}\n\nvoid main() {\n  drawGradient();\n  drawLines();\n  drawCircles();\n\n  gl_FragColor = vec4(color, 1.0);\n}";
}),
(function (e) {
    var t = (function () {
        "use strict";
        function t(e, t) {
            var n;
            for (n in e) Object.hasOwnProperty.call(e, n) && t(n);
        }
        function n(e, n) {
            return (
                t(n, function (t) {
                    e[t] = n[t];
                }),
                    e
            );
        }
        function r(e, n) {
            return (
                t(n, function (t) {
                    e[t] === void 0 && (e[t] = n[t]);
                }),
                    e
            );
        }
        function i(e, t, n, r, i, o, u) {
            var a,
                f = (e - o) / i;
            for (a in t) t.hasOwnProperty(a) && r.hasOwnProperty(a) && (t[a] = s(n[a], r[a], p[u[a]], f));
            return t;
        }
        function s(e, t, n, r) {
            return e + (t - e) * n(r);
        }
        function o(e, n, r) {
            var i = f.prototype.filter;
            t(i, function (t) {
                i[t][n] && i[t][n].apply(e, r);
            });
        }
        function u(e, t, n, r, s, a, f, l) {
            var c = t + n,
                p = Math.min(h(), c),
                d = p >= c;
            e._isTweening &&
            (d ||
            (e._loopId = setTimeout(function () {
                u(e, t, n, r, s, a, f, l);
            }, 1e3 / e.fps)),
                o(e, "beforeTween", [r, s, a, f]),
                i(p, r, s, a, n, t, f),
                o(e, "afterTween", [r, s, a, f]),
            l && l(r)),
            (d || !e._isTweening) && e.stop(!0);
        }
        function a(e, n) {
            var r = {};
            return (
                "string" == typeof n
                    ? t(e, function (e) {
                        r[e] = n;
                    })
                    : t(e, function (e) {
                        r[e] || (r[e] = n[e] || l);
                    }),
                    r
            );
        }
        function f(e) {
            var t = e || {};
            return (this.data = {}), (this.fps = t.fps || 60), (this._currentState = t.initialState || {}), this;
        }
        var l = "linear",
            c = 500,
            h = function () {
                return +new Date();
            };
        (f.prototype.tween = function (e) {
            if (!this._isTweening) {
                (this._loopId = 0),
                    (this._pausedAtTime = null),
                    (this._step = e.step),
                    (this._callback = e.callback),
                    (this._targetState = e.to || {}),
                    (this._duration = e.duration || c),
                    (this._currentState = e.from || this.get()),
                    (this._timestamp = h());
                var t = this._currentState,
                    i = this._targetState;
                r(t, i), r(i, t), (this._easing = a(t, e.easing || l));
                var s = (this._originalState = n({}, t));
                return o(this, "tweenCreated", [t, s, i, this._easing]), this.resume();
            }
        }),
            (f.prototype.get = function () {
                return n({}, this._currentState);
            }),
            (f.prototype.set = function (e) {
                this._currentState = e;
            }),
            (f.prototype.stop = function (e) {
                return (
                    clearTimeout(this._loopId),
                        (this._isTweening = !1),
                        (this._isPaused = !1),
                    e &&
                    (n(this._currentState, this._targetState),
                        o(this, "afterTweenEnd", [this._currentState, this._originalState, this._targetState, this._easing]),
                    this._callback && this._callback.call(this._currentState, this._currentState)),
                        this
                );
            }),
            (f.prototype.pause = function () {
                return clearTimeout(this._loopId), (this._pausedAtTime = h()), (this._isPaused = !0), this;
            }),
            (f.prototype.resume = function () {
                return (
                    this._isPaused && (this._timestamp += h() - this._pausedAtTime),
                        (this._isPaused = !1),
                        (this._isTweening = !0),
                        u(this, this._timestamp, this._duration, this._currentState, this._originalState, this._targetState, this._easing, this._step),
                        this
                );
            }),
            (f.prototype.isPlaying = function () {
                return this._isTweening && !this._isPaused;
            }),
            (f.prototype.filter = {}),
            n(f, { now: h, each: t, tweenProps: i, tweenProp: s, applyFilter: o, shallowCopy: n, defaults: r, composeEasingObject: a }),
            (f.prototype.formula = {
                linear: function (e) {
                    return e;
                },
            });
        var p = f.prototype.formula;
        return (
            "object" == typeof exports
                ? (module.exports = f)
                : "function" == typeof define && define.amd
                ? define("shifty", [], function () {
                    return f;
                })
                : e.Tweenable === void 0 && (e.Tweenable = f),
                f
        );
    })();
    (function () {
        t.shallowCopy(t.prototype.formula, {
            easeInQuad: function (e) {
                return Math.pow(e, 2);
            },
            easeOutQuad: function (e) {
                return -(Math.pow(e - 1, 2) - 1);
            },
            easeInOutQuad: function (e) {
                return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 2) : -0.5 * ((e -= 2) * e - 2);
            },
            easeInCubic: function (e) {
                return Math.pow(e, 3);
            },
            easeOutCubic: function (e) {
                return Math.pow(e - 1, 3) + 1;
            },
            easeInOutCubic: function (e) {
                return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 3) : 0.5 * (Math.pow(e - 2, 3) + 2);
            },
            easeInQuart: function (e) {
                return Math.pow(e, 4);
            },
            easeOutQuart: function (e) {
                return -(Math.pow(e - 1, 4) - 1);
            },
            easeInOutQuart: function (e) {
                return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 4) : -0.5 * ((e -= 2) * Math.pow(e, 3) - 2);
            },
            easeInQuint: function (e) {
                return Math.pow(e, 5);
            },
            easeOutQuint: function (e) {
                return Math.pow(e - 1, 5) + 1;
            },
            easeInOutQuint: function (e) {
                return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 5) : 0.5 * (Math.pow(e - 2, 5) + 2);
            },
            easeInSine: function (e) {
                return -Math.cos(e * (Math.PI / 2)) + 1;
            },
            easeOutSine: function (e) {
                return Math.sin(e * (Math.PI / 2));
            },
            easeInOutSine: function (e) {
                return -0.5 * (Math.cos(Math.PI * e) - 1);
            },
            easeInExpo: function (e) {
                return 0 === e ? 0 : Math.pow(2, 10 * (e - 1));
            },
            easeOutExpo: function (e) {
                return 1 === e ? 1 : -Math.pow(2, -10 * e) + 1;
            },
            easeInOutExpo: function (e) {
                return 0 === e ? 0 : 1 === e ? 1 : 1 > (e /= 0.5) ? 0.5 * Math.pow(2, 10 * (e - 1)) : 0.5 * (-Math.pow(2, -10 * --e) + 2);
            },
            easeInCirc: function (e) {
                return -(Math.sqrt(1 - e * e) - 1);
            },
            easeOutCirc: function (e) {
                return Math.sqrt(1 - Math.pow(e - 1, 2));
            },
            easeInOutCirc: function (e) {
                return 1 > (e /= 0.5) ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
            },
            easeOutBounce: function (e) {
                return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
            },
            easeInBack: function (e) {
                var t = 1.70158;
                return e * e * ((t + 1) * e - t);
            },
            easeOutBack: function (e) {
                var t = 1.70158;
                return (e -= 1) * e * ((t + 1) * e + t) + 1;
            },
            easeInOutBack: function (e) {
                var t = 1.70158;
                return 1 > (e /= 0.5) ? 0.5 * e * e * (((t *= 1.525) + 1) * e - t) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
            },
            elastic: function (e) {
                return -1 * Math.pow(4, -8 * e) * Math.sin(((6 * e - 1) * 2 * Math.PI) / 2) + 1;
            },
            swingFromTo: function (e) {
                var t = 1.70158;
                return 1 > (e /= 0.5) ? 0.5 * e * e * (((t *= 1.525) + 1) * e - t) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
            },
            swingFrom: function (e) {
                var t = 1.70158;
                return e * e * ((t + 1) * e - t);
            },
            swingTo: function (e) {
                var t = 1.70158;
                return (e -= 1) * e * ((t + 1) * e + t) + 1;
            },
            bounce: function (e) {
                return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
            },
            bouncePast: function (e) {
                return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 2 - (7.5625 * (e -= 1.5 / 2.75) * e + 0.75) : 2.5 / 2.75 > e ? 2 - (7.5625 * (e -= 2.25 / 2.75) * e + 0.9375) : 2 - (7.5625 * (e -= 2.625 / 2.75) * e + 0.984375);
            },
            easeFromTo: function (e) {
                return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 4) : -0.5 * ((e -= 2) * Math.pow(e, 3) - 2);
            },
            easeFrom: function (e) {
                return Math.pow(e, 4);
            },
            easeTo: function (e) {
                return Math.pow(e, 0.25);
            },
        });
    })(),
        (function () {
            function e(e, r, i, s, o) {
                return t.tweenProps(s, r, e, i, 1, 0, o);
            }
            (t.interpolate = function (r, i, s, o) {
                var u, a, f;
                r && r.from && ((i = r.to), (s = r.position), (o = r.easing), (r = r.from)), (f = new t()), (f.easing = o || "linear"), (u = t.shallowCopy({}, r));
                var l = t.composeEasingObject(r, f.easing);
                return t.applyFilter(f, "tweenCreated", [u, r, i, l]), t.applyFilter(f, "beforeTween", [u, r, i, l]), (a = e(r, u, i, s, l)), t.applyFilter(f, "afterTween", [a, r, i, l]), a;
            }),
                (t.prototype.interpolate = function (e, r, i) {
                    var s;
                    return (s = t.interpolate(this.get(), e, r, i)), this.set(s), s;
                });
        })(),
        (function (e) {
            function t(e, t) {
                var n,
                    r = e.length,
                    i = [];
                for (n = 0; r > n; n++) i.push("_" + t + "_" + n);
                return i;
            }
            function n(e) {
                var t = e.match(w);
                return 1 === t.length && t.unshift(""), t.join(N);
            }
            function r(t) {
                e.each(t, function (e) {
                    var n = t[e];
                    "string" == typeof n && n.match(T) && (t[e] = i(n));
                });
            }
            function i(e) {
                return a(T, e, s);
            }
            function s(e) {
                var t = o(e);
                return "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")";
            }
            function o(e) {
                return (e = e.replace(/#/, "")), 3 === e.length && ((e = e.split("")), (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2])), [u(e.substr(0, 2)), u(e.substr(2, 2)), u(e.substr(4, 2))];
            }
            function u(e) {
                return parseInt(e, 16);
            }
            function a(e, t, n) {
                var r = t.match(e),
                    i = t.replace(e, N);
                if (r) for (var s, o = r.length, u = 0; o > u; u++) (s = r.shift()), (i = i.replace(N, n(s)));
                return i;
            }
            function f(e) {
                return a(S, e, l);
            }
            function l(e) {
                for (var t = e.match(E), n = t.length, r = e.match(x)[0], i = 0; n > i; i++) r += parseInt(t[i], 10) + ",";
                return (r = r.slice(0, -1) + ")");
            }
            function c(r) {
                var i = {};
                return (
                    e.each(r, function (e) {
                        var s = r[e];
                        if ("string" == typeof s) {
                            var o = g(s);
                            i[e] = { formatString: n(s), chunkNames: t(o, e) };
                        }
                    }),
                        i
                );
            }
            function h(t, n) {
                e.each(n, function (e) {
                    for (var r = t[e], i = g(r), s = i.length, o = 0; s > o; o++) t[n[e].chunkNames[o]] = +i[o];
                    delete t[e];
                });
            }
            function p(t, n) {
                e.each(n, function (e) {
                    var r = t[e],
                        i = d(t, n[e].chunkNames),
                        s = v(i, n[e].chunkNames);
                    (r = m(n[e].formatString, s)), (t[e] = f(r));
                });
            }
            function d(e, t) {
                for (var n, r = {}, i = t.length, s = 0; i > s; s++) (n = t[s]), (r[n] = e[n]), delete e[n];
                return r;
            }
            function v(e, t) {
                for (var n = [], r = t.length, i = 0; r > i; i++) n.push(e[t[i]]);
                return n;
            }
            function m(e, t) {
                for (var n = e, r = t.length, i = 0; r > i; i++) n = n.replace(N, +t[i].toFixed(4));
                return n;
            }
            function g(e) {
                return e.match(E);
            }
            function y(t, n) {
                e.each(n, function (e) {
                    for (var r = n[e], i = r.chunkNames, s = i.length, o = t[e].split(" "), u = o[o.length - 1], a = 0; s > a; a++) t[i[a]] = o[a] || u;
                    delete t[e];
                });
            }
            function b(t, n) {
                e.each(n, function (e) {
                    for (var r = n[e], i = r.chunkNames, s = i.length, o = "", u = 0; s > u; u++) (o += " " + t[i[u]]), delete t[i[u]];
                    (o = o.substr(1)), (t[e] = o);
                });
            }
            var w = /([^\-0-9\.]+)/g,
                E = /[0-9.\-]+/g,
                S = RegExp("rgb\\(" + E.source + /,\s*/.source + E.source + /,\s*/.source + E.source + "\\)", "g"),
                x = /^.*\(/,
                T = /#([0-9]|[a-f]){3,6}/g,
                N = "VAL";
            e.prototype.filter.token = {
                tweenCreated: function (e, t, n) {
                    r(e), r(t), r(n), (this._tokenData = c(e));
                },
                beforeTween: function (e, t, n, r) {
                    y(r, this._tokenData), h(e, this._tokenData), h(t, this._tokenData), h(n, this._tokenData);
                },
                afterTween: function (e, t, n, r) {
                    p(e, this._tokenData), p(t, this._tokenData), p(n, this._tokenData), b(r, this._tokenData);
                },
            };
        })(t);
})(this),
define("tween", ["class", "shifty"], function (e, t) {
    var n = e.extend({
        initialize: function (e) {
            (this.from = e.from), (this.to = e.to), (this.duration = e.duration / 1e3), (this.easing = e.easing), (this.step = e.step), (this.callback = e.callback), (this.elapsedTime = 0), (this.alive = !0);
        },
        update: function (e) {
            if (!this.alive) return;
            (this.elapsedTime += e), this.step && this.step(t.interpolate(this.from, this.to, this.elapsedTime / this.duration, this.easing)), this.elapsedTime > this.duration && (this.stop(), this.callback && this.callback());
        },
        stop: function () {
            (this.elapsedTime = 0), (this.alive = !1);
        },
        start: function () {
            this.alive = !0;
        },
    });
    return n;
}),
define("canyon/shaders/sky", ["./shader", "text!./vertex/basic.vs", "text!./fragment/sky.fs", "../../tween"], function (e, t, n, r) {
    function s() {
        var e = [
            { color: new THREE.Color(60139), radius: 0.25 * THREE.Math.randFloat(0.5, 1), speedFactor: 0.7, lifespan: 3 },
            { color: new THREE.Color(60139), radius: 0.06, speedFactor: 0.9, lifespan: 1.1 },
            { color: new THREE.Color(8267233), radius: 0.1, speedFactor: 0.8, lifespan: 0.6 },
            { color: new THREE.Color(12193781), radius: 0.12, speedFactor: 0.6, lifespan: 1.8 },
        ];
        return e[THREE.Math.randInt(0, e.length - 1)];
    }
    var i = e.extend({
        LINES_SPEED: 120,
        MAX_CIRCLES: 20,
        CIRCLE_SPAWN_DELAY: 0.17,
        CIRCLE_SPEED_X: 0.05,
        CIRCLE_SPEED_Y: 0.5,
        vertexShader: t,
        fragmentShader: n,
        uniforms: {
            aspect: { type: "f", value: WIDTH / HEIGHT },
            midpoint: { type: "f", value: 0.7 },
            color1: { type: "c", value: new THREE.Color(16758630) },
            color2: { type: "c", value: new THREE.Color(14490108) },
            offset: { type: "f", value: 0 },
            offsetY: { type: "f", value: 0 },
            screenHeight: { type: "f", value: HEIGHT },
            centers: { type: "v2v", value: [] },
            colors: { type: "v3v", value: [] },
            radii: { type: "fv1", value: [] },
            alive: { type: "iv1", value: [] },
            circleOffset: { type: "v2", value: new THREE.Vector2(0, 0) },
        },
        initialize: function (t) {
            e.prototype.initialize.call(this),
            t && t.height && (this.material.uniforms.height.value = t.height),
                (this.circles = []),
                _.times(
                    this.MAX_CIRCLES,
                    _.bind(function () {
                        this.circles.push({ alive: !1, position: new THREE.Vector2(0, 0), color: new THREE.Color(0), direction: Math.random() > 0.5 ? 1 : -1, radius: 0 });
                    }, this)
                ),
                (this.lastSpawnTime = 0),
                (this.material.depthWrite = !1);
        },
        update: function (e, t) {
            this.animateLines(t), this.animateCircles(e, t), this.updateGradient();
        },
        updateGradient: function () {
            var e = this.material.uniforms.midpoint.value,
                t = 0.7 + mouseY * 0.25;
            this.material.uniforms.midpoint.value = THREE.Math.lerp(e, t, 0.1);
        },
        animateLines: function (e) {
            var t = this.material.uniforms.offsetY.value,
                n = mouseY * 0.25;
            (this.material.uniforms.offsetY.value = THREE.Math.lerp(t, n, 0.1)), (this.material.uniforms.offset.value -= e * this.LINES_SPEED);
        },
        spawnCircle: function (e) {
            var t = _.find(this.circles, function (e) {
                return !e.alive;
            });
            t && ((t.alive = !0), (t = _.extend(t, s())), (t.position = new THREE.Vector2(THREE.Math.randFloat(0.1, 0.9), 0.3 - t.radius)), (t.speedFactor *= THREE.Math.randFloat(0.5, 1.4)), (t.spawnTime = e)), (this.lastSpawnTime = e);
        },
        killCircles: function (e, t) {
            var n = 0.6;
            _.each(this.circles, function (i) {
                i.alive &&
                !i.death &&
                e - i.spawnTime > i.lifespan - n &&
                (i.death = new r({
                    from: { radius: i.radius },
                    to: { radius: 0 },
                    duration: n * 1e3,
                    easing: "easeInQuad",
                    step: function (e) {
                        i.radius = e.radius;
                    },
                    callback: function () {
                        (i.alive = !1), (i.death = null);
                    },
                })),
                i.death && i.death.update(t);
            });
        },
        animateCircles: function (e, t) {
            e - this.lastSpawnTime > this.CIRCLE_SPAWN_DELAY && this.spawnCircle(e),
                this.killCircles(e, t),
                _.each(
                    this.circles,
                    _.bind(function (e) {
                        THREE.Math.randFloat(0, 1) > 0.995 && (e.direction = -e.direction),
                            (e.position.x += e.direction * THREE.Math.randFloat(0.6, 1.3) * this.CIRCLE_SPEED_X * t),
                            (e.position.y += t * e.speedFactor * this.CIRCLE_SPEED_Y);
                    }, this)
                ),
                this.updateCircleUniforms(),
                this.updateCircleOffset();
        },
        updateCircleOffset: function () {
            var e = new THREE.Vector2(-mouseX * 0.5, mouseY * 0.25);
            this.material.uniforms.circleOffset.value.lerp(e, 0.1);
        },
        updateCircleUniforms: function () {
            (this.material.uniforms.alive.value = _.map(this.circles, function (e) {
                return e.alive ? 1 : 0;
            })),
                (this.material.uniforms.colors.value = _.map(this.circles, function (e) {
                    return new THREE.Vector3(e.color.r, e.color.g, e.color.b);
                })),
                (this.material.uniforms.radii.value = _.pluck(this.circles, "radius")),
                (this.material.uniforms.centers.value = _.pluck(this.circles, "position"));
        },
    });
    return i;
}),
define("text!canyon/shaders/fragment/bubble.fs", [], function () {
    return "varying vec2 vUv;\n\nconst int RING_PHASE = 0;\nconst int CROSS_PHASE = 1;\n\nuniform int phase;\nuniform float r1;\nuniform float r2;\nuniform vec3 color;\nuniform vec2 center;\nuniform float opacity;\nuniform float strokeWidth;\nuniform float crossLength;\nuniform float crossDecay;\n\nvec3 col = vec3(0.0);\nfloat alpha = 1.0;\n\nvoid drawRing() {\n  float border = 0.0001; // border smoothing length\n\n  vec3 c = color; // circle color\n  float dc = distance(vUv.xy, center); // distance from circle center\n  float db = r1 - dc; // distance from border\n  float t = 0.0;\n\n  if (dc < r1 + border) {\n    if (db > border) {\n      t = 1.0; // normal circle color\n    } else {\n      t = clamp(db / border, 0.0, 1.0); // smooth border\n    }\n    col = mix(color, c, t);\n  } else {\n    t = clamp(db / border, 0.0, 1.0); // smooth border\n    alpha = mix(0.0, 1.0, t);\n  }\n\n  if (dc < (r1 - (r1 - r2))) {\n    alpha = 0.0;\n  }\n}\n\nvoid drawCross() {\n  float thickness = strokeWidth / 2.0;\n  float dc = distance(vUv.xy, center);\n\n  alpha = 0.0;\n\n  if (vUv.x < (vUv.y + thickness) && vUv.x > (vUv.y - thickness)) {\n    col = vec3(1.0, 1.0, 1.0);\n    alpha = 1.0;\n  }\n\n  if (vUv.y > ((1.0 - vUv.x) - thickness) && vUv.y < ((1.0 - vUv.x) + thickness)) {\n    col = vec3(1.0, 1.0, 1.0);\n    alpha = 1.0;\n  }\n\n  if (dc < crossDecay || dc > crossLength) {\n    alpha = 0.0;\n  }\n}\n\nvoid main() {\n  if (phase == RING_PHASE) {\n    drawRing();\n  }\n\n  if (phase == CROSS_PHASE) {\n    drawCross();\n  }\n\n  gl_FragColor = vec4(col, alpha * opacity);\n}";
}),
define("canyon/shaders/bubble", ["./shader", "text!./vertex/basic.vs", "text!./fragment/bubble.fs", "../../tween"], function (e, t, n, r) {
    var i = e.extend({
        RING_SPEED: 0.05,
        vertexShader: t,
        fragmentShader: n,
        uniforms: {
            phase: { type: "i", value: 1 },
            r1: { type: "f", value: 0 },
            r2: { type: "f", value: 0 },
            center: { type: "v2", value: new THREE.Vector2(0.5, 0.5) },
            color: { type: "c", value: new THREE.Color(13172730) },
            opacity: { type: "f", value: 1 },
            strokeWidth: { type: "f", value: 0.05 },
            crossLength: { type: "f", value: 0 },
            crossDecay: { type: "f", value: 0 },
        },
        initialize: function (t) {
            e.prototype.initialize.call(this), (this.material.transparent = !0), (this.alive = !1);
        },
        growRing: function () {
            var e = this.material.uniforms.r1,
                t = this.material.uniforms.r2,
                n = 1e3;
            (this.alive = !0),
                (this.material.uniforms.phase.value = 0),
                (this.material.uniforms.opacity.value = 1),
                (this.radius1 = new r({
                    from: { radius: 0 },
                    to: { radius: 0.5 },
                    duration: n,
                    easing: "easeInQuad",
                    step: function (t) {
                        e.value = t.radius;
                    },
                    callback: _.bind(function () {
                        this.radius1 = null;
                    }, this),
                })),
                (this.radius2 = new r({
                    from: { radius: 0 },
                    to: { radius: 0.45 },
                    duration: n * 1.1,
                    easing: "easeInQuad",
                    step: function (e) {
                        t.value = e.radius;
                    },
                    callback: _.bind(function () {
                        (this.radius2 = null), this.shrinkRing();
                    }, this),
                }));
        },
        shrinkRing: function () {
            var e = this.material.uniforms.r1,
                t = this.material.uniforms.r2,
                n = this.material.uniforms.opacity,
                i = 800;
            (this.radius1 = new r({
                from: { radius: 0.5, opacity: n.value },
                to: { radius: 0, opacity: 0 },
                duration: i,
                easing: "easeOutQuart",
                step: function (t) {
                    (e.value = t.radius), (n.value = t.opacity);
                },
                callback: _.bind(function () {
                    this.radius1 = null;
                }, this),
            })),
                (this.radius2 = new r({
                    from: { radius: 0.45 },
                    to: { radius: 0 },
                    duration: i,
                    easing: "easeOutQuart",
                    step: function (e) {
                        t.value = e.radius;
                    },
                    callback: _.bind(function () {
                        (this.radius2 = null), this.drawCross();
                    }, this),
                }));
        },
        drawCross: function () {
            var e = this.material.uniforms.crossLength,
                t = this.material.uniforms.crossDecay,
                n = 250;
            (this.material.uniforms.phase.value = 1),
                (this.material.uniforms.opacity.value = 1),
                (this.draw = new r({
                    from: { value: 0 },
                    to: { value: 0.5 },
                    duration: n,
                    easing: "linear",
                    step: function (t) {
                        e.value = t.value;
                    },
                    callback: _.bind(function () {
                        this.draw = null;
                    }, this),
                })),
                (this.erase = new r({
                    from: { value: 0 },
                    to: { value: 0.5 },
                    duration: n * 2,
                    easing: "linear",
                    step: function (e) {
                        t.value = e.value;
                    },
                    callback: _.bind(function () {
                        (this.alive = !1), (this.erase = null), this.growRing();
                    }, this),
                }));
        },
        update: function (e, t) {
            t < 300 && !this.alive && this.growRing(), this.radius1 && this.radius1.update(e), this.radius2 && this.radius2.update(e), this.draw && this.draw.update(e), this.erase && this.erase.update(e);
        },
    });
    return i;
}),
define("canyon/canyon", ["../world", "./objects", "./textures", "./landscape", "./shaders/sky", "./shaders/bubble"], function (e, t, n, r, i, s) {
    function u() {
        var e = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
        return new THREE.WebGLRenderTarget(WIDTH, HEIGHT, e);
    }
    var o = e.extend({
        initialize: function (n) {
            function y(e, t) {
                var n = p.getObjectByName(e, !0),
                    r = n.clone();
                return t && (r.material = t), m.add(r), r;
            }
            e.prototype.initialize.call(this),
                (this.thickLines = n.thickLines),
                (this.CAMERA_SPEED = 150),
                (this.BOUNDARIES = { x: WIDTH / 10, y: HEIGHT / 10 }),
                this.camera.position.set(10, 10, 500),
                (this.camera.target = new THREE.Vector3(this.scene.position.x, this.scene.position.y + 80, this.scene.position.z)),
                this.camera.lookAt(this.camera.target);
            var o = (this.glowCamera = this.camera.clone()),
                u = new THREE.DirectionalLight(16777215, 1);
            u.position.set(-500, 250, 250), u.target.position.set(0, 0, 0), this.scene.add(u), this.lights.push(u);
            var a = WIDTH * 4,
                f = HEIGHT * 4,
                l = (this.skyShader = new i()),
                c = (this.sky = new THREE.Mesh(new THREE.PlaneGeometry(a, f, 1, 1), l.material)),
                h = f / 2 / Math.tan(THREE.Math.degToRad(this.camera.fov / 2));
            (this.sky.width = a), (this.sky.height = f), this.sky.scale.set(1, 1, 1), c.position.set(0, 0, -h), this.camera.add(c);
            var p = (this.landscape = r({ thickLines: this.thickLines }));
            this.scene.add(p), this.initBlackParticles();
            var d = 6,
                v = (this.bubbles = new THREE.Object3D());
            _.times(d, function () {
                var e = t.createCross({ color: 13172215 }),
                    n = new s();
                (e.shader = n), (e.material = e.shader.material), (e.position.x = Math.random() * 150 - 75), (e.position.y = Math.random() * 45 + 5), (e.position.z = -(Math.random() * 1e3)), v.add(e);
            }),
                this.cameraContainer.add(v);
            var m = (this.glowScene = new THREE.Scene());
            m.add(o);
            var g = p.getObjectByName("ground", !0).material.clone();
            (g.defines = _.clone(g.defines)), delete g.defines.NORMAL_MODE, y("ground", g), y("peaks", g), y("peaks2", g), y("peaks3", g), y("groundGrid"), y("groundGrid2"), y("groundGrid3");
            var b = this.thickLines ? 10 : 1,
                w = new THREE.LineBasicMaterial({ color: 4107660, linewidth: b, opacity: 0.5, transparent: !0 });
            (this.glowScene.getObjectByName("groundGrid").material = w),
                (this.glowScene.getObjectByName("groundGrid2").material = w),
                (this.glowScene.getObjectByName("groundGrid3").material = w),
                (this.glowScene.getObjectByName("peaks").children[0].material = w),
                (this.glowScene.getObjectByName("peaks2").children[0].material = w),
                (this.glowScene.getObjectByName("peaks3").children[0].material = w);
        },
        setupDatGUI: function (e) {
            var t = e.addFolder("Light position"),
                n = this.lights[0];
            t.add(n.position, "x"), t.add(n.position, "y"), t.add(n.position, "z"), t.open();
        },
        setupCompositing: function (e, t) {
            var n = new THREE.RenderPass(this.glowScene, this.glowCamera),
                r = new THREE.ShaderPass(THREE.HorizontalBlurShader),
                i = new THREE.ShaderPass(THREE.VerticalBlurShader),
                s = 3;
            if (!this.thickLines) {
                var o = new THREE.ShaderPass(THREE.StrokeShader),
                    a = new THREE.SavePass(u()),
                    f = new THREE.ShaderPass(THREE.BlendShader);
                (f.uniforms.tDiffuse2.value = a.renderTarget),
                    (o.uniforms.h.value = 1 / WIDTH),
                    (o.uniforms.cells.value = [
                        new THREE.Vector2(0, 0),
                        new THREE.Vector2(1, 1),
                        new THREE.Vector2(0, 1),
                        new THREE.Vector2(-1, 1),
                        new THREE.Vector2(-1, 0),
                        new THREE.Vector2(-1, -1),
                        new THREE.Vector2(0, -1),
                        new THREE.Vector2(1, -1),
                    ]);
            }
            (r.uniforms.h.value = s / WIDTH), (i.uniforms.v.value = s / HEIGHT), e.addPass(n), this.thickLines || (e.addPass(o), e.addPass(a)), e.addPass(r), e.addPass(i), this.thickLines || e.addPass(f);
            var l = new THREE.ShaderPass(THREE.AdditiveBlendShader, "tDiffuse1");
            l.uniforms.tDiffuse2.value = e.renderTarget2;
            var c = new THREE.RenderPass(this.scene, this.camera),
                h = new THREE.ShaderPass(THREE.FXAAShader);
            (h.uniforms.resolution.value = new THREE.Vector2(DENSITY / WIDTH, DENSITY / HEIGHT)), (h.renderToScreen = !0);
            var p = (this.finalComposer = new THREE.EffectComposer(t, u()));
            p.addPass(c), p.addPass(l), p.addPass(h);
        },
        initBlackParticles: function () {
            var e = n.get("blackcircle"),
                t = new THREE.Geometry(),
                r = 100;
            for (var i = 0; i < r; i++) {
                var s = new THREE.Vector3();
                (s.x = Math.random() * 150 - 75), (s.y = Math.random() * 40), (s.z = Math.random() * -1e3), (s.speed = Math.random() * 500 + 100), t.vertices.push(s);
            }
            var o = new THREE.ParticleBasicMaterial({ size: 2, map: e, transparent: !0, sizeAttenuation: !0, depthWrite: !1 }),
                u = (this.blackParticles = new THREE.ParticleSystem(t, o));
            this.cameraContainer.add(u), this.glowCamera.add(u.clone());
        },
        animateBlackParticles: function (e) {
            _.each(this.blackParticles.geometry.vertices, function (t, n) {
                (t.z += t.speed * e), t.z > 1e3 && (t.z = -1e3);
            }),
                (this.blackParticles.geometry.verticesNeedUpdate = !0);
        },
        resize: function (e, t) {
            var n = (e * 4 - this.sky.width) / this.sky.width,
                r = (t * 4 - this.sky.height) / this.sky.height,
                i = (t * 4) / 2 / Math.tan(THREE.Math.degToRad(this.camera.fov / 2));
            this.sky.position.set(0, 0, -i), this.sky.scale.setX(1 + n), this.sky.scale.setY(1 + r), (this.sky.material.uniforms.aspect.value = e / t);
        },
        updateBubbles: function (e) {
            _.each(
                this.bubbles.children,
                function (t) {
                    (t.position.z += e * this.CAMERA_SPEED), t.position.z > 1e3 && (t.position.z = 0);
                },
                this
            );
        },
        updateCamera: function () {
            var e = this.BOUNDARIES.x * mouseX,
                t = this.BOUNDARIES.y * -mouseY + 80,
                n = new THREE.Vector3(this.camera.position.x + e, this.scene.position.y + t, this.scene.position.z);
            this.camera.lookAt(this.camera.target.lerp(n, 0.1)), this.glowCamera.rotation.copy(this.camera.rotation);
        },
        update: function (e, t) {
            (this.cameraContainer.position.z -= t * this.CAMERA_SPEED),
            this.cameraContainer.position.z < -1e3 && (this.cameraContainer.position.z = 0),
                (this.glowCamera.position.z -= t * this.CAMERA_SPEED),
            this.glowCamera.position.z < -500 && (this.glowCamera.position.z = 500),
                this.updateBubbles(t),
                this.updateCamera(),
                this.animateBlackParticles(t),
                _.each(
                    this.bubbles.children,
                    _.bind(function (e) {
                        var n = e.shader.update(t, this.cameraContainer.position.z - e.position.z);
                    }, this)
                ),
                this.skyShader.update(e, t),
                this.landscape.terrainShader.update(t);
        },
    });
    return o;
}),
define("canyon/app", ["../class", "./canyon", "./objects", "./textures", "orbitcontrols", "effectcomposer", "compositingshaders"], function (e, t, n, r) {
    var i = e.extend({
        initialize: function (e) {
            (this.name = "canyon"),
                (this.description = '#02  Based on <a target="_blank" href="http://vimeo.com/58460459">Potus 3012</a> by Beeple'),
                (this.renderer = e.renderer),
                (this.container = e.container),
                (this.compositing = e.enableCompositing),
                (this.clock = new THREE.Clock(!1));
            var t = this.renderer.context,
                n = parseInt(t.getParameter(t.ALIASED_LINE_WIDTH_RANGE)[1]);
            this.thickLines = n > 1;
        },
        initWorld: function () {
            r.loadAll().done(
                _.bind(function () {
                    (this.world = new t({ thickLines: this.thickLines })), this.world.initHelpers(), this.world.toggleHelpers(), this.initCompositing(), this.datGUI && this.world.setupDatGUI(this.datGUI), this.trigger("ready");
                }, this)
            );
        },
        initCompositing: function () {
            var e = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: !1 },
                t = new THREE.WebGLRenderTarget(WIDTH, HEIGHT, e);
            (this.composer = new THREE.EffectComposer(this.renderer, t)), this.world.setupCompositing(this.composer, this.renderer);
        },
        render: function (e) {
            this.compositing && this.composer ? (this.composer.render(e), this.world.finalComposer.render(e)) : (this.renderer.clear(), this.renderer.render(this.world.scene, this.world.camera));
        },
        update: function () {
            var e = this.clock.getDelta(),
                t = this.clock.getElapsedTime();
            this.paused || (requestAnimationFrame(this.update.bind(this)), this.stats && this.stats.begin(), this.world.update(t, e), this.render(e), this.stats && this.stats.end());
        },
        pause: function () {
            this.clock.stop(), (this.paused = !0);
        },
        resume: function () {
            this.clock.start(), (this.paused = !1);
        },
        toggleGUIMode: function () {
            this.stats && this.datGUI && ($(this.stats.domElement).toggle(), $(this.datGUI.domElement).toggle());
        },
        resize: function (e, t) {
            var n = this.world.finalComposer.passes[2];
            n.uniforms.resolution.value.set(DENSITY / e, DENSITY / t);
            if (this.thickLines)
                var r = this.composer.passes[1],
                    i = this.composer.passes[2];
            else {
                var s = this.composer.passes[1],
                    r = this.composer.passes[3],
                    i = this.composer.passes[4];
                s.uniforms.h.value = 1 / e;
            }
            (r.uniforms.h.value = 3 / e), (i.uniforms.v.value = 3 / t), this.world.resize(e, t), this.world.setAspectRatio(e / t), (this.world.glowCamera.aspect = e / t), this.world.glowCamera.updateProjectionMatrix();
        },
    });
    return i;
}),
define("mountains/textures", ["../textureloader"], function (e) {
    var t = "textures/mountains/",
        n = { stripes: "stripe2.png", flake: "flake.png", terrain: "displacement64.png" },
        r = new e({ files: n, path: t });
    return { files: n, loader: r, loadAll: r.loadAllFiles.bind(r), get: r.getById.bind(r) };
}),
define("mountains/materials", ["./textures"], function (e) {
    var t = {};
    return (t.flake = new THREE.MeshBasicMaterial({ map: e.get("flake"), transparent: !0, lights: !1, side: THREE.DoubleSide })), t;
}),
define("mountains/shaders/shader", ["../../class"], function (e) {
    var t = e.extend({
        initialize: function () {
            this.material = new THREE.ShaderMaterial({ attributes: this.attributes || {}, uniforms: this.uniforms || {}, vertexShader: this.vertexShader, fragmentShader: this.fragmentShader });
        },
    });
    return t;
}),
define("text!mountains/shaders/vertex/basic.vs", [], function () {
    return "varying vec2 vUv;\n\nvoid main() {\n\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}";
}),
define("text!mountains/shaders/fragment/depth.fs", [], function () {
    return "uniform sampler2D map;\nuniform float mNear;\nuniform float mFar;\nuniform float opacity;\n\nvarying vec2 vUv;\n\nvoid main() {\n  float alpha = texture2D(map, vUv.xy).a;\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n  float color = 1.0 - smoothstep(mNear, mFar, depth);\n  gl_FragColor = vec4(vec3(color), opacity * alpha);\n}";
}),
define("mountains/shaders/depth", ["./shader", "text!./vertex/basic.vs", "text!./fragment/depth.fs"], function (e, t, n) {
    var r = e.extend({
        vertexShader: t,
        fragmentShader: n,
        uniforms: { map: { type: "t", value: null }, opacity: { type: "f", value: 1 }, mNear: { type: "f", value: 1 }, mFar: { type: "f", value: 2e3 } },
        initialize: function (t) {
            e.prototype.initialize.call(this), THREE.Material.call(this.material), (this.material.transparent = !0), t && t.map && (this.material.uniforms.map.value = t.map);
        },
        update: function (e) {
            (this.material.uniforms.mNear.value = e.near), (this.material.uniforms.mFar.value = e.far);
        },
    });
    return r;
}),
define("mountains/flake", ["../class", "./materials", "./shaders/depth"], function (e, t, n) {
    function i(e, t, n) {
        return Math.min(Math.max(e, t), n);
    }
    var r = e.extend({
        initialize: function (e) {
            (this.mesh = new THREE.Mesh(e.geometry, t.flake)),
                (this.angle = (Math.PI * 200) / 180),
                (this.velocity = 75),
                (this.startTime = e.delay / 1e3),
                (this.mesh.position = e.position),
                (this.startingPosition = e.position.clone()),
                (this.mesh.visible = !1);
        },
        update: function (e, t) {
            e > this.startTime &&
            ((this.mesh.visible = !0),
                (this.mesh.position.y -= this.velocity * t),
                (this.mesh.position.x -= this.velocity * 1.25 * t),
                (this.mesh.rotation.x += this.angle * t),
                (this.mesh.rotation.y += this.angle * t),
                (this.mesh.rotation.z += this.angle * t)),
            this.mesh.position.y < -100 && this.reset();
        },
        reset: function () {
            this.mesh.position = this.startingPosition.clone();
        },
    });
    return r;
}),
define("mountains/objects", ["./flake"], function (e) {
    var t = {};
    return (
        (t.createCamera = function (e) {
            var e = _.extend({ fov: 45, aspectRatio: WIDTH / HEIGHT, near: 1, far: 1e4 }, e),
                t = new THREE.PerspectiveCamera(e.fov, e.aspectRatio, e.near, e.far);
            return t;
        }),
            (t.createSnow = function (t, n) {
                var r = new THREE.Object3D(),
                    i = [],
                    s = 500,
                    o = new THREE.PlaneGeometry(5, 5, 1, 1);
                return (
                    _.times(s, function (s) {
                        var u = Math.random() * 1e4,
                            a = new e({ geometry: o, position: new THREE.Vector3(Math.random() * t - t / 2, 300, -Math.random() * n), delay: u });
                        r.add(a.mesh), i.push(a);
                    }),
                        (r.update = function (e, t) {
                            _.each(i, function (n) {
                                n.update(e, t);
                            });
                        }),
                        r
                );
            }),
            t
    );
}),
define("text!mountains/shaders/vertex/bokeh2.vs", [], function () {
    return "/**\n * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\nvarying vec2 vUv;\n\nvoid main() {\n\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}";
}),
define("text!mountains/shaders/fragment/bokeh2.fs", [], function () {
    return "/**\n * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\nvarying vec2 vUv;\n\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float textureWidth;\nuniform float textureHeight;\n\nconst float PI = 3.14159265;\n\nfloat width = textureWidth; //texture width\nfloat height = textureHeight; //texture height\n\nvec2 texel = vec2(1.0/width,1.0/height);\n\nuniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\nuniform float focalLength; //focal length in mm\nuniform float fstop; //f-stop value\nuniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\n\n/*\nmake sure that these two values are the same for your camera, otherwise distances will be wrong.\n*/\n\nuniform float znear; // camera clipping start\nuniform float zfar; // camera clipping end\n\n//------------------------------------------\n//user variables\n\nconst int samples = SAMPLES; //samples on the first ring\nconst int rings = RINGS; //ring count\n\nconst int maxringsamples = rings * samples;\n\nuniform bool manualdof; // manual dof calculation\nfloat ndofstart = 1.0; // near dof blur start\nfloat ndofdist = 2.0; // near dof blur falloff distance\nfloat fdofstart = 1.0; // far dof blur start\nfloat fdofdist = 3.0; // far dof blur falloff distance\n\nfloat CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\n\nuniform bool vignetting; // use optical lens vignetting\n\nfloat vignout = 1.3; // vignetting outer border\nfloat vignin = 0.0; // vignetting inner border\nfloat vignfade = 22.0; // f-stops till vignete fades\n\nuniform bool shaderFocus;\n\nbool autofocus = shaderFocus;\n//use autofocus in shader - use with focusCoords\n// disable if you use external focalDepth value\n\nuniform vec2 focusCoords;\n// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\n// if center of screen use vec2(0.5, 0.5);\n\nuniform float maxblur;\n//clamp value of max blur (0.0 = no blur, 1.0 default)\n\nuniform float threshold; // highlight threshold;\nuniform float gain; // highlight gain;\n\nuniform float bias; // bokeh edge bias\nuniform float fringe; // bokeh chromatic aberration / fringing\n\nuniform bool noise; //use noise instead of pattern for sample dithering\n\nuniform float dithering;\nfloat namount = dithering; //dither amount\n\nuniform bool depthblur; // blur the depth buffer\nfloat dbsize = 1.25; // depth blur size\n\n/*\nnext part is experimental\nnot looking good with small sample and ring count\nlooks okay starting from samples = 4, rings = 4\n*/\n\nuniform bool pentagon; //use pentagon as bokeh shape?\nfloat feather = 0.4; //pentagon shape feather\n\n//------------------------------------------\n\nfloat penta(vec2 coords) {\n  //pentagonal shape\n  float scale = float(rings) - 1.3;\n  vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\n  vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\n  vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\n  vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\n  vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\n  vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\n\n  vec4  one = vec4( 1.0 );\n\n  vec4 P = vec4((coords),vec2(scale, scale));\n\n  vec4 dist = vec4(0.0);\n  float inorout = -4.0;\n\n  dist.x = dot( P, HS0 );\n  dist.y = dot( P, HS1 );\n  dist.z = dot( P, HS2 );\n  dist.w = dot( P, HS3 );\n\n  dist = smoothstep( -feather, feather, dist );\n\n  inorout += dot( dist, one );\n\n  dist.x = dot( P, HS4 );\n  dist.y = HS5.w - abs( P.z );\n\n  dist = smoothstep( -feather, feather, dist );\n  inorout += dist.x;\n\n  return clamp( inorout, 0.0, 1.0 );\n}\n\nfloat bdepth(vec2 coords) {\n  // Depth buffer blur\n  float d = 0.0;\n  float kernel[9];\n  vec2 offset[9];\n\n  vec2 wh = vec2(texel.x, texel.y) * dbsize;\n\n  offset[0] = vec2(-wh.x,-wh.y);\n  offset[1] = vec2( 0.0, -wh.y);\n  offset[2] = vec2( wh.x -wh.y);\n\n  offset[3] = vec2(-wh.x,  0.0);\n  offset[4] = vec2( 0.0,   0.0);\n  offset[5] = vec2( wh.x,  0.0);\n\n  offset[6] = vec2(-wh.x, wh.y);\n  offset[7] = vec2( 0.0,  wh.y);\n  offset[8] = vec2( wh.x, wh.y);\n\n  kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\n  kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\n  kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\n\n\n  for( int i=0; i<9; i++ ) {\n    float tmp = texture2D(tDepth, coords + offset[i]).r;\n    d += tmp * kernel[i];\n  }\n\n  return d;\n}\n\n\nvec3 color(vec2 coords,float blur) {\n  //processing the sample\n\n  vec3 col = vec3(0.0);\n\n  col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\n  col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\n  col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\n\n  vec3 lumcoeff = vec3(0.299,0.587,0.114);\n  float lum = dot(col.rgb, lumcoeff);\n  float thresh = max((lum-threshold)*gain, 0.0);\n  return col+mix(vec3(0.0),col,thresh*blur);\n}\n\nvec2 rand(vec2 coord) {\n  // generating noise / pattern texture for dithering\n\n  float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;\n\n  if (noise) {\n    noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\n    noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\n  }\n\n  return vec2(noiseX,noiseY);\n}\n\nvec3 debugFocus(vec3 col, float blur, float depth) {\n  float edge = 0.002*depth; //distance based edge smoothing\n  float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\n  float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\n\n  col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\n  col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\n\n  return col;\n}\n\nfloat linearize(float depth) {\n  return -zfar * znear / (depth * (zfar - znear) - zfar);\n}\n\n\nfloat vignette() {\n  float dist = distance(vUv.xy, vec2(0.5,0.5));\n  dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\n  return clamp(dist,0.0,1.0);\n}\n\nfloat gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\n  float rings2 = float(rings);\n  float step = PI*2.0 / float(ringsamples);\n  float pw = cos(j*step)*i;\n  float ph = sin(j*step)*i;\n  float p = 1.0;\n  if (pentagon) {\n    p = penta(vec2(pw,ph));\n  }\n  col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\n  return 1.0 * mix(1.0, i /rings2, bias) * p;\n}\n\nvoid main() {\n  //scene depth calculation\n\n  float depth = linearize(texture2D(tDepth,vUv.xy).x);\n\n  // Blur depth?\n  if (depthblur) {\n    depth = linearize(bdepth(vUv.xy));\n  }\n\n  //focal plane calculation\n\n  float fDepth = focalDepth;\n\n  if (autofocus) {\n\n    fDepth = linearize(texture2D(tDepth,focusCoords).x);\n\n  }\n\n  // dof blur factor calculation\n\n  float blur = 0.0;\n\n  if (manualdof) {\n    float a = depth-fDepth; // Focal plane\n    float b = (a-fdofstart)/fdofdist; // Far DoF\n    float c = (-a-ndofstart)/ndofdist; // Near Dof\n    blur = (a>0.0) ? b : c;\n  } else {\n    float f = focalLength; // focal length in mm\n    float d = fDepth*1000.0; // focal plane in mm\n    float o = depth*1000.0; // depth in mm\n\n    float a = (o*f)/(o-f);\n    float b = (d*f)/(d-f);\n    float c = (d-f)/(d*fstop*CoC);\n\n    blur = abs(a-b)*c;\n  }\n\n  blur = clamp(blur,0.0,1.0);\n\n  // calculation of pattern for dithering\n\n  vec2 noise = rand(vUv.xy)*namount*blur;\n\n  // getting blur x and y step factor\n\n  float w = (1.0/width)*blur*maxblur+noise.x;\n  float h = (1.0/height)*blur*maxblur+noise.y;\n\n  // calculation of final color\n\n  vec3 col = vec3(0.0);\n\n  if(blur < 0.05) {\n    //some optimization thingy\n    col = texture2D(tColor, vUv.xy).rgb;\n  } else {\n    col = texture2D(tColor, vUv.xy).rgb;\n    float s = 1.0;\n    int ringsamples;\n\n    for (int i = 1; i <= rings; i++) {\n      /*unboxstart*/\n      ringsamples = i * samples;\n\n      for (int j = 0 ; j < maxringsamples ; j++) {\n        if (j >= ringsamples) break;\n        s += gather(float(i), float(j), ringsamples, col, w, h, blur);\n      }\n      /*unboxend*/\n    }\n\n    col /= s; //divide by sample count\n  }\n\n  if (showFocus) {\n    col = debugFocus(col, blur, depth);\n  }\n\n  if (vignetting) {\n    col *= vignette();\n  }\n\n  gl_FragColor.rgb = col;\n  gl_FragColor.a = 1.0;\n  // gl_FragColor.a = texture2D(tColor, vUv.xy).a;\n}";
}),
define("mountains/shaders/bokeh2", ["./shader", "text!./vertex/bokeh2.vs", "text!./fragment/bokeh2.fs"], function (e, t, n) {
    var r = e.extend({
        vertexShader: t,
        fragmentShader: n,
        uniforms: {
            textureWidth: { type: "f", value: 1 },
            textureHeight: { type: "f", value: 1 },
            focalDepth: { type: "f", value: 1 },
            focalLength: { type: "f", value: 24 },
            fstop: { type: "f", value: 2.25 },
            tColor: { type: "t", value: null },
            tDepth: { type: "t", value: null },
            maxblur: { type: "f", value: 2 },
            showFocus: { type: "i", value: 0 },
            manualdof: { type: "i", value: 0 },
            vignetting: { type: "i", value: 1 },
            depthblur: { type: "i", value: 0 },
            threshold: { type: "f", value: 0.5 },
            gain: { type: "f", value: 0.2 },
            bias: { type: "f", value: 0.15 },
            fringe: { type: "f", value: 0.7 },
            znear: { type: "f", value: 0.1 },
            zfar: { type: "f", value: 100 },
            noise: { type: "i", value: 1 },
            dithering: { type: "f", value: 1e-4 },
            pentagon: { type: "i", value: 0 },
            shaderFocus: { type: "i", value: 1 },
            focusCoords: { type: "v2", value: new THREE.Vector2() },
        },
        initialize: function (t) {
            e.prototype.initialize.call(this),
                (this.material.uniforms.tColor.value = t.tColor),
                (this.material.uniforms.tDepth.value = t.tDepth),
                (this.material.uniforms.textureWidth.value = WIDTH),
                (this.material.uniforms.textureHeight.value = HEIGHT),
                (this.material.defines = { RINGS: 3, SAMPLES: 4 });
        },
    });
    return r;
}),
define("text!mountains/shaders/fragment/gradient.fs", [], function () {
    return "// Gradient Shader for 1 midpoint\n\n// #ifdef GL_ES\n// precision highp float;\n// #endif\n\n// varying vec2 vUv;\n\n// uniform vec3 color1;\n// uniform vec3 color2;\n// uniform float midpoint;\n\n// void main() {\n//   vec3 midcolor = mix(color1, color2, 0.5);\n//   vec3 color = vec3(0.0);\n\n//   if (vUv.y < midpoint) {\n//     color = mix(color1, midcolor, vUv.y / midpoint);\n//   } else {\n//     color = mix(midcolor, color2, (vUv.y - midpoint) / (1.0 - midpoint));\n//   }\n\n//   gl_FragColor = vec4(color, 1.0);\n// }\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec2 vUv;\n\nuniform vec3 color1;\nuniform vec3 color2;\nuniform float midpoint;\n\nvoid main() {\n  vec3 color = vec3(0.0);\n  float s1 = midpoint - 0.1;\n  float s2 = midpoint + 0.15;\n\n  if (vUv.y < s1) {\n    color = color1;\n  } else if (vUv.y > s2) {\n    color = color2;\n  } else {\n    color = mix(color1, color2, (vUv.y - s1) / (s2 - s1));\n  }\n\n  gl_FragColor = vec4(color, 1.0);\n}";
}),
define("mountains/shaders/gradient", ["./shader", "text!./vertex/basic.vs", "text!./fragment/gradient.fs"], function (e, t, n) {
    var r = e.extend({
        vertexShader: t,
        fragmentShader: n,
        uniforms: { color1: { type: "c", value: new THREE.Color(0) }, color2: { type: "c", value: new THREE.Color(16777215) }, midpoint: { type: "f", value: 0.7 } },
        initialize: function (t) {
            e.prototype.initialize.call(this),
            t && t.color1 && (this.material.uniforms.color1.value = t.color1),
            t && t.color2 && (this.material.uniforms.color2.value = t.color2),
            t && t.midpoint && (this.material.uniforms.midpoint.value = t.midpoint);
        },
        update: function () {
            var e = this.material.uniforms.midpoint.value,
                t = 0.7 + mouseY * 0.25;
            this.material.uniforms.midpoint.value = THREE.Math.lerp(e, t, 0.1);
        },
    });
    return r;
}),
define("mountains/mountains", ["../world", "./materials", "./textures", "./objects", "./shaders/bokeh2", "./shaders/gradient", "./shaders/depth"], function (e, t, n, r, i, s, o) {
    function a(e, t, n) {
        var r = (n * e.width + t) * 4;
        return e.data[r];
    }
    var u = e.extend({
        initialize: function () {
            e.prototype.initialize.call(this),
                (this.BOUNDARIES = { x: WIDTH / 10, y: HEIGHT / 10 }),
                this.scene.add(this.camera),
                this.cameraContainer.position.set(-500, 0, 0),
                this.camera.position.set(0, 50, 500),
                (this.camera.target = new THREE.Vector3(-500, 50, -500)),
                this.camera.lookAt(this.camera.target),
                (this.camera.speed = 60),
                (this.camera.far = 1500),
                (this.camera.near = 1);
            var t = new THREE.DirectionalLight(16777215, 1.25);
            t.position.set(-500, 250, 250),
                t.target.position.set(0, 0, 0),
                (t.shadowCameraVisible = !1),
                (t.shadowCameraNear = 100),
                (t.shadowCameraFar = 2e3),
                (t.shadowCameraLeft = -400),
                (t.shadowCameraRight = 400),
                (t.shadowCameraTop = 400),
                (t.shadowCameraBottom = -400),
                (t.shadowMapWidth = 1024),
                (t.shadowMapHeight = 1024),
                (t.shadowDarkness = 0.3),
                (t.castShadow = !1),
                this.scene.add(t),
                this.lights.push(t);
            var i = n.get("stripes");
            (i.wrapS = i.wrapT = THREE.RepeatWrapping), i.repeat.set(80, 80);
            var s = new THREE.MeshLambertMaterial({ color: 11985889, shading: THREE.FlatShading, emissive: 4473924, map: i }),
                o = (this.terrain = new THREE.Mesh(new THREE.PlaneGeometry(1e3, 1e3, 63, 63), s));
            (o.rotation.x = -Math.PI / 2), (o.receiveShadow = !0), (o.castShadow = !0), this.scene.add(o);
            var u = n.get("terrain").image,
                f = document.createElement("canvas");
            (f.width = 64), (f.height = 64);
            var l = f.getContext("2d");
            l.drawImage(u, 0, 0, f.width, f.height);
            var c = l.getImageData(0, 0, f.width, f.height),
                h = [];
            for (var p = 0; p < c.height; p++) for (var d = 0; d < c.width; d++) h.push(a(c, d, p));
            var v = 250;
            _.each(o.geometry.vertices, function (e, t) {
                e.z = (h[t] / 255) * v;
            }),
                (o.geometry.dynamic = !0),
                (o.geometry.verticesNeedUpdate = !0),
                o.geometry.computeFaceNormals(),
                (o.geometry.normalsNeedUpdate = !0);
            var m = (this.terrainLeft = o.clone());
            m.position.set(-1e3, 0, 0), this.scene.add(m);
            var g = (this.terrainRight = o.clone());
            g.position.set(1e3, 0, 0), this.scene.add(g);
            var y = (this.snow = r.createSnow(WIDTH, 1500));
            this.cameraContainer.add(y), y.position.set(0, 50, 500);
            var b = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
            (this.rtDepth = new THREE.WebGLRenderTarget(WIDTH, HEIGHT, b)), this.initSky();
        },
        initSky: function () {
            var e = new THREE.Color(4774911),
                t = new THREE.Color(15659408);
            (this.skyScene = new THREE.Scene()), (this.skyCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1)), (this.skyShader = new s({ color1: t, color2: e, midpoint: 0.7 }));
            var n = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this.skyShader.material);
            (n.name = "sky"), this.skyScene.add(n);
        },
        render: function (e, t) {
            (this.scene.overrideMaterial = this.depthMaterial), e.render(this.scene, this.camera, this.rtDepth, !0), (this.scene.overrideMaterial = null), t.render();
        },
        setupCompositing: function (e) {
            var t = new THREE.RenderPass(this.skyScene, this.skyCamera),
                n = new THREE.RenderPass(this.scene, this.camera),
                r = new THREE.ShaderPass(THREE.HorizontalDofShader),
                i = new THREE.ShaderPass(THREE.VerticalDofShader),
                s = 2;
            (this.depthMaterial = new THREE.MeshDepthMaterial()),
                (r.uniforms.tDepth.value = this.rtDepth),
                (i.uniforms.tDepth.value = this.rtDepth),
                (r.uniforms.h.value = s / WIDTH),
                (i.uniforms.v.value = s / HEIGHT),
                e.addPass(t),
                e.addPass({
                    enabled: !0,
                    render: function (e) {
                        e.clear(!1, !0, !1);
                    },
                }),
                e.addPass(n),
                (n.clear = !1),
                e.addPass(r),
                e.addPass(i),
                (i.renderToScreen = !0);
        },
        setupDatGUI: function (e) {},
        resize: function (e, t, n) {
            (this.camera.aspect = e / t), (n.passes[3].uniforms.h.value = 2 / WIDTH), (n.passes[4].uniforms.v.value = 2 / HEIGHT);
        },
        updateCamera: function (e) {
            this.cameraContainer.position.x += e * this.camera.speed;
            if (this.cameraContainer.position.x > 500) {
                var t = 500 - this.camera.target.x;
                (this.cameraContainer.position.x = -500), (this.camera.target.x = -500 - t);
            }
            this.camera.position.x = this.cameraContainer.position.x;
            var n = this.BOUNDARIES.x * mouseX,
                r = this.BOUNDARIES.y * -mouseY + 50,
                i = new THREE.Vector3(this.camera.position.x + n, this.scene.position.y + r, this.scene.position.z);
            (this.camera.target.x += this.camera.speed * e), this.camera.lookAt(this.camera.target.lerp(i, 0.1));
        },
        update: function (e, t) {
            this.updateCamera(t), (this.lights[0].position.x = this.camera.position.x - 500), (this.lights[0].target.position.x = this.lights[0].position.x + 500), this.snow.update(e, t), this.skyShader.update();
        },
    });
    return u;
}),
define("mountains/app", ["class", "./textures", "./mountains", "./objects", "orbitcontrols"], function (e, t, n, r) {
    var i = e.extend({
        initialize: function (e) {
            (this.name = "mountains"),
                (this.description = '#03  Based on <a target="_blank" href="http://vimeo.com/9961551">Moytains</a> by Beeple'),
                (this.renderer = e.renderer),
                (this.container = e.container),
                (this.compositing = e.enableCompositing),
                (this.clock = new THREE.Clock(!1));
        },
        initWorld: function () {
            t.loadAll().done(
                _.bind(function () {
                    (this.world = new n()), this.world.initHelpers(), this.world.toggleHelpers(), this.datGUI && this.world.setupDatGUI(this.datGUI), this.initCompositing(), this.trigger("ready");
                }, this)
            );
        },
        initCompositing: function () {
            (this.composer = new THREE.EffectComposer(this.renderer)), this.world.setupCompositing(this.composer);
        },
        render: function (e) {
            this.compositing && this.composer ? this.world.render(this.renderer, this.composer, e) : this.renderer.render(this.world.scene, this.world.camera);
        },
        update: function () {
            var e = this.clock.getDelta(),
                t = this.clock.getElapsedTime();
            this.paused || (requestAnimationFrame(this.update.bind(this)), this.stats && this.stats.begin(), this.world.update(t, e), this.render(e), this.stats && this.stats.end());
        },
        pause: function () {
            this.clock.stop(), (this.paused = !0);
        },
        resume: function () {
            this.clock.start(), (this.paused = !1);
        },
        toggleGUIMode: function () {
            this.stats && this.datGUI && ($(this.stats.domElement).toggle(), $(this.datGUI.domElement).toggle());
        },
        resize: function (e, t) {
            this.world.setAspectRatio(e / t), this.world.resize(e, t, this.composer);
        },
    });
    return i;
}),
define("road/materials", ["three"], function (e) {
    var t = {};
    return (
        (t.whiteLambert = new e.MeshLambertMaterial({ color: 16777215, shading: e.FlatShading })),
            (t.blackMaterial = new e.MeshBasicMaterial({ color: 0 })),
            (t.greenWireframe = new e.MeshBasicMaterial({ color: 65280, wireframe: !0 })),
            (t.greenLineMaterial = new e.LineBasicMaterial({ color: 65280 })),
            (t.tealLine = new e.MeshBasicMaterial({ color: 8257535, wireframe: !0 })),
            t
    );
}),
define("road/objects", ["three", "./materials"], function (e, t) {
    var n = {};
    return (
        (n.createCamera = function (t) {
            var t = _.extend({ fov: 45, aspectRatio: window.innerWidth / window.innerHeight, near: 1, far: 1e4 }, t),
                n = new e.PerspectiveCamera(t.fov, t.aspectRatio, t.near, t.far);
            return n;
        }),
            (n.createGrid = function (t) {
                var t = _.extend({ size: 100, step: 10, color: 0, opacity: 0.2 }, t),
                    n = new e.Geometry(),
                    r = t.size;
                for (var i = -r; i <= r; i += t.step) n.vertices.push(new e.Vector3(-r, 0, i)), n.vertices.push(new e.Vector3(r, 0, i)), n.vertices.push(new e.Vector3(i, 0, -r)), n.vertices.push(new e.Vector3(i, 0, r));
                var s = new e.LineBasicMaterial({ color: t.color, opacity: t.opacity }),
                    o = new e.Line(n, s);
                return (o.type = e.LinePieces), o;
            }),
            (n.createCube = function (t) {
                var t = _.extend({ size: 10, material: new e.MeshBasicMaterial({ color: 0 }) }, t),
                    n = t.size,
                    r = new e.Mesh(new e.CubeGeometry(n, n, n), t.material);
                return r;
            }),
            (n.loadModel = function (t) {
                var n = new jQuery.Deferred(),
                    r = new e.JSONLoader();
                return (
                    r.load(t, function (t, r) {
                        n.resolve(new e.Mesh(t, r[0]));
                    }),
                        n.promise()
                );
            }),
            n
    );
}),
define("road/models", ["../modelloader"], function (e) {
    var t = "models/",
        n = { pillar: "pillar.js", pillarTop: "pillar-top.js" },
        r = new e({ files: n, path: t });
    return { loadAll: r.loadAllFiles.bind(r), get: r.getById.bind(r) };
}),
define("road/curves", ["three"], function (e) {
    var t = {};
    return (
        (t.segments = [
            new e.CubicBezierCurve3(new e.Vector3(-0.000003, 1e-6, 203.05304), new e.Vector3(23.146696, 1e-6, 196.850906), new e.Vector3(74.906815, 0.103815, 184.577896), new e.Vector3(67.778229, 7.215911, 152.21936)),
            new e.CubicBezierCurve3(new e.Vector3(67.778229, 7.215911, 152.21936), new e.Vector3(60.649647, 14.328003, 119.86084), new e.Vector3(27.17379, -0.061909, 108.809753), new e.Vector3(-0.000001, 1e-6, 101.385696)),
            new e.CubicBezierCurve3(new e.Vector3(-0.000001, 1e-6, 101.385696), new e.Vector3(-27.173798, 0.061911, 93.961639), new e.Vector3(-67.778229, 18.644653, 84.441147), new e.Vector3(-67.778229, 18.644653, 50.552025)),
            new e.CubicBezierCurve3(new e.Vector3(-67.778229, 18.644653, 50.552025), new e.Vector3(-67.778229, 18.644653, 16.66291), new e.Vector3(-33.094025, 1e-6, 7.016156), new e.Vector3(-0.000003, 1e-6, -0.281647)),
            new e.CubicBezierCurve3(new e.Vector3(-0.000003, 1e-6, -0.281647), new e.Vector3(33.094017, 1e-6, -7.57945), new e.Vector3(67.778229, 15.084962, -16.392532), new e.Vector3(67.778229, 15.084962, -50.281647)),
            new e.CubicBezierCurve3(new e.Vector3(67.778229, 15.084962, -50.281647), new e.Vector3(67.778229, 15.084962, -84.170761), new e.Vector3(30.739862, 9.676497, -89.797722), new e.Vector3(12e-6, -0.000001, -100.281647)),
            new e.CubicBezierCurve3(new e.Vector3(12e-6, -0.000001, -100.281647), new e.Vector3(-30.739819, -9.676495, -110.765564), new e.Vector3(-60.382263, -28.574028, -122.624451), new e.Vector3(-67.778244, -15, -152.782654)),
            new e.CubicBezierCurve3(new e.Vector3(-67.778244, -15, -152.782654), new e.Vector3(-75.174225, -1.425972, -182.940857), new e.Vector3(-32.734283, -0.000001, -194.811523), new e.Vector3(16e-6, -0.000001, -203.582657)),
        ]),
            (t.path = new e.CurvePath()),
            (t.path.curves = t.segments),
            t
    );
}),
define("road/pillars", ["three"], function (e) {
    var t = {};
    return (
        (t.locations = [
            new e.Vector3(-69.924065, -2.220383, -200.555115),
            new e.Vector3(-90.849434, 16.835037, -131.393204),
            new e.Vector3(14.147863, 15.186833, -60.1078),
            new e.Vector3(46.454262, 11.690985, -120.717995),
            new e.Vector3(100.640388, 9.458103, 163.619141),
            new e.Vector3(-14.764275, -14.765525, -188.681961),
            new e.Vector3(-4.78531, -6.048833, -182.56424),
            new e.Vector3(-39.635326, -13.543379, -177.913742),
            new e.Vector3(-14.492905, -24.306738, -177.613693),
            new e.Vector3(-29.004236, -20.966387, -180.964218),
            new e.Vector3(-42.54113, -9.643389, -208.578796),
            new e.Vector3(-30.577366, -12.983742, -208.974686),
            new e.Vector3(-53.172218, -2.220383, -205.52832),
            new e.Vector3(-20.86977, 5.274163, -213.925232),
            new e.Vector3(-30.848736, -3.442529, -220.042953),
            new e.Vector3(19.932108, -5.6465, 215.314575),
            new e.Vector3(9.644325, 14.123769, 182.262802),
            new e.Vector3(30.348974, -17.198723, 210.079941),
            new e.Vector3(8.800739, -15.286646, 214.399643),
            new e.Vector3(-68.514641, -0.666766, 78.812645),
            new e.Vector3(-74.760231, 8.362053, 67.111153),
            new e.Vector3(-21.285807, -10.140958, 107.372864),
            new e.Vector3(-43.108974, -2.475075, 97.445847),
            new e.Vector3(1.011446, -14.665241, 118.004959),
            new e.Vector3(12.228237, -10.439904, 94.730156),
            new e.Vector3(-31.558161, -8.87346, 69.97319),
            new e.Vector3(-22.621239, -8.317799, 81.029831),
            new e.Vector3(-4.43346, -20.079678, 85.518066),
            new e.Vector3(30.110031, 3.369871, 99.187508),
            new e.Vector3(-46.444466, -1.180009, 73.228638),
            new e.Vector3(57.673347, -1.892759, 161.526306),
            new e.Vector3(43.732567, -13.952258, 152.71788),
            new e.Vector3(23.005001, -3.922407, 129.872574),
            new e.Vector3(29.854961, -5.261323, 138.347427),
            new e.Vector3(34.651794, 13.950373, 124.698845),
            new e.Vector3(49.244083, -7.233284, 172.512604),
            new e.Vector3(51.37925, 4.134676, 139.298172),
            new e.Vector3(34.53474, 1.603703, 177.705307),
            new e.Vector3(2.129829, -8.090742, -87.262703),
            new e.Vector3(23.832186, 3.344772, -118.265617),
            new e.Vector3(13.075104, 0.811732, -112.14769),
            new e.Vector3(28.855417, -3.747733, -106.261803),
            new e.Vector3(78.065399, -3.217184, 168.643875),
            new e.Vector3(46.67207, 22.483398, 101.614769),
            new e.Vector3(89.865219, 7.647039, 130.657745),
            new e.Vector3(86.624512, -3.720921, 156.536774),
            new e.Vector3(72.314575, -1.748961, 133.761826),
            new e.Vector3(46.67207, 22.483398, 101.614769),
            new e.Vector3(69.333275, -0.410044, 120.544739),
            new e.Vector3(56.383614, 9.818995, 111.817711),
            new e.Vector3(76.698494, -10.439896, 147.404022),
            new e.Vector3(99.528801, 1.619604, 147.020477),
            new e.Vector3(72.841583, 1.619604, 181.04097),
            new e.Vector3(59.8116, -17.926373, 195.84964),
            new e.Vector3(45.752048, 1.783675, 204.977295),
            new e.Vector3(58.888523, 5.474229, 212.175354),
            new e.Vector3(76.163872, 5.269204, 196.339615),
            new e.Vector3(96.316612, -1.971584, 175.969406),
            new e.Vector3(95.625557, 14.016932, -29.347076),
            new e.Vector3(82.813911, 6.067989, -8.976847),
            new e.Vector3(65.538559, 6.273015, 6.858894),
            new e.Vector3(52.402088, 2.58246, -0.33917),
            new e.Vector3(66.618263, -7.859836, -7.357284),
            new e.Vector3(74.896034, -11.667654, -22.65317),
            new e.Vector3(99.701408, -6.233868, -55.70504),
            new e.Vector3(83.389511, -5.379319, -60.020809),
            new e.Vector3(55.955547, 1.965523, -94.987724),
            new e.Vector3(67.778564, 5.376258, -84.987656),
            new e.Vector3(43.498501, 14.629928, -98.701294),
            new e.Vector3(74.628525, -2.383026, -76.512794),
            new e.Vector3(78.551788, 9.609264, -87.540688),
            new e.Vector3(87.403481, 9.609264, -48.462593),
            new e.Vector3(90.037827, -0.206433, -72.067772),
            new e.Vector3(79.308304, 14.629927, -37.15493),
            new e.Vector3(27.688911, 14.629927, -34.356289),
            new e.Vector3(14.373295, 14.629928, -85.823715),
            new e.Vector3(57.972782, -0.206433, -43.081699),
            new e.Vector3(54.934708, 9.609265, -61.733353),
            new e.Vector3(42.948956, 9.609265, -72.685364),
            new e.Vector3(26.830349, 1.965523, -82.110146),
            new e.Vector3(41.847412, -18.293367, -48.764442),
            new e.Vector3(47.002308, -6.233868, -31.672112),
            new e.Vector3(35.69331, -6.233868, -22.013948),
            new e.Vector3(-53.40295, -15.026654, -169.532761),
            new e.Vector3(-77.864494, 4.792339, -152.890335),
            new e.Vector3(-75.050423, -24.993448, -166.207886),
            new e.Vector3(-74.447632, -31.017559, -142.371292),
            new e.Vector3(-80.209267, -12.75826, -178.237564),
            new e.Vector3(-66.658684, -20.556166, -183.043091),
            new e.Vector3(-56.692078, -31.016151, -158.859146),
            new e.Vector3(-73.739784, 12.974339, -126.737572),
            new e.Vector3(-64.265984, -19.493813, -117.891846),
            new e.Vector3(-56.42609, -29.85454, -145.325531),
            new e.Vector3(-53.254337, -18.293365, -113.018303),
            new e.Vector3(-39.719975, -18.112343, -143.836533),
            new e.Vector3(-48.206852, -29.012661, -135.673782),
            new e.Vector3(-11.169664, -9.968513, -128.227875),
            new e.Vector3(-2.902144, -1.251821, -119.942078),
            new e.Vector3(-37.321842, -8.746367, -126.841347),
            new e.Vector3(-13.49951, -19.509727, -117.404198),
            new e.Vector3(-25.222944, -16.169373, -119.822815),
            new e.Vector3(-25.081341, -4.302496, -89.952202),
            new e.Vector3(-34.896976, -8.263515, -96.803627),
            new e.Vector3(-12.102392, 3.284912, -90.670273),
            new e.Vector3(-43.998993, -9.602431, -103.747368),
            new e.Vector3(-41.311543, 9.609265, -87.779564),
            new e.Vector3(-60.001392, 9.609265, -93.204895),
            new e.Vector3(-65.906464, -13.466378, -105.218391),
            new e.Vector3(-55.168678, 17.825991, -6.101646),
            new e.Vector3(-68.018654, 27.641687, -2.350389),
            new e.Vector3(-76.577095, 18.365707, 15.128114),
            new e.Vector3(-65.118492, 8.429991, 12.739216),
            new e.Vector3(-81.214142, 6.636311, 48.619827),
            new e.Vector3(-68.790512, 9.768908, 22.998909),
            new e.Vector3(-77.227776, 28.596657, 31.490147),
            new e.Vector3(-45.080051, 14.083374, 43.056961),
            new e.Vector3(-43.796692, 9.286056, 24.920797),
            new e.Vector3(-53.682049, 16.780602, 57.622665),
            new e.Vector3(-28.210602, -10.98024, 16.571442),
            new e.Vector3(-21.628857, -0.079923, 26.335567),
            new e.Vector3(-54.394112, -0.260944, 5.215968),
            new e.Vector3(-14.741057, -6.066782, 13.432004),
            new e.Vector3(-42.966103, 11.798555, -2.306267),
            new e.Vector3(-32.623032, 11.798555, -10.117819),
            new e.Vector3(7.758904, -3.442529, -22.875816),
            new e.Vector3(1.989553, -15.291476, 11.80082),
            new e.Vector3(25.199577, -8.045743, 4.698078),
            new e.Vector3(16.800121, 5.274162, -15.441923),
            new e.Vector3(6.50318, -12.983741, -11.875666),
            new e.Vector3(-12.218436, -32.418457, -12.212127),
        ]),
            (t.scales = [
                new e.Vector3(1.420152, 1.420151, 1.420152),
                new e.Vector3(1.938255, 1.938255, 1.938255),
                new e.Vector3(2.42313, 2.42313, 2.42313),
                new e.Vector3(2.076288, 2.076288, 2.076288),
                new e.Vector3(0.669806, 0.669806, 0.669806),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(2.127787, 2.127787, 2.127787),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1.283336, 1.283336, 1.283336),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1.762825, 1.762825, 1.762825),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1.675632, 1.675631, 1.675632),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1.916129, 1.916129, 1.916129),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(0.669806, 0.669806, 0.669806),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1.462429, 1.462429, 1.462429),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(0.72627, 0.72627, 0.72627),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1.406791, 1.406791, 1.406791),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1.18628, 1.18628, 1.18628),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(0.695738, 0.695738, 0.695738),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(0.750125, 0.750125, 0.750125),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(0.665522, 0.665522, 0.665522),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1.229326, 1.229326, 1.229326),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1.784455, 1.784454, 1.784455),
                new e.Vector3(1, 1, 1),
                new e.Vector3(0.54925, 0.54925, 0.54925),
                new e.Vector3(1.59206, 1.59206, 1.59206),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1.456782, 1.456782, 1.456782),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(1, 1, 1),
                new e.Vector3(2.005709, 2.005709, 2.005709),
            ]),
            (t.rotationsY = [
                0.37033915519714355,
                0.37033915519714355,
                -0.6171221733093262,
                -0.4416244328022003,
                -0.6171221733093262,
                0.37033915519714355,
                0.37033915519714355,
                0.37033915519714355,
                0.37033915519714355,
                0.37033915519714355,
                0.37033915519714355,
                0.37033915519714355,
                0.37033915519714355,
                0.37033915519714355,
                0.37033915519714355,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
                -1.6098090410232544,
                -1.4465432167053223,
                -0.8363050818443298,
                0.023695094510912895,
                -1.245148777961731,
                -1.245148777961731,
                -0.478750616312027,
                -0.3514663875102997,
                -0.3514663875102997,
                -0.3514663875102997,
                0.023695094510912895,
                -1.8859660625457764,
                -1.8859660625457764,
                -0.9922836422920227,
                -0.9922836422920227,
                -0.9922836422920227,
                -0.9922836422920227,
                -0.9922836422920227,
                -0.6171221733093262,
                -0.6171221733093262,
                -0.4416244328022003,
                -0.4416244328022003,
                -0.4416244328022003,
                -0.6171221733093262,
                -0.6171221733093262,
                -0.9922836422920227,
                -0.9922836422920227,
                -0.9922836422920227,
                -0.6171221733093262,
                -0.9922836422920227,
                -0.6171221733093262,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -0.6932804584503174,
                -1.8859660625457764,
                -1.8859660625457764,
                -0.6171221733093262,
                -0.9922836422920227,
                -0.6171221733093262,
                -0.9922836422920227,
                -0.9922836422920227,
                -0.9922836422920227,
                -0.9922836422920227,
                -0.6171221733093262,
                -0.6171221733093262,
                -0.6171221733093262,
                -0.9922836422920227,
                -0.9922836422920227,
                -0.9922836422920227,
                -0.6171221733093262,
                -1.8859660625457764,
                -1.8859660625457764,
                -1.8859660625457764,
                -4.697138786315918,
                -4.307406425476074,
                -4.307406425476074,
                -4.307406425476074,
                -4.307406425476074,
                -4.307406425476074,
                -4.697138786315918,
                -4.307406425476074,
                -4.307406425476074,
                -4.307406425476074,
                -4.307406425476074,
                -4.307406425476074,
                -4.307406425476074,
                -6.149378776550293,
                -6.149378776550293,
                -6.149378776550293,
                -6.149378776550293,
                -6.149378776550293,
                -3.413723945617676,
                -3.413723945617676,
                -3.413723945617676,
                -3.413723945617676,
                -3.413723945617676,
                -3.413723945617676,
                -3.413723945617676,
                1.1258455514907837,
                1.1258455514907837,
                1.1258455514907837,
                1.1258455514907837,
                1.5992904901504517,
                1.497353434562683,
                1.1258455514907837,
                -1.6098090410232544,
                -1.6098090410232544,
                -1.8568350076675415,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
                0.23216302692890167,
            ]),
            t
    );
}),
define("road/shaders/shader", ["three", "class"], function (e, t) {
    function r(e) {
        var t = {};
        return (
            _.each(e, function (e, n) {
                t[n] = _.clone(e);
            }),
                t
        );
    }
    var n = t.extend({
        initialize: function () {
            (this.attributes = r(this.attributes)),
                (this.uniforms = e.UniformsUtils.clone(this.uniforms)),
                (this.material = new e.ShaderMaterial({ attributes: this.attributes || {}, uniforms: this.uniforms || {}, vertexShader: this.vertexShader, fragmentShader: this.fragmentShader }));
        },
    });
    return n;
}),
define("text!road/shaders/vertex/basic.vs", [], function () {
    return "varying vec3 vPosition;\nvarying vec3 vViewPosition;\nvarying vec3 vViewNormal;\n\nvoid main() {\n  vec4 pos = modelViewMatrix * vec4(position, 1.0);\n  vViewPosition = pos.xyz;\n  vPosition = position;\n  vViewNormal = normalize(normalMatrix * normal);\n  gl_Position = projectionMatrix * pos;\n}";
}),
define("text!road/shaders/fragment/pillar.fs", [], function () {
    return "varying vec3 vPosition;\nvarying vec3 vViewPosition;\nvarying vec3 vViewNormal;\nconst float PI = 3.14159265359;\n\nuniform vec3 lineColor1;\nuniform vec3 lineColor2;\nuniform float lineWidth;\nuniform float colorBlend;\n\nfloat border(float start, float end, float dotNormalEye) {\n  return smoothstep(start, end, dotNormalEye);\n}\n\nvoid main() {\n  vec3 lineColor = mix(lineColor1, lineColor2, colorBlend);\n  float angle = atan(vPosition.z / vPosition.x);\n  vec3 black = vec3(0.0, 0.0, 0.0);\n  vec3 color = black;\n\n  vec2 normal = normalize(vViewNormal.xz);\n  vec2 eye = normalize(-vViewPosition.xz);\n  float dotNormalEye = dot(normal, eye);\n  float normalFactor = ((1.0 - (dotNormalEye / 1.0)) * 3.0) + 1.0;\n\n  float m = mod(angle, PI / 5.0);\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n  float d = depth / 200.0;\n  float range = lineWidth * d * normalFactor;\n  float tolerance = 0.005 * d;\n\n  if (m < range) {\n    if (m > (range - tolerance)) {\n      color = mix(lineColor, black, (m - (range - tolerance)) / tolerance);\n    } else {\n      color = lineColor;\n    }\n  }\n\n  if (m > ((PI / 5.0) - range) ) {\n    if (m < ((PI / 5.0) - range + tolerance)) {\n      color = mix(lineColor, black, ((PI / 5.0) - range + tolerance - m) / tolerance);\n    } else {\n      color = lineColor;\n    }\n  }\n\n  gl_FragColor = vec4(color * border(0.05, 0.9, dotNormalEye), 1.0);\n  // gl_FragColor = vec4(color, 1.0);\n}";
}),
define("road/shaders/pillar", ["./shader", "text!./vertex/basic.vs", "text!./fragment/pillar.fs", "shifty"], function (e, t, n, r) {
    var i = e.extend({
        vertexShader: t,
        fragmentShader: n,
        uniforms: { lineColor1: { type: "c", value: new THREE.Color(6619005) }, lineColor2: { type: "c", value: new THREE.Color(255) }, lineWidth: { type: "f", value: 0.015 }, colorBlend: { type: "f", value: 0 } },
        initialize: function (t) {
            e.prototype.initialize.call(this),
            t.lineColor1 && (this.material.uniforms.lineColor1.value = t.lineColor1),
            t.lineColor2 && (this.material.uniforms.lineColor2.value = t.lineColor2),
                (this.material.shading = THREE.FlatShading),
            t.lineWidth && (this.material.uniforms.lineWidth.value = t.lineWidth),
                (this.lastColorChange = 0);
        },
        revertColor: function () {
            var e = new r(),
                t = this.material.uniforms.colorBlend;
            e.tween({
                from: { colorBlend: 1 },
                to: { colorBlend: 0 },
                duration: 750,
                easing: "easeInOutQuad",
                step: function (e) {
                    t.value = e.colorBlend;
                },
            });
        },
        changeColor: function () {
            var e = new r(),
                t = this.material.uniforms.colorBlend;
            e.tween({
                from: { colorBlend: 0 },
                to: { colorBlend: 1 },
                duration: 750,
                easing: "easeInOutQuad",
                step: function (e) {
                    t.value = e.colorBlend;
                },
                callback: this.revertColor.bind(this),
            });
        },
        update: function (e, t) {
            e - this.lastColorChange > 5 && (this.changeColor(), (this.lastColorChange = e));
        },
    });
    return i;
}),
define("text!road/shaders/vertex/wireframe.vs", [], function () {
    return "attribute vec3 barycentric;\nvarying vec3 vBarycentric;\n\nvoid main() {\n  vBarycentric = barycentric;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";
}),
define("text!road/shaders/fragment/wireframe.fs", [], function () {
    return "#extension GL_OES_standard_derivatives : enable\n\nvarying vec3 vBarycentric;\n\nuniform vec3 fillColor;\nuniform vec3 lineColor1;\nuniform vec3 lineColor2;\nuniform float lineWidth;\nuniform float colorBlend;\n\nfloat edgeFactor(){\n  vec3 d = fwidth(vBarycentric);\n  vec3 a3 = smoothstep(vec3(0.0), d * lineWidth, vBarycentric);\n  return min(min(a3.x, a3.y), a3.z);\n}\n\nvoid main() {\n  vec3 color = fillColor;\n  vec3 lineColor = mix(lineColor1, lineColor2, colorBlend);\n  // if(any(lessThan(vBarycentric, vec3(0.02)))){\n  //     color = vec3(1.0);\n  // }\n\n  // gl_FragColor = vec4(color, 1.0);\n\n  // coloring by edge\n  gl_FragColor.rgb = mix(lineColor, fillColor, edgeFactor());\n  gl_FragColor.a = 1.0;\n}";
}),
define("road/shaders/wireframe", ["./shader", "text!./vertex/wireframe.vs", "text!./fragment/wireframe.fs", "shifty"], function (e, t, n, r) {
    var i = e.extend({
        vertexShader: t,
        fragmentShader: n,
        attributes: { barycentric: { type: "v3", value: [] } },
        uniforms: {
            fillColor: { type: "c", value: new THREE.Color(0) },
            lineColor1: { type: "c", value: new THREE.Color(16777215) },
            lineColor2: { type: "c", value: new THREE.Color(255) },
            lineWidth: { type: "f", value: 3 },
            colorBlend: { type: "f", value: 0 },
        },
        initialize: function (t) {
            e.prototype.initialize.call(this),
                (this.material.attributes.barycentric.value = t.barycentricAttributes),
            t.lineColor1 && (this.material.uniforms.lineColor1.value = t.lineColor1),
            t.lineColor2 && (this.material.uniforms.lineColor2.value = t.lineColor2),
                (this.material.uniforms.lineWidth.value = window.innerWidth * 0.0015),
                (this.lastColorChange = 0);
        },
        revertColor: function () {
            var e = new r(),
                t = this.material.uniforms.colorBlend;
            e.tween({
                from: { colorBlend: 1 },
                to: { colorBlend: 0 },
                duration: 750,
                easing: "easeInOutQuad",
                step: function (e) {
                    t.value = e.colorBlend;
                },
            });
        },
        changeColor: function () {
            var e = new r(),
                t = this.material.uniforms.colorBlend;
            e.tween({
                from: { colorBlend: 0 },
                to: { colorBlend: 1 },
                duration: 750,
                easing: "easeInOutQuad",
                step: function (e) {
                    t.value = e.colorBlend;
                },
                callback: this.revertColor.bind(this),
            });
        },
        update: function (e, t) {
            e - this.lastColorChange > 5 && (this.changeColor(), (this.lastColorChange = e));
        },
    });
    return i;
}),
define("text!road/shaders/vertex/sky.vs", [], function () {
    return "varying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";
}),
define("text!road/shaders/fragment/sky.fs", [], function () {
    return "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec2 vUv;\n\nuniform vec3 color1;\nuniform vec3 color2;\nuniform float midpoint;\nuniform float range;\nuniform float offset;\n\nconst float lineCount = 20.0;\n\nvoid main() {\n  vec3 color = vec3(0.0);\n  float s1 = midpoint - (range / 2.0);\n  float s2 = midpoint + (range / 2.0);\n\n  // float y = vUv.y + offset / 10.0;\n  float y = vUv.y;\n\n  if (y < s1) {\n    color = color1;\n  } else if (y > s2) {\n    color = color2;\n  } else {\n    float t = (y - s1) / (s2 - s1);\n    // t += offset;\n    color = mix(color1, color2, (floor((t * lineCount) + offset) - offset) / lineCount);\n  }\n\n  gl_FragColor = vec4(color, 1.0);\n}";
}),
define("road/shaders/sky", ["./shader", "text!./vertex/sky.vs", "text!./fragment/sky.fs", "shifty"], function (e, t, n, r) {
    var i = e.extend({
        vertexShader: t,
        fragmentShader: n,
        uniforms: { color1: { type: "c", value: new THREE.Color(0) }, color2: { type: "c", value: new THREE.Color(16777215) }, midpoint: { type: "f", value: 0.5 }, range: { type: "f", value: 1 }, offset: { type: "f", value: 0 } },
        initialize: function (t) {
            e.prototype.initialize.call(this),
            t && t.color1 && (this.material.uniforms.color1.value = t.color1),
            t && t.color2 && (this.material.uniforms.color2.value = t.color2),
            t && t.midpoint && (this.material.uniforms.midpoint.value = t.midpoint),
                (this.lastBrightnessChange = 0);
        },
        brighten: function () {
            var e = new r(),
                t = this.material.uniforms.color1,
                n = t.value.getHSL();
            e.tween({
                from: { offset: 0 },
                to: { offset: 0.35 },
                duration: 750,
                easing: "easeInOutQuad",
                step: function (e) {
                    t.value.setHSL(n.h, n.s, n.l + e.offset);
                },
            });
        },
        darken: function () {
            var e = new r(),
                t = this.material.uniforms.color1,
                n = t.value.getHSL();
            e.tween({
                from: { offset: 0 },
                to: { offset: 0.35 },
                duration: 750,
                easing: "easeInOutQuad",
                step: function (e) {
                    t.value.setHSL(n.h, n.s, n.l - e.offset);
                },
                callback: this.brighten.bind(this),
            });
        },
        update: function (e, t) {
            var n = this.material.uniforms.offset,
                r = 4,
                i = 1 - n.value;
            n.value + t > 1 ? (n.value = 0) : (n.value += t * r), e - this.lastBrightnessChange > 5 && (this.darken(), (this.lastBrightnessChange = e));
        },
    });
    return i;
}),
define("road/road", ["three", "world", "./objects", "./models", "./curves", "./pillars", "./shaders/pillar", "./shaders/wireframe", "./shaders/sky"], function (e, t, n, r, i, s, o, u, a) {
    function c(e) {
        return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 2) : -0.5 * ((e -= 2) * e - 2);
    }
    var f = [
            { color1: new e.Color(4057417), color2: new e.Color(13115194) },
            { color1: new e.Color(5963672), color2: new e.Color(1384055) },
            { color1: new e.Color(5701628), color2: new e.Color(1447414) },
        ],
        l = t.extend({
            initialize: function () {
                t.prototype.initialize.call(this), (this.progress = 0), (this.camera.speed = 2.5), (this.shaders = []), this.initTrack(), this.initPillars(), this.initSky();
                var n = { minFilter: e.LinearFilter, magFilter: e.LinearFilter, format: e.RGBAFormat };
                (this.skyTarget = new e.WebGLRenderTarget(512, 512, n)),
                    (this.sceneTarget = new e.WebGLRenderTarget(window.innerWidth, window.innerHeight, n)),
                    (this.camera.target = new e.Quaternion()),
                    (this.targetQuaternion = new e.Quaternion()),
                    this.camera.lookAt(this.camera.target),
                    (this.projector = new e.Projector());
            },
            initSky: function () {
                (this.skyScene = new e.Scene()), (this.skyCamera = new e.OrthographicCamera(-1, 1, 1, -1, 0, 1)), (this.skyShader = new a({ color1: new e.Color(3538766), color2: new e.Color(65539) }));
                var t = new e.Mesh(new e.PlaneGeometry(2, 2), this.skyShader.material);
                (t.name = "sky"), this.skyScene.add(t);
            },
            initTrack: function () {
                this.trackGeometry = new e.Geometry();
                var t = 24;
                _.each(
                    i.segments,
                    function (n, r) {
                        var i = r > 6 ? t + 1 : t,
                            s = r < 1 ? 0 : 1;
                        for (var o = s; o < i; o++) {
                            var u = c(o * (1 / t)),
                                a = n.getPoint(u),
                                f = n.getTangent(u).multiplyScalar(2);
                            f.applyAxisAngle(new e.Vector3(0, 1, 0), Math.PI / 2);
                            var l = a.clone().sub(f),
                                h = a.clone().add(f),
                                p = h.clone(),
                                d = h.clone(),
                                v = l.clone(),
                                m = l.clone();
                            (l.y = h.y = a.y), (p.y = m.y = a.y - 0.1);
                            var g = f.clone().multiplyScalar(0.05);
                            p.add(g), m.sub(g), (d.y = v.y = a.y - 0.2), this.trackGeometry.vertices.push(l, h, p, d, v, m);
                        }
                    },
                    this
                ),
                    this.createTrackFaces(this.trackGeometry),
                    this.computeBarycentricCoordinates(this.trackGeometry),
                    (this.trackShader = new u({ barycentricAttributes: this.trackGeometry.barycentricAttributes })),
                    (this.trackShader.material.uniforms.lineColor1.value = new e.Color(5701628)),
                    (this.trackShader.material.uniforms.lineColor2.value = new e.Color(15610040)),
                    this.shaders.push(this.trackShader),
                    (this.track = new e.Mesh(this.trackGeometry, this.trackShader.material)),
                    (this.track.name = "track"),
                    this.track.scale.multiplyScalar(10),
                    this.scene.add(this.track),
                    this.initTrackClone();
            },
            computeBarycentricCoordinates: function (t) {
                var n = t.vertices,
                    r = [],
                    i = (t.barycentricAttributes = []),
                    s = [new e.Vector3(1, 0, 0), new e.Vector3(0, 1, 0), new e.Vector3(0, 0, 1)];
                _.each(t.faces, function (e, n) {
                    var o = [e.a, e.b, e.c];
                    (e.a = n * 3),
                        (e.b = n * 3 + 1),
                        (e.c = n * 3 + 2),
                        _.each(o, function (e, n) {
                            r.push(t.vertices[e].clone()), i.push(s[n]);
                        });
                }),
                    (t.vertices = r),
                    (t.verticesNeedUpdate = !0),
                    (t.buffersNeedUpdate = !0);
            },
            initTrackClone: function () {
                var e = i.path.getBoundingBox(),
                    t = (e.maxZ - e.minZ) * 10;
                (this.track2 = this.track.clone()),
                    (this.track2.name = "track2"),
                    (this.track2.geometry = this.track.geometry.clone()),
                    (this.track2.geometry.vertices = _.first(this.track2.geometry.vertices, 900)),
                    (this.track2.geometry.faces = _.first(this.track2.geometry.faces, 300)),
                    (this.track2.geometry.verticesNeedUpdate = !0),
                    (this.track2.geometry.buffersNeedUpdate = !0),
                    this.track2.position.set(0, 0, -t),
                    this.scene.add(this.track2);
            },
            initPillarClones: function () {
                var e = this.pillars.clone(),
                    t = [];
                (e.name = "pillars2"),
                    _.each(e.children, function (e) {
                        e.position.z < 120 && t.push(e);
                    }),
                    _.each(t, function (t) {
                        e.remove(t);
                    }),
                    e.position.set(0, 0, -4066.3),
                    this.scene.add(e);
            },
            initPillars: function () {
                (this.pillars = new e.Object3D()), (this.pillars.name = "pillars");
                var t = r.get("pillar");
                (this.pillar = t), t.geometry.computeVertexNormals(), (t.geometry.needsUpdate = !0);
                var n = r.get("pillarTop");
                (this.pillarTop = n), this.pillar.add(n), this.computeBarycentricCoordinates(n.geometry);
                var i = [];
                _.each(
                    f,
                    function (e) {
                        var t = new u({ barycentricAttributes: n.geometry.barycentricAttributes, lineColor1: e.color1, lineColor2: e.color2 });
                        i.push(t.material), this.shaders.push(t);
                    },
                    this
                ),
                    _.each(
                        s.locations,
                        function (e, t) {
                            var n = this.pillar.clone(),
                                r = f[t % 3],
                                u = new o({ lineColor1: r.color1, lineColor2: r.color2, lineWidth: 0.009 / s.scales[t].x });
                            this.shaders.push(u), (n.position = e), (n.scale = s.scales[t]), (n.rotation.y = s.rotationsY[t]), (n.material = u.material), (n.children[0].material = i[t % 3]), this.pillars.add(n);
                        },
                        this
                    ),
                    this.pillars.scale.multiplyScalar(10),
                    this.scene.add(this.pillars),
                    this.initPillarClones();
            },
            createTrackFaces: function (t) {
                var n = t.faces;
                for (var r = 0; r < this.trackGeometry.vertices.length - 6; r += 6)
                    n.push(new e.Face3(r, r + 6, r + 1)),
                        n.push(new e.Face3(r + 6, r + 7, r + 1)),
                        n.push(new e.Face3(r + 1, r + 7, r + 2)),
                        n.push(new e.Face3(r + 7, r + 8, r + 2)),
                        n.push(new e.Face3(r + 2, r + 8, r + 3)),
                        n.push(new e.Face3(r + 8, r + 9, r + 3)),
                        n.push(new e.Face3(r + 3, r + 9, r + 4)),
                        n.push(new e.Face3(r + 9, r + 10, r + 4)),
                        n.push(new e.Face3(r + 4, r + 10, r + 5)),
                        n.push(new e.Face3(r + 10, r + 11, r + 5)),
                        n.push(new e.Face3(r + 5, r + 11, r)),
                        n.push(new e.Face3(r + 11, r + 6, r));
                t.needsUpdate = !0;
            },
            setupDatGUI: function (e) {
                var t = e.addFolder("FXAA");
                t.add(this.fxaa, "enabled"), t.open();
                var n = e.addFolder("Glow");
                n.add(this.blur, "blurriness", 0, 10).onChange(this.blur.onChangeBlurriness), n.add(this.additiveBlend, "opacity", 0, 1), n.open();
                var r = e.addFolder("Camera");
                r.add(this.camera, "speed", 0, 10), r.add(this, "progress", 0, 100).listen(), r.open();
            },
            render: function (e, t) {
                this.skyScene && this.scene && (e.render(this.skyScene, this.skyCamera, this.skyTarget, !0), e.render(this.scene, this.camera, this.sceneTarget, !0), t[1].render(), t[0].render());
            },
            setupGlowComposer: function (t) {
                var n = new e.CopyPass(this.sceneTarget),
                    r = new e.ShaderPass(e.HorizontalBlurShader),
                    i = new e.ShaderPass(e.VerticalBlurShader);
                (this.blur = {
                    blurriness: 2,
                    onChangeBlurriness: function (e) {
                        (r.uniforms.h.value = e / window.innerWidth), (i.uniforms.v.value = e / window.innerHeight);
                    },
                }),
                    this.blur.onChangeBlurriness(this.blur.blurriness),
                    t.addPass(n),
                    t.addPass(r),
                    t.addPass(i),
                    (this.glowTarget = t.renderTarget1);
            },
            setupMainComposer: function (t) {
                var n = new e.NormalBlendPass(this.skyTarget, this.sceneTarget),
                    r = new e.AdditiveBlendPass(null, this.glowTarget, 0.8),
                    i = (this.fxaa = new e.ShaderPass(e.FXAAShader));
                (i.uniforms.resolution.value = new e.Vector2(DENSITY / WIDTH, DENSITY / HEIGHT)), (i.enabled = !1), (this.additiveBlend = r), t.addPass(n), t.addPass(r), t.addPass(i);
            },
            setupCompositing: function (e) {
                this.setupGlowComposer(e[1]), this.setupMainComposer(e[0]);
            },
            updateCamera: function () {
                var e = this.progress / 100,
                    t = i.path.getPoint(e).multiplyScalar(10);
                (this.camera.position = t), (this.camera.position.y += 6);
                var n = i.path.getTangent(e),
                    r = t.clone().add(n);
                this.camera.lookAt(r), this.targetQuaternion.set(-mouseY / 8, -mouseX / 4, 0, 1).normalize(), this.camera.target.slerp(this.targetQuaternion, 0.1), this.camera.quaternion.multiply(this.camera.target);
            },
            updateShaders: function (e, t) {
                _.each(this.shaders, function (n) {
                    n.update(e, t);
                }),
                    this.skyShader.update(e, t);
            },
            update: function (e, t) {
                this.updateCamera(), this.updateShaders(e, t), (this.progress += t * this.camera.speed), this.progress > 100 && (this.progress = 0);
            },
        });
    return (
        (e.CurvePath.prototype.getBoundingBox = function () {
            var t = this.getPoints(),
                n,
                r,
                i,
                s,
                o,
                u;
            (n = r = i = Number.NEGATIVE_INFINITY), (s = o = u = Number.POSITIVE_INFINITY);
            var a,
                f,
                l,
                c,
                h = t[0] instanceof e.Vector3;
            c = h ? new e.Vector3() : new e.Vector2();
            for (f = 0, l = t.length; f < l; f++) (a = t[f]), a.x > n ? (n = a.x) : a.x < s && (s = a.x), a.y > r ? (r = a.y) : a.y < o && (o = a.y), h && (a.z > i ? (i = a.z) : a.z < u && (u = a.z)), c.add(a);
            var p = { minX: s, minY: o, maxX: n, maxY: r, centroid: c.divideScalar(l) };
            return h && ((p.maxZ = i), (p.minZ = u)), p;
        }),
            l
    );
}),
define("road/app", ["class", "./objects", "./models", "./road", "orbitcontrols", "effectcomposer", "compositingshaders"], function (e, t, n, r) {
    var i = e.extend({
        initialize: function (e) {
            (this.name = "road"),
                (this.description = '#04  Based on <a target="_blank" href="http://vimeo.com/35215202">Yellowbrick</a> by Beeple'),
                (this.renderer = e.renderer),
                (this.container = e.container),
                (this.clock = new THREE.Clock(!1)),
                (this.compositing = e.enableCompositing);
        },
        initWorld: function () {
            $.when(n.loadAll()).done(
                _.bind(function () {
                    (this.world = new r()), this.world.initHelpers(), this.world.toggleHelpers(), this.initCompositing(), this.datGUI && this.world.setupDatGUI(this.datGUI), this.trigger("ready");
                }, this)
            );
        },
        initCompositing: function () {
            this.mainComposer = new THREE.EffectComposer(this.renderer);
            var e = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat },
                t = new THREE.WebGLRenderTarget(window.innerWidth / 2, window.innerHeight / 2, e);
            (this.glowComposer = new THREE.EffectComposer(this.renderer, t)), this.world.setupCompositing([this.mainComposer, this.glowComposer]);
            var n = new THREE.ShaderPass(THREE.CopyShader);
            (n.renderToScreen = !0), this.mainComposer.addPass(n);
        },
        render: function () {
            this.compositing && this.mainComposer && this.glowComposer
                ? this.world.render(this.renderer, [this.mainComposer, this.glowComposer])
                : (this.renderer.clear(), this.renderer.render(this.world.skyScene, this.world.skyCamera), this.renderer.clear(!1, !0, !1), this.renderer.render(this.world.scene, this.world.camera));
        },
        update: function () {
            var e = this.clock.getDelta(),
                t = this.clock.getElapsedTime();
            this.paused || (requestAnimationFrame(this.update.bind(this)), this.stats && this.stats.begin(), this.world.update(t, e), this.render(), this.stats && this.stats.end());
        },
        pause: function () {
            this.clock.stop(), (this.paused = !0);
        },
        resume: function () {
            this.clock.start(), (this.paused = !1);
        },
        toggleGUIMode: function () {
            this.stats && this.datGUI && ($(this.stats.domElement).toggle(), $(this.datGUI.domElement).toggle());
        },
        resize: function (e, t) {
            this.world.setAspectRatio(e / t);
        },
    });
    return i;
}),
define("datgui", {}),
define("stats", {});
var Detector = {
    canvas: !!window.CanvasRenderingContext2D,
    webgl: (function () {
        try {
            var e = document.createElement("canvas");
            return !!window.WebGLRenderingContext && (e.getContext("webgl") || e.getContext("experimental-webgl"));
        } catch (t) {
            return !1;
        }
    })(),
    workers: !!window.Worker,
    fileapi: window.File && window.FileReader && window.FileList && window.Blob,
    getWebGLErrorMessage: function () {
        var e = document.createElement("p");
        return (
            this.webgl ||
            (e.innerHTML = window.WebGLRenderingContext
                ? [
                    'Your browser or graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>.<br />',
                    'Find out how to get it <a href="http://get.webgl.org/">here</a>.',
                ].join("\n")
                : [
                    'Your browser or graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>.<br/>',
                    'Find out how to get it <a href="http://get.webgl.org/">here</a>.',
                ].join("\n")),
                e
        );
    },
    addGetWebGLMessage: function (e) {
        var t, n, r;
        (e = e || {}), (t = e.parent !== undefined ? e.parent : document.body), (n = e.id !== undefined ? e.id : "oldie"), (r = Detector.getWebGLErrorMessage()), (r.id = n), t.appendChild(r);
    },
};
define("detector", (function (e) {
    return function () {
        var t, n;
        return t || e.Detector;
    };
})(this));
var hudSize = 120;
(window.WIDTH = window.innerWidth),
    (window.HEIGHT = window.innerHeight - hudSize),
    (window.DENSITY = 1 / window.devicePixelRatio),
    (window.mouseX = 0),
    (window.mouseY = 0),
    define("main", ["neons/app", "canyon/app", "mountains/app", "road/app", "datgui", "stats", "detector"], function (e, t, n, r, i, s, o) {
        function m(e) {
            (mouseX = (e.pageX / WIDTH) * 2 - 1), (mouseY = (e.pageY / HEIGHT) * 2 - 1);
        }
        function g() {
            var e = (window.WIDTH = window.innerWidth),
                t = (window.HEIGHT = window.innerHeight - 120);
            a.setSize(e, t),
                _.each(l, function (n) {
                    n.resize(e, t);
                });
        }
        function y(e) {
            e.keyCode == 68 && !h && ((c = !c), p.toggleGUIMode(), p.world.toggleHelpers()), e.keyCode == 37 && b(), e.keyCode == 39 && w();
        }
        function b() {
            d > 0 ? E(d - 1) : E(l.length - 1);
        }
        function w() {
            d < l.length - 1 ? E(d + 1) : E(0);
        }
        function E(e) {
            if (e < 0 || e >= l.length) return;
            if (e === d || v) return;
            var t = l[e],
                n = function () {
                    f.off("transitionend webkitTransitionEnd mozTransitionEnd msTransitionEnd oTransitionEnd"),
                        f.removeClass("hidden"),
                        S(t),
                        t.resume(),
                        t.update(),
                        (v = !1),
                    p && (x(p), p.pause()),
                        (p = t),
                        (d = e),
                    h || (window.location.hash = e + 1);
                };
            f.addClass("hidden").on("transitionend webkitTransitionEnd mozTransitionEnd msTransitionEnd oTransitionEnd", n), (v = !0), T(e, t.description);
        }
        function S(e) {
            c && ($(e.stats.domElement).show(), $(e.datGUI.domElement).show());
        }
        function x(e) {
            c && ($(e.stats.domElement).hide(), $(e.datGUI.domElement).hide());
        }
        function T(e, t) {
            $(".selected").removeClass("selected"), D.eq(e).addClass("selected"), P.text("0" + (e + 1)), H.html(t);
        }
        function N() {
            return parseInt(window.location.hash.substring(1, window.location.hash.length));
        }
        function O() {
            document[L]
                ? p.pause()
                : setTimeout(function () {
                    p.resume(), p.update();
                }, 50);
        }
        function B() {
            var e = d - 1;
            e < 0 && (e = l.length - 1), E(e);
        }
        function j() {
            var e = (d + 1) % D.length;
            E(e);
        }
        function F(e) {
            var t = D.index($(e.target).closest("li"));
            E(t);
        }
        function I(e) {
            if (!h) {
                var t = new i.GUI();
                if (!_.isUndefined(e.compositing)) {
                    var n = t.addFolder("General");
                    n.add(e, "compositing"), n.open();
                }
                f.append(t.domElement), $(t.domElement).css({ position: "absolute", top: "0px", right: "10px" }), (e.datGUI = t);
            }
        }
        function q(e) {
            if (!h) {
                var t = new s();
                (t.domElement.style.position = "absolute"), (t.domElement.style.left = "0px"), (t.domElement.style.top = "0px"), f.append(t.domElement), (e.stats = t);
            }
        }
        THREE.Math.lerp = function (e, t, n) {
            return e + (t - e) * n;
        };
        if (!o.webgl) {
            var u = $("#no-webgl");
            $("body").prepend(u.html()), $(".no-webgl .content").append(o.getWebGLErrorMessage());
        }
        $("body").removeClass("no-transitions");
        var a = new THREE.WebGLRenderer({ antialias: !0 });
        (a.autoClear = !1), a.setSize(WIDTH, HEIGHT);
        var f = $(".container");
        f.append(a.domElement);
        var l = [],
            c = !1,
            h = !_.isFunction(s);
        l.push(new e({ renderer: a, container: f[0], enableCompositing: !1 })),
            l.push(new t({ renderer: a, container: f[0], enableCompositing: !0 })),
            l.push(new n({ renderer: a, container: f[0], enableCompositing: !0 })),
            l.push(new r({ renderer: a, container: f[0], enableCompositing: !1 })),
            _.each(l, function (e) {
                I(e), q(e), e.toggleGUIMode();
            });
        var p = null,
            d = -1,
            v = !1;
        _.each(l, function (e, t) {
            e.initWorld();
        }),
        h ||
        (window.onhashchange = function () {
            E(N() - 1);
        });
        var C = N() - 1 || 0,
            k = l[C];
        k.on("ready", function () {
            E(C);
        }),
            $(window).resize(g).on("keyup", y).on("mousemove", m);
        var L, A;
        typeof document.hidden != "undefined"
            ? ((L = "hidden"), (A = "visibilitychange"))
            : typeof document.mozHidden != "undefined"
            ? ((L = "mozHidden"), (A = "mozvisibilitychange"))
            : typeof document.msHidden != "undefined"
                ? ((L = "msHidden"), (A = "msvisibilitychange"))
                : typeof document.webkitHidden != "undefined" && ((L = "webkitHidden"), (A = "webkitvisibilitychange")),
        typeof document.addEventListener != "undefined" && document.addEventListener(A, O, !1);
        var M = $(".about"),
            D = $(".thumbnails").find("li").not(":last-child"),
            P = $(".current-page"),
            H = $(".caption");
        $(".close").on("click", function () {
            M.removeClass("visible");
        }),
            $(".about-link").on("click", function () {
                M.toggleClass("visible");
            }),
            $(".arrow.previous").on("click", function () {
                B();
            }),
            $(".arrow.next").on("click", function () {
                j();
            }),
            D.on("click", F);
    }),
    !function () {
        var e = this,
            t = e._,
            n = {},
            r = Array.prototype,
            i = Object.prototype,
            s = Function.prototype,
            o = r.push,
            u = r.slice,
            a = r.concat,
            f = i.toString,
            l = i.hasOwnProperty,
            c = r.forEach,
            h = r.map,
            p = r.reduce,
            d = r.reduceRight,
            v = r.filter,
            m = r.every,
            g = r.some,
            y = r.indexOf,
            b = r.lastIndexOf,
            w = Array.isArray,
            E = Object.keys,
            S = s.bind,
            x = function (e) {
                return e instanceof x ? e : this instanceof x ? ((this._wrapped = e), void 0) : new x(e);
            };
        "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = x), (exports._ = x)) : (e._ = x), (x.VERSION = "1.5.1");
        var T = (x.each = x.forEach = function (e, t, r) {
            if (null != e)
                if (c && e.forEach === c) e.forEach(t, r);
                else if (e.length === +e.length) {
                    for (var i = 0, s = e.length; s > i; i++) if (t.call(r, e[i], i, e) === n) return;
                } else for (var o in e) if (x.has(e, o) && t.call(r, e[o], o, e) === n) return;
        });
        x.map = x.collect = function (e, t, n) {
            var r = [];
            return null == e
                ? r
                : h && e.map === h
                    ? e.map(t, n)
                    : (T(e, function (e, i, s) {
                        r.push(t.call(n, e, i, s));
                    }),
                        r);
        };
        var N = "Reduce of empty array with no initial value";
        (x.reduce = x.foldl = x.inject = function (e, t, n, r) {
            var i = arguments.length > 2;
            if ((null == e && (e = []), p && e.reduce === p)) return r && (t = x.bind(t, r)), i ? e.reduce(t, n) : e.reduce(t);
            if (
                (T(e, function (e, s, o) {
                    i ? (n = t.call(r, n, e, s, o)) : ((n = e), (i = !0));
                }),
                    !i)
            )
                throw new TypeError(N);
            return n;
        }),
            (x.reduceRight = x.foldr = function (e, t, n, r) {
                var i = arguments.length > 2;
                if ((null == e && (e = []), d && e.reduceRight === d)) return r && (t = x.bind(t, r)), i ? e.reduceRight(t, n) : e.reduceRight(t);
                var s = e.length;
                if (s !== +s) {
                    var o = x.keys(e);
                    s = o.length;
                }
                if (
                    (T(e, function (u, a, f) {
                        (a = o ? o[--s] : --s), i ? (n = t.call(r, n, e[a], a, f)) : ((n = e[a]), (i = !0));
                    }),
                        !i)
                )
                    throw new TypeError(N);
                return n;
            }),
            (x.find = x.detect = function (e, t, n) {
                var r;
                return (
                    C(e, function (e, i, s) {
                        return t.call(n, e, i, s) ? ((r = e), !0) : void 0;
                    }),
                        r
                );
            }),
            (x.filter = x.select = function (e, t, n) {
                var r = [];
                return null == e
                    ? r
                    : v && e.filter === v
                        ? e.filter(t, n)
                        : (T(e, function (e, i, s) {
                            t.call(n, e, i, s) && r.push(e);
                        }),
                            r);
            }),
            (x.reject = function (e, t, n) {
                return x.filter(
                    e,
                    function (e, r, i) {
                        return !t.call(n, e, r, i);
                    },
                    n
                );
            }),
            (x.every = x.all = function (e, t, r) {
                t || (t = x.identity);
                var i = !0;
                return null == e
                    ? i
                    : m && e.every === m
                        ? e.every(t, r)
                        : (T(e, function (e, s, o) {
                            return (i = i && t.call(r, e, s, o)) ? void 0 : n;
                        }),
                            !!i);
            });
        var C = (x.some = x.any = function (e, t, r) {
            t || (t = x.identity);
            var i = !1;
            return null == e
                ? i
                : g && e.some === g
                    ? e.some(t, r)
                    : (T(e, function (e, s, o) {
                        return i || (i = t.call(r, e, s, o)) ? n : void 0;
                    }),
                        !!i);
        });
        (x.contains = x.include = function (e, t) {
            return null == e
                ? !1
                : y && e.indexOf === y
                    ? e.indexOf(t) != -1
                    : C(e, function (e) {
                        return e === t;
                    });
        }),
            (x.invoke = function (e, t) {
                var n = u.call(arguments, 2),
                    r = x.isFunction(t);
                return x.map(e, function (e) {
                    return (r ? t : e[t]).apply(e, n);
                });
            }),
            (x.pluck = function (e, t) {
                return x.map(e, function (e) {
                    return e[t];
                });
            }),
            (x.where = function (e, t, n) {
                return x.isEmpty(t)
                    ? n
                        ? void 0
                        : []
                    : x[n ? "find" : "filter"](e, function (e) {
                        for (var n in t) if (t[n] !== e[n]) return !1;
                        return !0;
                    });
            }),
            (x.findWhere = function (e, t) {
                return x.where(e, t, !0);
            }),
            (x.max = function (e, t, n) {
                if (!t && x.isArray(e) && e[0] === +e[0] && e.length < 65535) return Math.max.apply(Math, e);
                if (!t && x.isEmpty(e)) return -1 / 0;
                var r = { computed: -1 / 0, value: -1 / 0 };
                return (
                    T(e, function (e, i, s) {
                        var o = t ? t.call(n, e, i, s) : e;
                        o > r.computed && (r = { value: e, computed: o });
                    }),
                        r.value
                );
            }),
            (x.min = function (e, t, n) {
                if (!t && x.isArray(e) && e[0] === +e[0] && e.length < 65535) return Math.min.apply(Math, e);
                if (!t && x.isEmpty(e)) return 1 / 0;
                var r = { computed: 1 / 0, value: 1 / 0 };
                return (
                    T(e, function (e, i, s) {
                        var o = t ? t.call(n, e, i, s) : e;
                        o < r.computed && (r = { value: e, computed: o });
                    }),
                        r.value
                );
            }),
            (x.shuffle = function (e) {
                var t,
                    n = 0,
                    r = [];
                return (
                    T(e, function (e) {
                        (t = x.random(n++)), (r[n - 1] = r[t]), (r[t] = e);
                    }),
                        r
                );
            });
        var k = function (e) {
            return x.isFunction(e)
                ? e
                : function (t) {
                    return t[e];
                };
        };
        x.sortBy = function (e, t, n) {
            var r = k(t);
            return x.pluck(
                x
                    .map(e, function (e, t, i) {
                        return { value: e, index: t, criteria: r.call(n, e, t, i) };
                    })
                    .sort(function (e, t) {
                        var n = e.criteria,
                            r = t.criteria;
                        if (n !== r) {
                            if (n > r || n === void 0) return 1;
                            if (r > n || r === void 0) return -1;
                        }
                        return e.index < t.index ? -1 : 1;
                    }),
                "value"
            );
        };
        var L = function (e, t, n, r) {
            var i = {},
                s = k(null == t ? x.identity : t);
            return (
                T(e, function (t, o) {
                    var u = s.call(n, t, o, e);
                    r(i, u, t);
                }),
                    i
            );
        };
        (x.groupBy = function (e, t, n) {
            return L(e, t, n, function (e, t, n) {
                (x.has(e, t) ? e[t] : (e[t] = [])).push(n);
            });
        }),
            (x.countBy = function (e, t, n) {
                return L(e, t, n, function (e, t) {
                    x.has(e, t) || (e[t] = 0), e[t]++;
                });
            }),
            (x.sortedIndex = function (e, t, n, r) {
                n = null == n ? x.identity : k(n);
                for (var i = n.call(r, t), s = 0, o = e.length; o > s; ) {
                    var u = (s + o) >>> 1;
                    n.call(r, e[u]) < i ? (s = u + 1) : (o = u);
                }
                return s;
            }),
            (x.toArray = function (e) {
                return e ? (x.isArray(e) ? u.call(e) : e.length === +e.length ? x.map(e, x.identity) : x.values(e)) : [];
            }),
            (x.size = function (e) {
                return null == e ? 0 : e.length === +e.length ? e.length : x.keys(e).length;
            }),
            (x.first = x.head = x.take = function (e, t, n) {
                return null == e ? void 0 : null == t || n ? e[0] : u.call(e, 0, t);
            }),
            (x.initial = function (e, t, n) {
                return u.call(e, 0, e.length - (null == t || n ? 1 : t));
            }),
            (x.last = function (e, t, n) {
                return null == e ? void 0 : null == t || n ? e[e.length - 1] : u.call(e, Math.max(e.length - t, 0));
            }),
            (x.rest = x.tail = x.drop = function (e, t, n) {
                return u.call(e, null == t || n ? 1 : t);
            }),
            (x.compact = function (e) {
                return x.filter(e, x.identity);
            });
        var A = function (e, t, n) {
            return t && x.every(e, x.isArray)
                ? a.apply(n, e)
                : (T(e, function (e) {
                    x.isArray(e) || x.isArguments(e) ? (t ? o.apply(n, e) : A(e, t, n)) : n.push(e);
                }),
                    n);
        };
        (x.flatten = function (e, t) {
            return A(e, t, []);
        }),
            (x.without = function (e) {
                return x.difference(e, u.call(arguments, 1));
            }),
            (x.uniq = x.unique = function (e, t, n, r) {
                x.isFunction(t) && ((r = n), (n = t), (t = !1));
                var i = n ? x.map(e, n, r) : e,
                    s = [],
                    o = [];
                return (
                    T(i, function (n, r) {
                        (t ? r && o[o.length - 1] === n : x.contains(o, n)) || (o.push(n), s.push(e[r]));
                    }),
                        s
                );
            }),
            (x.union = function () {
                return x.uniq(x.flatten(arguments, !0));
            }),
            (x.intersection = function (e) {
                var t = u.call(arguments, 1);
                return x.filter(x.uniq(e), function (e) {
                    return x.every(t, function (t) {
                        return x.indexOf(t, e) >= 0;
                    });
                });
            }),
            (x.difference = function (e) {
                var t = a.apply(r, u.call(arguments, 1));
                return x.filter(e, function (e) {
                    return !x.contains(t, e);
                });
            }),
            (x.zip = function () {
                for (var e = x.max(x.pluck(arguments, "length").concat(0)), t = new Array(e), n = 0; e > n; n++) t[n] = x.pluck(arguments, "" + n);
                return t;
            }),
            (x.object = function (e, t) {
                if (null == e) return {};
                for (var n = {}, r = 0, i = e.length; i > r; r++) t ? (n[e[r]] = t[r]) : (n[e[r][0]] = e[r][1]);
                return n;
            }),
            (x.indexOf = function (e, t, n) {
                if (null == e) return -1;
                var r = 0,
                    i = e.length;
                if (n) {
                    if ("number" != typeof n) return (r = x.sortedIndex(e, t)), e[r] === t ? r : -1;
                    r = 0 > n ? Math.max(0, i + n) : n;
                }
                if (y && e.indexOf === y) return e.indexOf(t, n);
                for (; i > r; r++) if (e[r] === t) return r;
                return -1;
            }),
            (x.lastIndexOf = function (e, t, n) {
                if (null == e) return -1;
                var r = null != n;
                if (b && e.lastIndexOf === b) return r ? e.lastIndexOf(t, n) : e.lastIndexOf(t);
                for (var i = r ? n : e.length; i--; ) if (e[i] === t) return i;
                return -1;
            }),
            (x.range = function (e, t, n) {
                arguments.length <= 1 && ((t = e || 0), (e = 0)), (n = arguments[2] || 1);
                for (var r = Math.max(Math.ceil((t - e) / n), 0), i = 0, s = new Array(r); r > i; ) (s[i++] = e), (e += n);
                return s;
            });
        var O = function () {};
        (x.bind = function (e, t) {
            var n, r;
            if (S && e.bind === S) return S.apply(e, u.call(arguments, 1));
            if (!x.isFunction(e)) throw new TypeError();
            return (
                (n = u.call(arguments, 2)),
                    (r = function () {
                        if (this instanceof r) {
                            O.prototype = e.prototype;
                            var i = new O();
                            O.prototype = null;
                            var s = e.apply(i, n.concat(u.call(arguments)));
                            return Object(s) === s ? s : i;
                        }
                        return e.apply(t, n.concat(u.call(arguments)));
                    })
            );
        }),
            (x.partial = function (e) {
                var t = u.call(arguments, 1);
                return function () {
                    return e.apply(this, t.concat(u.call(arguments)));
                };
            }),
            (x.bindAll = function (e) {
                var t = u.call(arguments, 1);
                if (0 === t.length) throw new Error("bindAll must be passed function names");
                return (
                    T(t, function (t) {
                        e[t] = x.bind(e[t], e);
                    }),
                        e
                );
            }),
            (x.memoize = function (e, t) {
                var n = {};
                return (
                    t || (t = x.identity),
                        function () {
                            var r = t.apply(this, arguments);
                            return x.has(n, r) ? n[r] : (n[r] = e.apply(this, arguments));
                        }
                );
            }),
            (x.delay = function (e, t) {
                var n = u.call(arguments, 2);
                return setTimeout(function () {
                    return e.apply(null, n);
                }, t);
            }),
            (x.defer = function (e) {
                return x.delay.apply(x, [e, 1].concat(u.call(arguments, 1)));
            }),
            (x.throttle = function (e, t, n) {
                var r,
                    i,
                    s,
                    o = null,
                    u = 0;
                n || (n = {});
                var a = function () {
                    (u = n.leading === !1 ? 0 : new Date()), (o = null), (s = e.apply(r, i));
                };
                return function () {
                    var f = new Date();
                    u || n.leading !== !1 || (u = f);
                    var l = t - (f - u);
                    return (r = this), (i = arguments), 0 >= l ? (clearTimeout(o), (o = null), (u = f), (s = e.apply(r, i))) : o || n.trailing === !1 || (o = setTimeout(a, l)), s;
                };
            }),
            (x.debounce = function (e, t, n) {
                var r,
                    i = null;
                return function () {
                    var s = this,
                        o = arguments,
                        u = function () {
                            (i = null), n || (r = e.apply(s, o));
                        },
                        a = n && !i;
                    return clearTimeout(i), (i = setTimeout(u, t)), a && (r = e.apply(s, o)), r;
                };
            }),
            (x.once = function (e) {
                var t,
                    n = !1;
                return function () {
                    return n ? t : ((n = !0), (t = e.apply(this, arguments)), (e = null), t);
                };
            }),
            (x.wrap = function (e, t) {
                return function () {
                    var n = [e];
                    return o.apply(n, arguments), t.apply(this, n);
                };
            }),
            (x.compose = function () {
                var e = arguments;
                return function () {
                    for (var t = arguments, n = e.length - 1; n >= 0; n--) t = [e[n].apply(this, t)];
                    return t[0];
                };
            }),
            (x.after = function (e, t) {
                return function () {
                    return --e < 1 ? t.apply(this, arguments) : void 0;
                };
            }),
            (x.keys =
                E ||
                function (e) {
                    if (e !== Object(e)) throw new TypeError("Invalid object");
                    var t = [];
                    for (var n in e) x.has(e, n) && t.push(n);
                    return t;
                }),
            (x.values = function (e) {
                var t = [];
                for (var n in e) x.has(e, n) && t.push(e[n]);
                return t;
            }),
            (x.pairs = function (e) {
                var t = [];
                for (var n in e) x.has(e, n) && t.push([n, e[n]]);
                return t;
            }),
            (x.invert = function (e) {
                var t = {};
                for (var n in e) x.has(e, n) && (t[e[n]] = n);
                return t;
            }),
            (x.functions = x.methods = function (e) {
                var t = [];
                for (var n in e) x.isFunction(e[n]) && t.push(n);
                return t.sort();
            }),
            (x.extend = function (e) {
                return (
                    T(u.call(arguments, 1), function (t) {
                        if (t) for (var n in t) e[n] = t[n];
                    }),
                        e
                );
            }),
            (x.pick = function (e) {
                var t = {},
                    n = a.apply(r, u.call(arguments, 1));
                return (
                    T(n, function (n) {
                        n in e && (t[n] = e[n]);
                    }),
                        t
                );
            }),
            (x.omit = function (e) {
                var t = {},
                    n = a.apply(r, u.call(arguments, 1));
                for (var i in e) x.contains(n, i) || (t[i] = e[i]);
                return t;
            }),
            (x.defaults = function (e) {
                return (
                    T(u.call(arguments, 1), function (t) {
                        if (t) for (var n in t) e[n] === void 0 && (e[n] = t[n]);
                    }),
                        e
                );
            }),
            (x.clone = function (e) {
                return x.isObject(e) ? (x.isArray(e) ? e.slice() : x.extend({}, e)) : e;
            }),
            (x.tap = function (e, t) {
                return t(e), e;
            });
        var M = function (e, t, n, r) {
            if (e === t) return 0 !== e || 1 / e == 1 / t;
            if (null == e || null == t) return e === t;
            e instanceof x && (e = e._wrapped), t instanceof x && (t = t._wrapped);
            var i = f.call(e);
            if (i != f.call(t)) return !1;
            switch (i) {
                case "[object String]":
                    return e == String(t);
                case "[object Number]":
                    return e != +e ? t != +t : 0 == e ? 1 / e == 1 / t : e == +t;
                case "[object Date]":
                case "[object Boolean]":
                    return +e == +t;
                case "[object RegExp]":
                    return e.source == t.source && e.global == t.global && e.multiline == t.multiline && e.ignoreCase == t.ignoreCase;
            }
            if ("object" != typeof e || "object" != typeof t) return !1;
            for (var s = n.length; s--; ) if (n[s] == e) return r[s] == t;
            var o = e.constructor,
                u = t.constructor;
            if (o !== u && !(x.isFunction(o) && o instanceof o && x.isFunction(u) && u instanceof u)) return !1;
            n.push(e), r.push(t);
            var a = 0,
                l = !0;
            if ("[object Array]" == i) {
                if (((a = e.length), (l = a == t.length))) for (; a-- && (l = M(e[a], t[a], n, r)); );
            } else {
                for (var c in e) if (x.has(e, c) && (a++, !(l = x.has(t, c) && M(e[c], t[c], n, r)))) break;
                if (l) {
                    for (c in t) if (x.has(t, c) && !a--) break;
                    l = !a;
                }
            }
            return n.pop(), r.pop(), l;
        };
        (x.isEqual = function (e, t) {
            return M(e, t, [], []);
        }),
            (x.isEmpty = function (e) {
                if (null == e) return !0;
                if (x.isArray(e) || x.isString(e)) return 0 === e.length;
                for (var t in e) if (x.has(e, t)) return !1;
                return !0;
            }),
            (x.isElement = function (e) {
                return !!e && 1 === e.nodeType;
            }),
            (x.isArray =
                w ||
                function (e) {
                    return "[object Array]" == f.call(e);
                }),
            (x.isObject = function (e) {
                return e === Object(e);
            }),
            T(["Arguments", "Function", "String", "Number", "Date", "RegExp"], function (e) {
                x["is" + e] = function (t) {
                    return f.call(t) == "[object " + e + "]";
                };
            }),
        x.isArguments(arguments) ||
        (x.isArguments = function (e) {
            return !!e && !!x.has(e, "callee");
        }),
        "function" != typeof /./ &&
        (x.isFunction = function (e) {
            return "function" == typeof e;
        }),
            (x.isFinite = function (e) {
                return isFinite(e) && !isNaN(parseFloat(e));
            }),
            (x.isNaN = function (e) {
                return x.isNumber(e) && e != +e;
            }),
            (x.isBoolean = function (e) {
                return e === !0 || e === !1 || "[object Boolean]" == f.call(e);
            }),
            (x.isNull = function (e) {
                return null === e;
            }),
            (x.isUndefined = function (e) {
                return e === void 0;
            }),
            (x.has = function (e, t) {
                return l.call(e, t);
            }),
            (x.noConflict = function () {
                return (e._ = t), this;
            }),
            (x.identity = function (e) {
                return e;
            }),
            (x.times = function (e, t, n) {
                for (var r = Array(Math.max(0, e)), i = 0; e > i; i++) r[i] = t.call(n, i);
                return r;
            }),
            (x.random = function (e, t) {
                return null == t && ((t = e), (e = 0)), e + Math.floor(Math.random() * (t - e + 1));
            });
        var _ = { escape: { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "/": "&#x2F;" } };
        _.unescape = x.invert(_.escape);
        var D = { escape: new RegExp("[" + x.keys(_.escape).join("") + "]", "g"), unescape: new RegExp("(" + x.keys(_.unescape).join("|") + ")", "g") };
        x.each(["escape", "unescape"], function (e) {
            x[e] = function (t) {
                return null == t
                    ? ""
                    : ("" + t).replace(D[e], function (t) {
                        return _[e][t];
                    });
            };
        }),
            (x.result = function (e, t) {
                if (null == e) return void 0;
                var n = e[t];
                return x.isFunction(n) ? n.call(e) : n;
            }),
            (x.mixin = function (e) {
                T(x.functions(e), function (t) {
                    var n = (x[t] = e[t]);
                    x.prototype[t] = function () {
                        var e = [this._wrapped];
                        return o.apply(e, arguments), F.call(this, n.apply(x, e));
                    };
                });
            });
        var P = 0;
        (x.uniqueId = function (e) {
            var t = ++P + "";
            return e ? e + t : t;
        }),
            (x.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g });
        var H = /(.)^/,
            B = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "	": "t", "\u2028": "u2028", "\u2029": "u2029" },
            j = /\\|'|\r|\n|\t|\u2028|\u2029/g;
        (x.template = function (e, t, n) {
            var r;
            n = x.defaults({}, n, x.templateSettings);
            var i = new RegExp([(n.escape || H).source, (n.interpolate || H).source, (n.evaluate || H).source].join("|") + "|$", "g"),
                s = 0,
                o = "__p+='";
            e.replace(i, function (t, n, r, i, u) {
                return (
                    (o += e.slice(s, u).replace(j, function (e) {
                        return "\\" + B[e];
                    })),
                    n && (o += "'+\n((__t=(" + n + "))==null?'':_.escape(__t))+\n'"),
                    r && (o += "'+\n((__t=(" + r + "))==null?'':__t)+\n'"),
                    i && (o += "';\n" + i + "\n__p+='"),
                        (s = u + t.length),
                        t
                );
            }),
                (o += "';\n"),
            n.variable || (o = "with(obj||{}){\n" + o + "}\n"),
                (o = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + o + "return __p;\n");
            try {
                r = new Function(n.variable || "obj", "_", o);
            } catch (u) {
                throw ((u.source = o), u);
            }
            if (t) return r(t, x);
            var a = function (e) {
                return r.call(this, e, x);
            };
            return (a.source = "function(" + (n.variable || "obj") + "){\n" + o + "}"), a;
        }),
            (x.chain = function (e) {
                return x(e).chain();
            });
        var F = function (e) {
            return this._chain ? x(e).chain() : e;
        };
        x.mixin(x),
            T(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (e) {
                var t = r[e];
                x.prototype[e] = function () {
                    var n = this._wrapped;
                    return t.apply(n, arguments), ("shift" != e && "splice" != e) || 0 !== n.length || delete n[0], F.call(this, n);
                };
            }),
            T(["concat", "join", "slice"], function (e) {
                var t = r[var requirejs, require, define;
                (function (e) {
                    function h(e, t) {
                        return f.call(e, t);
                    }
                    function p(e, t) {
                        var n,
                            r,
                            i,
                            s,
                            o,
                            a,
                            f,
                            l,
                            h,
                            p,
                            d,
                            v = t && t.split("/"),
                            m = u.map,
                            g = (m && m["*"]) || {};
                        if (e && e.charAt(0) === ".")
                            if (t) {
                                (v = v.slice(0, v.length - 1)), (e = e.split("/")), (o = e.length - 1), u.nodeIdCompat && c.test(e[o]) && (e[o] = e[o].replace(c, "")), (e = v.concat(e));
                                for (h = 0; h < e.length; h += 1) {
                                    d = e[h];
                                    if (d === ".") e.splice(h, 1), (h -= 1);
                                    else if (d === "..") {
                                        if (h === 1 && (e[2] === ".." || e[0] === "..")) break;
                                        h > 0 && (e.splice(h - 1, 2), (h -= 2));
                                    }
                                }
                                e = e.join("/");
                            } else e.indexOf("./") === 0 && (e = e.substring(2));
                        if ((v || g) && m) {
                            n = e.split("/");
                            for (h = n.length; h > 0; h -= 1) {
                                r = n.slice(0, h).join("/");
                                if (v)
                                    for (p = v.length; p > 0; p -= 1) {
                                        i = m[v.slice(0, p).join("/")];
                                        if (i) {
                                            i = i[r];
                                            if (i) {
                                                (s = i), (a = h);
                                                break;
                                            }
                                        }
                                    }
                                if (s) break;
                                !f && g && g[r] && ((f = g[r]), (l = h));
                            }
                            !s && f && ((s = f), (a = l)), s && (n.splice(0, a, s), (e = n.join("/")));
                        }
                        return e;
                    }
                    function d(t, r) {
                        return function () {
                            return n.apply(e, l.call(arguments, 0).concat([t, r]));
                        };
                    }
                    function v(e) {
                        return function (t) {
                            return p(t, e);
                        };
                    }
                    function m(e) {
                        return function (t) {
                            s[e] = t;
                        };
                    }
                    function g(n) {
                        if (h(o, n)) {
                            var r = o[n];
                            delete o[n], (a[n] = !0), t.apply(e, r);
                        }
                        if (!h(s, n) && !h(a, n)) throw new Error("No " + n);
                        return s[n];
                    }
                    function y(e) {
                        var t,
                            n = e ? e.indexOf("!") : -1;
                        return n > -1 && ((t = e.substring(0, n)), (e = e.substring(n + 1, e.length))), [t, e];
                    }
                    function b(e) {
                        return function () {
                            return (u && u.config && u.config[e]) || {};
                        };
                    }
                    var t,
                        n,
                        r,
                        i,
                        s = {},
                        o = {},
                        u = {},
                        a = {},
                        f = Object.prototype.hasOwnProperty,
                        l = [].slice,
                        c = /\.js$/;
                    (r = function (e, t) {
                        var n,
                            r = y(e),
                            i = r[0];
                        return (
                            (e = r[1]),
                            i && ((i = p(i, t)), (n = g(i))),
                                i ? (n && n.normalize ? (e = n.normalize(e, v(t))) : (e = p(e, t))) : ((e = p(e, t)), (r = y(e)), (i = r[0]), (e = r[1]), i && (n = g(i))),
                                { f: i ? i + "!" + e : e, n: e, pr: i, p: n }
                        );
                    }),
                        (i = {
                            require: function (e) {
                                return d(e);
                            },
                            exports: function (e) {
                                var t = s[e];
                                return typeof t != "undefined" ? t : (s[e] = {});
                            },
                            module: function (e) {
                                return { id: e, uri: "", exports: s[e], config: b(e) };
                            },
                        }),
                        (t = function (t, n, u, f) {
                            var l,
                                c,
                                p,
                                v,
                                y,
                                b = [],
                                w = typeof u,
                                E;
                            f = f || t;
                            if (w === "undefined" || w === "function") {
                                n = !n.length && u.length ? ["require", "exports", "module"] : n;
                                for (y = 0; y < n.length; y += 1) {
                                    (v = r(n[y], f)), (c = v.f);
                                    if (c === "require") b[y] = i.require(t);
                                    else if (c === "exports") (b[y] = i.exports(t)), (E = !0);
                                    else if (c === "module") l = b[y] = i.module(t);
                                    else if (h(s, c) || h(o, c) || h(a, c)) b[y] = g(c);
                                    else {
                                        if (!v.p) throw new Error(t + " missing " + c);
                                        v.p.load(v.n, d(f, !0), m(c), {}), (b[y] = s[c]);
                                    }
                                }
                                p = u ? u.apply(s[t], b) : undefined;
                                if (t)
                                    if (l && l.exports !== e && l.exports !== s[t]) s[t] = l.exports;
                                    else if (p !== e || !E) s[t] = p;
                            } else t && (s[t] = u);
                        }),
                        (requirejs = require = n = function (s, o, a, f, l) {
                            if (typeof s == "string") return i[s] ? i[s](o) : g(r(s, o).f);
                            if (!s.splice) {
                                (u = s), u.deps && n(u.deps, u.callback);
                                if (!o) return;
                                o.splice ? ((s = o), (o = a), (a = null)) : (s = e);
                            }
                            return (
                                (o = o || function () {}),
                                typeof a == "function" && ((a = f), (f = l)),
                                    f
                                        ? t(e, s, o, a)
                                        : setTimeout(function () {
                                            t(e, s, o, a);
                                        }, 4),
                                    n
                            );
                        }),
                        (n.config = function (e) {
                            return n(e);
                        }),
                        (requirejs._defined = s),
                        (define = function (e, t, n) {
                            t.splice || ((n = t), (t = [])), !h(s, e) && !h(o, e) && (o[e] = [e, t, n]);
                        }),
                        (define.amd = { jQuery: !0 });
                })(),
                    define("almond", function () {}),
                    define("class", [], function () {
                        var e = function () {
                                this.initialize.apply(this, arguments);
                            },
                            t = function (e, t) {
                                var n = this,
                                    r;
                                e && _.has(e, "constructor")
                                    ? (r = e.constructor)
                                    : (r = function () {
                                        return n.apply(this, arguments);
                                    }),
                                    _.extend(r, n, t);
                                var i = function () {
                                    this.constructor = r;
                                };
                                return (i.prototype = n.prototype), (r.prototype = new i()), e && _.extend(r.prototype, e), (r.__super__ = n.prototype), r;
                            };
                        e.extend = t;
                        var n = {
                                on: function (e, t, n) {
                                    if (!i(this, "on", e, [t, n]) || !t) return this;
                                    this._events || (this._events = {});
                                    var r = this._events[e] || (this._events[e] = []);
                                    return r.push({ callback: t, context: n, ctx: n || this }), this;
                                },
                                off: function (e, t, n) {
                                    var r, s, o, u, a, f, l, c;
                                    if (!this._events || !i(this, "off", e, [t, n])) return this;
                                    if (!e && !t && !n) return (this._events = {}), this;
                                    u = e ? [e] : _.keys(this._events);
                                    for (a = 0, f = u.length; a < f; a++) {
                                        e = u[a];
                                        if ((o = this._events[e])) {
                                            this._events[e] = r = [];
                                            if (t || n) for (l = 0, c = o.length; l < c; l++) (s = o[l]), ((t && t !== s.callback && t !== s.callback._callback) || (n && n !== s.context)) && r.push(s);
                                            r.length || delete this._events[e];
                                        }
                                    }
                                    return this;
                                },
                                trigger: function (e) {
                                    if (!this._events) return this;
                                    var t = [].slice.call(arguments, 1);
                                    if (!i(this, "trigger", e, t)) return this;
                                    var n = this._events[e],
                                        r = this._events.all;
                                    return n && s(n, t), r && s(r, arguments), this;
                                },
                            },
                            r = /\s+/,
                            i = function (e, t, n, i) {
                                if (!n) return !0;
                                if (typeof n == "object") {
                                    for (var s in n) e[t].apply(e, [s, n[s]].concat(i));
                                    return !1;
                                }
                                if (r.test(n)) {
                                    var o = n.split(r);
                                    for (var u = 0, a = o.length; u < a; u++) e[t].apply(e, [o[u]].concat(i));
                                    return !1;
                                }
                                return !0;
                            },
                            s = function (e, t) {
                                var n,
                                    r = -1,
                                    i = e.length,
                                    s = t[0],
                                    o = t[1],
                                    u = t[2];
                                switch (t.length) {
                                    case 0:
                                        while (++r < i) (n = e[r]).callback.call(n.ctx);
                                        return;
                                    case 1:
                                        while (++r < i) (n = e[r]).callback.call(n.ctx, s);
                                        return;
                                    case 2:
                                        while (++r < i) (n = e[r]).callback.call(n.ctx, s, o);
                                        return;
                                    case 3:
                                        while (++r < i) (n = e[r]).callback.call(n.ctx, s, o, u);
                                        return;
                                    default:
                                        while (++r < i) (n = e[r]).callback.apply(n.ctx, t);
                                }
                            };
                        return _.extend(e.prototype, n), e;
                    }),
                    define("textureloader", ["class"], function (e) {
                        var t = e.extend({
                            initialize: function (e) {
                                (this.loaded = !1), (this.textures = {}), (this.path = e.path), (this.files = e.files);
                            },
                            loadAllFiles: function () {
                                var e = new jQuery.Deferred(),
                                    t = _.size(this.files);
                                return (
                                    _.each(
                                        this.files,
                                        function (n, r) {
                                            this.textures[r] = new THREE.ImageUtils.loadTexture(this.path + n, null, function () {
                                                --t == 0 && e.resolve();
                                            });
                                        },
                                        this
                                    ),
                                        (this.loaded = !0),
                                        e.promise()
                                );
                            },
                            getById: function (e) {
                                return this.loaded || this.loadAllFiles(), this.textures[e];
                            },
                        });
                        return t;
                    }),
                    define("neons/textures", ["../textureloader"], function (e) {
                        var t = "textures/neons/",
                            n = { lightgradient: "light-gradient.png", light: "light.png", head: "head.png", flare: "flare.png", grid: "grid.png", tower: "tower.png", box: "box.png" },
                            r = new e({ files: n, path: t });
                        return { loadAll: r.loadAllFiles.bind(r), get: r.getById.bind(r) };
                    }),
                    define("neons/objects", ["./textures"], function (e) {
                        var t = {};
                        return (
                            (t.createGround = function (t) {
                                var t = _.extend({ opacity: 1 }, t),
                                    n = e.get("grid");
                                (n.wrapS = THREE.RepeatWrapping), (n.wrapT = THREE.RepeatWrapping), (n.repeat.x = 80), (n.repeat.y = 16);
                                var r = new THREE.Mesh(new THREE.PlaneGeometry(10240, 2048, 1, 1), new THREE.MeshPhongMaterial({ map: n, shininess: 1, specular: 0 }));
                                return (r.position.y = 0.01), (r.rotation.x = -Math.PI / 2), (r.position.x = 2560), r;
                            }),
                                (t.createLine = function (e) {
                                    var e = _.extend({ color: 16777215, start: 0, end: 5e3, pos: 10, linewidth: 1, speed: 250 }, e),
                                        t = new THREE.Geometry(),
                                        n = new THREE.LineBasicMaterial({ color: e.color, blending: THREE.AdditiveBlending, linewidth: e.linewidth });
                                    t.vertices = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(e.end, 0, 0)];
                                    var r = new THREE.Line(t, n);
                                    return (
                                        (r.type = THREE.LinePieces),
                                            (r.start = e.start),
                                            (r.end = e.end),
                                            (r.speed = e.speed),
                                            (r.geometry.dynamic = !0),
                                            r.position.set(e.start, 0.5, e.pos - 500),
                                            (r.update = function (e) {
                                                (r.geometry.vertices[1].x = e * r.end), (r.geometry.verticesNeedUpdate = !0);
                                            }),
                                            r
                                    );
                                }),
                                (t.createQuad = function (e) {
                                    var t = new THREE.Mesh(new THREE.PlaneGeometry(e.width, e.height, 1, 1), e.material);
                                    return t;
                                }),
                                (t.createFlare = function (e) {
                                    var n = e.width || 128,
                                        r = e.height || 128,
                                        i = new THREE.Geometry(),
                                        s = new THREE.MeshBasicMaterial({ map: e.map, transparent: !0, depthWrite: !1, depthTest: !1, blending: THREE.AdditiveBlending, side: THREE.DoubleSide }),
                                        o = t.createQuad({ width: n, height: r, material: s });
                                    return o;
                                }),
                                t
                        );
                    }),
                    define("modelloader", ["class"], function (e) {
                        var t = e.extend({
                            initialize: function (e) {
                                (this.loaded = !1), (this.models = {}), (this.path = e.path), (this.files = e.files);
                            },
                            loadAllFiles: function () {
                                var e = new jQuery.Deferred(),
                                    t = _.size(this.files),
                                    n = this.models,
                                    r = new THREE.JSONLoader();
                                return (
                                    _.each(
                                        this.files,
                                        function (i, s) {
                                            r.load(this.path + i, function (r, i) {
                                                (n[s] = new THREE.Mesh(r, new THREE.MeshFaceMaterial(i))), --t == 0 && e.resolve();
                                            });
                                        },
                                        this
                                    ),
                                        (this.loaded = !0),
                                        e.promise()
                                );
                            },
                            getById: function (e) {
                                return this.loaded || this.loadAllFiles(), this.models[e];
                            },
                        });
                        return t;
                    }),
                    define("neons/models", ["../modelloader"], function (e) {
                        var t = "models/",
                            n = { tower: "tower.js", box: "box.js" },
                            r = new e({ files: n, path: t });
                        return { loadAll: r.loadAllFiles.bind(r), get: r.getById.bind(r) };
                    }),
                    define("world", ["class"], function (e) {
                        function n(e) {
                            var e = _.extend({ fov: 45, aspectRatio: WIDTH / HEIGHT, near: 1, far: 1e4 }, e),
                                t = new THREE.PerspectiveCamera(e.fov, e.aspectRatio, e.near, e.far);
                            return t;
                        }
                        var t = e.extend({
                            initialize: function () {
                                (this.scene = new THREE.Scene()),
                                    (this.lights = []),
                                    (this.camera = n()),
                                    this.camera.position.set(0, 200, 550),
                                    this.camera.lookAt(new THREE.Vector3(0, -150, 0)),
                                    (this.cameraContainer = new THREE.Gyroscope()),
                                    this.cameraContainer.add(this.camera),
                                    this.scene.add(this.cameraContainer);
                            },
                            update: function () {},
                            setupDatGUI: function (e) {},
                            setupCompositing: function (e) {
                                var t = new THREE.RenderPass(this.scene, this.camera);
                                e.addPass(t);
                            },
                            initHelpers: function () {
                                (this.helpers = []),
                                    _.each(
                                        this.lights,
                                        _.bind(function (e) {
                                            var t = new THREE.PointLightHelper(e, 5);
                                            t.material.color.setHex(0), this.scene.add(t), this.helpers.push(t);
                                        }, this)
                                    );
                                var e = new THREE.AxisHelper(20);
                                (e.position.y += 0.05), this.scene.add(e), this.helpers.push(e);
                            },
                            toggleHelpers: function () {
                                _.each(this.helpers, function (e) {
                                    e.visible = !e.visible;
                                });
                            },
                            setAspectRatio: function (e) {
                                (this.camera.aspect = e), this.camera.updateProjectionMatrix();
                            },
                        });
                        return t;
                    }),
                    define("neons/neon", ["class", "./objects", "./textures"], function (e, t, n) {
                        function i(e) {
                            var t = [],
                                n = e.length;
                            return (
                                _.each(e, function (r, i) {
                                    i === 0 ? t.push(new THREE.Vector3(0, r, 0)) : r !== e[i - 1] && (t.push(new THREE.Vector3(i * 128, e[i - 1], 0)), t.push(new THREE.Vector3(i * 128, r, 0))), i === n - 1 && t.push(new THREE.Vector3((i + 1) * 128, r, 0));
                                }),
                                    t
                            );
                        }
                        var r = e.extend({
                            initialize: function (e) {
                                var t = new THREE.Object3D();
                                (this.scene = e.scene),
                                    (this.length = 0),
                                    this.createSegments({ vertices: i(e.row), start: 0, pos: e.pos }),
                                    t.add(this.segments),
                                    (this.obj = t),
                                    (this.segments = this.obj.children[0].children),
                                    (this.flares = []),
                                    this.createHead(),
                                    (this.currentSegmentIndex = 0),
                                    (this.speed = this.length / e.duration);
                            },
                            reset: function () {
                                _.each(this.segments, function (e) {
                                    (e.material.opacity = 0), (e.children[0].material.opacity = 0);
                                }),
                                    _.each(this.flares, function (e) {
                                        e.visible = !1;
                                    }),
                                    (this.flares = []);
                            },
                            getCurrentSegment: function () {
                                return this.segments[this.currentSegmentIndex];
                            },
                            getSegmentByProgress: function (e) {
                                return (
                                    e > 1 && (e = 1),
                                        _.find(
                                            this.segments,
                                            function (t) {
                                                return t.endingPosition / this.length >= e;
                                            },
                                            this
                                        )
                                );
                            },
                            getCurrentPosition: function (e) {
                                var t = new THREE.Vector3(0, 0, 0),
                                    n = this.getSegmentByProgress(e);
                                return n && ((t = n.geometry.vertices[1].clone()), t.applyMatrix4(n.matrixWorld), (t.z += 20)), t;
                            },
                            showSegment: function (e) {
                                (e.material.opacity = 1), (e.children[0].material.opacity = 1);
                            },
                            completeSegment: function (e) {
                                (e.geometry.vertices[1].x = e.length / 2), (e.geometry.vertices[3].x = e.length / 2), (e.geometry.verticesNeedUpdate = !0), e.orientation === 1 && _.contains(this.flares, e.flare) === !1 && this.flares.push(e.flare);
                            },
                            createSegment: function (e) {
                                var r = new THREE.MeshBasicMaterial({ map: e.map, transparent: !0, blending: THREE.AdditiveBlending, side: THREE.DoubleSide }),
                                    i = t.createQuad({ width: e.length, height: 60, material: r });
                                i.rotation.x = -Math.PI / 2;
                                var s = n.get("lightgradient"),
                                    o = i.clone();
                                (o.material = i.material.clone()),
                                    (o.material.map = s),
                                    i.add(o),
                                    e.orientation === 1 ? (i.rotation.y = -Math.PI / 2) : e.orientation === -1 && (i.rotation.y = Math.PI / 2),
                                    (i.length = e.length),
                                    (i.orientation = e.orientation),
                                    (o.position.z = 10),
                                    (o.rotation.x = Math.PI / 2),
                                    (o.material.depthWrite = !1),
                                    (i.material.opacity = 0),
                                    (o.material.opacity = 0);
                                if (i.orientation !== 0) {
                                    var u = t.createFlare({ map: n.get("flare"), height: 60, width: 60 });
                                    (u.visible = !1), this.scene.add(u), (i.flare = u), i.orientation !== 0 && i.flare.position.setY(e.length / 2);
                                }
                                return i;
                            },
                            createSegments: function (e) {
                                this.segments = new THREE.Object3D();
                                var t = n.get("light"),
                                    r = 0;
                                for (var i = 0; i < e.vertices.length - 1; i++) {
                                    var s = e.vertices[i],
                                        o = e.vertices[i + 1],
                                        u = s.distanceTo(o),
                                        a;
                                    r++;
                                    if (o.y > s.y) {
                                        a = 1;
                                        var f = this.createSegment({ map: t, length: u, orientation: a });
                                        f.position.set(s.x - 0.1, s.y + u / 2, e.pos - 512), f.flare.position.add(f.position);
                                    } else if (o.y < s.y) {
                                        a = -1;
                                        var f = this.createSegment({ map: t, length: u, orientation: a });
                                        f.position.set(s.x + 0.1, s.y - u / 2, e.pos - 512), f.flare.position.add(f.position);
                                    } else {
                                        a = 0;
                                        var f = this.createSegment({ map: t, length: u, orientation: a });
                                        f.position.set(s.x + u / 2, s.y + 0.1, e.pos - 512);
                                    }
                                    this.segments.add(f), (this.length += u), (f.startingPosition = this.length - u), (f.endingPosition = this.length), (f.index = r), i === 0 && ((f.frustumCulled = !1), (f.children[0].frustumCulled = !1));
                                }
                            },
                            createHead: function () {
                                var e = n.get("head"),
                                    r = new THREE.MeshBasicMaterial({ map: e, transparent: !0, blending: THREE.AdditiveBlending, side: THREE.DoubleSide }),
                                    i = t.createQuad({ height: 60, width: 60, material: r });
                                (i.rotation.x = Math.PI / 2), this.obj.add(i), (this.head = i);
                            },
                            moveTo: function (e, t) {
                                var n = e.startingPosition / this.length,
                                    r = e.endingPosition / this.length,
                                    i = r - n,
                                    s = (t - n) / i,
                                    o = s * e.length - e.length / 2;
                                _.each(
                                    _.first(this.segments, e.index),
                                    function (e) {
                                        this.completeSegment(e);
                                    },
                                    this
                                ),
                                    this.showSegment(e),
                                    (e.geometry.vertices[1].x = o),
                                    (e.geometry.vertices[3].x = o),
                                    (e.geometry.verticesNeedUpdate = !0),
                                    (this.head.position = this.getCurrentPosition(t)),
                                    (this.head.position.x += 30),
                                    (this.head.position.z += 10),
                                    this.updateComponents(e, s * e.length);
                            },
                            updateComponents: function (e, t) {
                                e.orientation === -1 && (_.contains(this.flares, e.flare) === !1 && this.flares.push(e.flare), (this.head.material.opacity = 0)),
                                e.orientation === 1 && (this.head.material.opacity = 0),
                                e.orientation === 0 &&
                                ((this.head.material.opacity = 1),
                                    t < 120
                                        ? ((this.head.geometry.vertices[1].x = t / 2 - 30), (this.head.geometry.vertices[3].x = t / 2 - 30), (this.head.geometry.verticesNeedUpdate = !0))
                                        : ((this.head.geometry.vertices[1].x = 30), (this.head.geometry.vertices[3].x = 30), (this.head.geometry.verticesNeedUpdate = !0)));
                            },
                            update: function (e, t, n, r) {
                                var i = this.getSegmentByProgress(r);
                                _.each(
                                    this.flares,
                                    function (r) {
                                        if (e.intersectsObject(r)) {
                                            n(r, r.position.clone()), r.lookAt(t.position);
                                            var i = r.position.distanceTo(t.position) / 500;
                                            r.scale.set(i, i, i);
                                        }
                                    },
                                    this
                                ),
                                    this.moveTo(i, r);
                            },
                        });
                        return r;
                    }),
                    define("neons/neons", ["../world", "./objects", "./textures", "./models", "./neon"], function (e, t, n, r, i) {
                        function a() {
                            var e = [4317433, 2228221, 1989848, 4097011],
                                t = Math.floor(Math.random() * 4);
                            return e[t];
                        }
                        var s = 17500,
                            o = (5120 / s) * 1e3,
                            u = e.extend({
                                initialize: function (t) {
                                    e.prototype.initialize.call(this);
                                    var n = this.loadBoxMap();
                                    (this.BOUNDARIES = { x: WIDTH / 10, y: HEIGHT / 10 }),
                                        (this.raycaster = new THREE.Raycaster()),
                                        (this.pointLights = new THREE.Object3D()),
                                        this.scene.add(this.pointLights),
                                        (this.progress = 0),
                                        this.createLights(),
                                        this.createGround(),
                                        this.createBoxes(n),
                                        this.createNeons(n, [8, 12, 16, 18, 20, 22]).done(this.start.bind(this)),
                                        this.createTowers(),
                                        this.createLines([6, 10, 11, 14, 15, 20, 23]),
                                        (this.camera.target = new THREE.Vector3(0, 0, 0)),
                                        this.camera.lookAt(this.camera.target);
                                },
                                start: function () {
                                    (this.started = !0), this.trigger("started");
                                },
                                createLights: function () {
                                    (this.dirLight = new THREE.DirectionalLight(16777215, 1)),
                                        this.dirLight.position.set(0, 500, -350),
                                        (this.dirLight.castShadow = !0),
                                        (this.dirLight.shadowDarkness = 0.25),
                                        this.scene.add(this.dirLight),
                                        (this.spotLight = new THREE.SpotLight(16777215)),
                                        this.spotLight.position.set(0, 400, -500),
                                        (this.spotLight.intensity = 4),
                                        (this.spotLight.angle = Math.PI / 12),
                                        (this.spotLight.exponent = 50),
                                        this.scene.add(this.spotLight),
                                        this.lights.push(this.spotLight);
                                },
                                createGround: function () {
                                    (this.ground = t.createGround({ opacity: 0.85 })), this.ground.position.setY(0.01), (this.ground.receiveShadow = !0), this.scene.add(this.ground);
                                },
                                loadBoxMap: function (e) {
                                    var t = new jQuery.Deferred(),
                                        n = new Image();
                                    return (
                                        (n.onload = function () {
                                            var e = document.createElement("canvas");
                                            (e.width = 40), (e.height = 32);
                                            var r = e.getContext("2d");
                                            r.drawImage(n, 0, 0, e.width, e.height);
                                            var i = r.getImageData(0, 0, e.width, e.height);
                                            t.resolve(i);
                                        }),
                                            (n.src = "textures/neons/map.png"),
                                            t.promise()
                                    );
                                },
                                createTowers: function (e) {
                                    this.towers = new THREE.Object3D();
                                    var t = r.get("tower"),
                                        i = n.get("tower"),
                                        s = new THREE.MeshPhongMaterial({ map: i, shading: THREE.FlatShading, shininess: 1 });
                                    (t.material.materials[0] = s), (t.material.materials[1].shading = THREE.FlatShading), (t.material.needsUpdate = !0), (t.castShadow = !0), (t.receiveShadow = !0);
                                    var t = t.clone();
                                    t.position.set(1500, 80, 200), this.towers.add(t);
                                    var t = t.clone();
                                    t.position.set(2500, 80, 300), this.towers.add(t);
                                    var t = t.clone();
                                    t.position.set(3e3, 80, -50), this.towers.add(t);
                                    var t = t.clone();
                                    t.position.set(4e3, 80, 50), this.towers.add(t), this.scene.add(this.towers);
                                },
                                createBoxes: function (e) {
                                    var t = (this.boxes = new THREE.Object3D());
                                    this.scene.add(t);
                                    var i = n.get("box"),
                                        s = r.get("box"),
                                        o = new THREE.MeshPhongMaterial({ map: i, shading: THREE.FlatShading, shininess: 1 });
                                    (s.material = o),
                                        (s.castShadow = !0),
                                        (s.receiveShadow = !0),
                                        e.done(function (e) {
                                            for (var n = 0; n < e.height; n++)
                                                for (var r = 0; r < e.width; r++) {
                                                    var i = (n * e.width + r) * 4,
                                                        o = (e.data[i] / 255) * 80;
                                                    if (o > 0) {
                                                        var u = s.clone();
                                                        t.add(u);
                                                        var a = 64 + r * 128,
                                                            f = 16 + n * 32,
                                                            l = o - 50;
                                                        u.position.set(a, l, -512 + f);
                                                        if (r < 8) {
                                                            var c = u.clone();
                                                            (c.position.x += 5120), t.add(c);
                                                        }
                                                        if (r > 32) {
                                                            var c = u.clone();
                                                            (c.position.x -= 5120), t.add(c);
                                                        }
                                                    }
                                                }
                                        });
                                },
                                createNeons: function (e, t) {
                                    var n = new jQuery.Deferred(),
                                        r = new THREE.Object3D();
                                    return (
                                        (this.neons = []),
                                            this.scene.add(r),
                                            e.done(
                                                _.bind(function (e) {
                                                    var o = [];
                                                    for (var u = 0; u < e.height; u++) {
                                                        o[u] = [];
                                                        for (var a = 0; a < e.width; a++) {
                                                            var f = (u * e.width + a) * 4;
                                                            if (e.data[f] !== 0) {
                                                                var l = (e.data[f] / 255) * 80;
                                                                o[u].push(l);
                                                            } else o[u].push(0);
                                                        }
                                                    }
                                                    _.each(
                                                        t,
                                                        function (e, t) {
                                                            var n = new i({ row: o[e], pos: e * 32 + 5, scene: this.scene, duration: s });
                                                            this.neons.push(n), r.add(n.obj);
                                                            if (t === 3 || t === 4 || t === 5) {
                                                                var u = new THREE.PointLight(12556543, 1.5, 400);
                                                                (u.i = t), this.pointLights.add(u);
                                                            }
                                                        },
                                                        this
                                                    );
                                                    var c = r.clone();
                                                    (c.position.x -= 5120),
                                                        this.scene.add(c),
                                                        _.each(c.children, function (e) {
                                                            _.each(e.children[0].children, function (e) {
                                                                var t = e.children[0];
                                                                (e.geometry = e.geometry.clone()), (t.geometry = t.geometry.clone()), (e.material = e.material.clone()), (t.material = t.material.clone()), (e.material.opacity = 1), (t.material.opacity = 1);
                                                            });
                                                        }),
                                                        n.resolve();
                                                }, this)
                                            ),
                                            n.promise()
                                    );
                                },
                                createLines: function (e) {
                                    (this.lines = []),
                                        (this.lines2 = []),
                                        _.each(
                                            e,
                                            function (e) {
                                                this.lines.push(t.createLine({ color: a(), pos: e * 32, start: Math.random() * 300 - 150, end: 5120, linewidth: 3 }));
                                            },
                                            this
                                        ),
                                        _.each(
                                            this.lines,
                                            function (e) {
                                                this.scene.add(e);
                                                var t = e.clone();
                                                (t.geometry = e.geometry.clone()), (t.position.x = -5120 + e.start), this.scene.add(t);
                                            },
                                            this
                                        );
                                },
                                setupDatGUI: function (e) {
                                    var t = e.addFolder("Light position"),
                                        n = this.lights[0];
                                    t.add(n.position, "x"), t.add(n.position, "y"), t.add(n.position, "z"), t.open();
                                },
                                setupCompositing: function (e) {
                                    var t = new THREE.RenderPass(this.scene, this.camera),
                                        n = new THREE.ShaderPass(THREE.RGBShiftShader);
                                    (n.uniforms.amount.value = 0.03), e.addPass(t), e.addPass(n);
                                },
                                updateLines: function (e) {
                                    _.each(
                                        this.lines,
                                        function (e) {
                                            e.update(this.progress);
                                        },
                                        this
                                    );
                                },
                                updateDirLight: function () {
                                    (this.dirLight.position.x = this.camera.position.x), (this.dirLight.target.position.x = this.camera.position.x);
                                },
                                updateSpotLight: function (e) {
                                    (this.spotLight.position.x = this.camera.position.x), (this.spotLight.target.position.x = this.camera.position.x + e), (this.spotLight.target.position.z = e);
                                },
                                updatePointLights: function () {
                                    _.each(
                                        this.pointLights.children,
                                        function (e) {
                                            e.position = this.neons[e.i].getCurrentPosition(this.progress);
                                        },
                                        this
                                    );
                                },
                                updateFlareVisibility: function (e, t) {
                                    var n = t.sub(this.camera.position),
                                        r = n.length();
                                    (this.raycaster.far = r), this.raycaster.set(this.camera.position, n.normalize());
                                    var i = this.raycaster.intersectObjects(this.boxes.children, !0);
                                    i.length > 0 ? (e.visible = !1) : (e.visible = !0);
                                },
                                updateNeons: function () {
                                    var e = this.getCameraFrustum();
                                    _.each(
                                        this.neons,
                                        function (t) {
                                            t.update(e, this.camera, this.updateFlareVisibility.bind(this), this.progress);
                                        },
                                        this
                                    );
                                },
                                getCameraFrustum: function () {
                                    var e = new THREE.Frustum(),
                                        t = new THREE.Matrix4();
                                    return this.camera.updateMatrixWorld(), this.camera.matrixWorldInverse.getInverse(this.camera.matrixWorld), t.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse), e.setFromMatrix(t), e;
                                },
                                updateCamera: function (e, t) {
                                    (this.camera.position.y = 200 + t / 2), (this.camera.position.x += o * e), (this.camera.position.z = 550);
                                    if (this.camera.position.x > 5120) {
                                        var n = 5120 - this.camera.target.x;
                                        (this.camera.target.x = -n),
                                            (this.camera.position.x = 0),
                                            _.each(
                                                this.neons,
                                                function (e) {
                                                    e.reset();
                                                },
                                                this
                                            );
                                    }
                                    var r = this.BOUNDARIES.x * mouseX,
                                        i = this.BOUNDARIES.y * -mouseY,
                                        s = new THREE.Vector3(this.camera.position.x + r, i, 0);
                                    (this.camera.target.x += o * e), this.camera.lookAt(this.camera.target.lerp(s, 0.1)), (this.progress = this.camera.position.x / 5120);
                                },
                                update: function (e, t) {
                                    var n = Math.sin((Math.PI / 2) * e * 0.3) * 100;
                                    this.started && (this.updateCamera(t, n), this.updateLines(t), this.updateSpotLight(n), this.updateDirLight(), this.updateNeons(), this.updatePointLights());
                                },
                            });
                        return u;
                    });
                var THREE = THREE || { REVISION: "61" };
                (self.console = self.console || { info: function () {}, log: function () {}, debug: function () {}, warn: function () {}, error: function () {} }),
                    (String.prototype.trim =
                        String.prototype.trim ||
                        function () {
                            return this.replace(/^\s+|\s+$/g, "");
                        }),
                    (THREE.extend = function (e, t) {
                        if (Object.keys) {
                            var n = Object.keys(t);
                            for (var r = 0, i = n.length; r < i; r++) {
                                var s = n[r];
                                Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(t, s));
                            }
                        } else {
                            var o = {}.hasOwnProperty;
                            for (var s in t) o.call(t, s) && (e[s] = t[s]);
                        }
                        return e;
                    }),
                    (function () {
                        var e = 0,
                            t = ["ms", "moz", "webkit", "o"];
                        for (var n = 0; n < t.length && !self.requestAnimationFrame; ++n)
                            (self.requestAnimationFrame = self[t[n] + "RequestAnimationFrame"]), (self.cancelAnimationFrame = self[t[n] + "CancelAnimationFrame"] || self[t[n] + "CancelRequestAnimationFrame"]);
                        self.requestAnimationFrame === undefined &&
                        self.setTimeout !== undefined &&
                        (self.requestAnimationFrame = function (t) {
                            var n = Date.now(),
                                r = Math.max(0, 16 - (n - e)),
                                i = self.setTimeout(function () {
                                    t(n + r);
                                }, r);
                            return (e = n + r), i;
                        }),
                        self.cancelAnimationFrame === undefined &&
                        self.clearTimeout !== undefined &&
                        (self.cancelAnimationFrame = function (e) {
                            self.clearTimeout(e);
                        });
                    })(),
                    (THREE.CullFaceNone = 0),
                    (THREE.CullFaceBack = 1),
                    (THREE.CullFaceFront = 2),
                    (THREE.CullFaceFrontBack = 3),
                    (THREE.FrontFaceDirectionCW = 0),
                    (THREE.FrontFaceDirectionCCW = 1),
                    (THREE.BasicShadowMap = 0),
                    (THREE.PCFShadowMap = 1),
                    (THREE.PCFSoftShadowMap = 2),
                    (THREE.FrontSide = 0),
                    (THREE.BackSide = 1),
                    (THREE.DoubleSide = 2),
                    (THREE.NoShading = 0),
                    (THREE.FlatShading = 1),
                    (THREE.SmoothShading = 2),
                    (THREE.NoColors = 0),
                    (THREE.FaceColors = 1),
                    (THREE.VertexColors = 2),
                    (THREE.NoBlending = 0),
                    (THREE.NormalBlending = 1),
                    (THREE.AdditiveBlending = 2),
                    (THREE.SubtractiveBlending = 3),
                    (THREE.MultiplyBlending = 4),
                    (THREE.CustomBlending = 5),
                    (THREE.AddEquation = 100),
                    (THREE.SubtractEquation = 101),
                    (THREE.ReverseSubtractEquation = 102),
                    (THREE.ZeroFactor = 200),
                    (THREE.OneFactor = 201),
                    (THREE.SrcColorFactor = 202),
                    (THREE.OneMinusSrcColorFactor = 203),
                    (THREE.SrcAlphaFactor = 204),
                    (THREE.OneMinusSrcAlphaFactor = 205),
                    (THREE.DstAlphaFactor = 206),
                    (THREE.OneMinusDstAlphaFactor = 207),
                    (THREE.DstColorFactor = 208),
                    (THREE.OneMinusDstColorFactor = 209),
                    (THREE.SrcAlphaSaturateFactor = 210),
                    (THREE.MultiplyOperation = 0),
                    (THREE.MixOperation = 1),
                    (THREE.AddOperation = 2),
                    (THREE.UVMapping = function () {}),
                    (THREE.CubeReflectionMapping = function () {}),
                    (THREE.CubeRefractionMapping = function () {}),
                    (THREE.SphericalReflectionMapping = function () {}),
                    (THREE.SphericalRefractionMapping = function () {}),
                    (THREE.RepeatWrapping = 1e3),
                    (THREE.ClampToEdgeWrapping = 1001),
                    (THREE.MirroredRepeatWrapping = 1002),
                    (THREE.NearestFilter = 1003),
                    (THREE.NearestMipMapNearestFilter = 1004),
                    (THREE.NearestMipMapLinearFilter = 1005),
                    (THREE.LinearFilter = 1006),
                    (THREE.LinearMipMapNearestFilter = 1007),
                    (THREE.LinearMipMapLinearFilter = 1008),
                    (THREE.UnsignedByteType = 1009),
                    (THREE.ByteType = 1010),
                    (THREE.ShortType = 1011),
                    (THREE.UnsignedShortType = 1012),
                    (THREE.IntType = 1013),
                    (THREE.UnsignedIntType = 1014),
                    (THREE.FloatType = 1015),
                    (THREE.UnsignedShort4444Type = 1016),
                    (THREE.UnsignedShort5551Type = 1017),
                    (THREE.UnsignedShort565Type = 1018),
                    (THREE.AlphaFormat = 1019),
                    (THREE.RGBFormat = 1020),
                    (THREE.RGBAFormat = 1021),
                    (THREE.LuminanceFormat = 1022),
                    (THREE.LuminanceAlphaFormat = 1023),
                    (THREE.RGB_S3TC_DXT1_Format = 2001),
                    (THREE.RGBA_S3TC_DXT1_Format = 2002),
                    (THREE.RGBA_S3TC_DXT3_Format = 2003),
                    (THREE.RGBA_S3TC_DXT5_Format = 2004),
                    (THREE.Color = function (e) {
                        return e !== undefined && this.set(e), this;
                    }),
                    (THREE.Color.prototype = {
                        constructor: THREE.Color,
                        r: 1,
                        g: 1,
                        b: 1,
                        set: function (e) {
                            return e instanceof THREE.Color ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
                        },
                        setHex: function (e) {
                            return (e = Math.floor(e)), (this.r = ((e >> 16) & 255) / 255), (this.g = ((e >> 8) & 255) / 255), (this.b = (e & 255) / 255), this;
                        },
                        setRGB: function (e, t, n) {
                            return (this.r = e), (this.g = t), (this.b = n), this;
                        },
                        setHSL: function (e, t, n) {
                            if (t === 0) this.r = this.g = this.b = n;
                            else {
                                var r = function (e, t, n) {
                                        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 0.5 ? t : n < 2 / 3 ? e + (t - e) * 6 * (2 / 3 - n) : e;
                                    },
                                    i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
                                    s = 2 * n - i;
                                (this.r = r(s, i, e + 1 / 3)), (this.g = r(s, i, e)), (this.b = r(s, i, e - 1 / 3));
                            }
                            return this;
                        },
                        setStyle: function (e) {
                            if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(e)) {
                                var t = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(e);
                                return (this.r = Math.min(255, parseInt(t[1], 10)) / 255), (this.g = Math.min(255, parseInt(t[2], 10)) / 255), (this.b = Math.min(255, parseInt(t[3], 10)) / 255), this;
                            }
                            if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(e)) {
                                var t = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(e);
                                return (this.r = Math.min(100, parseInt(t[1], 10)) / 100), (this.g = Math.min(100, parseInt(t[2], 10)) / 100), (this.b = Math.min(100, parseInt(t[3], 10)) / 100), this;
                            }
                            if (/^\#([0-9a-f]{6})$/i.test(e)) {
                                var t = /^\#([0-9a-f]{6})$/i.exec(e);
                                return this.setHex(parseInt(t[1], 16)), this;
                            }
                            if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(e)) {
                                var t = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(e);
                                return this.setHex(parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3], 16)), this;
                            }
                            if (/^(\w+)$/i.test(e)) return this.setHex(THREE.ColorKeywords[e]), this;
                        },
                        copy: function (e) {
                            return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
                        },
                        copyGammaToLinear: function (e) {
                            return (this.r = e.r * e.r), (this.g = e.g * e.g), (this.b = e.b * e.b), this;
                        },
                        copyLinearToGamma: function (e) {
                            return (this.r = Math.sqrt(e.r)), (this.g = Math.sqrt(e.g)), (this.b = Math.sqrt(e.b)), this;
                        },
                        convertGammaToLinear: function () {
                            var e = this.r,
                                t = this.g,
                                n = this.b;
                            return (this.r = e * e), (this.g = t * t), (this.b = n * n), this;
                        },
                        convertLinearToGamma: function () {
                            return (this.r = Math.sqrt(this.r)), (this.g = Math.sqrt(this.g)), (this.b = Math.sqrt(this.b)), this;
                        },
                        getHex: function () {
                            return ((this.r * 255) << 16) ^ ((this.g * 255) << 8) ^ ((this.b * 255) << 0);
                        },
                        getHexString: function () {
                            return ("000000" + this.getHex().toString(16)).slice(-6);
                        },
                        getHSL: (function () {
                            var e = { h: 0, s: 0, l: 0 };
                            return function () {
                                var t = this.r,
                                    n = this.g,
                                    r = this.b,
                                    i = Math.max(t, n, r),
                                    s = Math.min(t, n, r),
                                    o,
                                    u,
                                    a = (s + i) / 2;
                                if (s === i) (o = 0), (u = 0);
                                else {
                                    var f = i - s;
                                    u = a <= 0.5 ? f / (i + s) : f / (2 - i - s);
                                    switch (i) {
                                        case t:
                                            o = (n - r) / f + (n < r ? 6 : 0);
                                            break;
                                        case n:
                                            o = (r - t) / f + 2;
                                            break;
                                        case r:
                                            o = (t - n) / f + 4;
                                    }
                                    o /= 6;
                                }
                                return (e.h = o), (e.s = u), (e.l = a), e;
                            };
                        })(),
                        getStyle: function () {
                            return "rgb(" + ((this.r * 255) | 0) + "," + ((this.g * 255) | 0) + "," + ((this.b * 255) | 0) + ")";
                        },
                        offsetHSL: function (e, t, n) {
                            var r = this.getHSL();
                            return (r.h += e), (r.s += t), (r.l += n), this.setHSL(r.h, r.s, r.l), this;
                        },
                        add: function (e) {
                            return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
                        },
                        addColors: function (e, t) {
                            return (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this;
                        },
                        addScalar: function (e) {
                            return (this.r += e), (this.g += e), (this.b += e), this;
                        },
                        multiply: function (e) {
                            return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
                        },
                        multiplyScalar: function (e) {
                            return (this.r *= e), (this.g *= e), (this.b *= e), this;
                        },
                        lerp: function (e, t) {
                            return (this.r += (e.r - this.r) * t), (this.g += (e.g - this.g) * t), (this.b += (e.b - this.b) * t), this;
                        },
                        equals: function (e) {
                            return e.r === this.r && e.g === this.g && e.b === this.b;
                        },
                        fromArray: function (e) {
                            return (this.r = e[0]), (this.g = e[1]), (this.b = e[2]), this;
                        },
                        toArray: function () {
                            return [this.r, this.g, this.b];
                        },
                        clone: function () {
                            return new THREE.Color().setRGB(this.r, this.g, this.b);
                        },
                    }),
                    (THREE.ColorKeywords = {
                        aliceblue: 15792383,
                        antiquewhite: 16444375,
                        aqua: 65535,
                        aquamarine: 8388564,
                        azure: 15794175,
                        beige: 16119260,
                        bisque: 16770244,
                        black: 0,
                        blanchedalmond: 16772045,
                        blue: 255,
                        blueviolet: 9055202,
                        brown: 10824234,
                        burlywood: 14596231,
                        cadetblue: 6266528,
                        chartreuse: 8388352,
                        chocolate: 13789470,
                        coral: 16744272,
                        cornflowerblue: 6591981,
                        cornsilk: 16775388,
                        crimson: 14423100,
                        cyan: 65535,
                        darkblue: 139,
                        darkcyan: 35723,
                        darkgoldenrod: 12092939,
                        darkgray: 11119017,
                        darkgreen: 25600,
                        darkgrey: 11119017,
                        darkkhaki: 12433259,
                        darkmagenta: 9109643,
                        darkolivegreen: 5597999,
                        darkorange: 16747520,
                        darkorchid: 10040012,
                        darkred: 9109504,
                        darksalmon: 15308410,
                        darkseagreen: 9419919,
                        darkslateblue: 4734347,
                        darkslategray: 3100495,
                        darkslategrey: 3100495,
                        darkturquoise: 52945,
                        darkviolet: 9699539,
                        deeppink: 16716947,
                        deepskyblue: 49151,
                        dimgray: 6908265,
                        dimgrey: 6908265,
                        dodgerblue: 2003199,
                        firebrick: 11674146,
                        floralwhite: 16775920,
                        forestgreen: 2263842,
                        fuchsia: 16711935,
                        gainsboro: 14474460,
                        ghostwhite: 16316671,
                        gold: 16766720,
                        goldenrod: 14329120,
                        gray: 8421504,
                        green: 32768,
                        greenyellow: 11403055,
                        grey: 8421504,
                        honeydew: 15794160,
                        hotpink: 16738740,
                        indianred: 13458524,
                        indigo: 4915330,
                        ivory: 16777200,
                        khaki: 15787660,
                        lavender: 15132410,
                        lavenderblush: 16773365,
                        lawngreen: 8190976,
                        lemonchiffon: 16775885,
                        lightblue: 11393254,
                        lightcoral: 15761536,
                        lightcyan: 14745599,
                        lightgoldenrodyellow: 16448210,
                        lightgray: 13882323,
                        lightgreen: 9498256,
                        lightgrey: 13882323,
                        lightpink: 16758465,
                        lightsalmon: 16752762,
                        lightseagreen: 2142890,
                        lightskyblue: 8900346,
                        lightslategray: 7833753,
                        lightslategrey: 7833753,
                        lightsteelblue: 11584734,
                        lightyellow: 16777184,
                        lime: 65280,
                        limegreen: 3329330,
                        linen: 16445670,
                        magenta: 16711935,
                        maroon: 8388608,
                        mediumaquamarine: 6737322,
                        mediumblue: 205,
                        mediumorchid: 12211667,
                        mediumpurple: 9662683,
                        mediumseagreen: 3978097,
                        mediumslateblue: 8087790,
                        mediumspringgreen: 64154,
                        mediumturquoise: 4772300,
                        mediumvioletred: 13047173,
                        midnightblue: 1644912,
                        mintcream: 16121850,
                        mistyrose: 16770273,
                        moccasin: 16770229,
                        navajowhite: 16768685,
                        navy: 128,
                        oldlace: 16643558,
                        olive: 8421376,
                        olivedrab: 7048739,
                        orange: 16753920,
                        orangered: 16729344,
                        orchid: 14315734,
                        palegoldenrod: 15657130,
                        palegreen: 10025880,
                        paleturquoise: 11529966,
                        palevioletred: 14381203,
                        papayawhip: 16773077,
                        peachpuff: 16767673,
                        peru: 13468991,
                        pink: 16761035,
                        plum: 14524637,
                        powderblue: 11591910,
                        purple: 8388736,
                        red: 16711680,
                        rosybrown: 12357519,
                        royalblue: 4286945,
                        saddlebrown: 9127187,
                        salmon: 16416882,
                        sandybrown: 16032864,
                        seagreen: 3050327,
                        seashell: 16774638,
                        sienna: 10506797,
                        silver: 12632256,
                        skyblue: 8900331,
                        slateblue: 6970061,
                        slategray: 7372944,
                        slategrey: 7372944,
                        snow: 16775930,
                        springgreen: 65407,
                        steelblue: 4620980,
                        tan: 13808780,
                        teal: 32896,
                        thistle: 14204888,
                        tomato: 16737095,
                        turquoise: 4251856,
                        violet: 15631086,
                        wheat: 16113331,
                        white: 16777215,
                        whitesmoke: 16119285,
                        yellow: 16776960,
                        yellowgreen: 10145074,
                    }),
                    (THREE.Quaternion = function (e, t, n, r) {
                        (this._x = e || 0), (this._y = t || 0), (this._z = n || 0), (this._w = r !== undefined ? r : 1);
                    }),
                    (THREE.Quaternion.prototype = {
                        constructor: THREE.Quaternion,
                        _x: 0,
                        _y: 0,
                        _z: 0,
                        _w: 0,
                        _euler: undefined,
                        _updateEuler: function (e) {
                            this._euler !== undefined && this._euler.setFromQuaternion(this, undefined, !1);
                        },
                        get x() {
                            return this._x;
                        },
                        set x(e) {
                            (this._x = e), this._updateEuler();
                        },
                        get y() {
                            return this._y;
                        },
                        set y(e) {
                            (this._y = e), this._updateEuler();
                        },
                        get z() {
                            return this._z;
                        },
                        set z(e) {
                            (this._z = e), this._updateEuler();
                        },
                        get w() {
                            return this._w;
                        },
                        set w(e) {
                            (this._w = e), this._updateEuler();
                        },
                        set: function (e, t, n, r) {
                            return (this._x = e), (this._y = t), (this._z = n), (this._w = r), this._updateEuler(), this;
                        },
                        copy: function (e) {
                            return (this._x = e._x), (this._y = e._y), (this._z = e._z), (this._w = e._w), this._updateEuler(), this;
                        },
                        setFromEuler: function (e, t) {
                            if (e instanceof THREE.Euler == 0) throw new Error("ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
                            var n = Math.cos(e._x / 2),
                                r = Math.cos(e._y / 2),
                                i = Math.cos(e._z / 2),
                                s = Math.sin(e._x / 2),
                                o = Math.sin(e._y / 2),
                                u = Math.sin(e._z / 2);
                            return (
                                e.order === "XYZ"
                                    ? ((this._x = s * r * i + n * o * u), (this._y = n * o * i - s * r * u), (this._z = n * r * u + s * o * i), (this._w = n * r * i - s * o * u))
                                    : e.order === "YXZ"
                                    ? ((this._x = s * r * i + n * o * u), (this._y = n * o * i - s * r * u), (this._z = n * r * u - s * o * i), (this._w = n * r * i + s * o * u))
                                    : e.order === "ZXY"
                                        ? ((this._x = s * r * i - n * o * u), (this._y = n * o * i + s * r * u), (this._z = n * r * u + s * o * i), (this._w = n * r * i - s * o * u))
                                        : e.order === "ZYX"
                                            ? ((this._x = s * r * i - n * o * u), (this._y = n * o * i + s * r * u), (this._z = n * r * u - s * o * i), (this._w = n * r * i + s * o * u))
                                            : e.order === "YZX"
                                                ? ((this._x = s * r * i + n * o * u), (this._y = n * o * i + s * r * u), (this._z = n * r * u - s * o * i), (this._w = n * r * i - s * o * u))
                                                : e.order === "XZY" && ((this._x = s * r * i - n * o * u), (this._y = n * o * i - s * r * u), (this._z = n * r * u + s * o * i), (this._w = n * r * i + s * o * u)),
                                t !== !1 && this._updateEuler(),
                                    this
                            );
                        },
                        setFromAxisAngle: function (e, t) {
                            var n = t / 2,
                                r = Math.sin(n);
                            return (this._x = e.x * r), (this._y = e.y * r), (this._z = e.z * r), (this._w = Math.cos(n)), this._updateEuler(), this;
                        },
                        setFromRotationMatrix: function (e) {
                            var t = e.elements,
                                n = t[0],
                                r = t[4],
                                i = t[8],
                                s = t[1],
                                o = t[5],
                                u = t[9],
                                a = t[2],
                                f = t[6],
                                l = t[10],
                                c = n + o + l,
                                h;
                            return (
                                c > 0
                                    ? ((h = 0.5 / Math.sqrt(c + 1)), (this._w = 0.25 / h), (this._x = (f - u) * h), (this._y = (i - a) * h), (this._z = (s - r) * h))
                                    : n > o && n > l
                                    ? ((h = 2 * Math.sqrt(1 + n - o - l)), (this._w = (f - u) / h), (this._x = 0.25 * h), (this._y = (r + s) / h), (this._z = (i + a) / h))
                                    : o > l
                                        ? ((h = 2 * Math.sqrt(1 + o - n - l)), (this._w = (i - a) / h), (this._x = (r + s) / h), (this._y = 0.25 * h), (this._z = (u + f) / h))
                                        : ((h = 2 * Math.sqrt(1 + l - n - o)), (this._w = (s - r) / h), (this._x = (i + a) / h), (this._y = (u + f) / h), (this._z = 0.25 * h)),
                                    this._updateEuler(),
                                    this
                            );
                        },
                        inverse: function () {
                            return this.conjugate().normalize(), this;
                        },
                        conjugate: function () {
                            return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._updateEuler(), this;
                        },
                        lengthSq: function () {
                            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
                        },
                        length: function () {
                            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
                        },
                        normalize: function () {
                            var e = this.length();
                            return e === 0 ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1)) : ((e = 1 / e), (this._x = this._x * e), (this._y = this._y * e), (this._z = this._z * e), (this._w = this._w * e)), this;
                        },
                        multiply: function (e, t) {
                            return t !== undefined ? (console.warn("DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e);
                        },
                        multiplyQuaternions: function (e, t) {
                            var n = e._x,
                                r = e._y,
                                i = e._z,
                                s = e._w,
                                o = t._x,
                                u = t._y,
                                a = t._z,
                                f = t._w;
                            return (this._x = n * f + s * o + r * a - i * u), (this._y = r * f + s * u + i * o - n * a), (this._z = i * f + s * a + n * u - r * o), (this._w = s * f - n * o - r * u - i * a), this._updateEuler(), this;
                        },
                        multiplyVector3: function (e) {
                            return console.warn("DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this);
                        },
                        slerp: function (e, t) {
                            var n = this._x,
                                r = this._y,
                                i = this._z,
                                s = this._w,
                                o = s * e._w + n * e._x + r * e._y + i * e._z;
                            o < 0 ? ((this._w = -e._w), (this._x = -e._x), (this._y = -e._y), (this._z = -e._z), (o = -o)) : this.copy(e);
                            if (o >= 1) return (this._w = s), (this._x = n), (this._y = r), (this._z = i), this;
                            var u = Math.acos(o),
                                a = Math.sqrt(1 - o * o);
                            if (Math.abs(a) < 0.001) return (this._w = 0.5 * (s + this._w)), (this._x = 0.5 * (n + this._x)), (this._y = 0.5 * (r + this._y)), (this._z = 0.5 * (i + this._z)), this;
                            var f = Math.sin((1 - t) * u) / a,
                                l = Math.sin(t * u) / a;
                            return (this._w = s * f + this._w * l), (this._x = n * f + this._x * l), (this._y = r * f + this._y * l), (this._z = i * f + this._z * l), this._updateEuler(), this;
                        },
                        equals: function (e) {
                            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
                        },
                        fromArray: function (e) {
                            return (this._x = e[0]), (this._y = e[1]), (this._z = e[2]), (this._w = e[3]), this._updateEuler(), this;
                        },
                        toArray: function () {
                            return [this._x, this._y, this._z, this._w];
                        },
                        clone: function () {
                            return new THREE.Quaternion(this._x, this._y, this._z, this._w);
                        },
                    }),
                    (THREE.Quaternion.slerp = function (e, t, n, r) {
                        return n.copy(e).slerp(t, r);
                    }),
                    (THREE.Vector2 = function (e, t) {
                        (this.x = e || 0), (this.y = t || 0);
                    }),
                    (THREE.Vector2.prototype = {
                        constructor: THREE.Vector2,
                        set: function (e, t) {
                            return (this.x = e), (this.y = t), this;
                        },
                        setX: function (e) {
                            return (this.x = e), this;
                        },
                        setY: function (e) {
                            return (this.y = e), this;
                        },
                        setComponent: function (e, t) {
                            switch (e) {
                                case 0:
                                    this.x = t;
                                    break;
                                case 1:
                                    this.y = t;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e);
                            }
                        },
                        getComponent: function (e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                default:
                                    throw new Error("index is out of range: " + e);
                            }
                        },
                        copy: function (e) {
                            return (this.x = e.x), (this.y = e.y), this;
                        },
                        add: function (e, t) {
                            return t !== undefined ? (console.warn("DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : ((this.x += e.x), (this.y += e.y), this);
                        },
                        addVectors: function (e, t) {
                            return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
                        },
                        addScalar: function (e) {
                            return (this.x += e), (this.y += e), this;
                        },
                        sub: function (e, t) {
                            return t !== undefined ? (console.warn("DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : ((this.x -= e.x), (this.y -= e.y), this);
                        },
                        subVectors: function (e, t) {
                            return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
                        },
                        multiplyScalar: function (e) {
                            return (this.x *= e), (this.y *= e), this;
                        },
                        divideScalar: function (e) {
                            if (e !== 0) {
                                var t = 1 / e;
                                (this.x *= t), (this.y *= t);
                            } else (this.x = 0), (this.y = 0);
                            return this;
                        },
                        min: function (e) {
                            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this;
                        },
                        max: function (e) {
                            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this;
                        },
                        clamp: function (e, t) {
                            return this.x < e.x ? (this.x = e.x) : this.x > t.x && (this.x = t.x), this.y < e.y ? (this.y = e.y) : this.y > t.y && (this.y = t.y), this;
                        },
                        negate: function () {
                            return this.multiplyScalar(-1);
                        },
                        dot: function (e) {
                            return this.x * e.x + this.y * e.y;
                        },
                        lengthSq: function () {
                            return this.x * this.x + this.y * this.y;
                        },
                        length: function () {
                            return Math.sqrt(this.x * this.x + this.y * this.y);
                        },
                        normalize: function () {
                            return this.divideScalar(this.length());
                        },
                        distanceTo: function (e) {
                            return Math.sqrt(this.distanceToSquared(e));
                        },
                        distanceToSquared: function (e) {
                            var t = this.x - e.x,
                                n = this.y - e.y;
                            return t * t + n * n;
                        },
                        setLength: function (e) {
                            var t = this.length();
                            return t !== 0 && e !== t && this.multiplyScalar(e / t), this;
                        },
                        lerp: function (e, t) {
                            return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
                        },
                        equals: function (e) {
                            return e.x === this.x && e.y === this.y;
                        },
                        fromArray: function (e) {
                            return (this.x = e[0]), (this.y = e[1]), this;
                        },
                        toArray: function () {
                            return [this.x, this.y];
                        },
                        clone: function () {
                            return new THREE.Vector2(this.x, this.y);
                        },
                    }),
                    (THREE.Vector3 = function (e, t, n) {
                        (this.x = e || 0), (this.y = t || 0), (this.z = n || 0);
                    }),
                    (THREE.Vector3.prototype = {
                        constructor: THREE.Vector3,
                        set: function (e, t, n) {
                            return (this.x = e), (this.y = t), (this.z = n), this;
                        },
                        setX: function (e) {
                            return (this.x = e), this;
                        },
                        setY: function (e) {
                            return (this.y = e), this;
                        },
                        setZ: function (e) {
                            return (this.z = e), this;
                        },
                        setComponent: function (e, t) {
                            switch (e) {
                                case 0:
                                    this.x = t;
                                    break;
                                case 1:
                                    this.y = t;
                                    break;
                                case 2:
                                    this.z = t;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e);
                            }
                        },
                        getComponent: function (e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                default:
                                    throw new Error("index is out of range: " + e);
                            }
                        },
                        copy: function (e) {
                            return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
                        },
                        add: function (e, t) {
                            return t !== undefined ? (console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
                        },
                        addScalar: function (e) {
                            return (this.x += e), (this.y += e), (this.z += e), this;
                        },
                        addVectors: function (e, t) {
                            return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this;
                        },
                        sub: function (e, t) {
                            return t !== undefined ? (console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
                        },
                        subVectors: function (e, t) {
                            return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this;
                        },
                        multiply: function (e, t) {
                            return t !== undefined
                                ? (console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t))
                                : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
                        },
                        multiplyScalar: function (e) {
                            return (this.x *= e), (this.y *= e), (this.z *= e), this;
                        },
                        multiplyVectors: function (e, t) {
                            return (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this;
                        },
                        applyMatrix3: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = this.z,
                                i = e.elements;
                            return (this.x = i[0] * t + i[3] * n + i[6] * r), (this.y = i[1] * t + i[4] * n + i[7] * r), (this.z = i[2] * t + i[5] * n + i[8] * r), this;
                        },
                        applyMatrix4: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = this.z,
                                i = e.elements;
                            return (this.x = i[0] * t + i[4] * n + i[8] * r + i[12]), (this.y = i[1] * t + i[5] * n + i[9] * r + i[13]), (this.z = i[2] * t + i[6] * n + i[10] * r + i[14]), this;
                        },
                        applyProjection: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = this.z,
                                i = e.elements,
                                s = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                            return (this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * s), (this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * s), (this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * s), this;
                        },
                        applyQuaternion: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = this.z,
                                i = e.x,
                                s = e.y,
                                o = e.z,
                                u = e.w,
                                a = u * t + s * r - o * n,
                                f = u * n + o * t - i * r,
                                l = u * r + i * n - s * t,
                                c = -i * t - s * n - o * r;
                            return (this.x = a * u + c * -i + f * -o - l * -s), (this.y = f * u + c * -s + l * -i - a * -o), (this.z = l * u + c * -o + a * -s - f * -i), this;
                        },
                        transformDirection: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = this.z,
                                i = e.elements;
                            return (this.x = i[0] * t + i[4] * n + i[8] * r), (this.y = i[1] * t + i[5] * n + i[9] * r), (this.z = i[2] * t + i[6] * n + i[10] * r), this.normalize(), this;
                        },
                        divide: function (e) {
                            return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
                        },
                        divideScalar: function (e) {
                            if (e !== 0) {
                                var t = 1 / e;
                                (this.x *= t), (this.y *= t), (this.z *= t);
                            } else (this.x = 0), (this.y = 0), (this.z = 0);
                            return this;
                        },
                        min: function (e) {
                            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this;
                        },
                        max: function (e) {
                            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this;
                        },
                        clamp: function (e, t) {
                            return this.x < e.x ? (this.x = e.x) : this.x > t.x && (this.x = t.x), this.y < e.y ? (this.y = e.y) : this.y > t.y && (this.y = t.y), this.z < e.z ? (this.z = e.z) : this.z > t.z && (this.z = t.z), this;
                        },
                        negate: function () {
                            return this.multiplyScalar(-1);
                        },
                        dot: function (e) {
                            return this.x * e.x + this.y * e.y + this.z * e.z;
                        },
                        lengthSq: function () {
                            return this.x * this.x + this.y * this.y + this.z * this.z;
                        },
                        length: function () {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                        },
                        lengthManhattan: function () {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
                        },
                        normalize: function () {
                            return this.divideScalar(this.length());
                        },
                        setLength: function (e) {
                            var t = this.length();
                            return t !== 0 && e !== t && this.multiplyScalar(e / t), this;
                        },
                        lerp: function (e, t) {
                            return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), this;
                        },
                        cross: function (e, t) {
                            if (t !== undefined) return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t);
                            var n = this.x,
                                r = this.y,
                                i = this.z;
                            return (this.x = r * e.z - i * e.y), (this.y = i * e.x - n * e.z), (this.z = n * e.y - r * e.x), this;
                        },
                        crossVectors: function (e, t) {
                            var n = e.x,
                                r = e.y,
                                i = e.z,
                                s = t.x,
                                o = t.y,
                                u = t.z;
                            return (this.x = r * u - i * o), (this.y = i * s - n * u), (this.z = n * o - r * s), this;
                        },
                        angleTo: function (e) {
                            var t = this.dot(e) / (this.length() * e.length());
                            return Math.acos(THREE.Math.clamp(t, -1, 1));
                        },
                        distanceTo: function (e) {
                            return Math.sqrt(this.distanceToSquared(e));
                        },
                        distanceToSquared: function (e) {
                            var t = this.x - e.x,
                                n = this.y - e.y,
                                r = this.z - e.z;
                            return t * t + n * n + r * r;
                        },
                        setEulerFromRotationMatrix: function (e, t) {
                            console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.");
                        },
                        setEulerFromQuaternion: function (e, t) {
                            console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.");
                        },
                        getPositionFromMatrix: function (e) {
                            return (this.x = e.elements[12]), (this.y = e.elements[13]), (this.z = e.elements[14]), this;
                        },
                        getScaleFromMatrix: function (e) {
                            var t = this.set(e.elements[0], e.elements[1], e.elements[2]).length(),
                                n = this.set(e.elements[4], e.elements[5], e.elements[6]).length(),
                                r = this.set(e.elements[8], e.elements[9], e.elements[10]).length();
                            return (this.x = t), (this.y = n), (this.z = r), this;
                        },
                        getColumnFromMatrix: function (e, t) {
                            var n = e * 4,
                                r = t.elements;
                            return (this.x = r[n]), (this.y = r[n + 1]), (this.z = r[n + 2]), this;
                        },
                        equals: function (e) {
                            return e.x === this.x && e.y === this.y && e.z === this.z;
                        },
                        fromArray: function (e) {
                            return (this.x = e[0]), (this.y = e[1]), (this.z = e[2]), this;
                        },
                        toArray: function () {
                            return [this.x, this.y, this.z];
                        },
                        clone: function () {
                            return new THREE.Vector3(this.x, this.y, this.z);
                        },
                    }),
                    THREE.extend(THREE.Vector3.prototype, {
                        applyEuler: (function () {
                            var e = new THREE.Quaternion();
                            return function (t) {
                                return t instanceof THREE.Euler == 0 && console.error("ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code."), this.applyQuaternion(e.setFromEuler(t)), this;
                            };
                        })(),
                        applyAxisAngle: (function () {
                            var e = new THREE.Quaternion();
                            return function (t, n) {
                                return this.applyQuaternion(e.setFromAxisAngle(t, n)), this;
                            };
                        })(),
                        projectOnVector: (function () {
                            var e = new THREE.Vector3();
                            return function (t) {
                                e.copy(t).normalize();
                                var n = this.dot(e);
                                return this.copy(e).multiplyScalar(n);
                            };
                        })(),
                        projectOnPlane: (function () {
                            var e = new THREE.Vector3();
                            return function (t) {
                                return e.copy(this).projectOnVector(t), this.sub(e);
                            };
                        })(),
                        reflect: (function () {
                            var e = new THREE.Vector3();
                            return function (t) {
                                return e.copy(this).projectOnVector(t).multiplyScalar(2), this.subVectors(e, this);
                            };
                        })(),
                    }),
                    (THREE.Vector4 = function (e, t, n, r) {
                        (this.x = e || 0), (this.y = t || 0), (this.z = n || 0), (this.w = r !== undefined ? r : 1);
                    }),
                    (THREE.Vector4.prototype = {
                        constructor: THREE.Vector4,
                        set: function (e, t, n, r) {
                            return (this.x = e), (this.y = t), (this.z = n), (this.w = r), this;
                        },
                        setX: function (e) {
                            return (this.x = e), this;
                        },
                        setY: function (e) {
                            return (this.y = e), this;
                        },
                        setZ: function (e) {
                            return (this.z = e), this;
                        },
                        setW: function (e) {
                            return (this.w = e), this;
                        },
                        setComponent: function (e, t) {
                            switch (e) {
                                case 0:
                                    this.x = t;
                                    break;
                                case 1:
                                    this.y = t;
                                    break;
                                case 2:
                                    this.z = t;
                                    break;
                                case 3:
                                    this.w = t;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e);
                            }
                        },
                        getComponent: function (e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                case 3:
                                    return this.w;
                                default:
                                    throw new Error("index is out of range: " + e);
                            }
                        },
                        copy: function (e) {
                            return (this.x = e.x), (this.y = e.y), (this.z = e.z), (this.w = e.w !== undefined ? e.w : 1), this;
                        },
                        add: function (e, t) {
                            return t !== undefined
                                ? (console.warn("DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t))
                                : ((this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this);
                        },
                        addScalar: function (e) {
                            return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
                        },
                        addVectors: function (e, t) {
                            return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), (this.w = e.w + t.w), this;
                        },
                        sub: function (e, t) {
                            return t !== undefined
                                ? (console.warn("DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t))
                                : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this);
                        },
                        subVectors: function (e, t) {
                            return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), (this.w = e.w - t.w), this;
                        },
                        multiplyScalar: function (e) {
                            return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
                        },
                        applyMatrix4: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = this.z,
                                i = this.w,
                                s = e.elements;
                            return (
                                (this.x = s[0] * t + s[4] * n + s[8] * r + s[12] * i),
                                    (this.y = s[1] * t + s[5] * n + s[9] * r + s[13] * i),
                                    (this.z = s[2] * t + s[6] * n + s[10] * r + s[14] * i),
                                    (this.w = s[3] * t + s[7] * n + s[11] * r + s[15] * i),
                                    this
                            );
                        },
                        divideScalar: function (e) {
                            if (e !== 0) {
                                var t = 1 / e;
                                (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t);
                            } else (this.x = 0), (this.y = 0), (this.z = 0), (this.w = 1);
                            return this;
                        },
                        setAxisAngleFromQuaternion: function (e) {
                            this.w = 2 * Math.acos(e.w);
                            var t = Math.sqrt(1 - e.w * e.w);
                            return t < 1e-4 ? ((this.x = 1), (this.y = 0), (this.z = 0)) : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)), this;
                        },
                        setAxisAngleFromRotationMatrix: function (e) {
                            var t,
                                n,
                                r,
                                i,
                                s = 0.01,
                                o = 0.1,
                                u = e.elements,
                                a = u[0],
                                f = u[4],
                                l = u[8],
                                c = u[1],
                                h = u[5],
                                p = u[9],
                                d = u[2],
                                v = u[6],
                                m = u[10];
                            if (Math.abs(f - c) < s && Math.abs(l - d) < s && Math.abs(p - v) < s) {
                                if (Math.abs(f + c) < o && Math.abs(l + d) < o && Math.abs(p + v) < o && Math.abs(a + h + m - 3) < o) return this.set(1, 0, 0, 0), this;
                                t = Math.PI;
                                var g = (a + 1) / 2,
                                    y = (h + 1) / 2,
                                    b = (m + 1) / 2,
                                    w = (f + c) / 4,
                                    E = (l + d) / 4,
                                    S = (p + v) / 4;
                                return (
                                    g > y && g > b
                                        ? g < s
                                        ? ((n = 0), (r = 0.707106781), (i = 0.707106781))
                                        : ((n = Math.sqrt(g)), (r = w / n), (i = E / n))
                                        : y > b
                                        ? y < s
                                            ? ((n = 0.707106781), (r = 0), (i = 0.707106781))
                                            : ((r = Math.sqrt(y)), (n = w / r), (i = S / r))
                                        : b < s
                                            ? ((n = 0.707106781), (r = 0.707106781), (i = 0))
                                            : ((i = Math.sqrt(b)), (n = E / i), (r = S / i)),
                                        this.set(n, r, i, t),
                                        this
                                );
                            }
                            var x = Math.sqrt((v - p) * (v - p) + (l - d) * (l - d) + (c - f) * (c - f));
                            return Math.abs(x) < 0.001 && (x = 1), (this.x = (v - p) / x), (this.y = (l - d) / x), (this.z = (c - f) / x), (this.w = Math.acos((a + h + m - 1) / 2)), this;
                        },
                        min: function (e) {
                            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this.w > e.w && (this.w = e.w), this;
                        },
                        max: function (e) {
                            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this.w < e.w && (this.w = e.w), this;
                        },
                        clamp: function (e, t) {
                            return (
                                this.x < e.x ? (this.x = e.x) : this.x > t.x && (this.x = t.x),
                                    this.y < e.y ? (this.y = e.y) : this.y > t.y && (this.y = t.y),
                                    this.z < e.z ? (this.z = e.z) : this.z > t.z && (this.z = t.z),
                                    this.w < e.w ? (this.w = e.w) : this.w > t.w && (this.w = t.w),
                                    this
                            );
                        },
                        negate: function () {
                            return this.multiplyScalar(-1);
                        },
                        dot: function (e) {
                            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
                        },
                        lengthSq: function () {
                            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                        },
                        length: function () {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                        },
                        lengthManhattan: function () {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
                        },
                        normalize: function () {
                            return this.divideScalar(this.length());
                        },
                        setLength: function (e) {
                            var t = this.length();
                            return t !== 0 && e !== t && this.multiplyScalar(e / t), this;
                        },
                        lerp: function (e, t) {
                            return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), (this.w += (e.w - this.w) * t), this;
                        },
                        equals: function (e) {
                            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
                        },
                        fromArray: function (e) {
                            return (this.x = e[0]), (this.y = e[1]), (this.z = e[2]), (this.w = e[3]), this;
                        },
                        toArray: function () {
                            return [this.x, this.y, this.z, this.w];
                        },
                        clone: function () {
                            return new THREE.Vector4(this.x, this.y, this.z, this.w);
                        },
                    }),
                    (THREE.Euler = function (e, t, n, r) {
                        (this._x = e || 0), (this._y = t || 0), (this._z = n || 0), (this._order = r || THREE.Euler.DefaultOrder);
                    }),
                    (THREE.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
                    (THREE.Euler.DefaultOrder = "XYZ"),
                    (THREE.Euler.prototype = {
                        constructor: THREE.Euler,
                        _x: 0,
                        _y: 0,
                        _z: 0,
                        _order: THREE.Euler.DefaultOrder,
                        _quaternion: undefined,
                        _updateQuaternion: function () {
                            this._quaternion !== undefined && this._quaternion.setFromEuler(this, !1);
                        },
                        get x() {
                            return this._x;
                        },
                        set x(e) {
                            (this._x = e), this._updateQuaternion();
                        },
                        get y() {
                            return this._y;
                        },
                        set y(e) {
                            (this._y = e), this._updateQuaternion();
                        },
                        get z() {
                            return this._z;
                        },
                        set z(e) {
                            (this._z = e), this._updateQuaternion();
                        },
                        get order() {
                            return this._order;
                        },
                        set order(e) {
                            (this._order = e), this._updateQuaternion();
                        },
                        set: function (e, t, n, r) {
                            return (this._x = e), (this._y = t), (this._z = n), (this._order = r || this._order), this._updateQuaternion(), this;
                        },
                        copy: function (e) {
                            return (this._x = e._x), (this._y = e._y), (this._z = e._z), (this._order = e._order), this._updateQuaternion(), this;
                        },
                        setFromRotationMatrix: function (e, t) {
                            function n(e) {
                                return Math.min(Math.max(e, -1), 1);
                            }
                            var r = e.elements,
                                i = r[0],
                                s = r[4],
                                o = r[8],
                                u = r[1],
                                a = r[5],
                                f = r[9],
                                l = r[2],
                                c = r[6],
                                h = r[10];
                            return (
                                (t = t || this._order),
                                    t === "XYZ"
                                        ? ((this._y = Math.asin(n(o))), Math.abs(o) < 0.99999 ? ((this._x = Math.atan2(-f, h)), (this._z = Math.atan2(-s, i))) : ((this._x = Math.atan2(c, a)), (this._z = 0)))
                                        : t === "YXZ"
                                        ? ((this._x = Math.asin(-n(f))), Math.abs(f) < 0.99999 ? ((this._y = Math.atan2(o, h)), (this._z = Math.atan2(u, a))) : ((this._y = Math.atan2(-l, i)), (this._z = 0)))
                                        : t === "ZXY"
                                            ? ((this._x = Math.asin(n(c))), Math.abs(c) < 0.99999 ? ((this._y = Math.atan2(-l, h)), (this._z = Math.atan2(-s, a))) : ((this._y = 0), (this._z = Math.atan2(u, i))))
                                            : t === "ZYX"
                                                ? ((this._y = Math.asin(-n(l))), Math.abs(l) < 0.99999 ? ((this._x = Math.atan2(c, h)), (this._z = Math.atan2(u, i))) : ((this._x = 0), (this._z = Math.atan2(-s, a))))
                                                : t === "YZX"
                                                    ? ((this._z = Math.asin(n(u))), Math.abs(u) < 0.99999 ? ((this._x = Math.atan2(-f, a)), (this._y = Math.atan2(-l, i))) : ((this._x = 0), (this._y = Math.atan2(o, h))))
                                                    : t === "XZY"
                                                        ? ((this._z = Math.asin(-n(s))), Math.abs(s) < 0.99999 ? ((this._x = Math.atan2(c, a)), (this._y = Math.atan2(o, i))) : ((this._x = Math.atan2(-f, h)), (this._y = 0)))
                                                        : console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: " + t),
                                    (this._order = t),
                                    this._updateQuaternion(),
                                    this
                            );
                        },
                        setFromQuaternion: function (e, t, n) {
                            function r(e) {
                                return Math.min(Math.max(e, -1), 1);
                            }
                            var i = e.x * e.x,
                                s = e.y * e.y,
                                o = e.z * e.z,
                                u = e.w * e.w;
                            return (
                                (t = t || this._order),
                                    t === "XYZ"
                                        ? ((this._x = Math.atan2(2 * (e.x * e.w - e.y * e.z), u - i - s + o)), (this._y = Math.asin(r(2 * (e.x * e.z + e.y * e.w)))), (this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), u + i - s - o)))
                                        : t === "YXZ"
                                        ? ((this._x = Math.asin(r(2 * (e.x * e.w - e.y * e.z)))), (this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), u - i - s + o)), (this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), u - i + s - o)))
                                        : t === "ZXY"
                                            ? ((this._x = Math.asin(r(2 * (e.x * e.w + e.y * e.z)))), (this._y = Math.atan2(2 * (e.y * e.w - e.z * e.x), u - i - s + o)), (this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), u - i + s - o)))
                                            : t === "ZYX"
                                                ? ((this._x = Math.atan2(2 * (e.x * e.w + e.z * e.y), u - i - s + o)), (this._y = Math.asin(r(2 * (e.y * e.w - e.x * e.z)))), (this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), u + i - s - o)))
                                                : t === "YZX"
                                                    ? ((this._x = Math.atan2(2 * (e.x * e.w - e.z * e.y), u - i + s - o)), (this._y = Math.atan2(2 * (e.y * e.w - e.x * e.z), u + i - s - o)), (this._z = Math.asin(r(2 * (e.x * e.y + e.z * e.w)))))
                                                    : t === "XZY"
                                                        ? ((this._x = Math.atan2(2 * (e.x * e.w + e.y * e.z), u - i + s - o)), (this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), u + i - s - o)), (this._z = Math.asin(r(2 * (e.z * e.w - e.x * e.y)))))
                                                        : console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: " + t),
                                    (this._order = t),
                                n !== !1 && this._updateQuaternion(),
                                    this
                            );
                        },
                        reorder: (function () {
                            var e = new THREE.Quaternion();
                            return function (t) {
                                e.setFromEuler(this), this.setFromQuaternion(e, t);
                            };
                        })(),
                        fromArray: function (e) {
                            return (this._x = e[0]), (this._y = e[1]), (this._z = e[2]), e[3] !== undefined && (this._order = e[3]), this._updateQuaternion(), this;
                        },
                        toArray: function () {
                            return [this._x, this._y, this._z, this._order];
                        },
                        equals: function (e) {
                            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
                        },
                        clone: function () {
                            return new THREE.Euler(this._x, this._y, this._z, this._order);
                        },
                    }),
                    (THREE.Line3 = function (e, t) {
                        (this.start = e !== undefined ? e : new THREE.Vector3()), (this.end = t !== undefined ? t : new THREE.Vector3());
                    }),
                    (THREE.Line3.prototype = {
                        constructor: THREE.Line3,
                        set: function (e, t) {
                            return this.start.copy(e), this.end.copy(t), this;
                        },
                        copy: function (e) {
                            return this.start.copy(e.start), this.end.copy(e.end), this;
                        },
                        center: function (e) {
                            var t = e || new THREE.Vector3();
                            return t.addVectors(this.start, this.end).multiplyScalar(0.5);
                        },
                        delta: function (e) {
                            var t = e || new THREE.Vector3();
                            return t.subVectors(this.end, this.start);
                        },
                        distanceSq: function () {
                            return this.start.distanceToSquared(this.end);
                        },
                        distance: function () {
                            return this.start.distanceTo(this.end);
                        },
                        at: function (e, t) {
                            var n = t || new THREE.Vector3();
                            return this.delta(n).multiplyScalar(e).add(this.start);
                        },
                        closestPointToPointParameter: (function () {
                            var e = new THREE.Vector3(),
                                t = new THREE.Vector3();
                            return function (n, r) {
                                e.subVectors(n, this.start), t.subVectors(this.end, this.start);
                                var i = t.dot(t),
                                    s = t.dot(e),
                                    o = s / i;
                                return r && (o = THREE.Math.clamp(o, 0, 1)), o;
                            };
                        })(),
                        closestPointToPoint: function (e, t, n) {
                            var r = this.closestPointToPointParameter(e, t),
                                i = n || new THREE.Vector3();
                            return this.delta(i).multiplyScalar(r).add(this.start);
                        },
                        applyMatrix4: function (e) {
                            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
                        },
                        equals: function (e) {
                            return e.start.equals(this.start) && e.end.equals(this.end);
                        },
                        clone: function () {
                            return new THREE.Line3().copy(this);
                        },
                    }),
                    (THREE.Box2 = function (e, t) {
                        (this.min = e !== undefined ? e : new THREE.Vector2(Infinity, Infinity)), (this.max = t !== undefined ? t : new THREE.Vector2(-Infinity, -Infinity));
                    }),
                    (THREE.Box2.prototype = {
                        constructor: THREE.Box2,
                        set: function (e, t) {
                            return this.min.copy(e), this.max.copy(t), this;
                        },
                        setFromPoints: function (e) {
                            if (e.length > 0) {
                                var t = e[0];
                                this.min.copy(t), this.max.copy(t);
                                for (var n = 1, r = e.length; n < r; n++) (t = e[n]), t.x < this.min.x ? (this.min.x = t.x) : t.x > this.max.x && (this.max.x = t.x), t.y < this.min.y ? (this.min.y = t.y) : t.y > this.max.y && (this.max.y = t.y);
                            } else this.makeEmpty();
                            return this;
                        },
                        setFromCenterAndSize: (function () {
                            var e = new THREE.Vector2();
                            return function (t, n) {
                                var r = e.copy(n).multiplyScalar(0.5);
                                return this.min.copy(t).sub(r), this.max.copy(t).add(r), this;
                            };
                        })(),
                        copy: function (e) {
                            return this.min.copy(e.min), this.max.copy(e.max), this;
                        },
                        makeEmpty: function () {
                            return (this.min.x = this.min.y = Infinity), (this.max.x = this.max.y = -Infinity), this;
                        },
                        empty: function () {
                            return this.max.x < this.min.x || this.max.y < this.min.y;
                        },
                        center: function (e) {
                            var t = e || new THREE.Vector2();
                            return t.addVectors(this.min, this.max).multiplyScalar(0.5);
                        },
                        size: function (e) {
                            var t = e || new THREE.Vector2();
                            return t.subVectors(this.max, this.min);
                        },
                        expandByPoint: function (e) {
                            return this.min.min(e), this.max.max(e), this;
                        },
                        expandByVector: function (e) {
                            return this.min.sub(e), this.max.add(e), this;
                        },
                        expandByScalar: function (e) {
                            return this.min.addScalar(-e), this.max.addScalar(e), this;
                        },
                        containsPoint: function (e) {
                            return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y ? !1 : !0;
                        },
                        containsBox: function (e) {
                            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y ? !0 : !1;
                        },
                        getParameter: function (e) {
                            return new THREE.Vector2((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
                        },
                        isIntersectionBox: function (e) {
                            return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y ? !1 : !0;
                        },
                        clampPoint: function (e, t) {
                            var n = t || new THREE.Vector2();
                            return n.copy(e).clamp(this.min, this.max);
                        },
                        distanceToPoint: (function () {
                            var e = new THREE.Vector2();
                            return function (t) {
                                var n = e.copy(t).clamp(this.min, this.max);
                                return n.sub(t).length();
                            };
                        })(),
                        intersect: function (e) {
                            return this.min.max(e.min), this.max.min(e.max), this;
                        },
                        union: function (e) {
                            return this.min.min(e.min), this.max.max(e.max), this;
                        },
                        translate: function (e) {
                            return this.min.add(e), this.max.add(e), this;
                        },
                        equals: function (e) {
                            return e.min.equals(this.min) && e.max.equals(this.max);
                        },
                        clone: function () {
                            return new THREE.Box2().copy(this);
                        },
                    }),
                    (THREE.Box3 = function (e, t) {
                        (this.min = e !== undefined ? e : new THREE.Vector3(Infinity, Infinity, Infinity)), (this.max = t !== undefined ? t : new THREE.Vector3(-Infinity, -Infinity, -Infinity));
                    }),
                    (THREE.Box3.prototype = {
                        constructor: THREE.Box3,
                        set: function (e, t) {
                            return this.min.copy(e), this.max.copy(t), this;
                        },
                        addPoint: function (e) {
                            e.x < this.min.x ? (this.min.x = e.x) : e.x > this.max.x && (this.max.x = e.x),
                                e.y < this.min.y ? (this.min.y = e.y) : e.y > this.max.y && (this.max.y = e.y),
                                e.z < this.min.z ? (this.min.z = e.z) : e.z > this.max.z && (this.max.z = e.z);
                        },
                        setFromPoints: function (e) {
                            if (e.length > 0) {
                                var t = e[0];
                                this.min.copy(t), this.max.copy(t);
                                for (var n = 1, r = e.length; n < r; n++) this.addPoint(e[n]);
                            } else this.makeEmpty();
                            return this;
                        },
                        setFromCenterAndSize: (function () {
                            var e = new THREE.Vector3();
                            return function (t, n) {
                                var r = e.copy(n).multiplyScalar(0.5);
                                return this.min.copy(t).sub(r), this.max.copy(t).add(r), this;
                            };
                        })(),
                        setFromObject: (function () {
                            var e = new THREE.Vector3();
                            return function (t) {
                                var n = this;
                                return (
                                    t.updateMatrixWorld(!0),
                                        this.makeEmpty(),
                                        t.traverse(function (t) {
                                            if (t.geometry !== undefined && t.geometry.vertices !== undefined) {
                                                var r = t.geometry.vertices;
                                                for (var i = 0, s = r.length; i < s; i++) e.copy(r[i]), e.applyMatrix4(t.matrixWorld), n.expandByPoint(e);
                                            }
                                        }),
                                        this
                                );
                            };
                        })(),
                        copy: function (e) {
                            return this.min.copy(e.min), this.max.copy(e.max), this;
                        },
                        makeEmpty: function () {
                            return (this.min.x = this.min.y = this.min.z = Infinity), (this.max.x = this.max.y = this.max.z = -Infinity), this;
                        },
                        empty: function () {
                            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
                        },
                        center: function (e) {
                            var t = e || new THREE.Vector3();
                            return t.addVectors(this.min, this.max).multiplyScalar(0.5);
                        },
                        size: function (e) {
                            var t = e || new THREE.Vector3();
                            return t.subVectors(this.max, this.min);
                        },
                        expandByPoint: function (e) {
                            return this.min.min(e), this.max.max(e), this;
                        },
                        expandByVector: function (e) {
                            return this.min.sub(e), this.max.add(e), this;
                        },
                        expandByScalar: function (e) {
                            return this.min.addScalar(-e), this.max.addScalar(e), this;
                        },
                        containsPoint: function (e) {
                            return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z ? !1 : !0;
                        },
                        containsBox: function (e) {
                            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z ? !0 : !1;
                        },
                        getParameter: function (e) {
                            return new THREE.Vector3((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
                        },
                        isIntersectionBox: function (e) {
                            return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z ? !1 : !0;
                        },
                        clampPoint: function (e, t) {
                            var n = t || new THREE.Vector3();
                            return n.copy(e).clamp(this.min, this.max);
                        },
                        distanceToPoint: (function () {
                            var e = new THREE.Vector3();
                            return function (t) {
                                var n = e.copy(t).clamp(this.min, this.max);
                                return n.sub(t).length();
                            };
                        })(),
                        getBoundingSphere: (function () {
                            var e = new THREE.Vector3();
                            return function (t) {
                                var n = t || new THREE.Sphere();
                                return (n.center = this.center()), (n.radius = this.size(e).length() * 0.5), n;
                            };
                        })(),
                        intersect: function (e) {
                            return this.min.max(e.min), this.max.min(e.max), this;
                        },
                        union: function (e) {
                            return this.min.min(e.min), this.max.max(e.max), this;
                        },
                        applyMatrix4: (function () {
                            var e = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
                            return function (t) {
                                return (
                                    e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                                        e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                                        e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                                        e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                                        e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                                        e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                                        e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                                        e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                                        this.makeEmpty(),
                                        this.setFromPoints(e),
                                        this
                                );
                            };
                        })(),
                        translate: function (e) {
                            return this.min.add(e), this.max.add(e), this;
                        },
                        equals: function (e) {
                            return e.min.equals(this.min) && e.max.equals(this.max);
                        },
                        clone: function () {
                            return new THREE.Box3().copy(this);
                        },
                    }),
                (THREE.Matrix3 = function (e, t, n, r, i, s, o, u, a) {
                    (this.elements = new Float32Array(9)), this.set(e !== undefined ? e : 1, t || 0, n || 0, r || 0, i !== undefined ? i : 1, s || 0, o || 0, u || 0, a !== undefined ? a : 1);
                }),
                (THREE.Matrix3.prototype = {
                    constructor: THREE.Matrix3,
                    set: function (e, t, n, r, i, s, o, u, a) {
                        var f = this.elements;
                        return (f[0] = e), (f[3] = t), (f[6] = n), (f[1] = r), (f[4] = i), (f[7] = s), (f[2] = o), (f[5] = u), (f[8] = a), this;
                    },
                    identity: function () {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
                    },
                    copy: function (e) {
                        var t = e.elements;
                        return this.set(t[0], t[3], t[6], t[1], t[4], t[7], t[2], t[5], t[8]), this;
                    },
                    multiplyVector3: function (e) {
                        return console.warn("DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this);
                    },
                    multiplyVector3Array: (function () {
                        var e = new THREE.Vector3();
                        return function (t) {
                            for (var n = 0, r = t.length; n < r; n += 3) (e.x = t[n]), (e.y = t[n + 1]), (e.z = t[n + 2]), e.applyMatrix3(this), (t[n] = e.x), (t[n + 1] = e.y), (t[n + 2] = e.z);
                            return t;
                        };
                    })(),
                    multiplyScalar: function (e) {
                        var t = this.elements;
                        return (t[0] *= e), (t[3] *= e), (t[6] *= e), (t[1] *= e), (t[4] *= e), (t[7] *= e), (t[2] *= e), (t[5] *= e), (t[8] *= e), this;
                    },
                    determinant: function () {
                        var e = this.elements,
                            t = e[0],
                            n = e[1],
                            r = e[2],
                            i = e[3],
                            s = e[4],
                            o = e[5],
                            u = e[6],
                            a = e[7],
                            f = e[8];
                        return t * s * f - t * o * a - n * i * f + n * o * u + r * i * a - r * s * u;
                    },
                    getInverse: function (e, t) {
                        var n = e.elements,
                            r = this.elements;
                        (r[0] = n[10] * n[5] - n[6] * n[9]),
                            (r[1] = -n[10] * n[1] + n[2] * n[9]),
                            (r[2] = n[6] * n[1] - n[2] * n[5]),
                            (r[3] = -n[10] * n[4] + n[6] * n[8]),
                            (r[4] = n[10] * n[0] - n[2] * n[8]),
                            (r[5] = -n[6] * n[0] + n[2] * n[4]),
                            (r[6] = n[9] * n[4] - n[5] * n[8]),
                            (r[7] = -n[9] * n[0] + n[1] * n[8]),
                            (r[8] = n[5] * n[0] - n[1] * n[4]);
                        var i = n[0] * r[0] + n[1] * r[3] + n[2] * r[6];
                        if (i === 0) {
                            var s = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
                            if (t || !1) throw new Error(s);
                            return console.warn(s), this.identity(), this;
                        }
                        return this.multiplyScalar(1 / i), this;
                    },
                    transpose: function () {
                        var e,
                            t = this.elements;
                        return (e = t[1]), (t[1] = t[3]), (t[3] = e), (e = t[2]), (t[2] = t[6]), (t[6] = e), (e = t[5]), (t[5] = t[7]), (t[7] = e), this;
                    },
                    getNormalMatrix: function (e) {
                        return this.getInverse(e).transpose(), this;
                    },
                    transposeIntoArray: function (e) {
                        var t = this.elements;
                        return (e[0] = t[0]), (e[1] = t[3]), (e[2] = t[6]), (e[3] = t[1]), (e[4] = t[4]), (e[5] = t[7]), (e[6] = t[2]), (e[7] = t[5]), (e[8] = t[8]), this;
                    },
                    clone: function () {
                        var e = this.elements;
                        return new THREE.Matrix3(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]);
                    },
                }),
                (THREE.Matrix4 = function (e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v) {
                    this.elements = new Float32Array(16);
                    var m = this.elements;
                    (m[0] = e !== undefined ? e : 1),
                        (m[4] = t || 0),
                        (m[8] = n || 0),
                        (m[12] = r || 0),
                        (m[1] = i || 0),
                        (m[5] = s !== undefined ? s : 1),
                        (m[9] = o || 0),
                        (m[13] = u || 0),
                        (m[2] = a || 0),
                        (m[6] = f || 0),
                        (m[10] = l !== undefined ? l : 1),
                        (m[14] = c || 0),
                        (m[3] = h || 0),
                        (m[7] = p || 0),
                        (m[11] = d || 0),
                        (m[15] = v !== undefined ? v : 1);
                }),
                (THREE.Matrix4.prototype = {
                    constructor: THREE.Matrix4,
                    set: function (e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v) {
                        var m = this.elements;
                        return (m[0] = e), (m[4] = t), (m[8] = n), (m[12] = r), (m[1] = i), (m[5] = s), (m[9] = o), (m[13] = u), (m[2] = a), (m[6] = f), (m[10] = l), (m[14] = c), (m[3] = h), (m[7] = p), (m[11] = d), (m[15] = v), this;
                    },
                    identity: function () {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
                    },
                    copy: function (e) {
                        return this.elements.set(e.elements), this;
                    },
                    extractPosition: function (e) {
                        return console.warn("DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e);
                    },
                    copyPosition: function (e) {
                        var t = this.elements,
                            n = e.elements;
                        return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
                    },
                    extractRotation: (function () {
                        var e = new THREE.Vector3();
                        return function (t) {
                            var n = this.elements,
                                r = t.elements,
                                i = 1 / e.set(r[0], r[1], r[2]).length(),
                                s = 1 / e.set(r[4], r[5], r[6]).length(),
                                o = 1 / e.set(r[8], r[9], r[10]).length();
                            return (n[0] = r[0] * i), (n[1] = r[1] * i), (n[2] = r[2] * i), (n[4] = r[4] * s), (n[5] = r[5] * s), (n[6] = r[6] * s), (n[8] = r[8] * o), (n[9] = r[9] * o), (n[10] = r[10] * o), this;
                        };
                    })(),
                    makeRotationFromEuler: function (e) {
                        e instanceof THREE.Euler == 0 && console.error("ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
                        var t = this.elements,
                            n = e.x,
                            r = e.y,
                            i = e.z,
                            s = Math.cos(n),
                            o = Math.sin(n),
                            u = Math.cos(r),
                            a = Math.sin(r),
                            f = Math.cos(i),
                            l = Math.sin(i);
                        if (e.order === "XYZ") {
                            var c = s * f,
                                h = s * l,
                                p = o * f,
                                d = o * l;
                            (t[0] = u * f), (t[4] = -u * l), (t[8] = a), (t[1] = h + p * a), (t[5] = c - d * a), (t[9] = -o * u), (t[2] = d - c * a), (t[6] = p + h * a), (t[10] = s * u);
                        } else if (e.order === "YXZ") {
                            var v = u * f,
                                m = u * l,
                                g = a * f,
                                y = a * l;
                            (t[0] = v + y * o), (t[4] = g * o - m), (t[8] = s * a), (t[1] = s * l), (t[5] = s * f), (t[9] = -o), (t[2] = m * o - g), (t[6] = y + v * o), (t[10] = s * u);
                        } else if (e.order === "ZXY") {
                            var v = u * f,
                                m = u * l,
                                g = a * f,
                                y = a * l;
                            (t[0] = v - y * o), (t[4] = -s * l), (t[8] = g + m * o), (t[1] = m + g * o), (t[5] = s * f), (t[9] = y - v * o), (t[2] = -s * a), (t[6] = o), (t[10] = s * u);
                        } else if (e.order === "ZYX") {
                            var c = s * f,
                                h = s * l,
                                p = o * f,
                                d = o * l;
                            (t[0] = u * f), (t[4] = p * a - h), (t[8] = c * a + d), (t[1] = u * l), (t[5] = d * a + c), (t[9] = h * a - p), (t[2] = -a), (t[6] = o * u), (t[10] = s * u);
                        } else if (e.order === "YZX") {
                            var b = s * u,
                                w = s * a,
                                E = o * u,
                                S = o * a;
                            (t[0] = u * f), (t[4] = S - b * l), (t[8] = E * l + w), (t[1] = l), (t[5] = s * f), (t[9] = -o * f), (t[2] = -a * f), (t[6] = w * l + E), (t[10] = b - S * l);
                        } else if (e.order === "XZY") {
                            var b = s * u,
                                w = s * a,
                                E = o * u,
                                S = o * a;
                            (t[0] = u * f), (t[4] = -l), (t[8] = a * f), (t[1] = b * l + S), (t[5] = s * f), (t[9] = w * l - E), (t[2] = E * l - w), (t[6] = o * f), (t[10] = S * l + b);
                        }
                        return (t[3] = 0), (t[7] = 0), (t[11] = 0), (t[12] = 0), (t[13] = 0), (t[14] = 0), (t[15] = 1), this;
                    },
                    setRotationFromQuaternion: function (e) {
                        return console.warn("DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code."), this.makeRotationFromQuaternion(e);
                    },
                    makeRotationFromQuaternion: function (e) {
                        var t = this.elements,
                            n = e.x,
                            r = e.y,
                            i = e.z,
                            s = e.w,
                            o = n + n,
                            u = r + r,
                            a = i + i,
                            f = n * o,
                            l = n * u,
                            c = n * a,
                            h = r * u,
                            p = r * a,
                            d = i * a,
                            v = s * o,
                            m = s * u,
                            g = s * a;
                        return (
                            (t[0] = 1 - (h + d)),
                                (t[4] = l - g),
                                (t[8] = c + m),
                                (t[1] = l + g),
                                (t[5] = 1 - (f + d)),
                                (t[9] = p - v),
                                (t[2] = c - m),
                                (t[6] = p + v),
                                (t[10] = 1 - (f + h)),
                                (t[3] = 0),
                                (t[7] = 0),
                                (t[11] = 0),
                                (t[12] = 0),
                                (t[13] = 0),
                                (t[14] = 0),
                                (t[15] = 1),
                                this
                        );
                    },
                    lookAt: (function () {
                        var e = new THREE.Vector3(),
                            t = new THREE.Vector3(),
                            n = new THREE.Vector3();
                        return function (r, i, s) {
                            var o = this.elements;
                            return (
                                n.subVectors(r, i).normalize(),
                                n.length() === 0 && (n.z = 1),
                                    e.crossVectors(s, n).normalize(),
                                e.length() === 0 && ((n.x += 1e-4), e.crossVectors(s, n).normalize()),
                                    t.crossVectors(n, e),
                                    (o[0] = e.x),
                                    (o[4] = t.x),
                                    (o[8] = n.x),
                                    (o[1] = e.y),
                                    (o[5] = t.y),
                                    (o[9] = n.y),
                                    (o[2] = e.z),
                                    (o[6] = t.z),
                                    (o[10] = n.z),
                                    this
                            );
                        };
                    })(),
                    multiply: function (e, t) {
                        return t !== undefined ? (console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e);
                    },
                    multiplyMatrices: function (e, t) {
                        var n = e.elements,
                            r = t.elements,
                            i = this.elements,
                            s = n[0],
                            o = n[4],
                            u = n[8],
                            a = n[12],
                            f = n[1],
                            l = n[5],
                            c = n[9],
                            h = n[13],
                            p = n[2],
                            d = n[6],
                            v = n[10],
                            m = n[14],
                            g = n[3],
                            y = n[7],
                            b = n[11],
                            w = n[15],
                            E = r[0],
                            S = r[4],
                            x = r[8],
                            T = r[12],
                            N = r[1],
                            C = r[5],
                            k = r[9],
                            L = r[13],
                            A = r[2],
                            O = r[6],
                            M = r[10],
                            _ = r[14],
                            D = r[3],
                            P = r[7],
                            H = r[11],
                            B = r[15];
                        return (
                            (i[0] = s * E + o * N + u * A + a * D),
                                (i[4] = s * S + o * C + u * O + a * P),
                                (i[8] = s * x + o * k + u * M + a * H),
                                (i[12] = s * T + o * L + u * _ + a * B),
                                (i[1] = f * E + l * N + c * A + h * D),
                                (i[5] = f * S + l * C + c * O + h * P),
                                (i[9] = f * x + l * k + c * M + h * H),
                                (i[13] = f * T + l * L + c * _ + h * B),
                                (i[2] = p * E + d * N + v * A + m * D),
                                (i[6] = p * S + d * C + v * O + m * P),
                                (i[10] = p * x + d * k + v * M + m * H),
                                (i[14] = p * T + d * L + v * _ + m * B),
                                (i[3] = g * E + y * N + b * A + w * D),
                                (i[7] = g * S + y * C + b * O + w * P),
                                (i[11] = g * x + y * k + b * M + w * H),
                                (i[15] = g * T + y * L + b * _ + w * B),
                                this
                        );
                    },
                    multiplyToArray: function (e, t, n) {
                        var r = this.elements;
                        return (
                            this.multiplyMatrices(e, t),
                                (n[0] = r[0]),
                                (n[1] = r[1]),
                                (n[2] = r[2]),
                                (n[3] = r[3]),
                                (n[4] = r[4]),
                                (n[5] = r[5]),
                                (n[6] = r[6]),
                                (n[7] = r[7]),
                                (n[8] = r[8]),
                                (n[9] = r[9]),
                                (n[10] = r[10]),
                                (n[11] = r[11]),
                                (n[12] = r[12]),
                                (n[13] = r[13]),
                                (n[14] = r[14]),
                                (n[15] = r[15]),
                                this
                        );
                    },
                    multiplyScalar: function (e) {
                        var t = this.elements;
                        return (t[0] *= e), (t[4] *= e), (t[8] *= e), (t[12] *= e), (t[1] *= e), (t[5] *= e), (t[9] *= e), (t[13] *= e), (t[2] *= e), (t[6] *= e), (t[10] *= e), (t[14] *= e), (t[3] *= e), (t[7] *= e), (t[11] *= e), (t[15] *= e), this;
                    },
                    multiplyVector3: function (e) {
                        return console.warn("DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), e.applyProjection(this);
                    },
                    multiplyVector4: function (e) {
                        return console.warn("DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
                    },
                    multiplyVector3Array: (function () {
                        var e = new THREE.Vector3();
                        return function (t) {
                            for (var n = 0, r = t.length; n < r; n += 3) (e.x = t[n]), (e.y = t[n + 1]), (e.z = t[n + 2]), e.applyProjection(this), (t[n] = e.x), (t[n + 1] = e.y), (t[n + 2] = e.z);
                            return t;
                        };
                    })(),
                    rotateAxis: function (e) {
                        console.warn("DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this);
                    },
                    crossVector: function (e) {
                        return console.warn("DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
                    },
                    determinant: function () {
                        var e = this.elements,
                            t = e[0],
                            n = e[4],
                            r = e[8],
                            i = e[12],
                            s = e[1],
                            o = e[5],
                            u = e[9],
                            a = e[13],
                            f = e[2],
                            l = e[6],
                            c = e[10],
                            h = e[14],
                            p = e[3],
                            d = e[7],
                            v = e[11],
                            m = e[15];
                        return (
                            p * (+i * u * l - r * a * l - i * o * c + n * a * c + r * o * h - n * u * h) +
                            d * (+t * u * h - t * a * c + i * s * c - r * s * h + r * a * f - i * u * f) +
                            v * (+t * a * l - t * o * h - i * s * l + n * s * h + i * o * f - n * a * f) +
                            m * (-r * o * f - t * u * l + t * o * c + r * s * l - n * s * c + n * u * f)
                        );
                    },
                    transpose: function () {
                        var e = this.elements,
                            t;
                        return (
                            (t = e[1]),
                                (e[1] = e[4]),
                                (e[4] = t),
                                (t = e[2]),
                                (e[2] = e[8]),
                                (e[8] = t),
                                (t = e[6]),
                                (e[6] = e[9]),
                                (e[9] = t),
                                (t = e[3]),
                                (e[3] = e[12]),
                                (e[12] = t),
                                (t = e[7]),
                                (e[7] = e[13]),
                                (e[13] = t),
                                (t = e[11]),
                                (e[11] = e[14]),
                                (e[14] = t),
                                this
                        );
                    },
                    flattenToArray: function (e) {
                        var t = this.elements;
                        return (
                            (e[0] = t[0]),
                                (e[1] = t[1]),
                                (e[2] = t[2]),
                                (e[3] = t[3]),
                                (e[4] = t[4]),
                                (e[5] = t[5]),
                                (e[6] = t[6]),
                                (e[7] = t[7]),
                                (e[8] = t[8]),
                                (e[9] = t[9]),
                                (e[10] = t[10]),
                                (e[11] = t[11]),
                                (e[12] = t[12]),
                                (e[13] = t[13]),
                                (e[14] = t[14]),
                                (e[15] = t[15]),
                                e
                        );
                    },
                    flattenToArrayOffset: function (e, t) {
                        var n = this.elements;
                        return (
                            (e[t] = n[0]),
                                (e[t + 1] = n[1]),
                                (e[t + 2] = n[2]),
                                (e[t + 3] = n[3]),
                                (e[t + 4] = n[4]),
                                (e[t + 5] = n[5]),
                                (e[t + 6] = n[6]),
                                (e[t + 7] = n[7]),
                                (e[t + 8] = n[8]),
                                (e[t + 9] = n[9]),
                                (e[t + 10] = n[10]),
                                (e[t + 11] = n[11]),
                                (e[t + 12] = n[12]),
                                (e[t + 13] = n[13]),
                                (e[t + 14] = n[14]),
                                (e[t + 15] = n[15]),
                                e
                        );
                    },
                    getPosition: (function () {
                        var e = new THREE.Vector3();
                        return function () {
                            console.warn("DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.");
                            var t = this.elements;
                            return e.set(t[12], t[13], t[14]);
                        };
                    })(),
                    setPosition: function (e) {
                        var t = this.elements;
                        return (t[12] = e.x), (t[13] = e.y), (t[14] = e.z), this;
                    },
                    getInverse: function (e, t) {
                        var n = this.elements,
                            r = e.elements,
                            i = r[0],
                            s = r[4],
                            o = r[8],
                            u = r[12],
                            a = r[1],
                            f = r[5],
                            l = r[9],
                            c = r[13],
                            h = r[2],
                            p = r[6],
                            d = r[10],
                            v = r[14],
                            m = r[3],
                            g = r[7],
                            y = r[11],
                            b = r[15];
                        (n[0] = l * v * g - c * d * g + c * p * y - f * v * y - l * p * b + f * d * b),
                            (n[4] = u * d * g - o * v * g - u * p * y + s * v * y + o * p * b - s * d * b),
                            (n[8] = o * c * g - u * l * g + u * f * y - s * c * y - o * f * b + s * l * b),
                            (n[12] = u * l * p - o * c * p - u * f * d + s * c * d + o * f * v - s * l * v),
                            (n[1] = c * d * m - l * v * m - c * h * y + a * v * y + l * h * b - a * d * b),
                            (n[5] = o * v * m - u * d * m + u * h * y - i * v * y - o * h * b + i * d * b),
                            (n[9] = u * l * m - o * c * m - u * a * y + i * c * y + o * a * b - i * l * b),
                            (n[13] = o * c * h - u * l * h + u * a * d - i * c * d - o * a * v + i * l * v),
                            (n[2] = f * v * m - c * p * m + c * h * g - a * v * g - f * h * b + a * p * b),
                            (n[6] = u * p * m - s * v * m - u * h * g + i * v * g + s * h * b - i * p * b),
                            (n[10] = s * c * m - u * f * m + u * a * g - i * c * g - s * a * b + i * f * b),
                            (n[14] = u * f * h - s * c * h - u * a * p + i * c * p + s * a * v - i * f * v),
                            (n[3] = l * p * m - f * d * m - l * h * g + a * d * g + f * h * y - a * p * y),
                            (n[7] = s * d * m - o * p * m + o * h * g - i * d * g - s * h * y + i * p * y),
                            (n[11] = o * f * m - s * l * m - o * a * g + i * l * g + s * a * y - i * f * y),
                            (n[15] = s * l * h - o * f * h + o * a * p - i * l * p - s * a * d + i * f * d);
                        var w = i * n[0] + a * n[4] + h * n[8] + m * n[12];
                        if (w == 0) {
                            var E = "Matrix4.getInverse(): can't invert matrix, determinant is 0";
                            if (t || !1) throw new Error(E);
                            return console.warn(E), this.identity(), this;
                        }
                        return this.multiplyScalar(1 / w), this;
                    },
                    translate: function (e) {
                        console.warn("DEPRECATED: Matrix4's .translate() has been removed.");
                    },
                    rotateX: function (e) {
                        console.warn("DEPRECATED: Matrix4's .rotateX() has been removed.");
                    },
                    rotateY: function (e) {
                        console.warn("DEPRECATED: Matrix4's .rotateY() has been removed.");
                    },
                    rotateZ: function (e) {
                        console.warn("DEPRECATED: Matrix4's .rotateZ() has been removed.");
                    },
                    rotateByAxis: function (e, t) {
                        console.warn("DEPRECATED: Matrix4's .rotateByAxis() has been removed.");
                    },
                    scale: function (e) {
                        var t = this.elements,
                            n = e.x,
                            r = e.y,
                            i = e.z;
                        return (t[0] *= n), (t[4] *= r), (t[8] *= i), (t[1] *= n), (t[5] *= r), (t[9] *= i), (t[2] *= n), (t[6] *= r), (t[10] *= i), (t[3] *= n), (t[7] *= r), (t[11] *= i), this;
                    },
                    getMaxScaleOnAxis: function () {
                        var e = this.elements,
                            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                            r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                        return Math.sqrt(Math.max(t, Math.max(n, r)));
                    },
                    makeTranslation: function (e, t, n) {
                        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
                    },
                    makeRotationX: function (e) {
                        var t = Math.cos(e),
                            n = Math.sin(e);
                        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
                    },
                    makeRotationY: function (e) {
                        var t = Math.cos(e),
                            n = Math.sin(e);
                        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
                    },
                    makeRotationZ: function (e) {
                        var t = Math.cos(e),
                            n = Math.sin(e);
                        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
                    },
                    makeRotationAxis: function (e, t) {
                        var n = Math.cos(t),
                            r = Math.sin(t),
                            i = 1 - n,
                            s = e.x,
                            o = e.y,
                            u = e.z,
                            a = i * s,
                            f = i * o;
                        return this.set(a * s + n, a * o - r * u, a * u + r * o, 0, a * o + r * u, f * o + n, f * u - r * s, 0, a * u - r * o, f * u + r * s, i * u * u + n, 0, 0, 0, 0, 1), this;
                    },
                    makeScale: function (e, t, n) {
                        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
                    },
                    compose: function (e, t, n) {
                        return this.makeRotationFromQuaternion(t), this.scale(n), this.setPosition(e), this;
                    },
                    decompose: (function () {
                        var e = new THREE.Vector3(),
                            t = new THREE.Matrix4();
                        return function (n, r, i) {
                            var s = this.elements,
                                o = e.set(s[0], s[1], s[2]).length(),
                                u = e.set(s[4], s[5], s[6]).length(),
                                a = e.set(s[8], s[9], s[10]).length();
                            (n.x = s[12]), (n.y = s[13]), (n.z = s[14]), t.elements.set(this.elements);
                            var f = 1 / o,
                                l = 1 / u,
                                c = 1 / a;
                            return (
                                (t.elements[0] *= f),
                                    (t.elements[1] *= f),
                                    (t.elements[2] *= f),
                                    (t.elements[4] *= l),
                                    (t.elements[5] *= l),
                                    (t.elements[6] *= l),
                                    (t.elements[8] *= c),
                                    (t.elements[9] *= c),
                                    (t.elements[10] *= c),
                                    r.setFromRotationMatrix(t),
                                    (i.x = o),
                                    (i.y = u),
                                    (i.z = a),
                                    this
                            );
                        };
                    })(),
                    makeFrustum: function (e, t, n, r, i, s) {
                        var o = this.elements,
                            u = (2 * i) / (t - e),
                            a = (2 * i) / (r - n),
                            f = (t + e) / (t - e),
                            l = (r + n) / (r - n),
                            c = -(s + i) / (s - i),
                            h = (-2 * s * i) / (s - i);
                        return (o[0] = u), (o[4] = 0), (o[8] = f), (o[12] = 0), (o[1] = 0), (o[5] = a), (o[9] = l), (o[13] = 0), (o[2] = 0), (o[6] = 0), (o[10] = c), (o[14] = h), (o[3] = 0), (o[7] = 0), (o[11] = -1), (o[15] = 0), this;
                    },
                    makePerspective: function (e, t, n, r) {
                        var i = n * Math.tan(THREE.Math.degToRad(e * 0.5)),
                            s = -i,
                            o = s * t,
                            u = i * t;
                        return this.makeFrustum(o, u, s, i, n, r);
                    },
                    makeOrthographic: function (e, t, n, r, i, s) {
                        var o = this.elements,
                            u = t - e,
                            a = n - r,
                            f = s - i,
                            l = (t + e) / u,
                            c = (n + r) / a,
                            h = (s + i) / f;
                        return (o[0] = 2 / u), (o[4] = 0), (o[8] = 0), (o[12] = -l), (o[1] = 0), (o[5] = 2 / a), (o[9] = 0), (o[13] = -c), (o[2] = 0), (o[6] = 0), (o[10] = -2 / f), (o[14] = -h), (o[3] = 0), (o[7] = 0), (o[11] = 0), (o[15] = 1), this;
                    },
                    fromArray: function (e) {
                        return this.elements.set(e), this;
                    },
                    toArray: function () {
                        var e = this.elements;
                        return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]];
                    },
                    clone: function () {
                        var e = this.elements;
                        return new THREE.Matrix4(e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15]);
                    },
                }),
                (THREE.Ray = function (e, t) {
                    (this.origin = e !== undefined ? e : new THREE.Vector3()), (this.direction = t !== undefined ? t : new THREE.Vector3());
                }),
                (THREE.Ray.prototype = {
                    constructor: THREE.Ray,
                    set: function (e, t) {
                        return this.origin.copy(e), this.direction.copy(t), this;
                    },
                    copy: function (e) {
                        return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
                    },
                    at: function (e, t) {
                        var n = t || new THREE.Vector3();
                        return n.copy(this.direction).multiplyScalar(e).add(this.origin);
                    },
                    recast: (function () {
                        var e = new THREE.Vector3();
                        return function (t) {
                            return this.origin.copy(this.at(t, e)), this;
                        };
                    })(),
                    closestPointToPoint: function (e, t) {
                        var n = t || new THREE.Vector3();
                        n.subVectors(e, this.origin);
                        var r = n.dot(this.direction);
                        return r < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin);
                    },
                    distanceToPoint: (function () {
                        var e = new THREE.Vector3();
                        return function (t) {
                            var n = e.subVectors(t, this.origin).dot(this.direction);
                            return n < 0 ? this.origin.distanceTo(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceTo(t));
                        };
                    })(),
                    distanceSqToSegment: function (e, t, n, r) {
                        var i = e.clone().add(t).multiplyScalar(0.5),
                            s = t.clone().sub(e).normalize(),
                            o = e.distanceTo(t) * 0.5,
                            u = this.origin.clone().sub(i),
                            a = -this.direction.dot(s),
                            f = u.dot(this.direction),
                            l = -u.dot(s),
                            c = u.lengthSq(),
                            h = Math.abs(1 - a * a),
                            p,
                            d,
                            v,
                            m;
                        if (h >= 0) {
                            (p = a * l - f), (d = a * f - l), (m = o * h);
                            if (p >= 0)
                                if (d >= -m)
                                    if (d <= m) {
                                        var g = 1 / h;
                                        (p *= g), (d *= g), (v = p * (p + a * d + 2 * f) + d * (a * p + d + 2 * l) + c);
                                    } else (d = o), (p = Math.max(0, -(a * d + f))), (v = -p * p + d * (d + 2 * l) + c);
                                else (d = -o), (p = Math.max(0, -(a * d + f))), (v = -p * p + d * (d + 2 * l) + c);
                            else
                                d <= -m
                                    ? ((p = Math.max(0, -(-a * o + f))), (d = p > 0 ? -o : Math.min(Math.max(-o, -l), o)), (v = -p * p + d * (d + 2 * l) + c))
                                    : d <= m
                                    ? ((p = 0), (d = Math.min(Math.max(-o, -l), o)), (v = d * (d + 2 * l) + c))
                                    : ((p = Math.max(0, -(a * o + f))), (d = p > 0 ? o : Math.min(Math.max(-o, -l), o)), (v = -p * p + d * (d + 2 * l) + c));
                        } else (d = a > 0 ? -o : o), (p = Math.max(0, -(a * d + f))), (v = -p * p + d * (d + 2 * l) + c);
                        return n && n.copy(this.direction.clone().multiplyScalar(p).add(this.origin)), r && r.copy(s.clone().multiplyScalar(d).add(i)), v;
                    },
                    isIntersectionSphere: function (e) {
                        return this.distanceToPoint(e.center) <= e.radius;
                    },
                    isIntersectionPlane: function (e) {
                        var t = e.distanceToPoint(this.origin);
                        if (t === 0) return !0;
                        var n = e.normal.dot(this.direction);
                        return n * t < 0 ? !0 : !1;
                    },
                    distanceToPlane: function (e) {
                        var t = e.normal.dot(this.direction);
                        if (t == 0) return e.distanceToPoint(this.origin) == 0 ? 0 : null;
                        var n = -(this.origin.dot(e.normal) + e.constant) / t;
                        return n >= 0 ? n : null;
                    },
                    intersectPlane: function (e, t) {
                        var n = this.distanceToPlane(e);
                        return n === null ? null : this.at(n, t);
                    },
                    isIntersectionBox: (function () {
                        var e = new THREE.Vector3();
                        return function (t) {
                            return this.intersectBox(t, e) !== null;
                        };
                    })(),
                    intersectBox: function (e, t) {
                        var n,
                            r,
                            i,
                            s,
                            o,
                            u,
                            a = 1 / this.direction.x,
                            f = 1 / this.direction.y,
                            l = 1 / this.direction.z,
                            c = this.origin;
                        a >= 0 ? ((n = (e.min.x - c.x) * a), (r = (e.max.x - c.x) * a)) : ((n = (e.max.x - c.x) * a), (r = (e.min.x - c.x) * a)),
                            f >= 0 ? ((i = (e.min.y - c.y) * f), (s = (e.max.y - c.y) * f)) : ((i = (e.max.y - c.y) * f), (s = (e.min.y - c.y) * f));
                        if (n > s || i > r) return null;
                        if (i > n || n !== n) n = i;
                        if (s < r || r !== r) r = s;
                        l >= 0 ? ((o = (e.min.z - c.z) * l), (u = (e.max.z - c.z) * l)) : ((o = (e.max.z - c.z) * l), (u = (e.min.z - c.z) * l));
                        if (n > u || o > r) return null;
                        if (o > n || n !== n) n = o;
                        if (u < r || r !== r) r = u;
                        return r < 0 ? null : this.at(n >= 0 ? n : r, t);
                    },
                    intersectTriangle: (function () {
                        var e = new THREE.Vector3(),
                            t = new THREE.Vector3(),
                            n = new THREE.Vector3(),
                            r = new THREE.Vector3();
                        return function (i, s, o, u, a) {
                            t.subVectors(s, i), n.subVectors(o, i), r.crossVectors(t, n);
                            var f = this.direction.dot(r),
                                l;
                            if (f > 0) {
                                if (u) return null;
                                l = 1;
                            } else {
                                if (!(f < 0)) return null;
                                (l = -1), (f = -f);
                            }
                            e.subVectors(this.origin, i);
                            var c = l * this.direction.dot(n.crossVectors(e, n));
                            if (c < 0) return null;
                            var h = l * this.direction.dot(t.cross(e));
                            if (h < 0) return null;
                            if (c + h > f) return null;
                            var p = -l * e.dot(r);
                            return p < 0 ? null : this.at(p / f, a);
                        };
                    })(),
                    applyMatrix4: function (e) {
                        return this.direction.add(this.origin).applyMatrix4(e), this.origin.applyMatrix4(e), this.direction.sub(this.origin), this.direction.normalize(), this;
                    },
                    equals: function (e) {
                        return e.origin.equals(this.origin) && e.direction.equals(this.direction);
                    },
                    clone: function () {
                        return new THREE.Ray().copy(this);
                    },
                }),
                (THREE.Sphere = function (e, t) {
                    (this.center = e !== undefined ? e : new THREE.Vector3()), (this.radius = t !== undefined ? t : 0);
                }),
                (THREE.Sphere.prototype = {
                    constructor: THREE.Sphere,
                    set: function (e, t) {
                        return this.center.copy(e), (this.radius = t), this;
                    },
                    setFromPoints: (function () {
                        var e = new THREE.Box3();
                        return function (t, n) {
                            var r = this.center;
                            n !== undefined ? r.copy(n) : e.setFromPoints(t).center(r);
                            var i = 0;
                            for (var s = 0, o = t.length; s < o; s++) i = Math.max(i, r.distanceToSquared(t[s]));
                            return (this.radius = Math.sqrt(i)), this;
                        };
                    })(),
                    copy: function (e) {
                        return this.center.copy(e.center), (this.radius = e.radius), this;
                    },
                    empty: function () {
                        return this.radius <= 0;
                    },
                    containsPoint: function (e) {
                        return e.distanceToSquared(this.center) <= this.radius * this.radius;
                    },
                    distanceToPoint: function (e) {
                        return e.distanceTo(this.center) - this.radius;
                    },
                    intersectsSphere: function (e) {
                        var t = this.radius + e.radius;
                        return e.center.distanceToSquared(this.center) <= t * t;
                    },
                    clampPoint: function (e, t) {
                        var n = this.center.distanceToSquared(e),
                            r = t || new THREE.Vector3();
                        return r.copy(e), n > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)), r;
                    },
                    getBoundingBox: function (e) {
                        var t = e || new THREE.Box3();
                        return t.set(this.center, this.center), t.expandByScalar(this.radius), t;
                    },
                    applyMatrix4: function (e) {
                        return this.center.applyMatrix4(e), (this.radius = this.radius * e.getMaxScaleOnAxis()), this;
                    },
                    translate: function (e) {
                        return this.center.add(e), this;
                    },
                    equals: function (e) {
                        return e.center.equals(this.center) && e.radius === this.radius;
                    },
                    clone: function () {
                        return new THREE.Sphere().copy(this);
                    },
                }),
                (THREE.Frustum = function (e, t, n, r, i, s) {
                    this.planes = [
                        e !== undefined ? e : new THREE.Plane(),
                        t !== undefined ? t : new THREE.Plane(),
                        n !== undefined ? n : new THREE.Plane(),
                        r !== undefined ? r : new THREE.Plane(),
                        i !== undefined ? i : new THREE.Plane(),
                        s !== undefined ? s : new THREE.Plane(),
                    ];
                }),
                (THREE.Frustum.prototype = {
                    constructor: THREE.Frustum,
                    set: function (e, t, n, r, i, s) {
                        var o = this.planes;
                        return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(s), this;
                    },
                    copy: function (e) {
                        var t = this.planes;
                        for (var n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                        return this;
                    },
                    setFromMatrix: function (e) {
                        var t = this.planes,
                            n = e.elements,
                            r = n[0],
                            i = n[1],
                            s = n[2],
                            o = n[3],
                            u = n[4],
                            a = n[5],
                            f = n[6],
                            l = n[7],
                            c = n[8],
                            h = n[9],
                            p = n[10],
                            d = n[11],
                            v = n[12],
                            m = n[13],
                            g = n[14],
                            y = n[15];
                        return (
                            t[0].setComponents(o - r, l - u, d - c, y - v).normalize(),
                                t[1].setComponents(o + r, l + u, d + c, y + v).normalize(),
                                t[2].setComponents(o + i, l + a, d + h, y + m).normalize(),
                                t[3].setComponents(o - i, l - a, d - h, y - m).normalize(),
                                t[4].setComponents(o - s, l - f, d - p, y - g).normalize(),
                                t[5].setComponents(o + s, l + f, d + p, y + g).normalize(),
                                this
                        );
                    },
                    intersectsObject: (function () {
                        var e = new THREE.Sphere();
                        return function (t) {
                            var n = t.geometry;
                            return n.boundingSphere === null && n.computeBoundingSphere(), e.copy(n.boundingSphere), e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e);
                        };
                    })(),
                    intersectsSphere: function (e) {
                        var t = this.planes,
                            n = e.center,
                            r = -e.radius;
                        for (var i = 0; i < 6; i++) {
                            var s = t[i].distanceToPoint(n);
                            if (s < r) return !1;
                        }
                        return !0;
                    },
                    intersectsBox: (function () {
                        var e = new THREE.Vector3(),
                            t = new THREE.Vector3();
                        return function (n) {
                            var r = this.planes;
                            for (var i = 0; i < 6; i++) {
                                var s = r[i];
                                (e.x = s.normal.x > 0 ? n.min.x : n.max.x),
                                    (t.x = s.normal.x > 0 ? n.max.x : n.min.x),
                                    (e.y = s.normal.y > 0 ? n.min.y : n.max.y),
                                    (t.y = s.normal.y > 0 ? n.max.y : n.min.y),
                                    (e.z = s.normal.z > 0 ? n.min.z : n.max.z),
                                    (t.z = s.normal.z > 0 ? n.max.z : n.min.z);
                                var o = s.distanceToPoint(e),
                                    u = s.distanceToPoint(t);
                                if (o < 0 && u < 0) return !1;
                            }
                            return !0;
                        };
                    })(),
                    containsPoint: function (e) {
                        var t = this.planes;
                        for (var n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
                        return !0;
                    },
                    clone: function () {
                        return new THREE.Frustum().copy(this);
                    },
                }),
                (THREE.Plane = function (e, t) {
                    (this.normal = e !== undefined ? e : new THREE.Vector3(1, 0, 0)), (this.constant = t !== undefined ? t : 0);
                }),
                (THREE.Plane.prototype = {
                    constructor: THREE.Plane,
                    set: function (e, t) {
                        return this.normal.copy(e), (this.constant = t), this;
                    },
                    setComponents: function (e, t, n, r) {
                        return this.normal.set(e, t, n), (this.constant = r), this;
                    },
                    setFromNormalAndCoplanarPoint: function (e, t) {
                        return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
                    },
                    setFromCoplanarPoints: (function () {
                        var e = new THREE.Vector3(),
                            t = new THREE.Vector3();
                        return function (n, r, i) {
                            var s = e.subVectors(i, r).cross(t.subVectors(n, r)).normalize();
                            return this.setFromNormalAndCoplanarPoint(s, n), this;
                        };
                    })(),
                    copy: function (e) {
                        return this.normal.copy(e.normal), (this.constant = e.constant), this;
                    },
                    normalize: function () {
                        var e = 1 / this.normal.length();
                        return this.normal.multiplyScalar(e), (this.constant *= e), this;
                    },
                    negate: function () {
                        return (this.constant *= -1), this.normal.negate(), this;
                    },
                    distanceToPoint: function (e) {
                        return this.normal.dot(e) + this.constant;
                    },
                    distanceToSphere: function (e) {
                        return this.distanceToPoint(e.center) - e.radius;
                    },
                    projectPoint: function (e, t) {
                        return this.orthoPoint(e, t).sub(e).negate();
                    },
                    orthoPoint: function (e, t) {
                        var n = this.distanceToPoint(e),
                            r = t || new THREE.Vector3();
                        return r.copy(this.normal).multiplyScalar(n);
                    },
                    isIntersectionLine: function (e) {
                        var t = this.distanceToPoint(e.start),
                            n = this.distanceToPoint(e.end);
                        return (t < 0 && n > 0) || (n < 0 && t > 0);
                    },
                    intersectLine: (function () {
                        var e = new THREE.Vector3();
                        return function (t, n) {
                            var r = n || new THREE.Vector3(),
                                i = t.delta(e),
                                s = this.normal.dot(i);
                            if (s == 0) return this.distanceToPoint(t.start) == 0 ? r.copy(t.start) : undefined;
                            var o = -(t.start.dot(this.normal) + this.constant) / s;
                            return o < 0 || o > 1 ? undefined : r.copy(i).multiplyScalar(o).add(t.start);
                        };
                    })(),
                    coplanarPoint: function (e) {
                        var t = e || new THREE.Vector3();
                        return t.copy(this.normal).multiplyScalar(-this.constant);
                    },
                    applyMatrix4: (function () {
                        var e = new THREE.Vector3(),
                            t = new THREE.Vector3();
                        return function (n, r) {
                            r = r || new THREE.Matrix3().getNormalMatrix(n);
                            var i = e.copy(this.normal).applyMatrix3(r),
                                s = this.coplanarPoint(t);
                            return s.applyMatrix4(n), this.setFromNormalAndCoplanarPoint(i, s), this;
                        };
                    })(),
                    translate: function (e) {
                        return (this.constant = this.constant - e.dot(this.normal)), this;
                    },
                    equals: function (e) {
                        return e.normal.equals(this.normal) && e.constant == this.constant;
                    },
                    clone: function () {
                        return new THREE.Plane().copy(this);
                    },
                }),
                (THREE.Math = {
                    PI2: Math.PI * 2,
                    generateUUID: (function () {
                        var e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                            t = new Array(36),
                            n = 0,
                            r;
                        return function () {
                            for (var i = 0; i < 36; i++)
                                i == 8 || i == 13 || i == 18 || i == 23 ? (t[i] = "-") : i == 14 ? (t[i] = "4") : (n <= 2 && (n = (33554432 + Math.random() * 16777216) | 0), (r = n & 15), (n >>= 4), (t[i] = e[i == 19 ? (r & 3) | 8 : r]));
                            return t.join("");
                        };
                    })(),
                    clamp: function (e, t, n) {
                        return e < t ? t : e > n ? n : e;
                    },
                    clampBottom: function (e, t) {
                        return e < t ? t : e;
                    },
                    mapLinear: function (e, t, n, r, i) {
                        return r + ((e - t) * (i - r)) / (n - t);
                    },
                    smoothstep: function (e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : ((e = (e - t) / (n - t)), e * e * (3 - 2 * e));
                    },
                    smootherstep: function (e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : ((e = (e - t) / (n - t)), e * e * e * (e * (e * 6 - 15) + 10));
                    },
                    random16: function () {
                        return (65280 * Math.random() + 255 * Math.random()) / 65535;
                    },
                    randInt: function (e, t) {
                        return e + Math.floor(Math.random() * (t - e + 1));
                    },
                    randFloat: function (e, t) {
                        return e + Math.random() * (t - e);
                    },
                    randFloatSpread: function (e) {
                        return e * (0.5 - Math.random());
                    },
                    sign: function (e) {
                        return e < 0 ? -1 : e > 0 ? 1 : 0;
                    },
                    degToRad: (function () {
                        var e = Math.PI / 180;
                        return function (t) {
                            return t * e;
                        };
                    })(),
                    radToDeg: (function () {
                        var e = 180 / Math.PI;
                        return function (t) {
                            return t * e;
                        };
                    })(),
                }),
                (THREE.Spline = function (e) {
                    function h(e, t, n, r, i, s, o) {
                        var u = (n - e) * 0.5,
                            a = (r - t) * 0.5;
                        return (2 * (t - n) + u + a) * o + (-3 * (t - n) - 2 * u - a) * s + u * i + t;
                    }
                    this.points = e;
                    var t = [],
                        n = { x: 0, y: 0, z: 0 },
                        r,
                        i,
                        s,
                        o,
                        u,
                        a,
                        f,
                        l,
                        c;
                    (this.initFromArray = function (e) {
                        this.points = [];
                        for (var t = 0; t < e.length; t++) this.points[t] = { x: e[t][0], y: e[t][1], z: e[t][2] };
                    }),
                        (this.getPoint = function (e) {
                            return (
                                (r = (this.points.length - 1) * e),
                                    (i = Math.floor(r)),
                                    (s = r - i),
                                    (t[0] = i === 0 ? i : i - 1),
                                    (t[1] = i),
                                    (t[2] = i > this.points.length - 2 ? this.points.length - 1 : i + 1),
                                    (t[3] = i > this.points.length - 3 ? this.points.length - 1 : i + 2),
                                    (a = this.points[t[0]]),
                                    (f = this.points[t[1]]),
                                    (l = this.points[t[2]]),
                                    (c = this.points[t[3]]),
                                    (o = s * s),
                                    (u = s * o),
                                    (n.x = h(a.x, f.x, l.x, c.x, s, o, u)),
                                    (n.y = h(a.y, f.y, l.y, c.y, s, o, u)),
                                    (n.z = h(a.z, f.z, l.z, c.z, s, o, u)),
                                    n
                            );
                        }),
                        (this.getControlPointsArray = function () {
                            var e,
                                t,
                                n = this.points.length,
                                r = [];
                            for (e = 0; e < n; e++) (t = this.points[e]), (r[e] = [t.x, t.y, t.z]);
                            return r;
                        }),
                        (this.getLength = function (e) {
                            var t,
                                n,
                                r,
                                i,
                                s = 0,
                                o = 0,
                                u = 0,
                                a = new THREE.Vector3(),
                                f = new THREE.Vector3(),
                                l = [],
                                c = 0;
                            (l[0] = 0), e || (e = 100), (r = this.points.length * e), a.copy(this.points[0]);
                            for (t = 1; t < r; t++) (n = t / r), (i = this.getPoint(n)), f.copy(i), (c += f.distanceTo(a)), a.copy(i), (s = (this.points.length - 1) * n), (o = Math.floor(s)), o != u && ((l[o] = c), (u = o));
                            return (l[l.length] = c), { chunks: l, total: c };
                        }),
                        (this.reparametrizeByArcLength = function (e) {
                            var t,
                                n,
                                r,
                                i,
                                s,
                                o,
                                u,
                                a,
                                f,
                                l = [],
                                c = new THREE.Vector3(),
                                h = this.getLength();
                            l.push(c.copy(this.points[0]).clone());
                            for (t = 1; t < this.points.length; t++) {
                                (u = h.chunks[t] - h.chunks[t - 1]), (a = Math.ceil((e * u) / h.total)), (i = (t - 1) / (this.points.length - 1)), (s = t / (this.points.length - 1));
                                for (n = 1; n < a - 1; n++) (r = i + n * (1 / a) * (s - i)), (f = this.getPoint(r)), l.push(c.copy(f).clone());
                                l.push(c.copy(this.points[t]).clone());
                            }
                            this.points = l;
                        });
                }),
                (THREE.Triangle = function (e, t, n) {
                    (this.a = e !== undefined ? e : new THREE.Vector3()), (this.b = t !== undefined ? t : new THREE.Vector3()), (this.c = n !== undefined ? n : new THREE.Vector3());
                }),
                (THREE.Triangle.normal = (function () {
                    var e = new THREE.Vector3();
                    return function (t, n, r, i) {
                        var s = i || new THREE.Vector3();
                        s.subVectors(r, n), e.subVectors(t, n), s.cross(e);
                        var o = s.lengthSq();
                        return o > 0 ? s.multiplyScalar(1 / Math.sqrt(o)) : s.set(0, 0, 0);
                    };
                })()),
                (THREE.Triangle.barycoordFromPoint = (function () {
                    var e = new THREE.Vector3(),
                        t = new THREE.Vector3(),
                        n = new THREE.Vector3();
                    return function (r, i, s, o, u) {
                        e.subVectors(o, i), t.subVectors(s, i), n.subVectors(r, i);
                        var a = e.dot(e),
                            f = e.dot(t),
                            l = e.dot(n),
                            c = t.dot(t),
                            h = t.dot(n),
                            p = a * c - f * f,
                            d = u || new THREE.Vector3();
                        if (p == 0) return d.set(-2, -1, -1);
                        var v = 1 / p,
                            m = (c * l - f * h) * v,
                            g = (a * h - f * l) * v;
                        return d.set(1 - m - g, g, m);
                    };
                })()),
                (THREE.Triangle.containsPoint = (function () {
                    var e = new THREE.Vector3();
                    return function (t, n, r, i) {
                        var s = THREE.Triangle.barycoordFromPoint(t, n, r, i, e);
                        return s.x >= 0 && s.y >= 0 && s.x + s.y <= 1;
                    };
                })()),
                (THREE.Triangle.prototype = {
                    constructor: THREE.Triangle,
                    set: function (e, t, n) {
                        return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
                    },
                    setFromPointsAndIndices: function (e, t, n, r) {
                        return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
                    },
                    copy: function (e) {
                        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
                    },
                    area: (function () {
                        var e = new THREE.Vector3(),
                            t = new THREE.Vector3();
                        return function () {
                            return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), e.cross(t).length() * 0.5;
                        };
                    })(),
                    midpoint: function (e) {
                        var t = e || new THREE.Vector3();
                        return t
                            .addVectors(this.a, this.b)
                            .add(this.c)
                            .multiplyScalar(1 / 3);
                    },
                    normal: function (e) {
                        return THREE.Triangle.normal(this.a, this.b, this.c, e);
                    },
                    plane: function (e) {
                        var t = e || new THREE.Plane();
                        return t.setFromCoplanarPoints(this.a, this.b, this.c);
                    },
                    barycoordFromPoint: function (e, t) {
                        return THREE.Triangle.barycoordFromPoint(e, this.a, this.b, this.c, t);
                    },
                    containsPoint: function (e) {
                        return THREE.Triangle.containsPoint(e, this.a, this.b, this.c);
                    },
                    equals: function (e) {
                        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
                    },
                    clone: function () {
                        return new THREE.Triangle().copy(this);
                    },
                }),
                (THREE.Vertex = function (e) {
                    return console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead."), e;
                }),
                (THREE.UV = function (e, t) {
                    return console.warn("THREE.UV has been DEPRECATED. Use THREE.Vector2 instead."), new THREE.Vector2(e, t);
                }),
                (THREE.Clock = function (e) {
                    (this.autoStart = e !== undefined ? e : !0), (this.startTime = 0), (this.oldTime = 0), (this.elapsedTime = 0), (this.running = !1);
                }),
                (THREE.Clock.prototype = {
                    constructor: THREE.Clock,
                    start: function () {
                        (this.startTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now()), (this.oldTime = this.startTime), (this.running = !0);
                    },
                    stop: function () {
                        this.getElapsedTime(), (this.running = !1);
                    },
                    getElapsedTime: function () {
                        return this.getDelta(), this.elapsedTime;
                    },
                    getDelta: function () {
                        var e = 0;
                        this.autoStart && !this.running && this.start();
                        if (this.running) {
                            var t = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
                            (e = 0.001 * (t - this.oldTime)), (this.oldTime = t), (this.elapsedTime += e);
                        }
                        return e;
                    },
                }),
                (THREE.EventDispatcher = function () {}),
                (THREE.EventDispatcher.prototype = {
                    constructor: THREE.EventDispatcher,
                    apply: function (e) {
                        (e.addEventListener = THREE.EventDispatcher.prototype.addEventListener),
                            (e.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener),
                            (e.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener),
                            (e.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent);
                    },
                    addEventListener: function (e, t) {
                        this._listeners === undefined && (this._listeners = {});
                        var n = this._listeners;
                        n[e] === undefined && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
                    },
                    hasEventListener: function (e, t) {
                        if (this._listeners === undefined) return !1;
                        var n = this._listeners;
                        return n[e] !== undefined && n[e].indexOf(t) !== -1 ? !0 : !1;
                    },
                    removeEventListener: function (e, t) {
                        if (this._listeners === undefined) return;
                        var n = this._listeners,
                            r = n[e].indexOf(t);
                        r !== -1 && n[e].splice(r, 1);
                    },
                    dispatchEvent: function (e) {
                        if (this._listeners === undefined) return;
                        var t = this._listeners,
                            n = t[e.type];
                        if (n !== undefined) {
                            e.target = this;
                            for (var r = 0, i = n.length; r < i; r++) n[r].call(this, e);
                        }
                    },
                }),
                (function (e) {
                    e.Raycaster = function (t, n, r, i) {
                        (this.ray = new e.Ray(t, n)), (this.near = r || 0), (this.far = i || Infinity);
                    };
                    var t = new e.Sphere(),
                        n = new e.Ray(),
                        r = new e.Plane(),
                        i = new e.Vector3(),
                        s = new e.Vector3(),
                        o = new e.Matrix4(),
                        u = function (e, t) {
                            return e.distance - t.distance;
                        },
                        a = new e.Vector3(),
                        f = new e.Vector3(),
                        l = new e.Vector3(),
                        c = function (r, i, u) {
                            if (r instanceof e.Particle) {
                                s.getPositionFromMatrix(r.matrixWorld);
                                var h = i.ray.distanceToPoint(s);
                                if (h > r.scale.x) return u;
                                u.push({ distance: h, point: r.position, face: null, object: r });
                            } else if (r instanceof e.LOD) {
                                s.getPositionFromMatrix(r.matrixWorld);
                                var h = i.ray.origin.distanceTo(s);
                                c(r.getObjectForDistance(h), i, u);
                            } else if (r instanceof e.Mesh) {
                                var p = r.geometry;
                                p.boundingSphere === null && p.computeBoundingSphere(), t.copy(p.boundingSphere), t.applyMatrix4(r.matrixWorld);
                                if (i.ray.isIntersectionSphere(t) === !1) return u;
                                o.getInverse(r.matrixWorld), n.copy(i.ray).applyMatrix4(o);
                                if (p.boundingBox !== null && n.isIntersectionBox(p.boundingBox) === !1) return u;
                                if (p instanceof e.BufferGeometry) {
                                    var d = r.material;
                                    if (d === undefined) return u;
                                    if (p.dynamic === !1) return u;
                                    var v,
                                        m,
                                        g,
                                        y = i.precision;
                                    if (p.attributes.index !== undefined) {
                                        var b = p.offsets,
                                            w = p.attributes.index.array,
                                            E = p.attributes.position.array,
                                            S = p.offsets.length,
                                            x = p.attributes.index.array.length / 3;
                                        for (var T = 0; T < S; ++T) {
                                            var N = b[T].start,
                                                C = b[T].count,
                                                k = b[T].index;
                                            for (var L = N, A = N + C; L < A; L += 3) {
                                                (v = k + w[L]), (m = k + w[L + 1]), (g = k + w[L + 2]), a.set(E[v * 3], E[v * 3 + 1], E[v * 3 + 2]), f.set(E[m * 3], E[m * 3 + 1], E[m * 3 + 2]), l.set(E[g * 3], E[g * 3 + 1], E[g * 3 + 2]);
                                                var O = n.intersectTriangle(a, f, l, d.side !== e.DoubleSide);
                                                if (O === null) continue;
                                                O.applyMatrix4(r.matrixWorld);
                                                var h = i.ray.origin.distanceTo(O);
                                                if (h < y || h < i.near || h > i.far) continue;
                                                u.push({ distance: h, point: O, face: null, faceIndex: null, object: r });
                                            }
                                        }
                                    } else {
                                        var b = p.offsets,
                                            E = p.attributes.position.array,
                                            S = p.offsets.length,
                                            x = p.attributes.position.array.length;
                                        for (var L = 0; L < x; L += 3) {
                                            (v = L), (m = L + 1), (g = L + 2), a.set(E[v * 3], E[v * 3 + 1], E[v * 3 + 2]), f.set(E[m * 3], E[m * 3 + 1], E[m * 3 + 2]), l.set(E[g * 3], E[g * 3 + 1], E[g * 3 + 2]);
                                            var O = n.intersectTriangle(a, f, l, d.side !== e.DoubleSide);
                                            if (O === null) continue;
                                            O.applyMatrix4(r.matrixWorld);
                                            var h = i.ray.origin.distanceTo(O);
                                            if (h < y || h < i.near || h > i.far) continue;
                                            u.push({ distance: h, point: O, face: null, faceIndex: null, object: r });
                                        }
                                    }
                                } else if (p instanceof e.Geometry) {
                                    var M = r.material instanceof e.MeshFaceMaterial,
                                        _ = M === !0 ? r.material.materials : null,
                                        v,
                                        m,
                                        g,
                                        D,
                                        y = i.precision,
                                        P = p.vertices;
                                    for (var H = 0, x = p.faces.length; H < x; H++) {
                                        var B = p.faces[H],
                                            d = M === !0 ? _[B.materialIndex] : r.material;
                                        if (d === undefined) continue;
                                        (v = P[B.a]), (m = P[B.b]), (g = P[B.c]);
                                        var O = n.intersectTriangle(v, m, g, d.side !== e.DoubleSide);
                                        if (O === null) continue;
                                        O.applyMatrix4(r.matrixWorld);
                                        var h = i.ray.origin.distanceTo(O);
                                        if (h < y || h < i.near || h > i.far) continue;
                                        u.push({ distance: h, point: O, face: B, faceIndex: H, object: r });
                                    }
                                }
                            } else if (r instanceof e.Line) {
                                var y = i.linePrecision,
                                    j = y * y,
                                    p = r.geometry;
                                p.boundingSphere === null && p.computeBoundingSphere(), t.copy(p.boundingSphere), t.applyMatrix4(r.matrixWorld);
                                if (i.ray.isIntersectionSphere(t) === !1) return u;
                                o.getInverse(r.matrixWorld), n.copy(i.ray).applyMatrix4(o);
                                if (p instanceof e.Geometry) {
                                    var P = p.vertices,
                                        F = P.length,
                                        I = new e.Vector3(),
                                        q = new e.Vector3(),
                                        R = r.type === e.LineStrip ? 1 : 2;
                                    for (var L = 0; L < F - 1; L += R) {
                                        var U = n.distanceSqToSegment(P[L], P[L + 1], q, I);
                                        if (U > j) continue;
                                        var h = n.origin.distanceTo(q);
                                        if (h < i.near || h > i.far) continue;
                                        u.push({ distance: h, point: I.clone().applyMatrix4(r.matrixWorld), face: null, faceIndex: null, object: r });
                                    }
                                }
                            }
                        },
                        h = function (e, t, n) {
                            var r = e.getDescendants();
                            for (var i = 0, s = r.length; i < s; i++) c(r[i], t, n);
                        };
                    (e.Raycaster.prototype.precision = 1e-4),
                        (e.Raycaster.prototype.linePrecision = 1),
                        (e.Raycaster.prototype.set = function (e, t) {
                            this.ray.set(e, t);
                        }),
                        (e.Raycaster.prototype.intersectObject = function (e, t) {
                            var n = [];
                            return t === !0 && h(e, this, n), c(e, this, n), n.sort(u), n;
                        }),
                        (e.Raycaster.prototype.intersectObjects = function (e, t) {
                            var n = [];
                            for (var r = 0, i = e.length; r < i; r++) c(e[r], this, n), t === !0 && h(e[r], this, n);
                            return n.sort(u), n;
                        });
                })(THREE),
                (THREE.Object3D = function () {
                    (this.id = THREE.Object3DIdCount++),
                        (this.uuid = THREE.Math.generateUUID()),
                        (this.name = ""),
                        (this.parent = undefined),
                        (this.children = []),
                        (this.up = new THREE.Vector3(0, 1, 0)),
                        (this.position = new THREE.Vector3()),
                        (this.rotation = new THREE.Euler()),
                        (this.quaternion = new THREE.Quaternion()),
                        (this.scale = new THREE.Vector3(1, 1, 1)),
                        (this.rotation._quaternion = this.quaternion),
                        (this.quaternion._euler = this.rotation),
                        (this.renderDepth = null),
                        (this.rotationAutoUpdate = !0),
                        (this.matrix = new THREE.Matrix4()),
                        (this.matrixWorld = new THREE.Matrix4()),
                        (this.matrixAutoUpdate = !0),
                        (this.matrixWorldNeedsUpdate = !0),
                        (this.visible = !0),
                        (this.castShadow = !1),
                        (this.receiveShadow = !1),
                        (this.frustumCulled = !0),
                        (this.userData = {});
                }),
                (THREE.Object3D.prototype = {
                    constructor: THREE.Object3D,
                    get eulerOrder() {
                        return console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order."), this.rotation.order;
                    },
                    set eulerOrder(e) {
                        console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order."), (this.rotation.order = e);
                    },
                    get useQuaternion() {
                        console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.");
                    },
                    set useQuaternion(e) {
                        console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.");
                    },
                    applyMatrix: (function () {
                        var e = new THREE.Matrix4();
                        return function (t) {
                            this.matrix.multiplyMatrices(t, this.matrix), this.position.getPositionFromMatrix(this.matrix), this.scale.getScaleFromMatrix(this.matrix), e.extractRotation(this.matrix), this.quaternion.setFromRotationMatrix(e);
                        };
                    })(),
                    setRotationFromAxisAngle: function (e, t) {
                        this.quaternion.setFromAxisAngle(e, t);
                    },
                    setRotationFromEuler: function (e) {
                        this.quaternion.setFromEuler(e, !0);
                    },
                    setRotationFromMatrix: function (e) {
                        this.quaternion.setFromRotationMatrix(e);
                    },
                    setRotationFromQuaternion: function (e) {
                        this.quaternion.copy(e);
                    },
                    rotateOnAxis: (function () {
                        var e = new THREE.Quaternion();
                        return function (t, n) {
                            return e.setFromAxisAngle(t, n), this.quaternion.multiply(e), this;
                        };
                    })(),
                    rotateX: (function () {
                        var e = new THREE.Vector3(1, 0, 0);
                        return function (t) {
                            return this.rotateOnAxis(e, t);
                        };
                    })(),
                    rotateY: (function () {
                        var e = new THREE.Vector3(0, 1, 0);
                        return function (t) {
                            return this.rotateOnAxis(e, t);
                        };
                    })(),
                    rotateZ: (function () {
                        var e = new THREE.Vector3(0, 0, 1);
                        return function (t) {
                            return this.rotateOnAxis(e, t);
                        };
                    })(),
                    translateOnAxis: (function () {
                        var e = new THREE.Vector3();
                        return function (t, n) {
                            return e.copy(t), e.applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this;
                        };
                    })(),
                    translate: function (e, t) {
                        return console.warn("DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed."), this.translateOnAxis(t, e);
                    },
                    translateX: (function () {
                        var e = new THREE.Vector3(1, 0, 0);
                        return function (t) {
                            return this.translateOnAxis(e, t);
                        };
                    })(),
                    translateY: (function () {
                        var e = new THREE.Vector3(0, 1, 0);
                        return function (t) {
                            return this.translateOnAxis(e, t);
                        };
                    })(),
                    translateZ: (function () {
                        var e = new THREE.Vector3(0, 0, 1);
                        return function (t) {
                            return this.translateOnAxis(e, t);
                        };
                    })(),
                    localToWorld: function (e) {
                        return e.applyMatrix4(this.matrixWorld);
                    },
                    worldToLocal: (function () {
                        var e = new THREE.Matrix4();
                        return function (t) {
                            return t.applyMatrix4(e.getInverse(this.matrixWorld));
                        };
                    })(),
                    lookAt: (function () {
                        var e = new THREE.Matrix4();
                        return function (t) {
                            e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e);
                        };
                    })(),
                    add: function (e) {
                        if (e === this) {
                            console.warn("THREE.Object3D.add: An object can't be added as a child of itself.");
                            return;
                        }
                        if (e instanceof THREE.Object3D) {
                            e.parent !== undefined && e.parent.remove(e), (e.parent = this), e.dispatchEvent({ type: "added" }), this.children.push(e);
                            var t = this;
                            while (t.parent !== undefined) t = t.parent;
                            t !== undefined && t instanceof THREE.Scene && t.__addObject(e);
                        }
                    },
                    remove: function (e) {
                        var t = this.children.indexOf(e);
                        if (t !== -1) {
                            (e.parent = undefined), e.dispatchEvent({ type: "removed" }), this.children.splice(t, 1);
                            var n = this;
                            while (n.parent !== undefined) n = n.parent;
                            n !== undefined && n instanceof THREE.Scene && n.__removeObject(e);
                        }
                    },
                    traverse: function (e) {
                        e(this);
                        for (var t = 0, n = this.children.length; t < n; t++) this.children[t].traverse(e);
                    },
                    getObjectById: function (e, t) {
                        for (var n = 0, r = this.children.length; n < r; n++) {
                            var i = this.children[n];
                            if (i.id === e) return i;
                            if (t === !0) {
                                i = i.getObjectById(e, t);
                                if (i !== undefined) return i;
                            }
                        }
                        return undefined;
                    },
                    getObjectByName: function (e, t) {
                        for (var n = 0, r = this.children.length; n < r; n++) {
                            var i = this.children[n];
                            if (i.name === e) return i;
                            if (t === !0) {
                                i = i.getObjectByName(e, t);
                                if (i !== undefined) return i;
                            }
                        }
                        return undefined;
                    },
                    getChildByName: function (e, t) {
                        return console.warn("DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e, t);
                    },
                    getDescendants: function (e) {
                        e === undefined && (e = []), Array.prototype.push.apply(e, this.children);
                        for (var t = 0, n = this.children.length; t < n; t++) this.children[t].getDescendants(e);
                        return e;
                    },
                    updateMatrix: function () {
                        this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
                    },
                    updateMatrixWorld: function (e) {
                        this.matrixAutoUpdate === !0 && this.updateMatrix();
                        if (this.matrixWorldNeedsUpdate === !0 || e === !0)
                            this.parent === undefined ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), (this.matrixWorldNeedsUpdate = !1), (e = !0);
                        for (var t = 0, n = this.children.length; t < n; t++) this.children[t].updateMatrixWorld(e);
                    },
                    clone: function (e, t) {
                        e === undefined && (e = new THREE.Object3D()),
                        t === undefined && (t = !0),
                            (e.name = this.name),
                            e.up.copy(this.up),
                            e.position.copy(this.position),
                            e.quaternion.copy(this.quaternion),
                            e.scale.copy(this.scale),
                            (e.renderDepth = this.renderDepth),
                            (e.rotationAutoUpdate = this.rotationAutoUpdate),
                            e.matrix.copy(this.matrix),
                            e.matrixWorld.copy(this.matrixWorld),
                            (e.matrixAutoUpdate = this.matrixAutoUpdate),
                            (e.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate),
                            (e.visible = this.visible),
                            (e.castShadow = this.castShadow),
                            (e.receiveShadow = this.receiveShadow),
                            (e.frustumCulled = this.frustumCulled),
                            (e.userData = JSON.parse(JSON.stringify(this.userData)));
                        if (t === !0)
                            for (var n = 0; n < this.children.length; n++) {
                                var r = this.children[n];
                                e.add(r.clone());
                            }
                        return e;
                    },
                }),
                THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype),
                (THREE.Object3DIdCount = 0),
                (THREE.Projector = function () {
                    function q() {
                        if (t === r) {
                            var e = new THREE.RenderableObject();
                            return n.push(e), r++, t++, e;
                        }
                        return n[t++];
                    }
                    function R() {
                        if (s === u) {
                            var e = new THREE.RenderableVertex();
                            return o.push(e), u++, s++, e;
                        }
                        return o[s++];
                    }
                    function U() {
                        if (f === c) {
                            var e = new THREE.RenderableFace3();
                            return l.push(e), c++, f++, e;
                        }
                        return l[f++];
                    }
                    function z() {
                        if (p === v) {
                            var e = new THREE.RenderableLine();
                            return d.push(e), v++, p++, e;
                        }
                        return d[p++];
                    }
                    function W() {
                        if (g === b) {
                            var e = new THREE.RenderableParticle();
                            return y.push(e), b++, g++, e;
                        }
                        return y[g++];
                    }
                    function X(e, t) {
                        return e.z !== t.z ? t.z - e.z : e.id !== t.id ? e.id - t.id : 0;
                    }
                    function V(e, t) {
                        var n = 0,
                            r = 1,
                            i = e.z + e.w,
                            s = t.z + t.w,
                            o = -e.z + e.w,
                            u = -t.z + t.w;
                        return i >= 0 && s >= 0 && o >= 0 && u >= 0
                            ? !0
                            : (i < 0 && s < 0) || (o < 0 && u < 0)
                                ? !1
                                : (i < 0 ? (n = Math.max(n, i / (i - s))) : s < 0 && (r = Math.min(r, i / (i - s))), o < 0 ? (n = Math.max(n, o / (o - u))) : u < 0 && (r = Math.min(r, o / (o - u))), r < n ? !1 : (e.lerp(t, n), t.lerp(e, 1 - r), !0));
                    }
                    var e,
                        t,
                        n = [],
                        r = 0,
                        i,
                        s,
                        o = [],
                        u = 0,
                        a,
                        f,
                        l = [],
                        c = 0,
                        h,
                        p,
                        d = [],
                        v = 0,
                        m,
                        g,
                        y = [],
                        b = 0,
                        w = { objects: [], sprites: [], lights: [], elements: [] },
                        E = new THREE.Vector3(),
                        S = new THREE.Vector4(),
                        x = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
                        T = new THREE.Box3(),
                        N = new Array(3),
                        C = new Array(4),
                        k = new THREE.Matrix4(),
                        L = new THREE.Matrix4(),
                        A,
                        O = new THREE.Matrix4(),
                        M = new THREE.Matrix3(),
                        _ = new THREE.Matrix3(),
                        D = new THREE.Vector3(),
                        P = new THREE.Frustum(),
                        H = new THREE.Vector4(),
                        B = new THREE.Vector4();
                    (this.projectVector = function (e, t) {
                        return t.matrixWorldInverse.getInverse(t.matrixWorld), L.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), e.applyProjection(L);
                    }),
                        (this.unprojectVector = function (e, t) {
                            return t.projectionMatrixInverse.getInverse(t.projectionMatrix), L.multiplyMatrices(t.matrixWorld, t.projectionMatrixInverse), e.applyProjection(L);
                        }),
                        (this.pickingRay = function (e, t) {
                            e.z = -1;
                            var n = new THREE.Vector3(e.x, e.y, 1);
                            return this.unprojectVector(e, t), this.unprojectVector(n, t), n.sub(e).normalize(), new THREE.Raycaster(e, n);
                        });
                    var j = function (t) {
                            return (e = q()), (e.id = t.id), (e.object = t), t.renderDepth !== null ? (e.z = t.renderDepth) : (E.getPositionFromMatrix(t.matrixWorld), E.applyProjection(L), (e.z = E.z)), e;
                        },
                        F = function (e) {
                            if (e.visible === !1) return;
                            e instanceof THREE.Light
                                ? w.lights.push(e)
                                : e instanceof THREE.Mesh || e instanceof THREE.Line
                                ? (e.frustumCulled === !1 || P.intersectsObject(e) === !0) && w.objects.push(j(e))
                                : (e instanceof THREE.Sprite || e instanceof THREE.Particle) && w.sprites.push(j(e));
                            for (var t = 0, n = e.children.length; t < n; t++) F(e.children[t]);
                        },
                        I = function (e, n) {
                            (t = 0), (w.objects.length = 0), (w.sprites.length = 0), (w.lights.length = 0), F(e), n === !0 && w.objects.sort(X);
                        };
                    this.projectScene = function (e, t, n, r) {
                        var u = !1,
                            l,
                            c,
                            d,
                            v,
                            y,
                            b,
                            E,
                            C,
                            j,
                            F,
                            q,
                            $,
                            J,
                            K,
                            Q,
                            G,
                            Y,
                            Z,
                            et,
                            tt,
                            nt,
                            rt,
                            it,
                            st,
                            ot,
                            ut;
                        (f = 0),
                            (p = 0),
                            (g = 0),
                            (w.elements.length = 0),
                        e.autoUpdate === !0 && e.updateMatrixWorld(),
                        t.parent === undefined && t.updateMatrixWorld(),
                            k.copy(t.matrixWorldInverse.getInverse(t.matrixWorld)),
                            L.multiplyMatrices(t.projectionMatrix, k),
                            _.getNormalMatrix(k),
                            P.setFromMatrix(L),
                            I(e, n);
                        for (l = 0, c = w.objects.length; l < c; l++) {
                            (J = w.objects[l].object), (A = J.matrixWorld), (s = 0);
                            if (J instanceof THREE.Mesh) {
                                (K = J.geometry), (Q = K.vertices), (G = K.faces), (et = K.faceVertexUvs), M.getNormalMatrix(A), (ot = J.material instanceof THREE.MeshFaceMaterial), (ut = ot === !0 ? J.material : null);
                                for (d = 0, v = Q.length; d < v; d++) {
                                    (i = R()), i.positionWorld.copy(Q[d]).applyMatrix4(A), i.positionScreen.copy(i.positionWorld).applyMatrix4(L);
                                    var at = 1 / i.positionScreen.w;
                                    (i.positionScreen.x *= at),
                                        (i.positionScreen.y *= at),
                                        (i.positionScreen.z *= at),
                                        (i.visible = !(i.positionScreen.x < -1 || i.positionScreen.x > 1 || i.positionScreen.y < -1 || i.positionScreen.y > 1 || i.positionScreen.z < -1 || i.positionScreen.z > 1));
                                }
                                for (y = 0, b = G.length; y < b; y++) {
                                    Y = G[y];
                                    var ft = ot === !0 ? ut.materials[Y.materialIndex] : J.material;
                                    if (ft === undefined) continue;
                                    var lt = ft.side;
                                    (nt = o[Y.a]), (rt = o[Y.b]), (it = o[Y.c]), (N[0] = nt.positionScreen), (N[1] = rt.positionScreen), (N[2] = it.positionScreen);
                                    if (nt.visible !== !0 && rt.visible !== !0 && it.visible !== !0 && !x.isIntersectionBox(T.setFromPoints(N))) continue;
                                    u = (it.positionScreen.x - nt.positionScreen.x) * (rt.positionScreen.y - nt.positionScreen.y) - (it.positionScreen.y - nt.positionScreen.y) * (rt.positionScreen.x - nt.positionScreen.x) < 0;
                                    if (lt !== THREE.DoubleSide && u !== (lt === THREE.FrontSide)) continue;
                                    (a = U()),
                                        (a.id = J.id),
                                        a.v1.copy(nt),
                                        a.v2.copy(rt),
                                        a.v3.copy(it),
                                        a.normalModel.copy(Y.normal),
                                    u === !1 && (lt === THREE.BackSide || lt === THREE.DoubleSide) && a.normalModel.negate(),
                                        a.normalModel.applyMatrix3(M).normalize(),
                                        a.normalModelView.copy(a.normalModel).applyMatrix3(_),
                                        a.centroidModel.copy(Y.centroid).applyMatrix4(A),
                                        (Z = Y.vertexNormals);
                                    for (E = 0, C = Math.min(Z.length, 3); E < C; E++) {
                                        var ct = a.vertexNormalsModel[E];
                                        ct.copy(Z[E]), u === !1 && (lt === THREE.BackSide || lt === THREE.DoubleSide) && ct.negate(), ct.applyMatrix3(M).normalize();
                                        var ht = a.vertexNormalsModelView[E];
                                        ht.copy(ct).applyMatrix3(_);
                                    }
                                    a.vertexNormalsLength = Z.length;
                                    for (j = 0, F = Math.min(et.length, 3); j < F; j++) {
                                        tt = et[j][y];
                                        if (tt === undefined) continue;
                                        for (q = 0, $ = tt.length; q < $; q++) a.uvs[j][q] = tt[q];
                                    }
                                    (a.color = Y.color), (a.material = ft), D.copy(a.centroidModel).applyProjection(L), (a.z = D.z), w.elements.push(a);
                                }
                            } else if (J instanceof THREE.Line) {
                                O.multiplyMatrices(L, A), (Q = J.geometry.vertices), (nt = R()), nt.positionScreen.copy(Q[0]).applyMatrix4(O);
                                var pt = J.type === THREE.LinePieces ? 2 : 1;
                                for (d = 1, v = Q.length; d < v; d++) {
                                    (nt = R()), nt.positionScreen.copy(Q[d]).applyMatrix4(O);
                                    if ((d + 1) % pt > 0) continue;
                                    (rt = o[s - 2]),
                                        H.copy(nt.positionScreen),
                                        B.copy(rt.positionScreen),
                                    V(H, B) === !0 &&
                                    (H.multiplyScalar(1 / H.w),
                                        B.multiplyScalar(1 / B.w),
                                        (h = z()),
                                        (h.id = J.id),
                                        h.v1.positionScreen.copy(H),
                                        h.v2.positionScreen.copy(B),
                                        (h.z = Math.max(H.z, B.z)),
                                        (h.material = J.material),
                                    J.material.vertexColors === THREE.VertexColors && (h.vertexColors[0].copy(J.geometry.colors[d]), h.vertexColors[1].copy(J.geometry.colors[d - 1])),
                                        w.elements.push(h));
                                }
                            }
                        }
                        for (l = 0, c = w.sprites.length; l < c; l++) {
                            (J = w.sprites[l].object), (A = J.matrixWorld);
                            if (J instanceof THREE.Particle) {
                                S.set(A.elements[12], A.elements[13], A.elements[14], 1), S.applyMatrix4(L);
                                var at = 1 / S.w;
                                (S.z *= at),
                                S.z > 0 &&
                                S.z < 1 &&
                                ((m = W()),
                                    (m.id = J.id),
                                    (m.x = S.x * at),
                                    (m.y = S.y * at),
                                    (m.z = S.z),
                                    (m.object = J),
                                    (m.rotation = J.rotation.z),
                                    (m.scale.x = J.scale.x * Math.abs(m.x - (S.x + t.projectionMatrix.elements[0]) / (S.w + t.projectionMatrix.elements[12]))),
                                    (m.scale.y = J.scale.y * Math.abs(m.y - (S.y + t.projectionMatrix.elements[5]) / (S.w + t.projectionMatrix.elements[13]))),
                                    (m.material = J.material),
                                    w.elements.push(m));
                            }
                        }
                        return r === !0 && w.elements.sort(X), w;
                    };
                }),
                (THREE.Face3 = function (e, t, n, r, i, s) {
                    (this.a = e),
                        (this.b = t),
                        (this.c = n),
                        (this.normal = r instanceof THREE.Vector3 ? r : new THREE.Vector3()),
                        (this.vertexNormals = r instanceof Array ? r : []),
                        (this.color = i instanceof THREE.Color ? i : new THREE.Color()),
                        (this.vertexColors = i instanceof Array ? i : []),
                        (this.vertexTangents = []),
                        (this.materialIndex = s !== undefined ? s : 0),
                        (this.centroid = new THREE.Vector3());
                }),
                (THREE.Face3.prototype = {
                    constructor: THREE.Face3,
                    clone: function () {
                        var e = new THREE.Face3(this.a, this.b, this.c);
                        e.normal.copy(this.normal), e.color.copy(this.color), e.centroid.copy(this.centroid), (e.materialIndex = this.materialIndex);
                        var t, n;
                        for (t = 0, n = this.vertexNormals.length; t < n; t++) e.vertexNormals[t] = this.vertexNormals[t].clone();
                        for (t = 0, n = this.vertexColors.length; t < n; t++) e.vertexColors[t] = this.vertexColors[t].clone();
                        for (t = 0, n = this.vertexTangents.length; t < n; t++) e.vertexTangents[t] = this.vertexTangents[t].clone();
                        return e;
                    },
                }),
                (THREE.Face4 = function (e, t, n, r, i, s, o) {
                    return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new THREE.Face3(e, t, n, i, s, o);
                }),
                (THREE.Geometry = function () {
                    (this.id = THREE.GeometryIdCount++),
                        (this.uuid = THREE.Math.generateUUID()),
                        (this.name = ""),
                        (this.vertices = []),
                        (this.colors = []),
                        (this.faces = []),
                        (this.faceVertexUvs = [[]]),
                        (this.morphTargets = []),
                        (this.morphColors = []),
                        (this.morphNormals = []),
                        (this.skinWeights = []),
                        (this.skinIndices = []),
                        (this.lineDistances = []),
                        (this.boundingBox = null),
                        (this.boundingSphere = null),
                        (this.hasTangents = !1),
                        (this.dynamic = !0),
                        (this.verticesNeedUpdate = !1),
                        (this.elementsNeedUpdate = !1),
                        (this.uvsNeedUpdate = !1),
                        (this.normalsNeedUpdate = !1),
                        (this.tangentsNeedUpdate = !1),
                        (this.colorsNeedUpdate = !1),
                        (this.lineDistancesNeedUpdate = !1),
                        (this.buffersNeedUpdate = !1);
                }),
                (THREE.Geometry.prototype = {
                    constructor: THREE.Geometry,
                    applyMatrix: function (e) {
                        var t = new THREE.Matrix3().getNormalMatrix(e);
                        for (var n = 0, r = this.vertices.length; n < r; n++) {
                            var i = this.vertices[n];
                            i.applyMatrix4(e);
                        }
                        for (var n = 0, r = this.faces.length; n < r; n++) {
                            var s = this.faces[n];
                            s.normal.applyMatrix3(t).normalize();
                            for (var o = 0, u = s.vertexNormals.length; o < u; o++) s.vertexNormals[o].applyMatrix3(t).normalize();
                            s.centroid.applyMatrix4(e);
                        }
                        this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox(), this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere();
                    },
                    computeCentroids: function () {
                        var e, t, n;
                        for (e = 0, t = this.faces.length; e < t; e++) (n = this.faces[e]), n.centroid.set(0, 0, 0), n.centroid.add(this.vertices[n.a]), n.centroid.add(this.vertices[n.b]), n.centroid.add(this.vertices[n.c]), n.centroid.divideScalar(3);
                    },
                    computeFaceNormals: function () {
                        var e = new THREE.Vector3(),
                            t = new THREE.Vector3();
                        for (var n = 0, r = this.faces.length; n < r; n++) {
                            var i = this.faces[n],
                                s = this.vertices[i.a],
                                o = this.vertices[i.b],
                                u = this.vertices[i.c];
                            e.subVectors(u, o), t.subVectors(s, o), e.cross(t), e.normalize(), i.normal.copy(e);
                        }
                    },
                    computeVertexNormals: function (e) {
                        var t, n, r, i, s, o;
                        if (this.__tmpVertices === undefined) {
                            (this.__tmpVertices = new Array(this.vertices.length)), (o = this.__tmpVertices);
                            for (t = 0, n = this.vertices.length; t < n; t++) o[t] = new THREE.Vector3();
                            for (r = 0, i = this.faces.length; r < i; r++) (s = this.faces[r]), (s.vertexNormals = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]);
                        } else {
                            o = this.__tmpVertices;
                            for (t = 0, n = this.vertices.length; t < n; t++) o[t].set(0, 0, 0);
                        }
                        if (e) {
                            var u,
                                a,
                                f,
                                l,
                                c = new THREE.Vector3(),
                                h = new THREE.Vector3(),
                                p = new THREE.Vector3(),
                                d = new THREE.Vector3(),
                                v = new THREE.Vector3();
                            for (r = 0, i = this.faces.length; r < i; r++)
                                (s = this.faces[r]), (u = this.vertices[s.a]), (a = this.vertices[s.b]), (f = this.vertices[s.c]), c.subVectors(f, a), h.subVectors(u, a), c.cross(h), o[s.a].add(c), o[s.b].add(c), o[s.c].add(c);
                        } else for (r = 0, i = this.faces.length; r < i; r++) (s = this.faces[r]), o[s.a].add(s.normal), o[s.b].add(s.normal), o[s.c].add(s.normal);
                        for (t = 0, n = this.vertices.length; t < n; t++) o[t].normalize();
                        for (r = 0, i = this.faces.length; r < i; r++) (s = this.faces[r]), s.vertexNormals[0].copy(o[s.a]), s.vertexNormals[1].copy(o[s.b]), s.vertexNormals[2].copy(o[s.c]);
                    },
                    computeMorphNormals: function () {
                        var e, t, n, r, i;
                        for (n = 0, r = this.faces.length; n < r; n++) {
                            (i = this.faces[n]), i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : (i.__originalFaceNormal = i.normal.clone()), i.__originalVertexNormals || (i.__originalVertexNormals = []);
                            for (e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : (i.__originalVertexNormals[e] = i.vertexNormals[e].clone());
                        }
                        var s = new THREE.Geometry();
                        s.faces = this.faces;
                        for (e = 0, t = this.morphTargets.length; e < t; e++) {
                            if (!this.morphNormals[e]) {
                                (this.morphNormals[e] = {}), (this.morphNormals[e].faceNormals = []), (this.morphNormals[e].vertexNormals = []);
                                var o = this.morphNormals[e].faceNormals,
                                    u = this.morphNormals[e].vertexNormals,
                                    a,
                                    f;
                                for (n = 0, r = this.faces.length; n < r; n++) (i = this.faces[n]), (a = new THREE.Vector3()), (f = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() }), o.push(a), u.push(f);
                            }
                            var l = this.morphNormals[e];
                            (s.vertices = this.morphTargets[e].vertices), s.computeFaceNormals(), s.computeVertexNormals();
                            var a, f;
                            for (n = 0, r = this.faces.length; n < r; n++)
                                (i = this.faces[n]), (a = l.faceNormals[n]), (f = l.vertexNormals[n]), a.copy(i.normal), f.a.copy(i.vertexNormals[0]), f.b.copy(i.vertexNormals[1]), f.c.copy(i.vertexNormals[2]);
                        }
                        for (n = 0, r = this.faces.length; n < r; n++) (i = this.faces[n]), (i.normal = i.__originalFaceNormal), (i.vertexNormals = i.__originalVertexNormals);
                    },
                    computeTangents: function () {
                        function B(e, t, n, r, i, s, o) {
                            (f = e.vertices[t]),
                                (l = e.vertices[n]),
                                (c = e.vertices[r]),
                                (h = a[i]),
                                (p = a[s]),
                                (d = a[o]),
                                (v = l.x - f.x),
                                (m = c.x - f.x),
                                (g = l.y - f.y),
                                (y = c.y - f.y),
                                (b = l.z - f.z),
                                (w = c.z - f.z),
                                (E = p.x - h.x),
                                (S = d.x - h.x),
                                (x = p.y - h.y),
                                (T = d.y - h.y),
                                (N = 1 / (E * T - S * x)),
                                O.set((T * v - x * m) * N, (T * g - x * y) * N, (T * b - x * w) * N),
                                M.set((E * m - S * v) * N, (E * y - S * g) * N, (E * w - S * b) * N),
                                L[t].add(O),
                                L[n].add(O),
                                L[r].add(O),
                                A[t].add(M),
                                A[n].add(M),
                                A[r].add(M);
                        }
                        var e,
                            t,
                            n,
                            r,
                            i,
                            s,
                            o,
                            u,
                            a,
                            f,
                            l,
                            c,
                            h,
                            p,
                            d,
                            v,
                            m,
                            g,
                            y,
                            b,
                            w,
                            E,
                            S,
                            x,
                            T,
                            N,
                            C,
                            k,
                            L = [],
                            A = [],
                            O = new THREE.Vector3(),
                            M = new THREE.Vector3(),
                            _ = new THREE.Vector3(),
                            D = new THREE.Vector3(),
                            P = new THREE.Vector3(),
                            H;
                        for (n = 0, r = this.vertices.length; n < r; n++) (L[n] = new THREE.Vector3()), (A[n] = new THREE.Vector3());
                        for (e = 0, t = this.faces.length; e < t; e++) (u = this.faces[e]), (a = this.faceVertexUvs[0][e]), B(this, u.a, u.b, u.c, 0, 1, 2);
                        var j = ["a", "b", "c", "d"];
                        for (e = 0, t = this.faces.length; e < t; e++) {
                            u = this.faces[e];
                            for (i = 0; i < Math.min(u.vertexNormals.length, 3); i++)
                                P.copy(u.vertexNormals[i]),
                                    (o = u[j[i]]),
                                    (C = L[o]),
                                    _.copy(C),
                                    _.sub(P.multiplyScalar(P.dot(C))).normalize(),
                                    D.crossVectors(u.vertexNormals[i], C),
                                    (k = D.dot(A[o])),
                                    (H = k < 0 ? -1 : 1),
                                    (u.vertexTangents[i] = new THREE.Vector4(_.x, _.y, _.z, H));
                        }
                        this.hasTangents = !0;
                    },
                    computeLineDistances: function () {
                        var e = 0,
                            t = this.vertices;
                        for (var n = 0, r = t.length; n < r; n++) n > 0 && (e += t[n].distanceTo(t[n - 1])), (this.lineDistances[n] = e);
                    },
                    computeBoundingBox: function () {
                        this.boundingBox === null && (this.boundingBox = new THREE.Box3()), this.boundingBox.setFromPoints(this.vertices);
                    },
                    computeBoundingSphere: function () {
                        this.boundingSphere === null && (this.boundingSphere = new THREE.Sphere()), this.boundingSphere.setFromPoints(this.vertices);
                    },
                    mergeVertices: function () {
                        var e = {},
                            t = [],
                            n = [],
                            r,
                            i,
                            s = 4,
                            o = Math.pow(10, s),
                            u,
                            a,
                            f,
                            l,
                            c,
                            h,
                            p,
                            d;
                        this.__tmpVertices = undefined;
                        for (u = 0, a = this.vertices.length; u < a; u++)
                            (r = this.vertices[u]), (i = Math.round(r.x * o) + "_" + Math.round(r.y * o) + "_" + Math.round(r.z * o)), e[i] === undefined ? ((e[i] = u), t.push(this.vertices[u]), (n[u] = t.length - 1)) : (n[u] = n[e[i]]);
                        var v = [];
                        for (u = 0, a = this.faces.length; u < a; u++) {
                            (f = this.faces[u]), (f.a = n[f.a]), (f.b = n[f.b]), (f.c = n[f.c]), (l = [f.a, f.b, f.c]);
                            var m = -1;
                            for (var g = 0; g < 3; g++)
                                if (l[g] == l[(g + 1) % 3]) {
                                    (m = g), v.push(u);
                                    break;
                                }
                        }
                        for (u = v.length - 1; u >= 0; u--) {
                            var y = v[u];
                            this.faces.splice(y, 1);
                            for (h = 0, p = this.faceVertexUvs.length; h < p; h++) this.faceVertexUvs[h].splice(y, 1);
                        }
                        var b = this.vertices.length - t.length;
                        return (this.vertices = t), b;
                    },
                    clone: function () {
                        var e = new THREE.Geometry(),
                            t = this.vertices;
                        for (var n = 0, r = t.length; n < r; n++) e.vertices.push(t[n].clone());
                        var i = this.faces;
                        for (var n = 0, r = i.length; n < r; n++) e.faces.push(i[n].clone());
                        var s = this.faceVertexUvs[0];
                        for (var n = 0, r = s.length; n < r; n++) {
                            var o = s[n],
                                u = [];
                            for (var a = 0, f = o.length; a < f; a++) u.push(new THREE.Vector2(o[a].x, o[a].y));
                            e.faceVertexUvs[0].push(u);
                        }
                        return e;
                    },
                    dispose: function () {
                        this.dispatchEvent({ type: "dispose" });
                    },
                }),
                THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype),
                (THREE.GeometryIdCount = 0),
                (THREE.BufferGeometry = function () {
                    (this.id = THREE.GeometryIdCount++),
                        (this.uuid = THREE.Math.generateUUID()),
                        (this.name = ""),
                        (this.attributes = {}),
                        (this.dynamic = !0),
                        (this.offsets = []),
                        (this.boundingBox = null),
                        (this.boundingSphere = null),
                        (this.hasTangents = !1),
                        (this.morphTargets = []);
                }),
                (THREE.BufferGeometry.prototype = {
                    constructor: THREE.BufferGeometry,
                    applyMatrix: function (e) {
                        var t, n;
                        this.attributes.position && (t = this.attributes.position.array), this.attributes.normal && (n = this.attributes.normal.array), t !== undefined && (e.multiplyVector3Array(t), (this.verticesNeedUpdate = !0));
                        if (n !== undefined) {
                            var r = new THREE.Matrix3().getNormalMatrix(e);
                            r.multiplyVector3Array(n), this.normalizeNormals(), (this.normalsNeedUpdate = !0);
                        }
                    },
                    computeBoundingBox: function () {
                        this.boundingBox === null && (this.boundingBox = new THREE.Box3());
                        var e = this.attributes.position.array;
                        if (e) {
                            var t = this.boundingBox,
                                n,
                                r,
                                i;
                            e.length >= 3 && ((t.min.x = t.max.x = e[0]), (t.min.y = t.max.y = e[1]), (t.min.z = t.max.z = e[2]));
                            for (var s = 3, o = e.length; s < o; s += 3)
                                (n = e[s]),
                                    (r = e[s + 1]),
                                    (i = e[s + 2]),
                                    n < t.min.x ? (t.min.x = n) : n > t.max.x && (t.max.x = n),
                                    r < t.min.y ? (t.min.y = r) : r > t.max.y && (t.max.y = r),
                                    i < t.min.z ? (t.min.z = i) : i > t.max.z && (t.max.z = i);
                        }
                        if (e === undefined || e.length === 0) this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);
                    },
                    computeBoundingSphere: (function () {
                        var e = new THREE.Box3(),
                            t = new THREE.Vector3();
                        return function () {
                            this.boundingSphere === null && (this.boundingSphere = new THREE.Sphere());
                            var n = this.attributes.position.array;
                            if (n) {
                                var r = this.boundingSphere.center;
                                for (var i = 0, s = n.length; i < s; i += 3) t.set(n[i], n[i + 1], n[i + 2]), e.addPoint(t);
                                e.center(r);
                                var o = 0;
                                for (var i = 0, s = n.length; i < s; i += 3) t.set(n[i], n[i + 1], n[i + 2]), (o = Math.max(o, r.distanceToSquared(t)));
                                this.boundingSphere.radius = Math.sqrt(o);
                            }
                        };
                    })(),
                    computeVertexNormals: function () {
                        if (this.attributes.position) {
                            var e,
                                t,
                                n,
                                r,
                                i = this.attributes.position.array.length;
                            if (this.attributes.normal === undefined) this.attributes.normal = { itemSize: 3, array: new Float32Array(i) };
                            else for (e = 0, t = this.attributes.normal.array.length; e < t; e++) this.attributes.normal.array[e] = 0;
                            var s = this.attributes.position.array,
                                o = this.attributes.normal.array,
                                u,
                                a,
                                f,
                                l,
                                c,
                                h,
                                p = new THREE.Vector3(),
                                d = new THREE.Vector3(),
                                v = new THREE.Vector3(),
                                m = new THREE.Vector3(),
                                g = new THREE.Vector3();
                            if (this.attributes.index) {
                                var y = this.attributes.index.array,
                                    b = this.offsets;
                                for (n = 0, r = b.length; n < r; ++n) {
                                    var w = b[n].start,
                                        E = b[n].count,
                                        S = b[n].index;
                                    for (e = w, t = w + E; e < t; e += 3)
                                        (u = S + y[e]),
                                            (a = S + y[e + 1]),
                                            (f = S + y[e + 2]),
                                            (l = s[u * 3]),
                                            (c = s[u * 3 + 1]),
                                            (h = s[u * 3 + 2]),
                                            p.set(l, c, h),
                                            (l = s[a * 3]),
                                            (c = s[a * 3 + 1]),
                                            (h = s[a * 3 + 2]),
                                            d.set(l, c, h),
                                            (l = s[f * 3]),
                                            (c = s[f * 3 + 1]),
                                            (h = s[f * 3 + 2]),
                                            v.set(l, c, h),
                                            m.subVectors(v, d),
                                            g.subVectors(p, d),
                                            m.cross(g),
                                            (o[u * 3] += m.x),
                                            (o[u * 3 + 1] += m.y),
                                            (o[u * 3 + 2] += m.z),
                                            (o[a * 3] += m.x),
                                            (o[a * 3 + 1] += m.y),
                                            (o[a * 3 + 2] += m.z),
                                            (o[f * 3] += m.x),
                                            (o[f * 3 + 1] += m.y),
                                            (o[f * 3 + 2] += m.z);
                                }
                            } else
                                for (e = 0, t = s.length; e < t; e += 9)
                                    (l = s[e]),
                                        (c = s[e + 1]),
                                        (h = s[e + 2]),
                                        p.set(l, c, h),
                                        (l = s[e + 3]),
                                        (c = s[e + 4]),
                                        (h = s[e + 5]),
                                        d.set(l, c, h),
                                        (l = s[e + 6]),
                                        (c = s[e + 7]),
                                        (h = s[e + 8]),
                                        v.set(l, c, h),
                                        m.subVectors(v, d),
                                        g.subVectors(p, d),
                                        m.cross(g),
                                        (o[e] = m.x),
                                        (o[e + 1] = m.y),
                                        (o[e + 2] = m.z),
                                        (o[e + 3] = m.x),
                                        (o[e + 4] = m.y),
                                        (o[e + 5] = m.z),
                                        (o[e + 6] = m.x),
                                        (o[e + 7] = m.y),
                                        (o[e + 8] = m.z);
                            this.normalizeNormals(), (this.normalsNeedUpdate = !0);
                        }
                    },
                    normalizeNormals: function () {
                        var e = this.attributes.normal.array,
                            t,
                            n,
                            r,
                            i;
                        for (var s = 0, o = e.length; s < o; s += 3) (t = e[s]), (n = e[s + 1]), (r = e[s + 2]), (i = 1 / Math.sqrt(t * t + n * n + r * r)), (e[s] *= i), (e[s + 1] *= i), (e[s + 2] *= i);
                    },
                    computeTangents: function () {
                        function F(e, n, i) {
                            (l = t[e * 3]),
                                (c = t[e * 3 + 1]),
                                (h = t[e * 3 + 2]),
                                (p = t[n * 3]),
                                (d = t[n * 3 + 1]),
                                (v = t[n * 3 + 2]),
                                (m = t[i * 3]),
                                (g = t[i * 3 + 1]),
                                (y = t[i * 3 + 2]),
                                (b = r[e * 2]),
                                (w = r[e * 2 + 1]),
                                (E = r[n * 2]),
                                (S = r[n * 2 + 1]),
                                (x = r[i * 2]),
                                (T = r[i * 2 + 1]),
                                (N = p - l),
                                (C = m - l),
                                (k = d - c),
                                (L = g - c),
                                (A = v - h),
                                (O = y - h),
                                (M = E - b),
                                (_ = x - b),
                                (D = S - w),
                                (P = T - w),
                                (H = 1 / (M * P - _ * D)),
                                B.set((P * N - D * C) * H, (P * k - D * L) * H, (P * A - D * O) * H),
                                j.set((M * C - _ * N) * H, (M * L - _ * k) * H, (M * O - _ * A) * H),
                                u[e].add(B),
                                u[n].add(B),
                                u[i].add(B),
                                a[e].add(j),
                                a[n].add(j),
                                a[i].add(j);
                        }
                        function rt(e) {
                            (Y.x = n[e * 3]),
                                (Y.y = n[e * 3 + 1]),
                                (Y.z = n[e * 3 + 2]),
                                Z.copy(Y),
                                (tt = u[e]),
                                Q.copy(tt),
                                Q.sub(Y.multiplyScalar(Y.dot(tt))).normalize(),
                                G.crossVectors(Z, tt),
                                (nt = G.dot(a[e])),
                                (et = nt < 0 ? -1 : 1),
                                (o[e * 4] = Q.x),
                                (o[e * 4 + 1] = Q.y),
                                (o[e * 4 + 2] = Q.z),
                                (o[e * 4 + 3] = et);
                        }
                        if (this.attributes.index === undefined || this.attributes.position === undefined || this.attributes.normal === undefined || this.attributes.uv === undefined) {
                            console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
                            return;
                        }
                        var e = this.attributes.index.array,
                            t = this.attributes.position.array,
                            n = this.attributes.normal.array,
                            r = this.attributes.uv.array,
                            i = t.length / 3;
                        if (this.attributes.tangent === undefined) {
                            var s = 4 * i;
                            this.attributes.tangent = { itemSize: 4, array: new Float32Array(s) };
                        }
                        var o = this.attributes.tangent.array,
                            u = [],
                            a = [];
                        for (var f = 0; f < i; f++) (u[f] = new THREE.Vector3()), (a[f] = new THREE.Vector3());
                        var l,
                            c,
                            h,
                            p,
                            d,
                            v,
                            m,
                            g,
                            y,
                            b,
                            w,
                            E,
                            S,
                            x,
                            T,
                            N,
                            C,
                            k,
                            L,
                            A,
                            O,
                            M,
                            _,
                            D,
                            P,
                            H,
                            B = new THREE.Vector3(),
                            j = new THREE.Vector3(),
                            I,
                            q,
                            R,
                            U,
                            z,
                            W,
                            X,
                            V = this.offsets;
                        for (R = 0, U = V.length; R < U; ++R) {
                            var $ = V[R].start,
                                J = V[R].count,
                                K = V[R].index;
                            for (I = $, q = $ + J; I < q; I += 3) (z = K + e[I]), (W = K + e[I + 1]), (X = K + e[I + 2]), F(z, W, X);
                        }
                        var Q = new THREE.Vector3(),
                            G = new THREE.Vector3(),
                            Y = new THREE.Vector3(),
                            Z = new THREE.Vector3(),
                            et,
                            tt,
                            nt;
                        for (R = 0, U = V.length; R < U; ++R) {
                            var $ = V[R].start,
                                J = V[R].count,
                                K = V[R].index;
                            for (I = $, q = $ + J; I < q; I += 3) (z = K + e[I]), (W = K + e[I + 1]), (X = K + e[I + 2]), rt(z), rt(W), rt(X);
                        }
                        (this.hasTangents = !0), (this.tangentsNeedUpdate = !0);
                    },
                    clone: function () {
                        var e = new THREE.BufferGeometry(),
                            t = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
                        for (var n in this.attributes) {
                            var r = this.attributes[n],
                                i = r.array,
                                s = { itemSize: r.itemSize, numItems: r.numItems, array: null };
                            for (var o = 0, u = t.length; o < u; o++) {
                                var a = t[o];
                                if (i instanceof a) {
                                    s.array = new a(i);
                                    break;
                                }
                            }
                            e.attributes[n] = s;
                        }
                        for (var o = 0, u = this.offsets.length; o < u; o++) {
                            var f = this.offsets[o];
                            e.offsets.push({ start: f.start, index: f.index, count: f.count });
                        }
                        return e;
                    },
                    dispose: function () {
                        this.dispatchEvent({ type: "dispose" });
                    },
                }),
                THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype),
                (THREE.Camera = function () {
                    THREE.Object3D.call(this), (this.matrixWorldInverse = new THREE.Matrix4()), (this.projectionMatrix = new THREE.Matrix4()), (this.projectionMatrixInverse = new THREE.Matrix4());
                }),
                (THREE.Camera.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.Camera.prototype.lookAt = (function () {
                    var e = new THREE.Matrix4();
                    return function (t) {
                        e.lookAt(this.position, t, this.up), this.quaternion.setFromRotationMatrix(e);
                    };
                })()),
                (THREE.Camera.prototype.clone = function (e) {
                    return (
                        e === undefined && (e = new THREE.Camera()),
                            THREE.Object3D.prototype.clone.call(this, e),
                            e.matrixWorldInverse.copy(this.matrixWorldInverse),
                            e.projectionMatrix.copy(this.projectionMatrix),
                            e.projectionMatrixInverse.copy(this.projectionMatrixInverse),
                            e
                    );
                }),
                (THREE.OrthographicCamera = function (e, t, n, r, i, s) {
                    THREE.Camera.call(this), (this.left = e), (this.right = t), (this.top = n), (this.bottom = r), (this.near = i !== undefined ? i : 0.1), (this.far = s !== undefined ? s : 2e3), this.updateProjectionMatrix();
                }),
                (THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype)),
                (THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
                    this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);
                }),
                (THREE.OrthographicCamera.prototype.clone = function () {
                    var e = new THREE.OrthographicCamera();
                    return THREE.Camera.prototype.clone.call(this, e), (e.left = this.left), (e.right = this.right), (e.top = this.top), (e.bottom = this.bottom), (e.near = this.near), (e.far = this.far), e;
                }),
                (THREE.PerspectiveCamera = function (e, t, n, r) {
                    THREE.Camera.call(this), (this.fov = e !== undefined ? e : 50), (this.aspect = t !== undefined ? t : 1), (this.near = n !== undefined ? n : 0.1), (this.far = r !== undefined ? r : 2e3), this.updateProjectionMatrix();
                }),
                (THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype)),
                (THREE.PerspectiveCamera.prototype.setLens = function (e, t) {
                    t === undefined && (t = 24), (this.fov = 2 * THREE.Math.radToDeg(Math.atan(t / (e * 2)))), this.updateProjectionMatrix();
                }),
                (THREE.PerspectiveCamera.prototype.setViewOffset = function (e, t, n, r, i, s) {
                    (this.fullWidth = e), (this.fullHeight = t), (this.x = n), (this.y = r), (this.width = i), (this.height = s), this.updateProjectionMatrix();
                }),
                (THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
                    if (this.fullWidth) {
                        var e = this.fullWidth / this.fullHeight,
                            t = Math.tan(THREE.Math.degToRad(this.fov * 0.5)) * this.near,
                            n = -t,
                            r = e * n,
                            i = e * t,
                            s = Math.abs(i - r),
                            o = Math.abs(t - n);
                        this.projectionMatrix.makeFrustum(r + (this.x * s) / this.fullWidth, r + ((this.x + this.width) * s) / this.fullWidth, t - ((this.y + this.height) * o) / this.fullHeight, t - (this.y * o) / this.fullHeight, this.near, this.far);
                    } else this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);
                }),
                (THREE.PerspectiveCamera.prototype.clone = function () {
                    var e = new THREE.PerspectiveCamera();
                    return THREE.Camera.prototype.clone.call(this, e), (e.fov = this.fov), (e.aspect = this.aspect), (e.near = this.near), (e.far = this.far), e;
                }),
                (THREE.Light = function (e) {
                    THREE.Object3D.call(this), (this.color = new THREE.Color(e));
                }),
                (THREE.Light.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.Light.prototype.clone = function (e) {
                    return e === undefined && (e = new THREE.Light()), THREE.Object3D.prototype.clone.call(this, e), e.color.copy(this.color), e;
                }),
                (THREE.AmbientLight = function (e) {
                    THREE.Light.call(this, e);
                }),
                (THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype)),
                (THREE.AmbientLight.prototype.clone = function () {
                    var e = new THREE.AmbientLight();
                    return THREE.Light.prototype.clone.call(this, e), e;
                }),
                (THREE.AreaLight = function (e, t) {
                    THREE.Light.call(this, e),
                        (this.normal = new THREE.Vector3(0, -1, 0)),
                        (this.right = new THREE.Vector3(1, 0, 0)),
                        (this.intensity = t !== undefined ? t : 1),
                        (this.width = 1),
                        (this.height = 1),
                        (this.constantAttenuation = 1.5),
                        (this.linearAttenuation = 0.5),
                        (this.quadraticAttenuation = 0.1);
                }),
                (THREE.AreaLight.prototype = Object.create(THREE.Light.prototype)),
                (THREE.DirectionalLight = function (e, t) {
                    THREE.Light.call(this, e),
                        this.position.set(0, 1, 0),
                        (this.target = new THREE.Object3D()),
                        (this.intensity = t !== undefined ? t : 1),
                        (this.castShadow = !1),
                        (this.onlyShadow = !1),
                        (this.shadowCameraNear = 50),
                        (this.shadowCameraFar = 5e3),
                        (this.shadowCameraLeft = -500),
                        (this.shadowCameraRight = 500),
                        (this.shadowCameraTop = 500),
                        (this.shadowCameraBottom = -500),
                        (this.shadowCameraVisible = !1),
                        (this.shadowBias = 0),
                        (this.shadowDarkness = 0.5),
                        (this.shadowMapWidth = 512),
                        (this.shadowMapHeight = 512),
                        (this.shadowCascade = !1),
                        (this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3)),
                        (this.shadowCascadeCount = 2),
                        (this.shadowCascadeBias = [0, 0, 0]),
                        (this.shadowCascadeWidth = [512, 512, 512]),
                        (this.shadowCascadeHeight = [512, 512, 512]),
                        (this.shadowCascadeNearZ = [-1, 0.99, 0.998]),
                        (this.shadowCascadeFarZ = [0.99, 0.998, 1]),
                        (this.shadowCascadeArray = []),
                        (this.shadowMap = null),
                        (this.shadowMapSize = null),
                        (this.shadowCamera = null),
                        (this.shadowMatrix = null);
                }),
                (THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype)),
                (THREE.DirectionalLight.prototype.clone = function () {
                    var e = new THREE.DirectionalLight();
                    return THREE.Light.prototype.clone.call(this, e), (e.target = this.target.clone()), (e.intensity = this.intensity), (e.castShadow = this.castShadow), (e.onlyShadow = this.onlyShadow), e;
                }),
                (THREE.HemisphereLight = function (e, t, n) {
                    THREE.Light.call(this, e), this.position.set(0, 100, 0), (this.groundColor = new THREE.Color(t)), (this.intensity = n !== undefined ? n : 1);
                }),
                (THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype)),
                (THREE.HemisphereLight.prototype.clone = function () {
                    var e = new THREE.HemisphereLight();
                    return THREE.Light.prototype.clone.call(this, e), e.groundColor.copy(this.groundColor), (e.intensity = this.intensity), e;
                }),
                (THREE.PointLight = function (e, t, n) {
                    THREE.Light.call(this, e), (this.intensity = t !== undefined ? t : 1), (this.distance = n !== undefined ? n : 0);
                }),
                (THREE.PointLight.prototype = Object.create(THREE.Light.prototype)),
                (THREE.PointLight.prototype.clone = function () {
                    var e = new THREE.PointLight();
                    return THREE.Light.prototype.clone.call(this, e), (e.intensity = this.intensity), (e.distance = this.distance), e;
                }),
                (THREE.SpotLight = function (e, t, n, r, i) {
                    THREE.Light.call(this, e),
                        this.position.set(0, 1, 0),
                        (this.target = new THREE.Object3D()),
                        (this.intensity = t !== undefined ? t : 1),
                        (this.distance = n !== undefined ? n : 0),
                        (this.angle = r !== undefined ? r : Math.PI / 3),
                        (this.exponent = i !== undefined ? i : 10),
                        (this.castShadow = !1),
                        (this.onlyShadow = !1),
                        (this.shadowCameraNear = 50),
                        (this.shadowCameraFar = 5e3),
                        (this.shadowCameraFov = 50),
                        (this.shadowCameraVisible = !1),
                        (this.shadowBias = 0),
                        (this.shadowDarkness = 0.5),
                        (this.shadowMapWidth = 512),
                        (this.shadowMapHeight = 512),
                        (this.shadowMap = null),
                        (this.shadowMapSize = null),
                        (this.shadowCamera = null),
                        (this.shadowMatrix = null);
                }),
                (THREE.SpotLight.prototype = Object.create(THREE.Light.prototype)),
                (THREE.SpotLight.prototype.clone = function () {
                    var e = new THREE.SpotLight();
                    return (
                        THREE.Light.prototype.clone.call(this, e),
                            (e.target = this.target.clone()),
                            (e.intensity = this.intensity),
                            (e.distance = this.distance),
                            (e.angle = this.angle),
                            (e.exponent = this.exponent),
                            (e.castShadow = this.castShadow),
                            (e.onlyShadow = this.onlyShadow),
                            e
                    );
                }),
                (THREE.Loader = function (e) {
                    (this.showStatus = e), (this.statusDomElement = e ? THREE.Loader.prototype.addStatusElement() : null), (this.onLoadStart = function () {}), (this.onLoadProgress = function () {}), (this.onLoadComplete = function () {});
                }),
                (THREE.Loader.prototype = {
                    constructor: THREE.Loader,
                    crossOrigin: "anonymous",
                    addStatusElement: function () {
                        var e = document.createElement("div");
                        return (
                            (e.style.position = "absolute"),
                                (e.style.right = "0px"),
                                (e.style.top = "0px"),
                                (e.style.fontSize = "0.8em"),
                                (e.style.textAlign = "left"),
                                (e.style.background = "rgba(0,0,0,0.25)"),
                                (e.style.color = "#fff"),
                                (e.style.width = "120px"),
                                (e.style.padding = "0.5em 0.5em 0.5em 0.5em"),
                                (e.style.zIndex = 1e3),
                                (e.innerHTML = "Loading ..."),
                                e
                        );
                    },
                    updateProgress: function (e) {
                        var t = "Loaded ";
                        e.total ? (t += ((100 * e.loaded) / e.total).toFixed(0) + "%") : (t += (e.loaded / 1e3).toFixed(2) + " KB"), (this.statusDomElement.innerHTML = t);
                    },
                    extractUrlBase: function (e) {
                        var t = e.split("/");
                        return t.pop(), (t.length < 1 ? "." : t.join("/")) + "/";
                    },
                    initMaterials: function (e, t) {
                        var n = [];
                        for (var r = 0; r < e.length; ++r) n[r] = THREE.Loader.prototype.createMaterial(e[r], t);
                        return n;
                    },
                    needsTangents: function (e) {
                        for (var t = 0, n = e.length; t < n; t++) {
                            var r = e[t];
                            if (r instanceof THREE.ShaderMaterial) return !0;
                        }
                        return !1;
                    },
                    createMaterial: function (e, t) {
                        function r(e) {
                            var t = Math.log(e) / Math.LN2;
                            return Math.floor(t) == t;
                        }
                        function i(e) {
                            var t = Math.log(e) / Math.LN2;
                            return Math.pow(2, Math.round(t));
                        }
                        function s(e, t) {
                            var s = new Image();
                            (s.onload = function () {
                                if (!r(this.width) || !r(this.height)) {
                                    var t = i(this.width),
                                        n = i(this.height);
                                    (e.image.width = t), (e.image.height = n), e.image.getContext("2d").drawImage(this, 0, 0, t, n);
                                } else e.image = this;
                                e.needsUpdate = !0;
                            }),
                                (s.crossOrigin = n.crossOrigin),
                                (s.src = t);
                        }
                        function o(e, n, r, i, o, u, a) {
                            var f = /\.dds$/i.test(r),
                                l = t + "/" + r;
                            if (f) {
                                var c = THREE.ImageUtils.loadCompressedTexture(l);
                                e[n] = c;
                            } else {
                                var c = document.createElement("canvas");
                                e[n] = new THREE.Texture(c);
                            }
                            (e[n].sourceFile = r), i && (e[n].repeat.set(i[0], i[1]), i[0] !== 1 && (e[n].wrapS = THREE.RepeatWrapping), i[1] !== 1 && (e[n].wrapT = THREE.RepeatWrapping)), o && e[n].offset.set(o[0], o[1]);
                            if (u) {
                                var h = { repeat: THREE.RepeatWrapping, mirror: THREE.MirroredRepeatWrapping };
                                h[u[0]] !== undefined && (e[n].wrapS = h[u[0]]), h[u[1]] !== undefined && (e[n].wrapT = h[u[1]]);
                            }
                            a && (e[n].anisotropy = a), f || s(e[n], l);
                        }
                        function u(e) {
                            return ((e[0] * 255) << 16) + ((e[1] * 255) << 8) + e[2] * 255;
                        }
                        var n = this,
                            a = "MeshLambertMaterial",
                            f = { color: 15658734, opacity: 1, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: !1 };
                        if (e.shading) {
                            var l = e.shading.toLowerCase();
                            l === "phong" ? (a = "MeshPhongMaterial") : l === "basic" && (a = "MeshBasicMaterial");
                        }
                        e.blending !== undefined && THREE[e.blending] !== undefined && (f.blending = THREE[e.blending]);
                        if (e.transparent !== undefined || e.opacity < 1) f.transparent = e.transparent;
                        e.depthTest !== undefined && (f.depthTest = e.depthTest),
                        e.depthWrite !== undefined && (f.depthWrite = e.depthWrite),
                        e.visible !== undefined && (f.visible = e.visible),
                        e.flipSided !== undefined && (f.side = THREE.BackSide),
                        e.doubleSided !== undefined && (f.side = THREE.DoubleSide),
                        e.wireframe !== undefined && (f.wireframe = e.wireframe),
                        e.vertexColors !== undefined && (e.vertexColors === "face" ? (f.vertexColors = THREE.FaceColors) : e.vertexColors && (f.vertexColors = THREE.VertexColors)),
                            e.colorDiffuse ? (f.color = u(e.colorDiffuse)) : e.DbgColor && (f.color = e.DbgColor),
                        e.colorSpecular && (f.specular = u(e.colorSpecular)),
                        e.colorAmbient && (f.ambient = u(e.colorAmbient)),
                        e.transparency && (f.opacity = e.transparency),
                        e.specularCoef && (f.shininess = e.specularCoef),
                        e.mapDiffuse && t && o(f, "map", e.mapDiffuse, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy),
                        e.mapLight && t && o(f, "lightMap", e.mapLight, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy),
                        e.mapBump && t && o(f, "bumpMap", e.mapBump, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy),
                        e.mapNormal && t && o(f, "normalMap", e.mapNormal, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy),
                        e.mapSpecular && t && o(f, "specularMap", e.mapSpecular, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy),
                        e.mapBumpScale && (f.bumpScale = e.mapBumpScale);
                        if (e.mapNormal) {
                            var c = THREE.ShaderLib.normalmap,
                                h = THREE.UniformsUtils.clone(c.uniforms);
                            (h.tNormal.value = f.normalMap),
                            e.mapNormalFactor && h.uNormalScale.value.set(e.mapNormalFactor, e.mapNormalFactor),
                            f.map && ((h.tDiffuse.value = f.map), (h.enableDiffuse.value = !0)),
                            f.specularMap && ((h.tSpecular.value = f.specularMap), (h.enableSpecular.value = !0)),
                            f.lightMap && ((h.tAO.value = f.lightMap), (h.enableAO.value = !0)),
                                h.uDiffuseColor.value.setHex(f.color),
                                h.uSpecularColor.value.setHex(f.specular),
                                h.uAmbientColor.value.setHex(f.ambient),
                                (h.uShininess.value = f.shininess),
                            f.opacity !== undefined && (h.uOpacity.value = f.opacity);
                            var p = { fragmentShader: c.fragmentShader, vertexShader: c.vertexShader, uniforms: h, lights: !0, fog: !0 },
                                d = new THREE.ShaderMaterial(p);
                            f.transparent && (d.transparent = !0);
                        } else var d = new THREE[a](f);
                        return e.DbgName !== undefined && (d.name = e.DbgName), d;
                    },
                }),
                (THREE.XHRLoader = function (e) {
                    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
                }),
                (THREE.XHRLoader.prototype = {
                    constructor: THREE.XHRLoader,
                    load: function (e, t, n, r) {
                        var i = this,
                            s = new XMLHttpRequest();
                        t !== undefined &&
                        s.addEventListener(
                            "load",
                            function (n) {
                                t(n.target.responseText), i.manager.itemEnd(e);
                            },
                            !1
                        ),
                        n !== undefined &&
                        s.addEventListener(
                            "progress",
                            function (e) {
                                n(e);
                            },
                            !1
                        ),
                        r !== undefined &&
                        s.addEventListener(
                            "error",
                            function (e) {
                                r(e);
                            },
                            !1
                        ),
                        this.crossOrigin !== undefined && (s.crossOrigin = this.crossOrigin),
                            s.open("GET", e, !0),
                            s.send(null),
                            i.manager.itemStart(e);
                    },
                    setCrossOrigin: function (e) {
                        this.crossOrigin = e;
                    },
                }),
                (THREE.ImageLoader = function (e) {
                    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
                }),
                (THREE.ImageLoader.prototype = {
                    constructor: THREE.ImageLoader,
                    load: function (e, t, n, r) {
                        var i = this,
                            s = document.createElement("img");
                        return (
                            t !== undefined &&
                            s.addEventListener(
                                "load",
                                function (n) {
                                    i.manager.itemEnd(e), t(this);
                                },
                                !1
                            ),
                            n !== undefined &&
                            s.addEventListener(
                                "progress",
                                function (e) {
                                    n(e);
                                },
                                !1
                            ),
                            r !== undefined &&
                            s.addEventListener(
                                "error",
                                function (e) {
                                    r(e);
                                },
                                !1
                            ),
                            this.crossOrigin !== undefined && (s.crossOrigin = this.crossOrigin),
                                (s.src = e),
                                i.manager.itemStart(e),
                                s
                        );
                    },
                    setCrossOrigin: function (e) {
                        this.crossOrigin = e;
                    },
                }),
                (THREE.JSONLoader = function (e) {
                    THREE.Loader.call(this, e), (this.withCredentials = !1);
                }),
                (THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype)),
                (THREE.JSONLoader.prototype.load = function (e, t, n) {
                    var r = this;
                    (n = n && typeof n == "string" ? n : this.extractUrlBase(e)), this.onLoadStart(), this.loadAjaxJSON(this, e, t, n);
                }),
                (THREE.JSONLoader.prototype.loadAjaxJSON = function (e, t, n, r, i) {
                    var s = new XMLHttpRequest(),
                        o = 0;
                    (s.onreadystatechange = function () {
                        if (s.readyState === s.DONE)
                            if (s.status === 200 || s.status === 0) {
                                if (s.responseText) {
                                    var u = JSON.parse(s.responseText),
                                        a = e.parse(u, r);
                                    n(a.geometry, a.materials);
                                } else console.warn("THREE.JSONLoader: [" + t + "] seems to be unreachable or file there is empty");
                                e.onLoadComplete();
                            } else console.error("THREE.JSONLoader: Couldn't load [" + t + "] [" + s.status + "]");
                        else
                            s.readyState === s.LOADING
                                ? i && (o === 0 && (o = s.getResponseHeader("Content-Length")), i({ total: o, loaded: s.responseText.length }))
                                : s.readyState === s.HEADERS_RECEIVED && i !== undefined && (o = s.getResponseHeader("Content-Length"));
                    }),
                        s.open("GET", t, !0),
                        (s.withCredentials = this.withCredentials),
                        s.send(null);
                }),
                (THREE.JSONLoader.prototype.parse = function (e, t) {
                    function s(t) {
                        function n(e, t) {
                            return e & (1 << t);
                        }
                        var i,
                            s,
                            o,
                            u,
                            a,
                            f,
                            l,
                            c,
                            h,
                            p,
                            d,
                            v,
                            m,
                            g,
                            y,
                            b,
                            w,
                            E,
                            S,
                            x,
                            T,
                            N,
                            C,
                            k,
                            L,
                            A,
                            O,
                            M,
                            _ = e.faces,
                            D = e.vertices,
                            P = e.normals,
                            H = e.colors,
                            B = 0;
                        if (e.uvs !== undefined) {
                            for (i = 0; i < e.uvs.length; i++) e.uvs[i].length && B++;
                            for (i = 0; i < B; i++) r.faceVertexUvs[i] = [];
                        }
                        (u = 0), (a = D.length);
                        while (u < a) (E = new THREE.Vector3()), (E.x = D[u++] * t), (E.y = D[u++] * t), (E.z = D[u++] * t), r.vertices.push(E);
                        (u = 0), (a = _.length);
                        while (u < a) {
                            (p = _[u++]), (d = n(p, 0)), (v = n(p, 1)), (m = n(p, 3)), (g = n(p, 4)), (y = n(p, 5)), (b = n(p, 6)), (w = n(p, 7));
                            if (d) {
                                (x = new THREE.Face3()),
                                    (x.a = _[u]),
                                    (x.b = _[u + 1]),
                                    (x.c = _[u + 3]),
                                    (T = new THREE.Face3()),
                                    (T.a = _[u + 1]),
                                    (T.b = _[u + 2]),
                                    (T.c = _[u + 3]),
                                    (u += 4),
                                v && ((h = _[u++]), (x.materialIndex = h), (T.materialIndex = h)),
                                    (o = r.faces.length);
                                if (m)
                                    for (i = 0; i < B; i++) {
                                        (L = e.uvs[i]), (r.faceVertexUvs[i][o] = []), (r.faceVertexUvs[i][o + 1] = []);
                                        for (s = 0; s < 4; s++) (c = _[u++]), (O = L[c * 2]), (M = L[c * 2 + 1]), (A = new THREE.Vector2(O, M)), s !== 2 && r.faceVertexUvs[i][o].push(A), s !== 0 && r.faceVertexUvs[i][o + 1].push(A);
                                    }
                                g && ((l = _[u++] * 3), x.normal.set(P[l++], P[l++], P[l]), T.normal.copy(x.normal));
                                if (y) for (i = 0; i < 4; i++) (l = _[u++] * 3), (k = new THREE.Vector3(P[l++], P[l++], P[l])), i !== 2 && x.vertexNormals.push(k), i !== 0 && T.vertexNormals.push(k);
                                b && ((f = _[u++]), (C = H[f]), x.color.setHex(C), T.color.setHex(C));
                                if (w) for (i = 0; i < 4; i++) (f = _[u++]), (C = H[f]), i !== 2 && x.vertexColors.push(new THREE.Color(C)), i !== 0 && T.vertexColors.push(new THREE.Color(C));
                                r.faces.push(x), r.faces.push(T);
                            } else {
                                (S = new THREE.Face3()), (S.a = _[u++]), (S.b = _[u++]), (S.c = _[u++]), v && ((h = _[u++]), (S.materialIndex = h)), (o = r.faces.length);
                                if (m)
                                    for (i = 0; i < B; i++) {
                                        (L = e.uvs[i]), (r.faceVertexUvs[i][o] = []);
                                        for (s = 0; s < 3; s++) (c = _[u++]), (O = L[c * 2]), (M = L[c * 2 + 1]), (A = new THREE.Vector2(O, M)), r.faceVertexUvs[i][o].push(A);
                                    }
                                g && ((l = _[u++] * 3), S.normal.set(P[l++], P[l++], P[l]));
                                if (y) for (i = 0; i < 3; i++) (l = _[u++] * 3), (k = new THREE.Vector3(P[l++], P[l++], P[l])), S.vertexNormals.push(k);
                                b && ((f = _[u++]), S.color.setHex(H[f]));
                                if (w) for (i = 0; i < 3; i++) (f = _[u++]), S.vertexColors.push(new THREE.Color(H[f]));
                                r.faces.push(S);
                            }
                        }
                    }
                    function o() {
                        var t, n, i, s, o, u, a, f, l, c;
                        if (e.skinWeights) for (t = 0, n = e.skinWeights.length; t < n; t += 2) (i = e.skinWeights[t]), (s = e.skinWeights[t + 1]), (o = 0), (u = 0), r.skinWeights.push(new THREE.Vector4(i, s, o, u));
                        if (e.skinIndices) for (t = 0, n = e.skinIndices.length; t < n; t += 2) (a = e.skinIndices[t]), (f = e.skinIndices[t + 1]), (l = 0), (c = 0), r.skinIndices.push(new THREE.Vector4(a, f, l, c));
                        (r.bones = e.bones), (r.animation = e.animation);
                    }
                    function u(t) {
                        if (e.morphTargets !== undefined) {
                            var n, i, s, o, u, a;
                            for (n = 0, i = e.morphTargets.length; n < i; n++) {
                                (r.morphTargets[n] = {}), (r.morphTargets[n].name = e.morphTargets[n].name), (r.morphTargets[n].vertices = []), (u = r.morphTargets[n].vertices), (a = e.morphTargets[n].vertices);
                                for (s = 0, o = a.length; s < o; s += 3) {
                                    var f = new THREE.Vector3();
                                    (f.x = a[s] * t), (f.y = a[s + 1] * t), (f.z = a[s + 2] * t), u.push(f);
                                }
                            }
                        }
                        if (e.morphColors !== undefined) {
                            var n, i, l, c, h, p, d;
                            for (n = 0, i = e.morphColors.length; n < i; n++) {
                                (r.morphColors[n] = {}), (r.morphColors[n].name = e.morphColors[n].name), (r.morphColors[n].colors = []), (h = r.morphColors[n].colors), (p = e.morphColors[n].colors);
                                for (l = 0, c = p.length; l < c; l += 3) (d = new THREE.Color(16755200)), d.setRGB(p[l], p[l + 1], p[l + 2]), h.push(d);
                            }
                        }
                    }
                    var n = this,
                        r = new THREE.Geometry(),
                        i = e.scale !== undefined ? 1 / e.scale : 1;
                    s(i), o(), u(i), r.computeCentroids(), r.computeFaceNormals(), r.computeBoundingSphere();
                    if (e.materials === undefined) return { geometry: r };
                    var a = this.initMaterials(e.materials, t);
                    return this.needsTangents(a) && r.computeTangents(), { geometry: r, materials: a };
                }),
                (THREE.LoadingManager = function (e, t, n) {
                    var r = this,
                        i = 0,
                        s = 0;
                    (this.onLoad = e),
                        (this.onProgress = t),
                        (this.onError = n),
                        (this.itemStart = function (e) {
                            s++;
                        }),
                        (this.itemEnd = function (e) {
                            i++, r.onProgress !== undefined && r.onProgress(e, i, s), i === s && r.onLoad !== undefined && r.onLoad();
                        });
                }),
                (THREE.DefaultLoadingManager = new THREE.LoadingManager()),
                (THREE.BufferGeometryLoader = function (e) {
                    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
                }),
                (THREE.BufferGeometryLoader.prototype = {
                    constructor: THREE.BufferGeometryLoader,
                    load: function (e, t, n, r) {
                        var i = this,
                            s = new THREE.XHRLoader();
                        s.setCrossOrigin(this.crossOrigin),
                            s.load(e, function (e) {
                                t(i.parse(JSON.parse(e)));
                            });
                    },
                    setCrossOrigin: function (e) {
                        this.crossOrigin = e;
                    },
                    parse: function (e) {
                        var t = new THREE.BufferGeometry(),
                            n = e.attributes,
                            r = e.offsets,
                            i = e.boundingSphere;
                        for (var s in n) {
                            var o = n[s];
                            t.attributes[s] = { itemSize: o.itemSize, array: new self[o.type](o.array) };
                        }
                        return r !== undefined && (t.offsets = JSON.parse(JSON.stringify(r))), i !== undefined && (t.boundingSphere = new THREE.Sphere(new THREE.Vector3().fromArray(i.center !== undefined ? i.center : [0, 0, 0]), i.radius)), t;
                    },
                }),
                (THREE.GeometryLoader = function (e) {
                    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
                }),
                (THREE.GeometryLoader.prototype = {
                    constructor: THREE.GeometryLoader,
                    load: function (e, t, n, r) {
                        var i = this,
                            s = new THREE.XHRLoader();
                        s.setCrossOrigin(this.crossOrigin),
                            s.load(e, function (e) {
                                t(i.parse(JSON.parse(e)));
                            });
                    },
                    setCrossOrigin: function (e) {
                        this.crossOrigin = e;
                    },
                    parse: function (e) {},
                }),
                (THREE.MaterialLoader = function (e) {
                    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
                }),
                (THREE.MaterialLoader.prototype = {
                    constructor: THREE.MaterialLoader,
                    load: function (e, t, n, r) {
                        var i = this,
                            s = new THREE.XHRLoader();
                        s.setCrossOrigin(this.crossOrigin),
                            s.load(e, function (e) {
                                t(i.parse(JSON.parse(e)));
                            });
                    },
                    setCrossOrigin: function (e) {
                        this.crossOrigin = e;
                    },
                    parse: function (e) {
                        var t = new THREE[e.type]();
                        e.color !== undefined && t.color.setHex(e.color),
                        e.ambient !== undefined && t.ambient.setHex(e.ambient),
                        e.emissive !== undefined && t.emissive.setHex(e.emissive),
                        e.specular !== undefined && t.specular.setHex(e.specular),
                        e.shininess !== undefined && (t.shininess = e.shininess),
                        e.vertexColors !== undefined && (t.vertexColors = e.vertexColors),
                        e.blending !== undefined && (t.blending = e.blending),
                        e.opacity !== undefined && (t.opacity = e.opacity),
                        e.transparent !== undefined && (t.transparent = e.transparent),
                        e.wireframe !== undefined && (t.wireframe = e.wireframe);
                        if (e.materials !== undefined) for (var n = 0, r = e.materials.length; n < r; n++) t.materials.push(this.parse(e.materials[n]));
                        return t;
                    },
                }),
                (THREE.ObjectLoader = function (e) {
                    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
                }),
                (THREE.ObjectLoader.prototype = {
                    constructor: THREE.ObjectLoader,
                    load: function (e, t, n, r) {
                        var i = this,
                            s = new THREE.XHRLoader(i.manager);
                        s.setCrossOrigin(this.crossOrigin),
                            s.load(e, function (e) {
                                t(i.parse(JSON.parse(e)));
                            });
                    },
                    setCrossOrigin: function (e) {
                        this.crossOrigin = e;
                    },
                    parse: function (e) {
                        var t = this.parseGeometries(e.geometries),
                            n = this.parseMaterials(e.materials),
                            r = this.parseObject(e.object, t, n);
                        return r;
                    },
                    parseGeometries: function (e) {
                        var t = {};
                        if (e !== undefined) {
                            var n = new THREE.JSONLoader(),
                                r = new THREE.BufferGeometryLoader();
                            for (var i = 0, s = e.length; i < s; i++) {
                                var o,
                                    u = e[i];
                                switch (u.type) {
                                    case "PlaneGeometry":
                                        o = new THREE.PlaneGeometry(u.width, u.height, u.widthSegments, u.heightSegments);
                                        break;
                                    case "CircleGeometry":
                                        o = new THREE.CircleGeometry(u.radius, u.segments);
                                        break;
                                    case "CubeGeometry":
                                        o = new THREE.CubeGeometry(u.width, u.height, u.depth, u.widthSegments, u.heightSegments, u.depthSegments);
                                        break;
                                    case "CylinderGeometry":
                                        o = new THREE.CylinderGeometry(u.radiusTop, u.radiusBottom, u.height, u.radiusSegments, u.heightSegments, u.openEnded);
                                        break;
                                    case "SphereGeometry":
                                        o = new THREE.SphereGeometry(u.radius, u.widthSegments, u.heightSegments, u.phiStart, u.phiLength, u.thetaStart, u.thetaLength);
                                        break;
                                    case "IcosahedronGeometry":
                                        o = new THREE.IcosahedronGeometry(u.radius, u.detail);
                                        break;
                                    case "TorusGeometry":
                                        o = new THREE.TorusGeometry(u.radius, u.tube, u.radialSegments, u.tubularSegments, u.arc);
                                        break;
                                    case "TorusKnotGeometry":
                                        o = new THREE.TorusKnotGeometry(u.radius, u.tube, u.radialSegments, u.tubularSegments, u.p, u.q, u.heightScale);
                                        break;
                                    case "BufferGeometry":
                                        o = r.parse(u.data);
                                        break;
                                    case "Geometry":
                                        o = n.parse(u.data).geometry;
                                }
                                (o.uuid = u.uuid), u.name !== undefined && (o.name = u.name), (t[u.uuid] = o);
                            }
                        }
                        return t;
                    },
                    parseMaterials: function (e) {
                        var t = {};
                        if (e !== undefined) {
                            var n = new THREE.MaterialLoader();
                            for (var r = 0, i = e.length; r < i; r++) {
                                var s = e[r],
                                    o = n.parse(s);
                                (o.uuid = s.uuid), s.name !== undefined && (o.name = s.name), (t[s.uuid] = o);
                            }
                        }
                        return t;
                    },
                    parseObject: (function () {
                        var e = new THREE.Matrix4();
                        return function (t, n, r) {
                            var i;
                            switch (t.type) {
                                case "Scene":
                                    i = new THREE.Scene();
                                    break;
                                case "PerspectiveCamera":
                                    i = new THREE.PerspectiveCamera(t.fov, t.aspect, t.near, t.far);
                                    break;
                                case "OrthographicCamera":
                                    i = new THREE.OrthographicCamera(t.left, t.right, t.top, t.bottom, t.near, t.far);
                                    break;
                                case "AmbientLight":
                                    i = new THREE.AmbientLight(t.color);
                                    break;
                                case "DirectionalLight":
                                    i = new THREE.DirectionalLight(t.color, t.intensity);
                                    break;
                                case "PointLight":
                                    i = new THREE.PointLight(t.color, t.intensity, t.distance);
                                    break;
                                case "SpotLight":
                                    i = new THREE.SpotLight(t.color, t.intensity, t.distance, t.angle, t.exponent);
                                    break;
                                case "HemisphereLight":
                                    i = new THREE.HemisphereLight(t.color, t.groundColor, t.intensity);
                                    break;
                                case "Mesh":
                                    var s = n[t.geometry],
                                        o = r[t.material];
                                    s === undefined && console.error("THREE.ObjectLoader: Undefined geometry " + t.geometry), o === undefined && console.error("THREE.ObjectLoader: Undefined material " + t.material), (i = new THREE.Mesh(s, o));
                                    break;
                                default:
                                    i = new THREE.Object3D();
                            }
                            (i.uuid = t.uuid),
                            t.name !== undefined && (i.name = t.name),
                                t.matrix !== undefined
                                    ? (e.fromArray(t.matrix), e.decompose(i.position, i.quaternion, i.scale))
                                    : (t.position !== undefined && i.position.fromArray(t.position), t.rotation !== undefined && i.rotation.fromArray(t.rotation), t.scale !== undefined && i.scale.fromArray(t.scale)),
                            t.visible !== undefined && (i.visible = t.visible),
                            t.userData !== undefined && (i.userData = t.userData);
                            if (t.children !== undefined) for (var u in t.children) i.add(this.parseObject(t.children[u], n, r));
                            return i;
                        };
                    })(),
                }),
                (THREE.SceneLoader = function () {
                    (this.onLoadStart = function () {}),
                        (this.onLoadProgress = function () {}),
                        (this.onLoadComplete = function () {}),
                        (this.callbackSync = function () {}),
                        (this.callbackProgress = function () {}),
                        (this.geometryHandlers = {}),
                        (this.hierarchyHandlers = {}),
                        this.addGeometryHandler("ascii", THREE.JSONLoader);
                }),
                (THREE.SceneLoader.prototype = {
                    constructor: THREE.SceneLoader,
                    load: function (e, t, n, r) {
                        var i = this,
                            s = new THREE.XHRLoader(i.manager);
                        s.setCrossOrigin(this.crossOrigin),
                            s.load(e, function (n) {
                                i.parse(JSON.parse(n), t, e);
                            });
                    },
                    setCrossOrigin: function (e) {
                        this.crossOrigin = e;
                    },
                    addGeometryHandler: function (e, t) {
                        this.geometryHandlers[e] = { loaderClass: t };
                    },
                    addHierarchyHandler: function (e, t) {
                        this.hierarchyHandlers[e] = { loaderClass: t };
                    },
                    parse: function (e, t, n) {
                        function k(e, t) {
                            return t == "relativeToHTML" ? e : i + "/" + e;
                        }
                        function L() {
                            A(b.scene, E.objects);
                        }
                        function A(e, t) {
                            var n, i, a, f, l, c;
                            for (var v in t) {
                                var m = b.objects[v],
                                    g = t[v];
                                if (m === undefined) {
                                    if (g.type && g.type in r.hierarchyHandlers) {
                                        if (g.loading === undefined) {
                                            var y = { type: 1, url: 1, material: 1, position: 1, rotation: 1, scale: 1, visible: 1, children: 1, userData: 1, skin: 1, morph: 1, mirroredLoop: 1, duration: 1 },
                                                S = {};
                                            for (var x in g) x in y || (S[x] = g[x]);
                                            (o = b.materials[g.material]), (g.loading = !0);
                                            var T = r.hierarchyHandlers[g.type].loaderObject;
                                            T.options ? T.load(k(g.url, E.urlBaseType), D(v, e, o, g)) : T.load(k(g.url, E.urlBaseType), D(v, e, o, g), S);
                                        }
                                    } else if (g.geometry !== undefined) {
                                        s = b.geometries[g.geometry];
                                        if (s) {
                                            var N = !1;
                                            (o = b.materials[g.material]),
                                                (N = o instanceof THREE.ShaderMaterial),
                                                (a = g.position),
                                                (f = g.rotation),
                                                (l = g.scale),
                                                (n = g.matrix),
                                                (c = g.quaternion),
                                            g.material || (o = new THREE.MeshFaceMaterial(b.face_materials[g.geometry])),
                                            o instanceof THREE.MeshFaceMaterial && o.materials.length === 0 && (o = new THREE.MeshFaceMaterial(b.face_materials[g.geometry]));
                                            if (o instanceof THREE.MeshFaceMaterial) for (var C = 0; C < o.materials.length; C++) N = N || o.materials[C] instanceof THREE.ShaderMaterial;
                                            N && s.computeTangents(),
                                                g.skin
                                                    ? (m = new THREE.SkinnedMesh(s, o))
                                                    : g.morph
                                                    ? ((m = new THREE.MorphAnimMesh(s, o)),
                                                    g.duration !== undefined && (m.duration = g.duration),
                                                    g.time !== undefined && (m.time = g.time),
                                                    g.mirroredLoop !== undefined && (m.mirroredLoop = g.mirroredLoop),
                                                    o.morphNormals && s.computeMorphNormals())
                                                    : (m = new THREE.Mesh(s, o)),
                                                (m.name = v),
                                                n
                                                    ? ((m.matrixAutoUpdate = !1), m.matrix.set(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9], n[10], n[11], n[12], n[13], n[14], n[15]))
                                                    : (m.position.fromArray(a), c ? m.quaternion.fromArray(c) : m.rotation.fromArray(f), m.scale.fromArray(l)),
                                                (m.visible = g.visible),
                                                (m.castShadow = g.castShadow),
                                                (m.receiveShadow = g.receiveShadow),
                                                e.add(m),
                                                (b.objects[v] = m);
                                        }
                                    } else
                                        g.type === "DirectionalLight" || g.type === "PointLight" || g.type === "AmbientLight"
                                            ? ((p = g.color !== undefined ? g.color : 16777215),
                                                (d = g.intensity !== undefined ? g.intensity : 1),
                                                g.type === "DirectionalLight"
                                                    ? ((a = g.direction), (h = new THREE.DirectionalLight(p, d)), h.position.fromArray(a), g.target && (w.push({ object: h, targetName: g.target }), (h.target = null)))
                                                    : g.type === "PointLight"
                                                    ? ((a = g.position), (i = g.distance), (h = new THREE.PointLight(p, d, i)), h.position.fromArray(a))
                                                    : g.type === "AmbientLight" && (h = new THREE.AmbientLight(p)),
                                                e.add(h),
                                                (h.name = v),
                                                (b.lights[v] = h),
                                                (b.objects[v] = h))
                                            : g.type === "PerspectiveCamera" || g.type === "OrthographicCamera"
                                            ? ((a = g.position),
                                                (f = g.rotation),
                                                (c = g.quaternion),
                                                g.type === "PerspectiveCamera"
                                                    ? (u = new THREE.PerspectiveCamera(g.fov, g.aspect, g.near, g.far))
                                                    : g.type === "OrthographicCamera" && (u = new THREE.OrthographicCamera(g.left, g.right, g.top, g.bottom, g.near, g.far)),
                                                (u.name = v),
                                                u.position.fromArray(a),
                                                c !== undefined ? u.quaternion.fromArray(c) : f !== undefined && u.rotation.fromArray(f),
                                                e.add(u),
                                                (b.cameras[v] = u),
                                                (b.objects[v] = u))
                                            : ((a = g.position),
                                                (f = g.rotation),
                                                (l = g.scale),
                                                (c = g.quaternion),
                                                (m = new THREE.Object3D()),
                                                (m.name = v),
                                                m.position.fromArray(a),
                                                c ? m.quaternion.fromArray(c) : m.rotation.fromArray(f),
                                                m.scale.fromArray(l),
                                                (m.visible = g.visible !== undefined ? g.visible : !1),
                                                e.add(m),
                                                (b.objects[v] = m),
                                                (b.empties[v] = m));
                                    if (m) {
                                        if (g.userData !== undefined)
                                            for (var L in g.userData) {
                                                var O = g.userData[L];
                                                m.userData[L] = O;
                                            }
                                        if (g.groups !== undefined)
                                            for (var C = 0; C < g.groups.length; C++) {
                                                var M = g.groups[C];
                                                b.groups[M] === undefined && (b.groups[M] = []), b.groups[M].push(v);
                                            }
                                    }
                                }
                                m !== undefined && g.children !== undefined && A(m, g.children);
                            }
                        }
                        function O(e, t, n) {
                            (b.geometries[n] = e), (b.face_materials[n] = t), L();
                        }
                        function M(e, t, n, r, i) {
                            var s = i.position,
                                o = i.rotation,
                                u = i.quaternion,
                                a = i.scale;
                            e.position.fromArray(s),
                                u ? e.quaternion.fromArray(u) : e.rotation.fromArray(o),
                                e.scale.fromArray(a),
                            r &&
                            e.traverse(function (e) {
                                e.material = r;
                            });
                            var f = i.visible !== undefined ? i.visible : !0;
                            e.traverse(function (e) {
                                e.visible = f;
                            }),
                                n.add(e),
                                (e.name = t),
                                (b.objects[t] = e),
                                L();
                        }
                        function _(e) {
                            return function (t, n) {
                                (t.name = e), O(t, n, e), (v -= 1), r.onLoadComplete(), H();
                            };
                        }
                        function D(e, t, n, i) {
                            return function (s) {
                                var o;
                                s.content ? (o = s.content) : s.dae ? (o = s.scene) : (o = s), M(o, e, t, n, i), (v -= 1), r.onLoadComplete(), H();
                            };
                        }
                        function P(e) {
                            return function (t, n) {
                                (t.name = e), (b.geometries[e] = t), (b.face_materials[e] = n);
                            };
                        }
                        function H() {
                            var e = { totalModels: g, totalTextures: y, loadedModels: g - v, loadedTextures: y - m };
                            r.callbackProgress(e, b), r.onLoadProgress(), v === 0 && m === 0 && (B(), t(b));
                        }
                        function B() {
                            for (var e = 0; e < w.length; e++) {
                                var t = w[e],
                                    n = b.objects[t.targetName];
                                n ? (t.object.target = n) : ((t.object.target = new THREE.Object3D()), b.scene.add(t.object.target)), (t.object.target.userData.targetInverse = t.object);
                            }
                        }
                        function I(e, t) {
                            t(e);
                            if (e.children !== undefined) for (var n in e.children) I(e.children[n], t);
                        }
                        var r = this,
                            i = THREE.Loader.prototype.extractUrlBase(n),
                            s,
                            o,
                            u,
                            a,
                            f,
                            l,
                            c,
                            h,
                            p,
                            d,
                            v,
                            m,
                            g,
                            y,
                            b,
                            w = [],
                            E = e;
                        for (var S in this.geometryHandlers) {
                            var x = this.geometryHandlers[S].loaderClass;
                            this.geometryHandlers[S].loaderObject = new x();
                        }
                        for (var S in this.hierarchyHandlers) {
                            var x = this.hierarchyHandlers[S].loaderClass;
                            this.hierarchyHandlers[S].loaderObject = new x();
                        }
                        (v = 0), (m = 0), (b = { scene: new THREE.Scene(), geometries: {}, face_materials: {}, materials: {}, textures: {}, objects: {}, cameras: {}, lights: {}, fogs: {}, empties: {}, groups: {} });
                        if (E.transform) {
                            var T = E.transform.position,
                                N = E.transform.rotation,
                                C = E.transform.scale;
                            T && b.scene.position.fromArray(T), N && b.scene.rotation.fromArray(N), C && b.scene.scale.fromArray(C);
                            if (T || N || C) b.scene.updateMatrix(), b.scene.updateMatrixWorld();
                        }
                        var j = function (e) {
                                (m -= e), H(), r.onLoadComplete();
                            },
                            F = function (e) {
                                return function () {
                                    j(e);
                                };
                            },
                            q,
                            R;
                        for (q in E.fogs) (R = E.fogs[q]), R.type === "linear" ? (a = new THREE.Fog(0, R.near, R.far)) : R.type === "exp2" && (a = new THREE.FogExp2(0, R.density)), (c = R.color), a.color.setRGB(c[0], c[1], c[2]), (b.fogs[q] = a);
                        var U, z;
                        for (U in E.geometries) (z = E.geometries[U]), z.type in this.geometryHandlers && ((v += 1), r.onLoadStart());
                        for (var W in E.objects)
                            I(E.objects[W], function (e) {
                                e.type && e.type in r.hierarchyHandlers && ((v += 1), r.onLoadStart());
                            });
                        g = v;
                        for (U in E.geometries) {
                            z = E.geometries[U];
                            if (z.type === "cube") (s = new THREE.CubeGeometry(z.width, z.height, z.depth, z.widthSegments, z.heightSegments, z.depthSegments)), (s.name = U), (b.geometries[U] = s);
                            else if (z.type === "plane") (s = new THREE.PlaneGeometry(z.width, z.height, z.widthSegments, z.heightSegments)), (s.name = U), (b.geometries[U] = s);
                            else if (z.type === "sphere") (s = new THREE.SphereGeometry(z.radius, z.widthSegments, z.heightSegments)), (s.name = U), (b.geometries[U] = s);
                            else if (z.type === "cylinder") (s = new THREE.CylinderGeometry(z.topRad, z.botRad, z.height, z.radSegs, z.heightSegs)), (s.name = U), (b.geometries[U] = s);
                            else if (z.type === "torus") (s = new THREE.TorusGeometry(z.radius, z.tube, z.segmentsR, z.segmentsT)), (s.name = U), (b.geometries[U] = s);
                            else if (z.type === "icosahedron") (s = new THREE.IcosahedronGeometry(z.radius, z.subdivisions)), (s.name = U), (b.geometries[U] = s);
                            else if (z.type in this.geometryHandlers) {
                                var X = {};
                                for (var V in z) V !== "type" && V !== "url" && (X[V] = z[V]);
                                var $ = this.geometryHandlers[z.type].loaderObject;
                                $.load(k(z.url, E.urlBaseType), _(U), X);
                            } else if (z.type === "embedded") {
                                var J = E.embeds[z.id],
                                    K = "";
                                J.metadata = E.metadata;
                                if (J) {
                                    var Q = this.geometryHandlers.ascii.loaderObject,
                                        G = Q.parse(J, K);
                                    P(U)(G.geometry, G.materials);
                                }
                            }
                        }
                        var Y, Z;
                        for (Y in E.textures) {
                            Z = E.textures[Y];
                            if (Z.url instanceof Array) {
                                m += Z.url.length;
                                for (var et = 0; et < Z.url.length; et++) r.onLoadStart();
                            } else (m += 1), r.onLoadStart();
                        }
                        y = m;
                        for (Y in E.textures) {
                            (Z = E.textures[Y]), Z.mapping !== undefined && THREE[Z.mapping] !== undefined && (Z.mapping = new THREE[Z.mapping]());
                            if (Z.url instanceof Array) {
                                var tt = Z.url.length,
                                    nt = [];
                                for (var rt = 0; rt < tt; rt++) nt[rt] = k(Z.url[rt], E.urlBaseType);
                                var it = /\.dds$/i.test(nt[0]);
                                it ? (f = THREE.ImageUtils.loadCompressedTextureCube(nt, Z.mapping, F(tt))) : (f = THREE.ImageUtils.loadTextureCube(nt, Z.mapping, F(tt)));
                            } else {
                                var it = /\.dds$/i.test(Z.url),
                                    st = k(Z.url, E.urlBaseType),
                                    ot = F(1);
                                it ? (f = THREE.ImageUtils.loadCompressedTexture(st, Z.mapping, ot)) : (f = THREE.ImageUtils.loadTexture(st, Z.mapping, ot)),
                                THREE[Z.minFilter] !== undefined && (f.minFilter = THREE[Z.minFilter]),
                                THREE[Z.magFilter] !== undefined && (f.magFilter = THREE[Z.magFilter]),
                                Z.anisotropy && (f.anisotropy = Z.anisotropy),
                                Z.repeat && (f.repeat.set(Z.repeat[0], Z.repeat[1]), Z.repeat[0] !== 1 && (f.wrapS = THREE.RepeatWrapping), Z.repeat[1] !== 1 && (f.wrapT = THREE.RepeatWrapping)),
                                Z.offset && f.offset.set(Z.offset[0], Z.offset[1]);
                                if (Z.wrap) {
                                    var ut = { repeat: THREE.RepeatWrapping, mirror: THREE.MirroredRepeatWrapping };
                                    ut[Z.wrap[0]] !== undefined && (f.wrapS = ut[Z.wrap[0]]), ut[Z.wrap[1]] !== undefined && (f.wrapT = ut[Z.wrap[1]]);
                                }
                            }
                            b.textures[Y] = f;
                        }
                        var at, ft, lt;
                        for (at in E.materials) {
                            ft = E.materials[at];
                            for (lt in ft.parameters)
                                if (lt === "envMap" || lt === "map" || lt === "lightMap" || lt === "bumpMap") ft.parameters[lt] = b.textures[ft.parameters[lt]];
                                else if (lt === "shading") ft.parameters[lt] = ft.parameters[lt] === "flat" ? THREE.FlatShading : THREE.SmoothShading;
                                else if (lt === "side") ft.parameters[lt] == "double" ? (ft.parameters[lt] = THREE.DoubleSide) : ft.parameters[lt] == "back" ? (ft.parameters[lt] = THREE.BackSide) : (ft.parameters[lt] = THREE.FrontSide);
                                else if (lt === "blending") ft.parameters[lt] = ft.parameters[lt] in THREE ? THREE[ft.parameters[lt]] : THREE.NormalBlending;
                                else if (lt === "combine") ft.parameters[lt] = ft.parameters[lt] in THREE ? THREE[ft.parameters[lt]] : THREE.MultiplyOperation;
                                else if (lt === "vertexColors") ft.parameters[lt] == "face" ? (ft.parameters[lt] = THREE.FaceColors) : ft.parameters[lt] && (ft.parameters[lt] = THREE.VertexColors);
                                else if (lt === "wrapRGB") {
                                    var ct = ft.parameters[lt];
                                    ft.parameters[lt] = new THREE.Vector3(ct[0], ct[1], ct[2]);
                                }
                            ft.parameters.opacity !== undefined && ft.parameters.opacity < 1 && (ft.parameters.transparent = !0);
                            if (ft.parameters.normalMap) {
                                var ht = THREE.ShaderLib.normalmap,
                                    pt = THREE.UniformsUtils.clone(ht.uniforms),
                                    dt = ft.parameters.color,
                                    vt = ft.parameters.specular,
                                    mt = ft.parameters.ambient,
                                    gt = ft.parameters.shininess;
                                (pt.tNormal.value = b.textures[ft.parameters.normalMap]),
                                ft.parameters.normalScale && pt.uNormalScale.value.set(ft.parameters.normalScale[0], ft.parameters.normalScale[1]),
                                ft.parameters.map && ((pt.tDiffuse.value = ft.parameters.map), (pt.enableDiffuse.value = !0)),
                                ft.parameters.envMap && ((pt.tCube.value = ft.parameters.envMap), (pt.enableReflection.value = !0), (pt.uReflectivity.value = ft.parameters.reflectivity)),
                                ft.parameters.lightMap && ((pt.tAO.value = ft.parameters.lightMap), (pt.enableAO.value = !0)),
                                ft.parameters.specularMap && ((pt.tSpecular.value = b.textures[ft.parameters.specularMap]), (pt.enableSpecular.value = !0)),
                                ft.parameters.displacementMap &&
                                ((pt.tDisplacement.value = b.textures[ft.parameters.displacementMap]),
                                    (pt.enableDisplacement.value = !0),
                                    (pt.uDisplacementBias.value = ft.parameters.displacementBias),
                                    (pt.uDisplacementScale.value = ft.parameters.displacementScale)),
                                    pt.uDiffuseColor.value.setHex(dt),
                                    pt.uSpecularColor.value.setHex(vt),
                                    pt.uAmbientColor.value.setHex(mt),
                                    (pt.uShininess.value = gt),
                                ft.parameters.opacity && (pt.uOpacity.value = ft.parameters.opacity);
                                var yt = { fragmentShader: ht.fragmentShader, vertexShader: ht.vertexShader, uniforms: pt, lights: !0, fog: !0 };
                                o = new THREE.ShaderMaterial(yt);
                            } else o = new THREE[ft.type](ft.parameters);
                            (o.name = at), (b.materials[at] = o);
                        }
                        for (at in E.materials) {
                            ft = E.materials[at];
                            if (ft.parameters.materials) {
                                var bt = [];
                                for (var rt = 0; rt < ft.parameters.materials.length; rt++) {
                                    var wt = ft.parameters.materials[rt];
                                    bt.push(b.materials[wt]);
                                }
                                b.materials[at].materials = bt;
                            }
                        }
                        L(), b.cameras && E.defaults.camera && (b.currentCamera = b.cameras[E.defaults.camera]), b.fogs && E.defaults.fog && (b.scene.fog = b.fogs[E.defaults.fog]), r.callbackSync(b), H();
                    },
                }),
                (THREE.TextureLoader = function (e) {
                    this.manager = e !== undefined ? e : THREE.DefaultLoadingManager;
                }),
                (THREE.TextureLoader.prototype = {
                    constructor: THREE.TextureLoader,
                    load: function (e, t, n, r) {
                        var i = this,
                            s = new THREE.ImageLoader(i.manager);
                        s.setCrossOrigin(this.crossOrigin),
                            s.load(e, function (e) {
                                var n = new THREE.Texture(e);
                                (n.needsUpdate = !0), t !== undefined && t(n);
                            });
                    },
                    setCrossOrigin: function (e) {
                        this.crossOrigin = e;
                    },
                }),
                (THREE.Material = function () {
                    (this.id = THREE.MaterialIdCount++),
                        (this.uuid = THREE.Math.generateUUID()),
                        (this.name = ""),
                        (this.side = THREE.FrontSide),
                        (this.opacity = 1),
                        (this.transparent = !1),
                        (this.blending = THREE.NormalBlending),
                        (this.blendSrc = THREE.SrcAlphaFactor),
                        (this.blendDst = THREE.OneMinusSrcAlphaFactor),
                        (this.blendEquation = THREE.AddEquation),
                        (this.depthTest = !0),
                        (this.depthWrite = !0),
                        (this.polygonOffset = !1),
                        (this.polygonOffsetFactor = 0),
                        (this.polygonOffsetUnits = 0),
                        (this.alphaTest = 0),
                        (this.overdraw = 0),
                        (this.visible = !0),
                        (this.needsUpdate = !0);
                }),
                (THREE.Material.prototype = {
                    constructor: THREE.Material,
                    setValues: function (e) {
                        if (e === undefined) return;
                        for (var t in e) {
                            var n = e[t];
                            if (n === undefined) {
                                console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                                continue;
                            }
                            if (t in this) {
                                var r = this[t];
                                r instanceof THREE.Color ? r.set(n) : r instanceof THREE.Vector3 && n instanceof THREE.Vector3 ? r.copy(n) : t == "overdraw" ? (this[t] = Number(n)) : (this[t] = n);
                            }
                        }
                    },
                    clone: function (e) {
                        return (
                            e === undefined && (e = new THREE.Material()),
                                (e.name = this.name),
                                (e.side = this.side),
                                (e.opacity = this.opacity),
                                (e.transparent = this.transparent),
                                (e.blending = this.blending),
                                (e.blendSrc = this.blendSrc),
                                (e.blendDst = this.blendDst),
                                (e.blendEquation = this.blendEquation),
                                (e.depthTest = this.depthTest),
                                (e.depthWrite = this.depthWrite),
                                (e.polygonOffset = this.polygonOffset),
                                (e.polygonOffsetFactor = this.polygonOffsetFactor),
                                (e.polygonOffsetUnits = this.polygonOffsetUnits),
                                (e.alphaTest = this.alphaTest),
                                (e.overdraw = this.overdraw),
                                (e.visible = this.visible),
                                e
                        );
                    },
                    dispose: function () {
                        this.dispatchEvent({ type: "dispose" });
                    },
                }),
                THREE.EventDispatcher.prototype.apply(THREE.Material.prototype),
                (THREE.MaterialIdCount = 0),
                (THREE.LineBasicMaterial = function (e) {
                    THREE.Material.call(this), (this.color = new THREE.Color(16777215)), (this.linewidth = 1), (this.linecap = "round"), (this.linejoin = "round"), (this.vertexColors = !1), (this.fog = !0), this.setValues(e);
                }),
                (THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype)),
                (THREE.LineBasicMaterial.prototype.clone = function () {
                    var e = new THREE.LineBasicMaterial();
                    return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), (e.linewidth = this.linewidth), (e.linecap = this.linecap), (e.linejoin = this.linejoin), (e.vertexColors = this.vertexColors), (e.fog = this.fog), e;
                }),
                (THREE.LineDashedMaterial = function (e) {
                    THREE.Material.call(this), (this.color = new THREE.Color(16777215)), (this.linewidth = 1), (this.scale = 1), (this.dashSize = 3), (this.gapSize = 1), (this.vertexColors = !1), (this.fog = !0), this.setValues(e);
                }),
                (THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype)),
                (THREE.LineDashedMaterial.prototype.clone = function () {
                    var e = new THREE.LineDashedMaterial();
                    return (
                        THREE.Material.prototype.clone.call(this, e),
                            e.color.copy(this.color),
                            (e.linewidth = this.linewidth),
                            (e.scale = this.scale),
                            (e.dashSize = this.dashSize),
                            (e.gapSize = this.gapSize),
                            (e.vertexColors = this.vertexColors),
                            (e.fog = this.fog),
                            e
                    );
                }),
                (THREE.MeshBasicMaterial = function (e) {
                    THREE.Material.call(this),
                        (this.color = new THREE.Color(16777215)),
                        (this.map = null),
                        (this.lightMap = null),
                        (this.specularMap = null),
                        (this.envMap = null),
                        (this.combine = THREE.MultiplyOperation),
                        (this.reflectivity = 1),
                        (this.refractionRatio = 0.98),
                        (this.fog = !0),
                        (this.shading = THREE.SmoothShading),
                        (this.wireframe = !1),
                        (this.wireframeLinewidth = 1),
                        (this.wireframeLinecap = "round"),
                        (this.wireframeLinejoin = "round"),
                        (this.vertexColors = THREE.NoColors),
                        (this.skinning = !1),
                        (this.morphTargets = !1),
                        this.setValues(e);
                }),
                (THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype)),
                (THREE.MeshBasicMaterial.prototype.clone = function () {
                    var e = new THREE.MeshBasicMaterial();
                    return (
                        THREE.Material.prototype.clone.call(this, e),
                            e.color.copy(this.color),
                            (e.map = this.map),
                            (e.lightMap = this.lightMap),
                            (e.specularMap = this.specularMap),
                            (e.envMap = this.envMap),
                            (e.combine = this.combine),
                            (e.reflectivity = this.reflectivity),
                            (e.refractionRatio = this.refractionRatio),
                            (e.fog = this.fog),
                            (e.shading = this.shading),
                            (e.wireframe = this.wireframe),
                            (e.wireframeLinewidth = this.wireframeLinewidth),
                            (e.wireframeLinecap = this.wireframeLinecap),
                            (e.wireframeLinejoin = this.wireframeLinejoin),
                            (e.vertexColors = this.vertexColors),
                            (e.skinning = this.skinning),
                            (e.morphTargets = this.morphTargets),
                            e
                    );
                }),
                (THREE.MeshLambertMaterial = function (e) {
                    THREE.Material.call(this),
                        (this.color = new THREE.Color(16777215)),
                        (this.ambient = new THREE.Color(16777215)),
                        (this.emissive = new THREE.Color(0)),
                        (this.wrapAround = !1),
                        (this.wrapRGB = new THREE.Vector3(1, 1, 1)),
                        (this.map = null),
                        (this.lightMap = null),
                        (this.specularMap = null),
                        (this.envMap = null),
                        (this.combine = THREE.MultiplyOperation),
                        (this.reflectivity = 1),
                        (this.refractionRatio = 0.98),
                        (this.fog = !0),
                        (this.shading = THREE.SmoothShading),
                        (this.wireframe = !1),
                        (this.wireframeLinewidth = 1),
                        (this.wireframeLinecap = "round"),
                        (this.wireframeLinejoin = "round"),
                        (this.vertexColors = THREE.NoColors),
                        (this.skinning = !1),
                        (this.morphTargets = !1),
                        (this.morphNormals = !1),
                        this.setValues(e);
                }),
                (THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype)),
                (THREE.MeshLambertMaterial.prototype.clone = function () {
                    var e = new THREE.MeshLambertMaterial();
                    return (
                        THREE.Material.prototype.clone.call(this, e),
                            e.color.copy(this.color),
                            e.ambient.copy(this.ambient),
                            e.emissive.copy(this.emissive),
                            (e.wrapAround = this.wrapAround),
                            e.wrapRGB.copy(this.wrapRGB),
                            (e.map = this.map),
                            (e.lightMap = this.lightMap),
                            (e.specularMap = this.specularMap),
                            (e.envMap = this.envMap),
                            (e.combine = this.combine),
                            (e.reflectivity = this.reflectivity),
                            (e.refractionRatio = this.refractionRatio),
                            (e.fog = this.fog),
                            (e.shading = this.shading),
                            (e.wireframe = this.wireframe),
                            (e.wireframeLinewidth = this.wireframeLinewidth),
                            (e.wireframeLinecap = this.wireframeLinecap),
                            (e.wireframeLinejoin = this.wireframeLinejoin),
                            (e.vertexColors = this.vertexColors),
                            (e.skinning = this.skinning),
                            (e.morphTargets = this.morphTargets),
                            (e.morphNormals = this.morphNormals),
                            e
                    );
                }),
                (THREE.MeshPhongMaterial = function (e) {
                    THREE.Material.call(this),
                        (this.color = new THREE.Color(16777215)),
                        (this.ambient = new THREE.Color(16777215)),
                        (this.emissive = new THREE.Color(0)),
                        (this.specular = new THREE.Color(1118481)),
                        (this.shininess = 30),
                        (this.metal = !1),
                        (this.perPixel = !0),
                        (this.wrapAround = !1),
                        (this.wrapRGB = new THREE.Vector3(1, 1, 1)),
                        (this.map = null),
                        (this.lightMap = null),
                        (this.bumpMap = null),
                        (this.bumpScale = 1),
                        (this.normalMap = null),
                        (this.normalScale = new THREE.Vector2(1, 1)),
                        (this.specularMap = null),
                        (this.envMap = null),
                        (this.combine = THREE.MultiplyOperation),
                        (this.reflectivity = 1),
                        (this.refractionRatio = 0.98),
                        (this.fog = !0),
                        (this.shading = THREE.SmoothShading),
                        (this.wireframe = !1),
                        (this.wireframeLinewidth = 1),
                        (this.wireframeLinecap = "round"),
                        (this.wireframeLinejoin = "round"),
                        (this.vertexColors = THREE.NoColors),
                        (this.skinning = !1),
                        (this.morphTargets = !1),
                        (this.morphNormals = !1),
                        this.setValues(e);
                }),
                (THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype)),
                (THREE.MeshPhongMaterial.prototype.clone = function () {
                    var e = new THREE.MeshPhongMaterial();
                    return (
                        THREE.Material.prototype.clone.call(this, e),
                            e.color.copy(this.color),
                            e.ambient.copy(this.ambient),
                            e.emissive.copy(this.emissive),
                            e.specular.copy(this.specular),
                            (e.shininess = this.shininess),
                            (e.metal = this.metal),
                            (e.perPixel = this.perPixel),
                            (e.wrapAround = this.wrapAround),
                            e.wrapRGB.copy(this.wrapRGB),
                            (e.map = this.map),
                            (e.lightMap = this.lightMap),
                            (e.bumpMap = this.bumpMap),
                            (e.bumpScale = this.bumpScale),
                            (e.normalMap = this.normalMap),
                            e.normalScale.copy(this.normalScale),
                            (e.specularMap = this.specularMap),
                            (e.envMap = this.envMap),
                            (e.combine = this.combine),
                            (e.reflectivity = this.reflectivity),
                            (e.refractionRatio = this.refractionRatio),
                            (e.fog = this.fog),
                            (e.shading = this.shading),
                            (e.wireframe = this.wireframe),
                            (e.wireframeLinewidth = this.wireframeLinewidth),
                            (e.wireframeLinecap = this.wireframeLinecap),
                            (e.wireframeLinejoin = this.wireframeLinejoin),
                            (e.vertexColors = this.vertexColors),
                            (e.skinning = this.skinning),
                            (e.morphTargets = this.morphTargets),
                            (e.morphNormals = this.morphNormals),
                            e
                    );
                }),
                (THREE.MeshDepthMaterial = function (e) {
                    THREE.Material.call(this), (this.wireframe = !1), (this.wireframeLinewidth = 1), this.setValues(e);
                }),
                (THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype)),
                (THREE.MeshDepthMaterial.prototype.clone = function () {
                    var e = new THREE.MeshDepthMaterial();
                    return THREE.Material.prototype.clone.call(this, e), (e.wireframe = this.wireframe), (e.wireframeLinewidth = this.wireframeLinewidth), e;
                }),
                (THREE.MeshNormalMaterial = function (e) {
                    THREE.Material.call(this, e), (this.shading = THREE.FlatShading), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.morphTargets = !1), this.setValues(e);
                }),
                (THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype)),
                (THREE.MeshNormalMaterial.prototype.clone = function () {
                    var e = new THREE.MeshNormalMaterial();
                    return THREE.Material.prototype.clone.call(this, e), (e.shading = this.shading), (e.wireframe = this.wireframe), (e.wireframeLinewidth = this.wireframeLinewidth), e;
                }),
                (THREE.MeshFaceMaterial = function (e) {
                    this.materials = e instanceof Array ? e : [];
                }),
                (THREE.MeshFaceMaterial.prototype.clone = function () {
                    var e = new THREE.MeshFaceMaterial();
                    for (var t = 0; t < this.materials.length; t++) e.materials.push(this.materials[t].clone());
                    return e;
                }),
                (THREE.ParticleBasicMaterial = function (e) {
                    THREE.Material.call(this), (this.color = new THREE.Color(16777215)), (this.map = null), (this.size = 1), (this.sizeAttenuation = !0), (this.vertexColors = !1), (this.fog = !0), this.setValues(e);
                }),
                (THREE.ParticleBasicMaterial.prototype = Object.create(THREE.Material.prototype)),
                (THREE.ParticleBasicMaterial.prototype.clone = function () {
                    var e = new THREE.ParticleBasicMaterial();
                    return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), (e.map = this.map), (e.size = this.size), (e.sizeAttenuation = this.sizeAttenuation), (e.vertexColors = this.vertexColors), (e.fog = this.fog), e;
                }),
                (THREE.ParticleCanvasMaterial = function (e) {
                    THREE.Material.call(this), (this.color = new THREE.Color(16777215)), (this.program = function (e, t) {}), this.setValues(e);
                }),
                (THREE.ParticleCanvasMaterial.prototype = Object.create(THREE.Material.prototype)),
                (THREE.ParticleCanvasMaterial.prototype.clone = function () {
                    var e = new THREE.ParticleCanvasMaterial();
                    return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), (e.program = this.program), e;
                }),
                (THREE.ShaderMaterial = function (e) {
                    THREE.Material.call(this),
                        (this.fragmentShader = "void main() {}"),
                        (this.vertexShader = "void main() {}"),
                        (this.uniforms = {}),
                        (this.defines = {}),
                        (this.attributes = null),
                        (this.shading = THREE.SmoothShading),
                        (this.linewidth = 1),
                        (this.wireframe = !1),
                        (this.wireframeLinewidth = 1),
                        (this.fog = !1),
                        (this.lights = !1),
                        (this.vertexColors = THREE.NoColors),
                        (this.skinning = !1),
                        (this.morphTargets = !1),
                        (this.morphNormals = !1),
                        (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
                        (this.index0AttributeName = "position"),
                        this.setValues(e);
                }),
                (THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype)),
                (THREE.ShaderMaterial.prototype.clone = function () {
                    var e = new THREE.ShaderMaterial();
                    return (
                        THREE.Material.prototype.clone.call(this, e),
                            (e.fragmentShader = this.fragmentShader),
                            (e.vertexShader = this.vertexShader),
                            (e.uniforms = THREE.UniformsUtils.clone(this.uniforms)),
                            (e.attributes = this.attributes),
                            (e.defines = this.defines),
                            (e.shading = this.shading),
                            (e.wireframe = this.wireframe),
                            (e.wireframeLinewidth = this.wireframeLinewidth),
                            (e.fog = this.fog),
                            (e.lights = this.lights),
                            (e.vertexColors = this.vertexColors),
                            (e.skinning = this.skinning),
                            (e.morphTargets = this.morphTargets),
                            (e.morphNormals = this.morphNormals),
                            e
                    );
                }),
                (THREE.SpriteMaterial = function (e) {
                    THREE.Material.call(this),
                        (this.color = new THREE.Color(16777215)),
                        (this.map = new THREE.Texture()),
                        (this.useScreenCoordinates = !0),
                        (this.depthTest = !this.useScreenCoordinates),
                        (this.sizeAttenuation = !this.useScreenCoordinates),
                        (this.scaleByViewport = !this.sizeAttenuation),
                        (this.alignment = THREE.SpriteAlignment.center.clone()),
                        (this.fog = !1),
                        (this.uvOffset = new THREE.Vector2(0, 0)),
                        (this.uvScale = new THREE.Vector2(1, 1)),
                        this.setValues(e),
                        (e = e || {}),
                    e.depthTest === undefined && (this.depthTest = !this.useScreenCoordinates),
                    e.sizeAttenuation === undefined && (this.sizeAttenuation = !this.useScreenCoordinates),
                    e.scaleByViewport === undefined && (this.scaleByViewport = !this.sizeAttenuation);
                }),
                (THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype)),
                (THREE.SpriteMaterial.prototype.clone = function () {
                    var e = new THREE.SpriteMaterial();
                    return (
                        THREE.Material.prototype.clone.call(this, e),
                            e.color.copy(this.color),
                            (e.map = this.map),
                            (e.useScreenCoordinates = this.useScreenCoordinates),
                            (e.sizeAttenuation = this.sizeAttenuation),
                            (e.scaleByViewport = this.scaleByViewport),
                            e.alignment.copy(this.alignment),
                            e.uvOffset.copy(this.uvOffset),
                            e.uvScale.copy(this.uvScale),
                            (e.fog = this.fog),
                            e
                    );
                }),
                (THREE.SpriteAlignment = {}),
                (THREE.SpriteAlignment.topLeft = new THREE.Vector2(1, -1)),
                (THREE.SpriteAlignment.topCenter = new THREE.Vector2(0, -1)),
                (THREE.SpriteAlignment.topRight = new THREE.Vector2(-1, -1)),
                (THREE.SpriteAlignment.centerLeft = new THREE.Vector2(1, 0)),
                (THREE.SpriteAlignment.center = new THREE.Vector2(0, 0)),
                (THREE.SpriteAlignment.centerRight = new THREE.Vector2(-1, 0)),
                (THREE.SpriteAlignment.bottomLeft = new THREE.Vector2(1, 1)),
                (THREE.SpriteAlignment.bottomCenter = new THREE.Vector2(0, 1)),
                (THREE.SpriteAlignment.bottomRight = new THREE.Vector2(-1, 1)),
                (THREE.Texture = function (e, t, n, r, i, s, o, u, a) {
                    (this.id = THREE.TextureIdCount++),
                        (this.uuid = THREE.Math.generateUUID()),
                        (this.name = ""),
                        (this.image = e),
                        (this.mipmaps = []),
                        (this.mapping = t !== undefined ? t : new THREE.UVMapping()),
                        (this.wrapS = n !== undefined ? n : THREE.ClampToEdgeWrapping),
                        (this.wrapT = r !== undefined ? r : THREE.ClampToEdgeWrapping),
                        (this.magFilter = i !== undefined ? i : THREE.LinearFilter),
                        (this.minFilter = s !== undefined ? s : THREE.LinearMipMapLinearFilter),
                        (this.anisotropy = a !== undefined ? a : 1),
                        (this.format = o !== undefined ? o : THREE.RGBAFormat),
                        (this.type = u !== undefined ? u : THREE.UnsignedByteType),
                        (this.offset = new THREE.Vector2(0, 0)),
                        (this.repeat = new THREE.Vector2(1, 1)),
                        (this.generateMipmaps = !0),
                        (this.premultiplyAlpha = !1),
                        (this.flipY = !0),
                        (this.unpackAlignment = 4),
                        (this.needsUpdate = !1),
                        (this.onUpdate = null);
                }),
                (THREE.Texture.prototype = {
                    constructor: THREE.Texture,
                    clone: function (e) {
                        return (
                            e === undefined && (e = new THREE.Texture()),
                                (e.image = this.image),
                                (e.mipmaps = this.mipmaps.slice(0)),
                                (e.mapping = this.mapping),
                                (e.wrapS = this.wrapS),
                                (e.wrapT = this.wrapT),
                                (e.magFilter = this.magFilter),
                                (e.minFilter = this.minFilter),
                                (e.anisotropy = this.anisotropy),
                                (e.format = this.format),
                                (e.type = this.type),
                                e.offset.copy(this.offset),
                                e.repeat.copy(this.repeat),
                                (e.generateMipmaps = this.generateMipmaps),
                                (e.premultiplyAlpha = this.premultiplyAlpha),
                                (e.flipY = this.flipY),
                                (e.unpackAlignment = this.unpackAlignment),
                                e
                        );
                    },
                    dispose: function () {
                        this.dispatchEvent({ type: "dispose" });
                    },
                }),
                THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype),
                (THREE.TextureIdCount = 0),
                (THREE.CompressedTexture = function (e, t, n, r, i, s, o, u, a, f, l) {
                    THREE.Texture.call(this, null, s, o, u, a, f, r, i, l), (this.image = { width: t, height: n }), (this.mipmaps = e), (this.generateMipmaps = !1);
                }),
                (THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype)),
                (THREE.CompressedTexture.prototype.clone = function () {
                    var e = new THREE.CompressedTexture();
                    return THREE.Texture.prototype.clone.call(this, e), e;
                }),
                (THREE.DataTexture = function (e, t, n, r, i, s, o, u, a, f, l) {
                    THREE.Texture.call(this, null, s, o, u, a, f, r, i, l), (this.image = { data: e, width: t, height: n });
                }),
                (THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype)),
                (THREE.DataTexture.prototype.clone = function () {
                    var e = new THREE.DataTexture();
                    return THREE.Texture.prototype.clone.call(this, e), e;
                }),
                (THREE.Particle = function (e) {
                    THREE.Object3D.call(this), (this.material = e);
                }),
                (THREE.Particle.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.Particle.prototype.clone = function (e) {
                    return e === undefined && (e = new THREE.Particle(this.material)), THREE.Object3D.prototype.clone.call(this, e), e;
                }),
                (THREE.ParticleSystem = function (e, t) {
                    THREE.Object3D.call(this),
                        (this.geometry = e !== undefined ? e : new THREE.Geometry()),
                        (this.material = t !== undefined ? t : new THREE.ParticleBasicMaterial({ color: Math.random() * 16777215 })),
                        (this.sortParticles = !1),
                        (this.frustumCulled = !1);
                }),
                (THREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.ParticleSystem.prototype.clone = function (e) {
                    return e === undefined && (e = new THREE.ParticleSystem(this.geometry, this.material)), (e.sortParticles = this.sortParticles), THREE.Object3D.prototype.clone.call(this, e), e;
                }),
                (THREE.Line = function (e, t, n) {
                    THREE.Object3D.call(this),
                        (this.geometry = e !== undefined ? e : new THREE.Geometry()),
                        (this.material = t !== undefined ? t : new THREE.LineBasicMaterial({ color: Math.random() * 16777215 })),
                        (this.type = n !== undefined ? n : THREE.LineStrip);
                }),
                (THREE.LineStrip = 0),
                (THREE.LinePieces = 1),
                (THREE.Line.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.Line.prototype.clone = function (e) {
                    return e === undefined && (e = new THREE.Line(this.geometry, this.material, this.type)), THREE.Object3D.prototype.clone.call(this, e), e;
                }),
                (THREE.Mesh = function (e, t) {
                    THREE.Object3D.call(this), (this.geometry = e !== undefined ? e : new THREE.Geometry()), (this.material = t !== undefined ? t : new THREE.MeshBasicMaterial({ color: Math.random() * 16777215 })), this.updateMorphTargets();
                }),
                (THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.Mesh.prototype.updateMorphTargets = function () {
                    if (this.geometry.morphTargets.length > 0) {
                        (this.morphTargetBase = -1), (this.morphTargetForcedOrder = []), (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                        for (var e = 0, t = this.geometry.morphTargets.length; e < t; e++) this.morphTargetInfluences.push(0), (this.morphTargetDictionary[this.geometry.morphTargets[e].name] = e);
                    }
                }),
                (THREE.Mesh.prototype.getMorphTargetIndexByName = function (e) {
                    return this.morphTargetDictionary[e] !== undefined ? this.morphTargetDictionary[e] : (console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + e + " does not exist. Returning 0."), 0);
                }),
                (THREE.Mesh.prototype.clone = function (e) {
                    return e === undefined && (e = new THREE.Mesh(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, e), e;
                }),
                (THREE.Bone = function (e) {
                    THREE.Object3D.call(this), (this.skin = e), (this.skinMatrix = new THREE.Matrix4());
                }),
                (THREE.Bone.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.Bone.prototype.update = function (e, t) {
                    this.matrixAutoUpdate && (t |= this.updateMatrix());
                    if (t || this.matrixWorldNeedsUpdate) e ? this.skinMatrix.multiplyMatrices(e, this.matrix) : this.skinMatrix.copy(this.matrix), (this.matrixWorldNeedsUpdate = !1), (t = !0);
                    var n,
                        r,
                        i = this.children.length;
                    for (r = 0; r < i; r++) this.children[r].update(this.skinMatrix, t);
                }),
                (THREE.SkinnedMesh = function (e, t, n) {
                    THREE.Mesh.call(this, e, t), (this.useVertexTexture = n !== undefined ? n : !0), (this.identityMatrix = new THREE.Matrix4()), (this.bones = []), (this.boneMatrices = []);
                    var r, i, s, o, u, a;
                    if (this.geometry && this.geometry.bones !== undefined) {
                        for (r = 0; r < this.geometry.bones.length; r++)
                            (s = this.geometry.bones[r]),
                                (o = s.pos),
                                (u = s.rotq),
                                (a = s.scl),
                                (i = this.addBone()),
                                (i.name = s.name),
                                i.position.set(o[0], o[1], o[2]),
                                i.quaternion.set(u[0], u[1], u[2], u[3]),
                                a !== undefined ? i.scale.set(a[0], a[1], a[2]) : i.scale.set(1, 1, 1);
                        for (r = 0; r < this.bones.length; r++) (s = this.geometry.bones[r]), (i = this.bones[r]), s.parent === -1 ? this.add(i) : this.bones[s.parent].add(i);
                        var f = this.bones.length;
                        if (this.useVertexTexture) {
                            var l;
                            f > 256 ? (l = 64) : f > 64 ? (l = 32) : f > 16 ? (l = 16) : (l = 8),
                                (this.boneTextureWidth = l),
                                (this.boneTextureHeight = l),
                                (this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4)),
                                (this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType)),
                                (this.boneTexture.minFilter = THREE.NearestFilter),
                                (this.boneTexture.magFilter = THREE.NearestFilter),
                                (this.boneTexture.generateMipmaps = !1),
                                (this.boneTexture.flipY = !1);
                        } else this.boneMatrices = new Float32Array(16 * f);
                        this.pose();
                    }
                }),
                (THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype)),
                (THREE.SkinnedMesh.prototype.addBone = function (e) {
                    return e === undefined && (e = new THREE.Bone(this)), this.bones.push(e), e;
                }),
                (THREE.SkinnedMesh.prototype.updateMatrixWorld = (function () {
                    var e = new THREE.Matrix4();
                    return function (t) {
                        this.matrixAutoUpdate && this.updateMatrix();
                        if (this.matrixWorldNeedsUpdate || t) this.parent ? this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) : this.matrixWorld.copy(this.matrix), (this.matrixWorldNeedsUpdate = !1), (t = !0);
                        for (var n = 0, r = this.children.length; n < r; n++) {
                            var i = this.children[n];
                            i instanceof THREE.Bone ? i.update(this.identityMatrix, !1) : i.updateMatrixWorld(!0);
                        }
                        if (this.boneInverses == undefined) {
                            this.boneInverses = [];
                            for (var s = 0, o = this.bones.length; s < o; s++) {
                                var u = new THREE.Matrix4();
                                u.getInverse(this.bones[s].skinMatrix), this.boneInverses.push(u);
                            }
                        }
                        for (var s = 0, o = this.bones.length; s < o; s++) e.multiplyMatrices(this.bones[s].skinMatrix, this.boneInverses[s]), e.flattenToArrayOffset(this.boneMatrices, s * 16);
                        this.useVertexTexture && (this.boneTexture.needsUpdate = !0);
                    };
                })()),
                (THREE.SkinnedMesh.prototype.pose = function () {
                    this.updateMatrixWorld(!0), this.normalizeSkinWeights();
                }),
                (THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
                    if (this.geometry instanceof THREE.Geometry)
                        for (var e = 0; e < this.geometry.skinIndices.length; e++) {
                            var t = this.geometry.skinWeights[e],
                                n = 1 / t.lengthManhattan();
                            n !== Infinity ? t.multiplyScalar(n) : t.set(1);
                        }
                }),
                (THREE.SkinnedMesh.prototype.clone = function (e) {
                    return e === undefined && (e = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), THREE.Mesh.prototype.clone.call(this, e), e;
                }),
                (THREE.MorphAnimMesh = function (e, t) {
                    THREE.Mesh.call(this, e, t),
                        (this.duration = 1e3),
                        (this.mirroredLoop = !1),
                        (this.time = 0),
                        (this.lastKeyframe = 0),
                        (this.currentKeyframe = 0),
                        (this.direction = 1),
                        (this.directionBackwards = !1),
                        this.setFrameRange(0, this.geometry.morphTargets.length - 1);
                }),
                (THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype)),
                (THREE.MorphAnimMesh.prototype.setFrameRange = function (e, t) {
                    (this.startKeyframe = e), (this.endKeyframe = t), (this.length = this.endKeyframe - this.startKeyframe + 1);
                }),
                (THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
                    (this.direction = 1), (this.directionBackwards = !1);
                }),
                (THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
                    (this.direction = -1), (this.directionBackwards = !0);
                }),
                (THREE.MorphAnimMesh.prototype.parseAnimations = function () {
                    var e = this.geometry;
                    e.animations || (e.animations = {});
                    var t,
                        n = e.animations,
                        r = /([a-z]+)(\d+)/;
                    for (var i = 0, s = e.morphTargets.length; i < s; i++) {
                        var o = e.morphTargets[i],
                            u = o.name.match(r);
                        if (u && u.length > 1) {
                            var a = u[1],
                                f = u[2];
                            n[a] || (n[a] = { start: Infinity, end: -Infinity });
                            var l = n[a];
                            i < l.start && (l.start = i), i > l.end && (l.end = i), t || (t = a);
                        }
                    }
                    e.firstAnimation = t;
                }),
                (THREE.MorphAnimMesh.prototype.setAnimationLabel = function (e, t, n) {
                    this.geometry.animations || (this.geometry.animations = {}), (this.geometry.animations[e] = { start: t, end: n });
                }),
                (THREE.MorphAnimMesh.prototype.playAnimation = function (e, t) {
                    var n = this.geometry.animations[e];
                    n ? (this.setFrameRange(n.start, n.end), (this.duration = 1e3 * ((n.end - n.start) / t)), (this.time = 0)) : console.warn("animation[" + e + "] undefined");
                }),
                (THREE.MorphAnimMesh.prototype.updateAnimation = function (e) {
                    var t = this.duration / this.length;
                    this.time += this.direction * e;
                    if (this.mirroredLoop) {
                        if (this.time > this.duration || this.time < 0)
                            (this.direction *= -1), this.time > this.duration && ((this.time = this.duration), (this.directionBackwards = !0)), this.time < 0 && ((this.time = 0), (this.directionBackwards = !1));
                    } else (this.time = this.time % this.duration), this.time < 0 && (this.time += this.duration);
                    var n = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / t), 0, this.length - 1);
                    n !== this.currentKeyframe &&
                    ((this.morphTargetInfluences[this.lastKeyframe] = 0), (this.morphTargetInfluences[this.currentKeyframe] = 1), (this.morphTargetInfluences[n] = 0), (this.lastKeyframe = this.currentKeyframe), (this.currentKeyframe = n));
                    var r = (this.time % t) / t;
                    this.directionBackwards && (r = 1 - r), (this.morphTargetInfluences[this.currentKeyframe] = r), (this.morphTargetInfluences[this.lastKeyframe] = 1 - r);
                }),
                (THREE.MorphAnimMesh.prototype.clone = function (e) {
                    return (
                        e === undefined && (e = new THREE.MorphAnimMesh(this.geometry, this.material)),
                            (e.duration = this.duration),
                            (e.mirroredLoop = this.mirroredLoop),
                            (e.time = this.time),
                            (e.lastKeyframe = this.lastKeyframe),
                            (e.currentKeyframe = this.currentKeyframe),
                            (e.direction = this.direction),
                            (e.directionBackwards = this.directionBackwards),
                            THREE.Mesh.prototype.clone.call(this, e),
                            e
                    );
                }),
                (THREE.LOD = function () {
                    THREE.Object3D.call(this), (this.objects = []);
                }),
                (THREE.LOD.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.LOD.prototype.addLevel = function (e, t) {
                    t === undefined && (t = 0), (t = Math.abs(t));
                    for (var n = 0; n < this.objects.length; n++) if (t < this.objects[n].distance) break;
                    this.objects.splice(n, 0, { distance: t, object: e }), this.add(e);
                }),
                (THREE.LOD.prototype.getObjectForDistance = function (e) {
                    for (var t = 1, n = this.objects.length; t < n; t++) if (e < this.objects[t].distance) break;
                    return this.objects[t - 1].object;
                }),
                (THREE.LOD.prototype.update = (function () {
                    var e = new THREE.Vector3(),
                        t = new THREE.Vector3();
                    return function (n) {
                        if (this.objects.length > 1) {
                            e.getPositionFromMatrix(n.matrixWorld), t.getPositionFromMatrix(this.matrixWorld);
                            var r = e.distanceTo(t);
                            this.objects[0].object.visible = !0;
                            for (var i = 1, s = this.objects.length; i < s; i++) {
                                if (!(r >= this.objects[i].distance)) break;
                                (this.objects[i - 1].object.visible = !1), (this.objects[i].object.visible = !0);
                            }
                            for (; i < s; i++) this.objects[i].object.visible = !1;
                        }
                    };
                })()),
                (THREE.LOD.prototype.clone = function () {}),
                (THREE.Sprite = function (e) {
                    THREE.Object3D.call(this), (this.material = e !== undefined ? e : new THREE.SpriteMaterial()), (this.rotation3d = this.rotation), (this.rotation = 0);
                }),
                (THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.Sprite.prototype.updateMatrix = function () {
                    this.rotation3d.set(0, 0, this.rotation, this.rotation3d.order), this.quaternion.setFromEuler(this.rotation3d), this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
                }),
                (THREE.Sprite.prototype.clone = function (e) {
                    return e === undefined && (e = new THREE.Sprite(this.material)), THREE.Object3D.prototype.clone.call(this, e), e;
                }),
                (THREE.Scene = function () {
                    THREE.Object3D.call(this), (this.fog = null), (this.overrideMaterial = null), (this.autoUpdate = !0), (this.matrixAutoUpdate = !1), (this.__lights = []), (this.__objectsAdded = []), (this.__objectsRemoved = []);
                }),
                (THREE.Scene.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.Scene.prototype.__addObject = function (e) {
                    if (e instanceof THREE.Light) this.__lights.indexOf(e) === -1 && this.__lights.push(e), e.target && e.target.parent === undefined && this.add(e.target);
                    else if (!(e instanceof THREE.Camera || e instanceof THREE.Bone)) {
                        this.__objectsAdded.push(e);
                        var t = this.__objectsRemoved.indexOf(e);
                        t !== -1 && this.__objectsRemoved.splice(t, 1);
                    }
                    for (var n = 0; n < e.children.length; n++) this.__addObject(e.children[n]);
                }),
                (THREE.Scene.prototype.__removeObject = function (e) {
                    if (e instanceof THREE.Light) {
                        var t = this.__lights.indexOf(e);
                        t !== -1 && this.__lights.splice(t, 1);
                        if (e.shadowCascadeArray) for (var n = 0; n < e.shadowCascadeArray.length; n++) this.__removeObject(e.shadowCascadeArray[n]);
                    } else if (!(e instanceof THREE.Camera)) {
                        this.__objectsRemoved.push(e);
                        var t = this.__objectsAdded.indexOf(e);
                        t !== -1 && this.__objectsAdded.splice(t, 1);
                    }
                    for (var r = 0; r < e.children.length; r++) this.__removeObject(e.children[r]);
                }),
                (THREE.Scene.prototype.clone = function (e) {
                    return (
                        e === undefined && (e = new THREE.Scene()),
                            THREE.Object3D.prototype.clone.call(this, e),
                        this.fog !== null && (e.fog = this.fog.clone()),
                        this.overrideMaterial !== null && (e.overrideMaterial = this.overrideMaterial.clone()),
                            (e.autoUpdate = this.autoUpdate),
                            (e.matrixAutoUpdate = this.matrixAutoUpdate),
                            e
                    );
                }),
                (THREE.Fog = function (e, t, n) {
                    (this.name = ""), (this.color = new THREE.Color(e)), (this.near = t !== undefined ? t : 1), (this.far = n !== undefined ? n : 1e3);
                }),
                (THREE.Fog.prototype.clone = function () {
                    return new THREE.Fog(this.color.getHex(), this.near, this.far);
                }),
                (THREE.FogExp2 = function (e, t) {
                    (this.name = ""), (this.color = new THREE.Color(e)), (this.density = t !== undefined ? t : 25e-5);
                }),
                (THREE.FogExp2.prototype.clone = function () {
                    return new THREE.FogExp2(this.color.getHex(), this.density);
                }),
                (THREE.CanvasRenderer = function (e) {
                    function xt() {
                        ht.setRGB(0, 0, 0), pt.setRGB(0, 0, 0), dt.setRGB(0, 0, 0);
                        for (var e = 0, t = s.length; e < t; e++) {
                            var n = s[e],
                                r = n.color;
                            n instanceof THREE.AmbientLight ? ht.add(r) : n instanceof THREE.DirectionalLight ? pt.add(r) : n instanceof THREE.PointLight && dt.add(r);
                        }
                    }
                    function Tt(e, t, n) {
                        for (var r = 0, i = s.length; r < i; r++) {
                            var o = s[r];
                            Q.copy(o.color);
                            if (o instanceof THREE.DirectionalLight) {
                                var u = vt.getPositionFromMatrix(o.matrixWorld).normalize(),
                                    a = t.dot(u);
                                if (a <= 0) continue;
                                (a *= o.intensity), n.add(Q.multiplyScalar(a));
                            } else if (o instanceof THREE.PointLight) {
                                var u = vt.getPositionFromMatrix(o.matrixWorld),
                                    a = t.dot(vt.subVectors(u, e).normalize());
                                if (a <= 0) continue;
                                a *= o.distance == 0 ? 1 : 1 - Math.min(e.distanceTo(u) / o.distance, 1);
                                if (a == 0) continue;
                                (a *= o.intensity), n.add(Q.multiplyScalar(a));
                            }
                        }
                    }
                    function Nt(e, t, n) {
                        Ht(n.opacity), Bt(n.blending);
                        var r, i, s, o, u, a, f;
                        if (n instanceof THREE.ParticleBasicMaterial)
                            if (n.map === null) {
                                (s = t.object.scale.x), (o = t.object.scale.y), (s *= t.scale.x * l), (o *= t.scale.y * c), ct.min.set(e.x - s, e.y - o), ct.max.set(e.x + s, e.y + o);
                                if (ft.isIntersectionBox(ct) === !1) {
                                    ct.makeEmpty();
                                    return;
                                }
                                Rt(n.color.getStyle()), h.save(), h.translate(e.x, e.y), h.rotate(-t.rotation), h.scale(s, o), h.fillRect(-1, -1, 2, 2), h.restore();
                            } else {
                                (u = n.map.image), (a = u.width >> 1), (f = u.height >> 1), (s = t.scale.x * l), (o = t.scale.y * c), (r = s * a), (i = o * f), ct.min.set(e.x - r, e.y - i), ct.max.set(e.x + r, e.y + i);
                                if (ft.isIntersectionBox(ct) === !1) {
                                    ct.makeEmpty();
                                    return;
                                }
                                h.save(), h.translate(e.x, e.y), h.rotate(-t.rotation), h.scale(s, -o), h.translate(-a, -f), h.drawImage(u, 0, 0), h.restore();
                            }
                        else if (n instanceof THREE.ParticleCanvasMaterial) {
                            (r = t.scale.x * l), (i = t.scale.y * c), ct.min.set(e.x - r, e.y - i), ct.max.set(e.x + r, e.y + i);
                            if (ft.isIntersectionBox(ct) === !1) {
                                ct.makeEmpty();
                                return;
                            }
                            qt(n.color.getStyle()), Rt(n.color.getStyle()), h.save(), h.translate(e.x, e.y), h.rotate(-t.rotation), h.scale(r, i), n.program(h), h.restore();
                        }
                    }
                    function Ct(e, t, n, r) {
                        Ht(r.opacity), Bt(r.blending), h.beginPath(), h.moveTo(e.positionScreen.x, e.positionScreen.y), h.lineTo(t.positionScreen.x, t.positionScreen.y);
                        if (r instanceof THREE.LineBasicMaterial) {
                            jt(r.linewidth), Ft(r.linecap), It(r.linejoin);
                            if (r.vertexColors !== THREE.VertexColors) qt(r.color.getStyle());
                            else {
                                var i = n.vertexColors[0].getStyle(),
                                    s = n.vertexColors[1].getStyle();
                                if (i === s) qt(i);
                                else {
                                    try {
                                        var o = h.createLinearGradient(e.positionScreen.x, e.positionScreen.y, t.positionScreen.x, t.positionScreen.y);
                                        o.addColorStop(0, i), o.addColorStop(1, s);
                                    } catch (u) {
                                        o = i;
                                    }
                                    qt(o);
                                }
                            }
                            h.stroke(), ct.expandByScalar(r.linewidth * 2);
                        } else r instanceof THREE.LineDashedMaterial && (jt(r.linewidth), Ft(r.linecap), It(r.linejoin), qt(r.color.getStyle()), Ut(r.dashSize, r.gapSize), h.stroke(), ct.expandByScalar(r.linewidth * 2), Ut(null, null));
                    }
                    function kt(e, r, i, s, o, u, a, f) {
                        (n.info.render.vertices += 3),
                            n.info.render.faces++,
                            Ht(f.opacity),
                            Bt(f.blending),
                            (M = e.positionScreen.x),
                            (_ = e.positionScreen.y),
                            (D = r.positionScreen.x),
                            (P = r.positionScreen.y),
                            (H = i.positionScreen.x),
                            (B = i.positionScreen.y),
                            Lt(M, _, D, P, H, B);
                        if ((f instanceof THREE.MeshLambertMaterial || f instanceof THREE.MeshPhongMaterial) && f.map === null)
                            J.copy(f.color),
                                K.copy(f.emissive),
                            f.vertexColors === THREE.FaceColors && J.multiply(a.color),
                                f.wireframe === !1 && f.shading == THREE.SmoothShading && a.vertexNormalsLength == 3
                                    ? (W.copy(ht),
                                        X.copy(ht),
                                        V.copy(ht),
                                        Tt(a.v1.positionWorld, a.vertexNormalsModel[0], W),
                                        Tt(a.v2.positionWorld, a.vertexNormalsModel[1], X),
                                        Tt(a.v3.positionWorld, a.vertexNormalsModel[2], V),
                                        W.multiply(J).add(K),
                                        X.multiply(J).add(K),
                                        V.multiply(J).add(K),
                                        $.addColors(X, V).multiplyScalar(0.5),
                                        (tt = Dt(W, X, V, $)),
                                        _t(M, _, D, P, H, B, 0, 0, 1, 0, 0, 1, tt))
                                    : (z.copy(ht), Tt(a.centroidModel, a.normalModel, z), z.multiply(J).add(K), f.wireframe === !0 ? At(z, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : Ot(z));
                        else if (f instanceof THREE.MeshBasicMaterial || f instanceof THREE.MeshLambertMaterial || f instanceof THREE.MeshPhongMaterial)
                            f.map !== null
                                ? f.map.mapping instanceof THREE.UVMapping && ((nt = a.uvs[0]), Mt(M, _, D, P, H, B, nt[s].x, nt[s].y, nt[o].x, nt[o].y, nt[u].x, nt[u].y, f.map))
                                : f.envMap !== null
                                ? f.envMap.mapping instanceof THREE.SphericalReflectionMapping &&
                                (vt.copy(a.vertexNormalsModelView[s]),
                                    (rt = 0.5 * vt.x + 0.5),
                                    (it = 0.5 * vt.y + 0.5),
                                    vt.copy(a.vertexNormalsModelView[o]),
                                    (st = 0.5 * vt.x + 0.5),
                                    (ot = 0.5 * vt.y + 0.5),
                                    vt.copy(a.vertexNormalsModelView[u]),
                                    (ut = 0.5 * vt.x + 0.5),
                                    (at = 0.5 * vt.y + 0.5),
                                    Mt(M, _, D, P, H, B, rt, it, st, ot, ut, at, f.envMap))
                                : (z.copy(f.color), f.vertexColors === THREE.FaceColors && z.multiply(a.color), f.wireframe === !0 ? At(z, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : Ot(z));
                        else if (f instanceof THREE.MeshDepthMaterial)
                            (Z = T.near),
                                (et = T.far),
                                (W.r = W.g = W.b = 1 - t(e.positionScreen.z * e.positionScreen.w, Z, et)),
                                (X.r = X.g = X.b = 1 - t(r.positionScreen.z * r.positionScreen.w, Z, et)),
                                (V.r = V.g = V.b = 1 - t(i.positionScreen.z * i.positionScreen.w, Z, et)),
                                $.addColors(X, V).multiplyScalar(0.5),
                                (tt = Dt(W, X, V, $)),
                                _t(M, _, D, P, H, B, 0, 0, 1, 0, 0, 1, tt);
                        else if (f instanceof THREE.MeshNormalMaterial) {
                            var l;
                            f.shading == THREE.FlatShading
                                ? ((l = a.normalModelView), z.setRGB(l.x, l.y, l.z).multiplyScalar(0.5).addScalar(0.5), f.wireframe === !0 ? At(z, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : Ot(z))
                                : f.shading == THREE.SmoothShading &&
                                ((l = a.vertexNormalsModelView[s]),
                                    W.setRGB(l.x, l.y, l.z).multiplyScalar(0.5).addScalar(0.5),
                                    (l = a.vertexNormalsModelView[o]),
                                    X.setRGB(l.x, l.y, l.z).multiplyScalar(0.5).addScalar(0.5),
                                    (l = a.vertexNormalsModelView[u]),
                                    V.setRGB(l.x, l.y, l.z).multiplyScalar(0.5).addScalar(0.5),
                                    $.addColors(X, V).multiplyScalar(0.5),
                                    (tt = Dt(W, X, V, $)),
                                    _t(M, _, D, P, H, B, 0, 0, 1, 0, 0, 1, tt));
                        }
                    }
                    function Lt(e, t, n, r, i, s) {
                        h.beginPath(), h.moveTo(e, t), h.lineTo(n, r), h.lineTo(i, s), h.closePath();
                    }
                    function At(e, t, n, r) {
                        jt(t), Ft(n), It(r), qt(e.getStyle()), h.stroke(), ct.expandByScalar(t * 2);
                    }
                    function Ot(e) {
                        Rt(e.getStyle()), h.fill();
                    }
                    function Mt(e, t, n, r, i, s, o, u, a, f, l, c, p) {
                        if (p instanceof THREE.DataTexture || p.image === undefined || p.image.width == 0) return;
                        if (p.needsUpdate === !0) {
                            var d = p.wrapS == THREE.RepeatWrapping,
                                v = p.wrapT == THREE.RepeatWrapping;
                            (G[p.id] = h.createPattern(p.image, d === !0 && v === !0 ? "repeat" : d === !0 && v === !1 ? "repeat-x" : d === !1 && v === !0 ? "repeat-y" : "no-repeat")), (p.needsUpdate = !1);
                        }
                        G[p.id] === undefined ? Rt("rgba(0,0,0,1)") : Rt(G[p.id]);
                        var m,
                            g,
                            y,
                            b,
                            w,
                            E,
                            S,
                            x,
                            T = p.offset.x / p.repeat.x,
                            N = p.offset.y / p.repeat.y,
                            C = p.image.width * p.repeat.x,
                            k = p.image.height * p.repeat.y;
                        (o = (o + T) * C), (u = (1 - u + N) * k), (a = (a + T) * C), (f = (1 - f + N) * k), (l = (l + T) * C), (c = (1 - c + N) * k), (n -= e), (r -= t), (i -= e), (s -= t), (a -= o), (f -= u), (l -= o), (c -= u), (S = a * c - l * f);
                        if (S === 0) {
                            if (Y[p.id] === undefined) {
                                var L = document.createElement("canvas");
                                (L.width = p.image.width), (L.height = p.image.height);
                                var A = L.getContext("2d");
                                A.drawImage(p.image, 0, 0), (Y[p.id] = A.getImageData(0, 0, p.image.width, p.image.height).data);
                            }
                            var O = Y[p.id],
                                M = (Math.floor(o) + Math.floor(u) * p.image.width) * 4;
                            z.setRGB(O[M] / 255, O[M + 1] / 255, O[M + 2] / 255), Ot(z);
                            return;
                        }
                        (x = 1 / S),
                            (m = (c * n - f * i) * x),
                            (g = (c * r - f * s) * x),
                            (y = (a * i - l * n) * x),
                            (b = (a * s - l * r) * x),
                            (w = e - m * o - y * u),
                            (E = t - g * o - b * u),
                            h.save(),
                            h.transform(m, g, y, b, w, E),
                            h.fill(),
                            h.restore();
                    }
                    function _t(e, t, n, r, i, s, o, u, a, f, l, c, p) {
                        var d,
                            v,
                            m,
                            g,
                            y,
                            b,
                            w,
                            E,
                            S = p.width - 1,
                            x = p.height - 1;
                        (o *= S),
                            (u *= x),
                            (a *= S),
                            (f *= x),
                            (l *= S),
                            (c *= x),
                            (n -= e),
                            (r -= t),
                            (i -= e),
                            (s -= t),
                            (a -= o),
                            (f -= u),
                            (l -= o),
                            (c -= u),
                            (w = a * c - l * f),
                            (E = 1 / w),
                            (d = (c * n - f * i) * E),
                            (v = (c * r - f * s) * E),
                            (m = (a * i - l * n) * E),
                            (g = (a * s - l * r) * E),
                            (y = e - d * o - m * u),
                            (b = t - v * o - g * u),
                            h.save(),
                            h.transform(d, v, m, g, y, b),
                            h.clip(),
                            h.drawImage(p, 0, 0),
                            h.restore();
                    }
                    function Dt(e, t, n, r) {
                        return (
                            (bt[0] = (e.r * 255) | 0),
                                (bt[1] = (e.g * 255) | 0),
                                (bt[2] = (e.b * 255) | 0),
                                (bt[4] = (t.r * 255) | 0),
                                (bt[5] = (t.g * 255) | 0),
                                (bt[6] = (t.b * 255) | 0),
                                (bt[8] = (n.r * 255) | 0),
                                (bt[9] = (n.g * 255) | 0),
                                (bt[10] = (n.b * 255) | 0),
                                (bt[12] = (r.r * 255) | 0),
                                (bt[13] = (r.g * 255) | 0),
                                (bt[14] = (r.b * 255) | 0),
                                gt.putImageData(yt, 0, 0),
                                Et.drawImage(mt, 0, 0),
                                wt
                        );
                    }
                    function Pt(e, t, n) {
                        var r = t.x - e.x,
                            i = t.y - e.y,
                            s = r * r + i * i,
                            o;
                        if (s === 0) return;
                        (o = n / Math.sqrt(s)), (r *= o), (i *= o), (t.x += r), (t.y += i), (e.x -= r), (e.y -= i);
                    }
                    function Ht(e) {
                        v !== e && ((h.globalAlpha = e), (v = e));
                    }
                    function Bt(e) {
                        m !== e &&
                        (e === THREE.NormalBlending
                            ? (h.globalCompositeOperation = "source-over")
                            : e === THREE.AdditiveBlending
                                ? (h.globalCompositeOperation = "lighter")
                                : e === THREE.SubtractiveBlending && (h.globalCompositeOperation = "darker"),
                            (m = e));
                    }
                    function jt(e) {
                        b !== e && ((h.lineWidth = e), (b = e));
                    }
                    function Ft(e) {
                        w !== e && ((h.lineCap = e), (w = e));
                    }
                    function It(e) {
                        E !== e && ((h.lineJoin = e), (E = e));
                    }
                    function qt(e) {
                        g !== e && ((h.strokeStyle = e), (g = e));
                    }
                    function Rt(e) {
                        y !== e && ((h.fillStyle = e), (y = e));
                    }
                    function Ut(e, t) {
                        if (S !== e || x !== t) h.setLineDash([e, t]), (S = e), (x = t);
                    }
                    console.log("THREE.CanvasRenderer", THREE.REVISION);
                    var t = THREE.Math.smoothstep;
                    e = e || {};
                    var n = this,
                        r,
                        i,
                        s,
                        o = new THREE.Projector(),
                        u = e.canvas !== undefined ? e.canvas : document.createElement("canvas"),
                        a,
                        f,
                        l,
                        c,
                        h = u.getContext("2d"),
                        p = new THREE.Color(0),
                        d = 0,
                        v = 1,
                        m = 0,
                        g = null,
                        y = null,
                        b = null,
                        w = null,
                        E = null,
                        S = null,
                        x = 0,
                        T,
                        N,
                        C,
                        k,
                        L,
                        A = new THREE.RenderableVertex(),
                        O = new THREE.RenderableVertex(),
                        M,
                        _,
                        D,
                        P,
                        H,
                        B,
                        j,
                        F,
                        I,
                        q,
                        R,
                        U,
                        z = new THREE.Color(),
                        W = new THREE.Color(),
                        X = new THREE.Color(),
                        V = new THREE.Color(),
                        $ = new THREE.Color(),
                        J = new THREE.Color(),
                        K = new THREE.Color(),
                        Q = new THREE.Color(),
                        G = {},
                        Y = {},
                        Z,
                        et,
                        tt,
                        nt,
                        rt,
                        it,
                        st,
                        ot,
                        ut,
                        at,
                        ft = new THREE.Box2(),
                        lt = new THREE.Box2(),
                        ct = new THREE.Box2(),
                        ht = new THREE.Color(),
                        pt = new THREE.Color(),
                        dt = new THREE.Color(),
                        vt = new THREE.Vector3(),
                        mt,
                        gt,
                        yt,
                        bt,
                        wt,
                        Et,
                        St = 16;
                    (mt = document.createElement("canvas")),
                        (mt.width = mt.height = 2),
                        (gt = mt.getContext("2d")),
                        (gt.fillStyle = "rgba(0,0,0,1)"),
                        gt.fillRect(0, 0, 2, 2),
                        (yt = gt.getImageData(0, 0, 2, 2)),
                        (bt = yt.data),
                        (wt = document.createElement("canvas")),
                        (wt.width = wt.height = St),
                        (Et = wt.getContext("2d")),
                        Et.translate(-St / 2, -St / 2),
                        Et.scale(St, St),
                        St--,
                    h.setLineDash === undefined &&
                    (h.mozDash !== undefined
                        ? (h.setLineDash = function (e) {
                            h.mozDash = e[0] !== null ? e : null;
                        })
                        : (h.setLineDash = function () {})),
                        (this.domElement = u),
                        (this.devicePixelRatio = e.devicePixelRatio !== undefined ? e.devicePixelRatio : self.devicePixelRatio !== undefined ? self.devicePixelRatio : 1),
                        (this.autoClear = !0),
                        (this.sortObjects = !0),
                        (this.sortElements = !0),
                        (this.info = { render: { vertices: 0, faces: 0 } }),
                        (this.supportsVertexTextures = function () {}),
                        (this.setFaceCulling = function () {}),
                        (this.setSize = function (e, t, n) {
                            (a = e * this.devicePixelRatio),
                                (f = t * this.devicePixelRatio),
                                (l = Math.floor(a / 2)),
                                (c = Math.floor(f / 2)),
                                (u.width = a),
                                (u.height = f),
                            this.devicePixelRatio !== 1 && n !== !1 && ((u.style.width = e + "px"), (u.style.height = t + "px")),
                                ft.set(new THREE.Vector2(-l, -c), new THREE.Vector2(l, c)),
                                lt.set(new THREE.Vector2(-l, -c), new THREE.Vector2(l, c)),
                                (v = 1),
                                (m = 0),
                                (g = null),
                                (y = null),
                                (b = null),
                                (w = null),
                                (E = null);
                        }),
                        (this.setClearColor = function (e, t) {
                            p.set(e), (d = t !== undefined ? t : 1), lt.set(new THREE.Vector2(-l, -c), new THREE.Vector2(l, c));
                        }),
                        (this.setClearColorHex = function (e, t) {
                            console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t);
                        }),
                        (this.getMaxAnisotropy = function () {
                            return 0;
                        }),
                        (this.clear = function () {
                            h.setTransform(1, 0, 0, -1, l, c),
                            lt.empty() === !1 &&
                            (lt.intersect(ft),
                                lt.expandByScalar(2),
                            d < 1 && h.clearRect(lt.min.x | 0, lt.min.y | 0, (lt.max.x - lt.min.x) | 0, (lt.max.y - lt.min.y) | 0),
                            d > 0 &&
                            (Bt(THREE.NormalBlending),
                                Ht(1),
                                Rt("rgba(" + Math.floor(p.r * 255) + "," + Math.floor(p.g * 255) + "," + Math.floor(p.b * 255) + "," + d + ")"),
                                h.fillRect(lt.min.x | 0, lt.min.y | 0, (lt.max.x - lt.min.x) | 0, (lt.max.y - lt.min.y) | 0)),
                                lt.makeEmpty());
                        }),
                        (this.render = function (e, t) {
                            if (t instanceof THREE.Camera == 0) {
                                console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
                                return;
                            }
                            this.autoClear === !0 && this.clear(),
                                h.setTransform(1, 0, 0, -1, l, c),
                                (n.info.render.vertices = 0),
                                (n.info.render.faces = 0),
                                (r = o.projectScene(e, t, this.sortObjects, this.sortElements)),
                                (i = r.elements),
                                (s = r.lights),
                                (T = t),
                                xt();
                            for (var u = 0, a = i.length; u < a; u++) {
                                var f = i[u],
                                    p = f.material;
                                if (p === undefined || p.visible === !1) continue;
                                ct.makeEmpty();
                                if (f instanceof THREE.RenderableParticle) (N = f), (N.x *= l), (N.y *= c), Nt(N, f, p);
                                else if (f instanceof THREE.RenderableLine)
                                    (N = f.v1),
                                        (C = f.v2),
                                        (N.positionScreen.x *= l),
                                        (N.positionScreen.y *= c),
                                        (C.positionScreen.x *= l),
                                        (C.positionScreen.y *= c),
                                        ct.setFromPoints([N.positionScreen, C.positionScreen]),
                                    ft.isIntersectionBox(ct) === !0 && Ct(N, C, f, p);
                                else if (f instanceof THREE.RenderableFace3) {
                                    (N = f.v1), (C = f.v2), (k = f.v3);
                                    if (N.positionScreen.z < -1 || N.positionScreen.z > 1) continue;
                                    if (C.positionScreen.z < -1 || C.positionScreen.z > 1) continue;
                                    if (k.positionScreen.z < -1 || k.positionScreen.z > 1) continue;
                                    (N.positionScreen.x *= l),
                                        (N.positionScreen.y *= c),
                                        (C.positionScreen.x *= l),
                                        (C.positionScreen.y *= c),
                                        (k.positionScreen.x *= l),
                                        (k.positionScreen.y *= c),
                                    p.overdraw > 0 && (Pt(N.positionScreen, C.positionScreen, p.overdraw), Pt(C.positionScreen, k.positionScreen, p.overdraw), Pt(k.positionScreen, N.positionScreen, p.overdraw)),
                                        ct.setFromPoints([N.positionScreen, C.positionScreen, k.positionScreen]),
                                    ft.isIntersectionBox(ct) === !0 && kt(N, C, k, 0, 1, 2, f, p);
                                }
                                lt.union(ct);
                            }
                            h.setTransform(1, 0, 0, 1, 0, 0);
                        });
                }),
                (THREE.ShaderChunk = {
                    fog_pars_fragment: ["#ifdef USE_FOG", "uniform vec3 fogColor;", "#ifdef FOG_EXP2", "uniform float fogDensity;", "#else", "uniform float fogNear;", "uniform float fogFar;", "#endif", "#endif"].join("\n"),
                    fog_fragment: [
                        "#ifdef USE_FOG",
                        "float depth = gl_FragCoord.z / gl_FragCoord.w;",
                        "#ifdef FOG_EXP2",
                        "const float LOG2 = 1.442695;",
                        "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
                        "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
                        "#else",
                        "float fogFactor = smoothstep( fogNear, fogFar, depth );",
                        "#endif",
                        "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
                        "#endif",
                    ].join("\n"),
                    envmap_pars_fragment: [
                        "#ifdef USE_ENVMAP",
                        "uniform float reflectivity;",
                        "uniform samplerCube envMap;",
                        "uniform float flipEnvMap;",
                        "uniform int combine;",
                        "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
                        "uniform bool useRefract;",
                        "uniform float refractionRatio;",
                        "#else",
                        "varying vec3 vReflect;",
                        "#endif",
                        "#endif",
                    ].join("\n"),
                    envmap_fragment: [
                        "#ifdef USE_ENVMAP",
                        "vec3 reflectVec;",
                        "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
                        "vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",
                        "if ( useRefract ) {",
                        "reflectVec = refract( cameraToVertex, normal, refractionRatio );",
                        "} else { ",
                        "reflectVec = reflect( cameraToVertex, normal );",
                        "}",
                        "#else",
                        "reflectVec = vReflect;",
                        "#endif",
                        "#ifdef DOUBLE_SIDED",
                        "float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
                        "vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",
                        "#else",
                        "vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",
                        "#endif",
                        "#ifdef GAMMA_INPUT",
                        "cubeColor.xyz *= cubeColor.xyz;",
                        "#endif",
                        "if ( combine == 1 ) {",
                        "gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );",
                        "} else if ( combine == 2 ) {",
                        "gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;",
                        "} else {",
                        "gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );",
                        "}",
                        "#endif",
                    ].join("\n"),
                    envmap_pars_vertex: ["#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )", "varying vec3 vReflect;", "uniform float refractionRatio;", "uniform bool useRefract;", "#endif"].join("\n"),
                    worldpos_vertex: [
                        "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",
                        "#ifdef USE_SKINNING",
                        "vec4 worldPosition = modelMatrix * skinned;",
                        "#endif",
                        "#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",
                        "vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );",
                        "#endif",
                        "#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",
                        "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
                        "#endif",
                        "#endif",
                    ].join("\n"),
                    envmap_vertex: [
                        "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",
                        "vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;",
                        "worldNormal = normalize( worldNormal );",
                        "vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",
                        "if ( useRefract ) {",
                        "vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",
                        "} else {",
                        "vReflect = reflect( cameraToVertex, worldNormal );",
                        "}",
                        "#endif",
                    ].join("\n"),
                    map_particle_pars_fragment: ["#ifdef USE_MAP", "uniform sampler2D map;", "#endif"].join("\n"),
                    map_particle_fragment: ["#ifdef USE_MAP", "gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );", "#endif"].join("\n"),
                    map_pars_vertex: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )", "varying vec2 vUv;", "uniform vec4 offsetRepeat;", "#endif"].join("\n"),
                    map_pars_fragment: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )", "varying vec2 vUv;", "#endif", "#ifdef USE_MAP", "uniform sampler2D map;", "#endif"].join("\n"),
                    map_vertex: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )", "vUv = uv * offsetRepeat.zw + offsetRepeat.xy;", "#endif"].join("\n"),
                    map_fragment: ["#ifdef USE_MAP", "vec4 texelColor = texture2D( map, vUv );", "#ifdef GAMMA_INPUT", "texelColor.xyz *= texelColor.xyz;", "#endif", "gl_FragColor = gl_FragColor * texelColor;", "#endif"].join("\n"),
                    lightmap_pars_fragment: ["#ifdef USE_LIGHTMAP", "varying vec2 vUv2;", "uniform sampler2D lightMap;", "#endif"].join("\n"),
                    lightmap_pars_vertex: ["#ifdef USE_LIGHTMAP", "varying vec2 vUv2;", "#endif"].join("\n"),
                    lightmap_fragment: ["#ifdef USE_LIGHTMAP", "gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );", "#endif"].join("\n"),
                    lightmap_vertex: ["#ifdef USE_LIGHTMAP", "vUv2 = uv2;", "#endif"].join("\n"),
                    bumpmap_pars_fragment: [
                        "#ifdef USE_BUMPMAP",
                        "uniform sampler2D bumpMap;",
                        "uniform float bumpScale;",
                        "vec2 dHdxy_fwd() {",
                        "vec2 dSTdx = dFdx( vUv );",
                        "vec2 dSTdy = dFdy( vUv );",
                        "float Hll = bumpScale * texture2D( bumpMap, vUv ).x;",
                        "float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;",
                        "float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;",
                        "return vec2( dBx, dBy );",
                        "}",
                        "vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",
                        "vec3 vSigmaX = dFdx( surf_pos );",
                        "vec3 vSigmaY = dFdy( surf_pos );",
                        "vec3 vN = surf_norm;",
                        "vec3 R1 = cross( vSigmaY, vN );",
                        "vec3 R2 = cross( vN, vSigmaX );",
                        "float fDet = dot( vSigmaX, R1 );",
                        "vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
                        "return normalize( abs( fDet ) * surf_norm - vGrad );",
                        "}",
                        "#endif",
                    ].join("\n"),
                    normalmap_pars_fragment: [
                        "#ifdef USE_NORMALMAP",
                        "uniform sampler2D normalMap;",
                        "uniform vec2 normalScale;",
                        "vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",
                        "vec3 q0 = dFdx( eye_pos.xyz );",
                        "vec3 q1 = dFdy( eye_pos.xyz );",
                        "vec2 st0 = dFdx( vUv.st );",
                        "vec2 st1 = dFdy( vUv.st );",
                        "vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
                        "vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
                        "vec3 N = normalize( surf_norm );",
                        "vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;",
                        "mapN.xy = normalScale * mapN.xy;",
                        "mat3 tsn = mat3( S, T, N );",
                        "return normalize( tsn * mapN );",
                        "}",
                        "#endif",
                    ].join("\n"),
                    specularmap_pars_fragment: ["#ifdef USE_SPECULARMAP", "uniform sampler2D specularMap;", "#endif"].join("\n"),
                    specularmap_fragment: ["float specularStrength;", "#ifdef USE_SPECULARMAP", "vec4 texelSpecular = texture2D( specularMap, vUv );", "specularStrength = texelSpecular.r;", "#else", "specularStrength = 1.0;", "#endif"].join("\n"),
                    lights_lambert_pars_vertex: [
                        "uniform vec3 ambient;",
                        "uniform vec3 diffuse;",
                        "uniform vec3 emissive;",
                        "uniform vec3 ambientLightColor;",
                        "#if MAX_DIR_LIGHTS > 0",
                        "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
                        "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
                        "#endif",
                        "#if MAX_HEMI_LIGHTS > 0",
                        "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
                        "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
                        "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
                        "#endif",
                        "#if MAX_POINT_LIGHTS > 0",
                        "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
                        "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
                        "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
                        "#endif",
                        "#if MAX_SPOT_LIGHTS > 0",
                        "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
                        "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
                        "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
                        "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
                        "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
                        "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
                        "#endif",
                        "#ifdef WRAP_AROUND",
                        "uniform vec3 wrapRGB;",
                        "#endif",
                    ].join("\n"),
                    lights_lambert_vertex: [
                        "vLightFront = vec3( 0.0 );",
                        "#ifdef DOUBLE_SIDED",
                        "vLightBack = vec3( 0.0 );",
                        "#endif",
                        "transformedNormal = normalize( transformedNormal );",
                        "#if MAX_DIR_LIGHTS > 0",
                        "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
                        "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
                        "vec3 dirVector = normalize( lDirection.xyz );",
                        "float dotProduct = dot( transformedNormal, dirVector );",
                        "vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",
                        "#ifdef DOUBLE_SIDED",
                        "vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
                        "#ifdef WRAP_AROUND",
                        "vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
                        "#endif",
                        "#endif",
                        "#ifdef WRAP_AROUND",
                        "vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
                        "directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );",
                        "#ifdef DOUBLE_SIDED",
                        "directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );",
                        "#endif",
                        "#endif",
                        "vLightFront += directionalLightColor[ i ] * directionalLightWeighting;",
                        "#ifdef DOUBLE_SIDED",
                        "vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;",
                        "#endif",
                        "}",
                        "#endif",
                        "#if MAX_POINT_LIGHTS > 0",
                        "for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
                        "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
                        "vec3 lVector = lPosition.xyz - mvPosition.xyz;",
                        "float lDistance = 1.0;",
                        "if ( pointLightDistance[ i ] > 0.0 )",
                        "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
                        "lVector = normalize( lVector );",
                        "float dotProduct = dot( transformedNormal, lVector );",
                        "vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );",
                        "#ifdef DOUBLE_SIDED",
                        "vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
                        "#ifdef WRAP_AROUND",
                        "vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
                        "#endif",
                        "#endif",
                        "#ifdef WRAP_AROUND",
                        "vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
                        "pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );",
                        "#ifdef DOUBLE_SIDED",
                        "pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );",
                        "#endif",
                        "#endif",
                        "vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;",
                        "#ifdef DOUBLE_SIDED",
                        "vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;",
                        "#endif",
                        "}",
                        "#endif",
                        "#if MAX_SPOT_LIGHTS > 0",
                        "for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
                        "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
                        "vec3 lVector = lPosition.xyz - mvPosition.xyz;",
                        "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );",
                        "if ( spotEffect > spotLightAngleCos[ i ] ) {",
                        "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
                        "float lDistance = 1.0;",
                        "if ( spotLightDistance[ i ] > 0.0 )",
                        "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
                        "lVector = normalize( lVector );",
                        "float dotProduct = dot( transformedNormal, lVector );",
                        "vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );",
                        "#ifdef DOUBLE_SIDED",
                        "vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
                        "#ifdef WRAP_AROUND",
                        "vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
                        "#endif",
                        "#endif",
                        "#ifdef WRAP_AROUND",
                        "vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
                        "spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );",
                        "#ifdef DOUBLE_SIDED",
                        "spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );",
                        "#endif",
                        "#endif",
                        "vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;",
                        "#ifdef DOUBLE_SIDED",
                        "vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;",
                        "#endif",
                        "}",
                        "}",
                        "#endif",
                        "#if MAX_HEMI_LIGHTS > 0",
                        "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
                        "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
                        "vec3 lVector = normalize( lDirection.xyz );",
                        "float dotProduct = dot( transformedNormal, lVector );",
                        "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
                        "float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;",
                        "vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
                        "#ifdef DOUBLE_SIDED",
                        "vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );",
                        "#endif",
                        "}",
                        "#endif",
                        "vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;",
                        "#ifdef DOUBLE_SIDED",
                        "vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;",
                        "#endif",
                    ].join("\n"),
                    lights_phong_pars_vertex: [
                        "#ifndef PHONG_PER_PIXEL",
                        "#if MAX_POINT_LIGHTS > 0",
                        "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
                        "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
                        "varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",
                        "#endif",
                        "#if MAX_SPOT_LIGHTS > 0",
                        "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
                        "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
                        "varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",
                        "#endif",
                        "#endif",
                        "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
                        "varying vec3 vWorldPosition;",
                        "#endif",
                    ].join("\n"),
                    lights_phong_vertex: [
                        "#ifndef PHONG_PER_PIXEL",
                        "#if MAX_POINT_LIGHTS > 0",
                        "for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
                        "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
                        "vec3 lVector = lPosition.xyz - mvPosition.xyz;",
                        "float lDistance = 1.0;",
                        "if ( pointLightDistance[ i ] > 0.0 )",
                        "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
                        "vPointLight[ i ] = vec4( lVector, lDistance );",
                        "}",
                        "#endif",
                        "#if MAX_SPOT_LIGHTS > 0",
                        "for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
                        "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
                        "vec3 lVector = lPosition.xyz - mvPosition.xyz;",
                        "float lDistance = 1.0;",
                        "if ( spotLightDistance[ i ] > 0.0 )",
                        "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
                        "vSpotLight[ i ] = vec4( lVector, lDistance );",
                        "}",
                        "#endif",
                        "#endif",
                        "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
                        "vWorldPosition = worldPosition.xyz;",
                        "#endif",
                    ].join("\n"),
                    lights_phong_pars_fragment: [
                        "uniform vec3 ambientLightColor;",
                        "#if MAX_DIR_LIGHTS > 0",
                        "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
                        "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
                        "#endif",
                        "#if MAX_HEMI_LIGHTS > 0",
                        "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
                        "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
                        "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
                        "#endif",
                        "#if MAX_POINT_LIGHTS > 0",
                        "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
                        "#ifdef PHONG_PER_PIXEL",
                        "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
                        "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
                        "#else",
                        "varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",
                        "#endif",
                        "#endif",
                        "#if MAX_SPOT_LIGHTS > 0",
                        "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
                        "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
                        "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
                        "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
                        "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
                        "#ifdef PHONG_PER_PIXEL",
                        "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
                        "#else",
                        "varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",
                        "#endif",
                        "#endif",
                        "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
                        "varying vec3 vWorldPosition;",
                        "#endif",
                        "#ifdef WRAP_AROUND",
                        "uniform vec3 wrapRGB;",
                        "#endif",
                        "varying vec3 vViewPosition;",
                        "varying vec3 vNormal;",
                    ].join("\n"),
                    lights_phong_fragment: [
                        "vec3 normal = normalize( vNormal );",
                        "vec3 viewPosition = normalize( vViewPosition );",
                        "#ifdef DOUBLE_SIDED",
                        "normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
                        "#endif",
                        "#ifdef USE_NORMALMAP",
                        "normal = perturbNormal2Arb( -vViewPosition, normal );",
                        "#elif defined( USE_BUMPMAP )",
                        "normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",
                        "#endif",
                        "#if MAX_POINT_LIGHTS > 0",
                        "vec3 pointDiffuse  = vec3( 0.0 );",
                        "vec3 pointSpecular = vec3( 0.0 );",
                        "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
                        "#ifdef PHONG_PER_PIXEL",
                        "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
                        "vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
                        "float lDistance = 1.0;",
                        "if ( pointLightDistance[ i ] > 0.0 )",
                        "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
                        "lVector = normalize( lVector );",
                        "#else",
                        "vec3 lVector = normalize( vPointLight[ i ].xyz );",
                        "float lDistance = vPointLight[ i ].w;",
                        "#endif",
                        "float dotProduct = dot( normal, lVector );",
                        "#ifdef WRAP_AROUND",
                        "float pointDiffuseWeightFull = max( dotProduct, 0.0 );",
                        "float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
                        "vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",
                        "#else",
                        "float pointDiffuseWeight = max( dotProduct, 0.0 );",
                        "#endif",
                        "pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;",
                        "vec3 pointHalfVector = normalize( lVector + viewPosition );",
                        "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
                        "float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",
                        "#ifdef PHYSICALLY_BASED_SHADING",
                        "float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
                        "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );",
                        "pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;",
                        "#else",
                        "pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;",
                        "#endif",
                        "}",
                        "#endif",
                        "#if MAX_SPOT_LIGHTS > 0",
                        "vec3 spotDiffuse  = vec3( 0.0 );",
                        "vec3 spotSpecular = vec3( 0.0 );",
                        "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
                        "#ifdef PHONG_PER_PIXEL",
                        "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
                        "vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
                        "float lDistance = 1.0;",
                        "if ( spotLightDistance[ i ] > 0.0 )",
                        "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
                        "lVector = normalize( lVector );",
                        "#else",
                        "vec3 lVector = normalize( vSpotLight[ i ].xyz );",
                        "float lDistance = vSpotLight[ i ].w;",
                        "#endif",
                        "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",
                        "if ( spotEffect > spotLightAngleCos[ i ] ) {",
                        "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
                        "float dotProduct = dot( normal, lVector );",
                        "#ifdef WRAP_AROUND",
                        "float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
                        "float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
                        "vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",
                        "#else",
                        "float spotDiffuseWeight = max( dotProduct, 0.0 );",
                        "#endif",
                        "spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;",
                        "vec3 spotHalfVector = normalize( lVector + viewPosition );",
                        "float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
                        "float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",
                        "#ifdef PHYSICALLY_BASED_SHADING",
                        "float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
                        "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );",
                        "spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;",
                        "#else",
                        "spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;",
                        "#endif",
                        "}",
                        "}",
                        "#endif",
                        "#if MAX_DIR_LIGHTS > 0",
                        "vec3 dirDiffuse  = vec3( 0.0 );",
                        "vec3 dirSpecular = vec3( 0.0 );",
                        "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
                        "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
                        "vec3 dirVector = normalize( lDirection.xyz );",
                        "float dotProduct = dot( normal, dirVector );",
                        "#ifdef WRAP_AROUND",
                        "float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
                        "float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
                        "vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",
                        "#else",
                        "float dirDiffuseWeight = max( dotProduct, 0.0 );",
                        "#endif",
                        "dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;",
                        "vec3 dirHalfVector = normalize( dirVector + viewPosition );",
                        "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
                        "float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",
                        "#ifdef PHYSICALLY_BASED_SHADING",
                        "float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
                        "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
                        "dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",
                        "#else",
                        "dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;",
                        "#endif",
                        "}",
                        "#endif",
                        "#if MAX_HEMI_LIGHTS > 0",
                        "vec3 hemiDiffuse  = vec3( 0.0 );",
                        "vec3 hemiSpecular = vec3( 0.0 );",
                        "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
                        "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
                        "vec3 lVector = normalize( lDirection.xyz );",
                        "float dotProduct = dot( normal, lVector );",
                        "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
                        "vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
                        "hemiDiffuse += diffuse * hemiColor;",
                        "vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
                        "float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
                        "float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",
                        "vec3 lVectorGround = -lVector;",
                        "vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
                        "float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
                        "float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",
                        "#ifdef PHYSICALLY_BASED_SHADING",
                        "float dotProductGround = dot( normal, lVectorGround );",
                        "float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
                        "vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
                        "vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
                        "hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",
                        "#else",
                        "hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;",
                        "#endif",
                        "}",
                        "#endif",
                        "vec3 totalDiffuse = vec3( 0.0 );",
                        "vec3 totalSpecular = vec3( 0.0 );",
                        "#if MAX_DIR_LIGHTS > 0",
                        "totalDiffuse += dirDiffuse;",
                        "totalSpecular += dirSpecular;",
                        "#endif",
                        "#if MAX_HEMI_LIGHTS > 0",
                        "totalDiffuse += hemiDiffuse;",
                        "totalSpecular += hemiSpecular;",
                        "#endif",
                        "#if MAX_POINT_LIGHTS > 0",
                        "totalDiffuse += pointDiffuse;",
                        "totalSpecular += pointSpecular;",
                        "#endif",
                        "#if MAX_SPOT_LIGHTS > 0",
                        "totalDiffuse += spotDiffuse;",
                        "totalSpecular += spotSpecular;",
                        "#endif",
                        "#ifdef METAL",
                        "gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );",
                        "#else",
                        "gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",
                        "#endif",
                    ].join("\n"),
                    color_pars_fragment: ["#ifdef USE_COLOR", "varying vec3 vColor;", "#endif"].join("\n"),
                    color_fragment: ["#ifdef USE_COLOR", "gl_FragColor = gl_FragColor * vec4( vColor, opacity );", "#endif"].join("\n"),
                    color_pars_vertex: ["#ifdef USE_COLOR", "varying vec3 vColor;", "#endif"].join("\n"),
                    color_vertex: ["#ifdef USE_COLOR", "#ifdef GAMMA_INPUT", "vColor = color * color;", "#else", "vColor = color;", "#endif", "#endif"].join("\n"),
                    skinning_pars_vertex: [
                        "#ifdef USE_SKINNING",
                        "#ifdef BONE_TEXTURE",
                        "uniform sampler2D boneTexture;",
                        "uniform int boneTextureWidth;",
                        "uniform int boneTextureHeight;",
                        "mat4 getBoneMatrix( const in float i ) {",
                        "float j = i * 4.0;",
                        "float x = mod( j, float( boneTextureWidth ) );",
                        "float y = floor( j / float( boneTextureWidth ) );",
                        "float dx = 1.0 / float( boneTextureWidth );",
                        "float dy = 1.0 / float( boneTextureHeight );",
                        "y = dy * ( y + 0.5 );",
                        "vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
                        "vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
                        "vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
                        "vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",
                        "mat4 bone = mat4( v1, v2, v3, v4 );",
                        "return bone;",
                        "}",
                        "#else",
                        "uniform mat4 boneGlobalMatrices[ MAX_BONES ];",
                        "mat4 getBoneMatrix( const in float i ) {",
                        "mat4 bone = boneGlobalMatrices[ int(i) ];",
                        "return bone;",
                        "}",
                        "#endif",
                        "#endif",
                    ].join("\n"),
                    skinbase_vertex: ["#ifdef USE_SKINNING", "mat4 boneMatX = getBoneMatrix( skinIndex.x );", "mat4 boneMatY = getBoneMatrix( skinIndex.y );", "#endif"].join("\n"),
                    skinning_vertex: [
                        "#ifdef USE_SKINNING",
                        "#ifdef USE_MORPHTARGETS",
                        "vec4 skinVertex = vec4( morphed, 1.0 );",
                        "#else",
                        "vec4 skinVertex = vec4( position, 1.0 );",
                        "#endif",
                        "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
                        "skinned 	  += boneMatY * skinVertex * skinWeight.y;",
                        "#endif",
                    ].join("\n"),
                    morphtarget_pars_vertex: ["#ifdef USE_MORPHTARGETS", "#ifndef USE_MORPHNORMALS", "uniform float morphTargetInfluences[ 8 ];", "#else", "uniform float morphTargetInfluences[ 4 ];", "#endif", "#endif"].join("\n"),
                    morphtarget_vertex: [
                        "#ifdef USE_MORPHTARGETS",
                        "vec3 morphed = vec3( 0.0 );",
                        "morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
                        "morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
                        "morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
                        "morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",
                        "#ifndef USE_MORPHNORMALS",
                        "morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
                        "morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
                        "morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
                        "morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",
                        "#endif",
                        "morphed += position;",
                        "#endif",
                    ].join("\n"),
                    default_vertex: [
                        "vec4 mvPosition;",
                        "#ifdef USE_SKINNING",
                        "mvPosition = modelViewMatrix * skinned;",
                        "#endif",
                        "#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )",
                        "mvPosition = modelViewMatrix * vec4( morphed, 1.0 );",
                        "#endif",
                        "#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )",
                        "mvPosition = modelViewMatrix * vec4( position, 1.0 );",
                        "#endif",
                        "gl_Position = projectionMatrix * mvPosition;",
                    ].join("\n"),
                    morphnormal_vertex: [
                        "#ifdef USE_MORPHNORMALS",
                        "vec3 morphedNormal = vec3( 0.0 );",
                        "morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
                        "morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
                        "morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
                        "morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",
                        "morphedNormal += normal;",
                        "#endif",
                    ].join("\n"),
                    skinnormal_vertex: [
                        "#ifdef USE_SKINNING",
                        "mat4 skinMatrix = skinWeight.x * boneMatX;",
                        "skinMatrix 	+= skinWeight.y * boneMatY;",
                        "#ifdef USE_MORPHNORMALS",
                        "vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );",
                        "#else",
                        "vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );",
                        "#endif",
                        "#endif",
                    ].join("\n"),
                    defaultnormal_vertex: [
                        "vec3 objectNormal;",
                        "#ifdef USE_SKINNING",
                        "objectNormal = skinnedNormal.xyz;",
                        "#endif",
                        "#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )",
                        "objectNormal = morphedNormal;",
                        "#endif",
                        "#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )",
                        "objectNormal = normal;",
                        "#endif",
                        "#ifdef FLIP_SIDED",
                        "objectNormal = -objectNormal;",
                        "#endif",
                        "vec3 transformedNormal = normalMatrix * objectNormal;",
                    ].join("\n"),
                    shadowmap_pars_fragment: [
                        "#ifdef USE_SHADOWMAP",
                        "uniform sampler2D shadowMap[ MAX_SHADOWS ];",
                        "uniform vec2 shadowMapSize[ MAX_SHADOWS ];",
                        "uniform float shadowDarkness[ MAX_SHADOWS ];",
                        "uniform float shadowBias[ MAX_SHADOWS ];",
                        "varying vec4 vShadowCoord[ MAX_SHADOWS ];",
                        "float unpackDepth( const in vec4 rgba_depth ) {",
                        "const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
                        "float depth = dot( rgba_depth, bit_shift );",
                        "return depth;",
                        "}",
                        "#endif",
                    ].join("\n"),
                    shadowmap_fragment: [
                        "#ifdef USE_SHADOWMAP",
                        "#ifdef SHADOWMAP_DEBUG",
                        "vec3 frustumColors[3];",
                        "frustumColors[0] = vec3( 1.0, 0.5, 0.0 );",
                        "frustumColors[1] = vec3( 0.0, 1.0, 0.8 );",
                        "frustumColors[2] = vec3( 0.0, 0.5, 1.0 );",
                        "#endif",
                        "#ifdef SHADOWMAP_CASCADE",
                        "int inFrustumCount = 0;",
                        "#endif",
                        "float fDepth;",
                        "vec3 shadowColor = vec3( 1.0 );",
                        "for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
                        "vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",
                        "bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
                        "bool inFrustum = all( inFrustumVec );",
                        "#ifdef SHADOWMAP_CASCADE",
                        "inFrustumCount += int( inFrustum );",
                        "bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );",
                        "#else",
                        "bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",
                        "#endif",
                        "bool frustumTest = all( frustumTestVec );",
                        "if ( frustumTest ) {",
                        "shadowCoord.z += shadowBias[ i ];",
                        "#if defined( SHADOWMAP_TYPE_PCF )",
                        "float shadow = 0.0;",
                        "const float shadowDelta = 1.0 / 9.0;",
                        "float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
                        "float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",
                        "float dx0 = -1.25 * xPixelOffset;",
                        "float dy0 = -1.25 * yPixelOffset;",
                        "float dx1 = 1.25 * xPixelOffset;",
                        "float dy1 = 1.25 * yPixelOffset;",
                        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
                        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
                        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
                        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
                        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
                        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
                        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
                        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
                        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
                        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
                        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
                        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
                        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
                        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
                        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
                        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
                        "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
                        "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
                        "shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",
                        "#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",
                        "float shadow = 0.0;",
                        "float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
                        "float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",
                        "float dx0 = -1.0 * xPixelOffset;",
                        "float dy0 = -1.0 * yPixelOffset;",
                        "float dx1 = 1.0 * xPixelOffset;",
                        "float dy1 = 1.0 * yPixelOffset;",
                        "mat3 shadowKernel;",
                        "mat3 depthKernel;",
                        "depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
                        "depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
                        "depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
                        "depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
                        "depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
                        "depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
                        "depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
                        "depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
                        "depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
                        "vec3 shadowZ = vec3( shadowCoord.z );",
                        "shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));",
                        "shadowKernel[0] *= vec3(0.25);",
                        "shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));",
                        "shadowKernel[1] *= vec3(0.25);",
                        "shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));",
                        "shadowKernel[2] *= vec3(0.25);",
                        "vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );",
                        "shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
                        "shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",
                        "vec4 shadowValues;",
                        "shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
                        "shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
                        "shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
                        "shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",
                        "shadow = dot( shadowValues, vec4( 1.0 ) );",
                        "shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",
                        "#else",
                        "vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
                        "float fDepth = unpackDepth( rgbaDepth );",
                        "if ( fDepth < shadowCoord.z )",
                        "shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );",
                        "#endif",
                        "}",
                        "#ifdef SHADOWMAP_DEBUG",
                        "#ifdef SHADOWMAP_CASCADE",
                        "if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];",
                        "#else",
                        "if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];",
                        "#endif",
                        "#endif",
                        "}",
                        "#ifdef GAMMA_OUTPUT",
                        "shadowColor *= shadowColor;",
                        "#endif",
                        "gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;",
                        "#endif",
                    ].join("\n"),
                    shadowmap_pars_vertex: ["#ifdef USE_SHADOWMAP", "varying vec4 vShadowCoord[ MAX_SHADOWS ];", "uniform mat4 shadowMatrix[ MAX_SHADOWS ];", "#endif"].join("\n"),
                    shadowmap_vertex: ["#ifdef USE_SHADOWMAP", "for( int i = 0; i < MAX_SHADOWS; i ++ ) {", "vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;", "}", "#endif"].join("\n"),
                    alphatest_fragment: ["#ifdef ALPHATEST", "if ( gl_FragColor.a < ALPHATEST ) discard;", "#endif"].join("\n"),
                    linear_to_gamma_fragment: ["#ifdef GAMMA_OUTPUT", "gl_FragColor.xyz = sqrt( gl_FragColor.xyz );", "#endif"].join("\n"),
                }),
                (THREE.UniformsUtils = {
                    merge: function (e) {
                        var t,
                            n,
                            r,
                            i = {};
                        for (t = 0; t < e.length; t++) {
                            r = this.clone(e[t]);
                            for (n in r) i[n] = r[n];
                        }
                        return i;
                    },
                    clone: function (e) {
                        var t,
                            n,
                            r,
                            i,
                            s = {};
                        for (t in e) {
                            s[t] = {};
                            for (n in e[t])
                                (i = e[t][n]),
                                    i instanceof THREE.Color || i instanceof THREE.Vector2 || i instanceof THREE.Vector3 || i instanceof THREE.Vector4 || i instanceof THREE.Matrix4 || i instanceof THREE.Texture
                                        ? (s[t][n] = i.clone())
                                        : i instanceof Array
                                        ? (s[t][n] = i.slice())
                                        : (s[t][n] = i);
                        }
                        return s;
                    },
                }),
                (THREE.UniformsLib = {
                    common: {
                        diffuse: { type: "c", value: new THREE.Color(15658734) },
                        opacity: { type: "f", value: 1 },
                        map: { type: "t", value: null },
                        offsetRepeat: { type: "v4", value: new THREE.Vector4(0, 0, 1, 1) },
                        lightMap: { type: "t", value: null },
                        specularMap: { type: "t", value: null },
                        envMap: { type: "t", value: null },
                        flipEnvMap: { type: "f", value: -1 },
                        useRefract: { type: "i", value: 0 },
                        reflectivity: { type: "f", value: 1 },
                        refractionRatio: { type: "f", value: 0.98 },
                        combine: { type: "i", value: 0 },
                        morphTargetInfluences: { type: "f", value: 0 },
                    },
                    bump: { bumpMap: { type: "t", value: null }, bumpScale: { type: "f", value: 1 } },
                    normalmap: { normalMap: { type: "t", value: null }, normalScale: { type: "v2", value: new THREE.Vector2(1, 1) } },
                    fog: { fogDensity: { type: "f", value: 25e-5 }, fogNear: { type: "f", value: 1 }, fogFar: { type: "f", value: 2e3 }, fogColor: { type: "c", value: new THREE.Color(16777215) } },
                    lights: {
                        ambientLightColor: { type: "fv", value: [] },
                        directionalLightDirection: { type: "fv", value: [] },
                        directionalLightColor: { type: "fv", value: [] },
                        hemisphereLightDirection: { type: "fv", value: [] },
                        hemisphereLightSkyColor: { type: "fv", value: [] },
                        hemisphereLightGroundColor: { type: "fv", value: [] },
                        pointLightColor: { type: "fv", value: [] },
                        pointLightPosition: { type: "fv", value: [] },
                        pointLightDistance: { type: "fv1", value: [] },
                        spotLightColor: { type: "fv", value: [] },
                        spotLightPosition: { type: "fv", value: [] },
                        spotLightDirection: { type: "fv", value: [] },
                        spotLightDistance: { type: "fv1", value: [] },
                        spotLightAngleCos: { type: "fv1", value: [] },
                        spotLightExponent: { type: "fv1", value: [] },
                    },
                    particle: {
                        psColor: { type: "c", value: new THREE.Color(15658734) },
                        opacity: { type: "f", value: 1 },
                        size: { type: "f", value: 1 },
                        scale: { type: "f", value: 1 },
                        map: { type: "t", value: null },
                        fogDensity: { type: "f", value: 25e-5 },
                        fogNear: { type: "f", value: 1 },
                        fogFar: { type: "f", value: 2e3 },
                        fogColor: { type: "c", value: new THREE.Color(16777215) },
                    },
                    shadowmap: { shadowMap: { type: "tv", value: [] }, shadowMapSize: { type: "v2v", value: [] }, shadowBias: { type: "fv1", value: [] }, shadowDarkness: { type: "fv1", value: [] }, shadowMatrix: { type: "m4v", value: [] } },
                }),
                (THREE.ShaderLib = {
                    basic: {
                        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
                        vertexShader: [
                            THREE.ShaderChunk.map_pars_vertex,
                            THREE.ShaderChunk.lightmap_pars_vertex,
                            THREE.ShaderChunk.envmap_pars_vertex,
                            THREE.ShaderChunk.color_pars_vertex,
                            THREE.ShaderChunk.morphtarget_pars_vertex,
                            THREE.ShaderChunk.skinning_pars_vertex,
                            THREE.ShaderChunk.shadowmap_pars_vertex,
                            "void main() {",
                            THREE.ShaderChunk.map_vertex,
                            THREE.ShaderChunk.lightmap_vertex,
                            THREE.ShaderChunk.color_vertex,
                            THREE.ShaderChunk.skinbase_vertex,
                            "#ifdef USE_ENVMAP",
                            THREE.ShaderChunk.morphnormal_vertex,
                            THREE.ShaderChunk.skinnormal_vertex,
                            THREE.ShaderChunk.defaultnormal_vertex,
                            "#endif",
                            THREE.ShaderChunk.morphtarget_vertex,
                            THREE.ShaderChunk.skinning_vertex,
                            THREE.ShaderChunk.default_vertex,
                            THREE.ShaderChunk.worldpos_vertex,
                            THREE.ShaderChunk.envmap_vertex,
                            THREE.ShaderChunk.shadowmap_vertex,
                            "}",
                        ].join("\n"),
                        fragmentShader: [
                            "uniform vec3 diffuse;",
                            "uniform float opacity;",
                            THREE.ShaderChunk.color_pars_fragment,
                            THREE.ShaderChunk.map_pars_fragment,
                            THREE.ShaderChunk.lightmap_pars_fragment,
                            THREE.ShaderChunk.envmap_pars_fragment,
                            THREE.ShaderChunk.fog_pars_fragment,
                            THREE.ShaderChunk.shadowmap_pars_fragment,
                            THREE.ShaderChunk.specularmap_pars_fragment,
                            "void main() {",
                            "gl_FragColor = vec4( diffuse, opacity );",
                            THREE.ShaderChunk.map_fragment,
                            THREE.ShaderChunk.alphatest_fragment,
                            THREE.ShaderChunk.specularmap_fragment,
                            THREE.ShaderChunk.lightmap_fragment,
                            THREE.ShaderChunk.color_fragment,
                            THREE.ShaderChunk.envmap_fragment,
                            THREE.ShaderChunk.shadowmap_fragment,
                            THREE.ShaderChunk.linear_to_gamma_fragment,
                            THREE.ShaderChunk.fog_fragment,
                            "}",
                        ].join("\n"),
                    },
                    lambert: {
                        uniforms: THREE.UniformsUtils.merge([
                            THREE.UniformsLib.common,
                            THREE.UniformsLib.fog,
                            THREE.UniformsLib.lights,
                            THREE.UniformsLib.shadowmap,
                            { ambient: { type: "c", value: new THREE.Color(16777215) }, emissive: { type: "c", value: new THREE.Color(0) }, wrapRGB: { type: "v3", value: new THREE.Vector3(1, 1, 1) } },
                        ]),
                        vertexShader: [
                            "#define LAMBERT",
                            "varying vec3 vLightFront;",
                            "#ifdef DOUBLE_SIDED",
                            "varying vec3 vLightBack;",
                            "#endif",
                            THREE.ShaderChunk.map_pars_vertex,
                            THREE.ShaderChunk.lightmap_pars_vertex,
                            THREE.ShaderChunk.envmap_pars_vertex,
                            THREE.ShaderChunk.lights_lambert_pars_vertex,
                            THREE.ShaderChunk.color_pars_vertex,
                            THREE.ShaderChunk.morphtarget_pars_vertex,
                            THREE.ShaderChunk.skinning_pars_vertex,
                            THREE.ShaderChunk.shadowmap_pars_vertex,
                            "void main() {",
                            THREE.ShaderChunk.map_vertex,
                            THREE.ShaderChunk.lightmap_vertex,
                            THREE.ShaderChunk.color_vertex,
                            THREE.ShaderChunk.morphnormal_vertex,
                            THREE.ShaderChunk.skinbase_vertex,
                            THREE.ShaderChunk.skinnormal_vertex,
                            THREE.ShaderChunk.defaultnormal_vertex,
                            THREE.ShaderChunk.morphtarget_vertex,
                            THREE.ShaderChunk.skinning_vertex,
                            THREE.ShaderChunk.default_vertex,
                            THREE.ShaderChunk.worldpos_vertex,
                            THREE.ShaderChunk.envmap_vertex,
                            THREE.ShaderChunk.lights_lambert_vertex,
                            THREE.ShaderChunk.shadowmap_vertex,
                            "}",
                        ].join("\n"),
                        fragmentShader: [
                            "uniform float opacity;",
                            "varying vec3 vLightFront;",
                            "#ifdef DOUBLE_SIDED",
                            "varying vec3 vLightBack;",
                            "#endif",
                            THREE.ShaderChunk.color_pars_fragment,
                            THREE.ShaderChunk.map_pars_fragment,
                            THREE.ShaderChunk.lightmap_pars_fragment,
                            THREE.ShaderChunk.envmap_pars_fragment,
                            THREE.ShaderChunk.fog_pars_fragment,
                            THREE.ShaderChunk.shadowmap_pars_fragment,
                            THREE.ShaderChunk.specularmap_pars_fragment,
                            "void main() {",
                            "gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
                            THREE.ShaderChunk.map_fragment,
                            THREE.ShaderChunk.alphatest_fragment,
                            THREE.ShaderChunk.specularmap_fragment,
                            "#ifdef DOUBLE_SIDED",
                            "if ( gl_FrontFacing )",
                            "gl_FragColor.xyz *= vLightFront;",
                            "else",
                            "gl_FragColor.xyz *= vLightBack;",
                            "#else",
                            "gl_FragColor.xyz *= vLightFront;",
                            "#endif",
                            THREE.ShaderChunk.lightmap_fragment,
                            THREE.ShaderChunk.color_fragment,
                            THREE.ShaderChunk.envmap_fragment,
                            THREE.ShaderChunk.shadowmap_fragment,
                            THREE.ShaderChunk.linear_to_gamma_fragment,
                            THREE.ShaderChunk.fog_fragment,
                            "}",
                        ].join("\n"),
                    },
                    phong: {
                        uniforms: THREE.UniformsUtils.merge([
                            THREE.UniformsLib.common,
                            THREE.UniformsLib.bump,
                            THREE.UniformsLib.normalmap,
                            THREE.UniformsLib.fog,
                            THREE.UniformsLib.lights,
                            THREE.UniformsLib.shadowmap,
                            {
                                ambient: { type: "c", value: new THREE.Color(16777215) },
                                emissive: { type: "c", value: new THREE.Color(0) },
                                specular: { type: "c", value: new THREE.Color(1118481) },
                                shininess: { type: "f", value: 30 },
                                wrapRGB: { type: "v3", value: new THREE.Vector3(1, 1, 1) },
                            },
                        ]),
                        vertexShader: [
                            "#define PHONG",
                            "varying vec3 vViewPosition;",
                            "varying vec3 vNormal;",
                            THREE.ShaderChunk.map_pars_vertex,
                            THREE.ShaderChunk.lightmap_pars_vertex,
                            THREE.ShaderChunk.envmap_pars_vertex,
                            THREE.ShaderChunk.lights_phong_pars_vertex,
                            THREE.ShaderChunk.color_pars_vertex,
                            THREE.ShaderChunk.morphtarget_pars_vertex,
                            THREE.ShaderChunk.skinning_pars_vertex,
                            THREE.ShaderChunk.shadowmap_pars_vertex,
                            "void main() {",
                            THREE.ShaderChunk.map_vertex,
                            THREE.ShaderChunk.lightmap_vertex,
                            THREE.ShaderChunk.color_vertex,
                            THREE.ShaderChunk.morphnormal_vertex,
                            THREE.ShaderChunk.skinbase_vertex,
                            THREE.ShaderChunk.skinnormal_vertex,
                            THREE.ShaderChunk.defaultnormal_vertex,
                            "vNormal = normalize( transformedNormal );",
                            THREE.ShaderChunk.morphtarget_vertex,
                            THREE.ShaderChunk.skinning_vertex,
                            THREE.ShaderChunk.default_vertex,
                            "vViewPosition = -mvPosition.xyz;",
                            THREE.ShaderChunk.worldpos_vertex,
                            THREE.ShaderChunk.envmap_vertex,
                            THREE.ShaderChunk.lights_phong_vertex,
                            THREE.ShaderChunk.shadowmap_vertex,
                            "}",
                        ].join("\n"),
                        fragmentShader: [
                            "uniform vec3 diffuse;",
                            "uniform float opacity;",
                            "uniform vec3 ambient;",
                            "uniform vec3 emissive;",
                            "uniform vec3 specular;",
                            "uniform float shininess;",
                            THREE.ShaderChunk.color_pars_fragment,
                            THREE.ShaderChunk.map_pars_fragment,
                            THREE.ShaderChunk.lightmap_pars_fragment,
                            THREE.ShaderChunk.envmap_pars_fragment,
                            THREE.ShaderChunk.fog_pars_fragment,
                            THREE.ShaderChunk.lights_phong_pars_fragment,
                            THREE.ShaderChunk.shadowmap_pars_fragment,
                            THREE.ShaderChunk.bumpmap_pars_fragment,
                            THREE.ShaderChunk.normalmap_pars_fragment,
                            THREE.ShaderChunk.specularmap_pars_fragment,
                            "void main() {",
                            "gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
                            THREE.ShaderChunk.map_fragment,
                            THREE.ShaderChunk.alphatest_fragment,
                            THREE.ShaderChunk.specularmap_fragment,
                            THREE.ShaderChunk.lights_phong_fragment,
                            THREE.ShaderChunk.lightmap_fragment,
                            THREE.ShaderChunk.color_fragment,
                            THREE.ShaderChunk.envmap_fragment,
                            THREE.ShaderChunk.shadowmap_fragment,
                            THREE.ShaderChunk.linear_to_gamma_fragment,
                            THREE.ShaderChunk.fog_fragment,
                            "}",
                        ].join("\n"),
                    },
                    particle_basic: {
                        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
                        vertexShader: [
                            "uniform float size;",
                            "uniform float scale;",
                            THREE.ShaderChunk.color_pars_vertex,
                            THREE.ShaderChunk.shadowmap_pars_vertex,
                            "void main() {",
                            THREE.ShaderChunk.color_vertex,
                            "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
                            "#ifdef USE_SIZEATTENUATION",
                            "gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
                            "#else",
                            "gl_PointSize = size;",
                            "#endif",
                            "gl_Position = projectionMatrix * mvPosition;",
                            THREE.ShaderChunk.worldpos_vertex,
                            THREE.ShaderChunk.shadowmap_vertex,
                            "}",
                        ].join("\n"),
                        fragmentShader: [
                            "uniform vec3 psColor;",
                            "uniform float opacity;",
                            THREE.ShaderChunk.color_pars_fragment,
                            THREE.ShaderChunk.map_particle_pars_fragment,
                            THREE.ShaderChunk.fog_pars_fragment,
                            THREE.ShaderChunk.shadowmap_pars_fragment,
                            "void main() {",
                            "gl_FragColor = vec4( psColor, opacity );",
                            THREE.ShaderChunk.map_particle_fragment,
                            THREE.ShaderChunk.alphatest_fragment,
                            THREE.ShaderChunk.color_fragment,
                            THREE.ShaderChunk.shadowmap_fragment,
                            THREE.ShaderChunk.fog_fragment,
                            "}",
                        ].join("\n"),
                    },
                    dashed: {
                        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, { scale: { type: "f", value: 1 }, dashSize: { type: "f", value: 1 }, totalSize: { type: "f", value: 2 } }]),
                        vertexShader: [
                            "uniform float scale;",
                            "attribute float lineDistance;",
                            "varying float vLineDistance;",
                            THREE.ShaderChunk.color_pars_vertex,
                            "void main() {",
                            THREE.ShaderChunk.color_vertex,
                            "vLineDistance = scale * lineDistance;",
                            "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
                            "gl_Position = projectionMatrix * mvPosition;",
                            "}",
                        ].join("\n"),
                        fragmentShader: [
                            "uniform vec3 diffuse;",
                            "uniform float opacity;",
                            "uniform float dashSize;",
                            "uniform float totalSize;",
                            "varying float vLineDistance;",
                            THREE.ShaderChunk.color_pars_fragment,
                            THREE.ShaderChunk.fog_pars_fragment,
                            "void main() {",
                            "if ( mod( vLineDistance, totalSize ) > dashSize ) {",
                            "discard;",
                            "}",
                            "gl_FragColor = vec4( diffuse, opacity );",
                            THREE.ShaderChunk.color_fragment,
                            THREE.ShaderChunk.fog_fragment,
                            "}",
                        ].join("\n"),
                    },
                    depth: {
                        uniforms: { mNear: { type: "f", value: 1 }, mFar: { type: "f", value: 2e3 }, opacity: { type: "f", value: 1 } },
                        vertexShader: ["void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                        fragmentShader: [
                            "uniform float mNear;",
                            "uniform float mFar;",
                            "uniform float opacity;",
                            "void main() {",
                            "float depth = gl_FragCoord.z / gl_FragCoord.w;",
                            "float color = 1.0 - smoothstep( mNear, mFar, depth );",
                            "gl_FragColor = vec4( vec3( color ), opacity );",
                            "}",
                        ].join("\n"),
                    },
                    normal: {
                        uniforms: { opacity: { type: "f", value: 1 } },
                        vertexShader: [
                            "varying vec3 vNormal;",
                            THREE.ShaderChunk.morphtarget_pars_vertex,
                            "void main() {",
                            "vNormal = normalize( normalMatrix * normal );",
                            THREE.ShaderChunk.morphtarget_vertex,
                            THREE.ShaderChunk.default_vertex,
                            "}",
                        ].join("\n"),
                        fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", "void main() {", "gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", "}"].join("\n"),
                    },
                    normalmap: {
                        uniforms: THREE.UniformsUtils.merge([
                            THREE.UniformsLib.fog,
                            THREE.UniformsLib.lights,
                            THREE.UniformsLib.shadowmap,
                            {
                                enableAO: { type: "i", value: 0 },
                                enableDiffuse: { type: "i", value: 0 },
                                enableSpecular: { type: "i", value: 0 },
                                enableReflection: { type: "i", value: 0 },
                                enableDisplacement: { type: "i", value: 0 },
                                tDisplacement: { type: "t", value: null },
                                tDiffuse: { type: "t", value: null },
                                tCube: { type: "t", value: null },
                                tNormal: { type: "t", value: null },
                                tSpecular: { type: "t", value: null },
                                tAO: { type: "t", value: null },
                                uNormalScale: { type: "v2", value: new THREE.Vector2(1, 1) },
                                uDisplacementBias: { type: "f", value: 0 },
                                uDisplacementScale: { type: "f", value: 1 },
                                uDiffuseColor: { type: "c", value: new THREE.Color(16777215) },
                                uSpecularColor: { type: "c", value: new THREE.Color(1118481) },
                                uAmbientColor: { type: "c", value: new THREE.Color(16777215) },
                                uShininess: { type: "f", value: 30 },
                                uOpacity: { type: "f", value: 1 },
                                useRefract: { type: "i", value: 0 },
                                uRefractionRatio: { type: "f", value: 0.98 },
                                uReflectivity: { type: "f", value: 0.5 },
                                uOffset: { type: "v2", value: new THREE.Vector2(0, 0) },
                                uRepeat: { type: "v2", value: new THREE.Vector2(1, 1) },
                                wrapRGB: { type: "v3", value: new THREE.Vector3(1, 1, 1) },
                            },
                        ]),
                        fragmentShader: [
                            "uniform vec3 uAmbientColor;",
                            "uniform vec3 uDiffuseColor;",
                            "uniform vec3 uSpecularColor;",
                            "uniform float uShininess;",
                            "uniform float uOpacity;",
                            "uniform bool enableDiffuse;",
                            "uniform bool enableSpecular;",
                            "uniform bool enableAO;",
                            "uniform bool enableReflection;",
                            "uniform sampler2D tDiffuse;",
                            "uniform sampler2D tNormal;",
                            "uniform sampler2D tSpecular;",
                            "uniform sampler2D tAO;",
                            "uniform samplerCube tCube;",
                            "uniform vec2 uNormalScale;",
                            "uniform bool useRefract;",
                            "uniform float uRefractionRatio;",
                            "uniform float uReflectivity;",
                            "varying vec3 vTangent;",
                            "varying vec3 vBinormal;",
                            "varying vec3 vNormal;",
                            "varying vec2 vUv;",
                            "uniform vec3 ambientLightColor;",
                            "#if MAX_DIR_LIGHTS > 0",
                            "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
                            "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
                            "#endif",
                            "#if MAX_HEMI_LIGHTS > 0",
                            "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
                            "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
                            "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
                            "#endif",
                            "#if MAX_POINT_LIGHTS > 0",
                            "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
                            "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
                            "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
                            "#endif",
                            "#if MAX_SPOT_LIGHTS > 0",
                            "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
                            "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
                            "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
                            "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
                            "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
                            "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
                            "#endif",
                            "#ifdef WRAP_AROUND",
                            "uniform vec3 wrapRGB;",
                            "#endif",
                            "varying vec3 vWorldPosition;",
                            "varying vec3 vViewPosition;",
                            THREE.ShaderChunk.shadowmap_pars_fragment,
                            THREE.ShaderChunk.fog_pars_fragment,
                            "void main() {",
                            "gl_FragColor = vec4( vec3( 1.0 ), uOpacity );",
                            "vec3 specularTex = vec3( 1.0 );",
                            "vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
                            "normalTex.xy *= uNormalScale;",
                            "normalTex = normalize( normalTex );",
                            "if( enableDiffuse ) {",
                            "#ifdef GAMMA_INPUT",
                            "vec4 texelColor = texture2D( tDiffuse, vUv );",
                            "texelColor.xyz *= texelColor.xyz;",
                            "gl_FragColor = gl_FragColor * texelColor;",
                            "#else",
                            "gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",
                            "#endif",
                            "}",
                            "if( enableAO ) {",
                            "#ifdef GAMMA_INPUT",
                            "vec4 aoColor = texture2D( tAO, vUv );",
                            "aoColor.xyz *= aoColor.xyz;",
                            "gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",
                            "#else",
                            "gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",
                            "#endif",
                            "}",
                            "if( enableSpecular )",
                            "specularTex = texture2D( tSpecular, vUv ).xyz;",
                            "mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
                            "vec3 finalNormal = tsb * normalTex;",
                            "#ifdef FLIP_SIDED",
                            "finalNormal = -finalNormal;",
                            "#endif",
                            "vec3 normal = normalize( finalNormal );",
                            "vec3 viewPosition = normalize( vViewPosition );",
                            "#if MAX_POINT_LIGHTS > 0",
                            "vec3 pointDiffuse = vec3( 0.0 );",
                            "vec3 pointSpecular = vec3( 0.0 );",
                            "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
                            "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
                            "vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",
                            "float pointDistance = 1.0;",
                            "if ( pointLightDistance[ i ] > 0.0 )",
                            "pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",
                            "pointVector = normalize( pointVector );",
                            "#ifdef WRAP_AROUND",
                            "float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
                            "float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",
                            "vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",
                            "#else",
                            "float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",
                            "#endif",
                            "pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;",
                            "vec3 pointHalfVector = normalize( pointVector + viewPosition );",
                            "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
                            "float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );",
                            "#ifdef PHYSICALLY_BASED_SHADING",
                            "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
                            "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );",
                            "pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",
                            "#else",
                            "pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;",
                            "#endif",
                            "}",
                            "#endif",
                            "#if MAX_SPOT_LIGHTS > 0",
                            "vec3 spotDiffuse = vec3( 0.0 );",
                            "vec3 spotSpecular = vec3( 0.0 );",
                            "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
                            "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
                            "vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",
                            "float spotDistance = 1.0;",
                            "if ( spotLightDistance[ i ] > 0.0 )",
                            "spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",
                            "spotVector = normalize( spotVector );",
                            "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",
                            "if ( spotEffect > spotLightAngleCos[ i ] ) {",
                            "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
                            "#ifdef WRAP_AROUND",
                            "float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
                            "float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",
                            "vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",
                            "#else",
                            "float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",
                            "#endif",
                            "spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;",
                            "vec3 spotHalfVector = normalize( spotVector + viewPosition );",
                            "float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
                            "float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );",
                            "#ifdef PHYSICALLY_BASED_SHADING",
                            "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
                            "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );",
                            "spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",
                            "#else",
                            "spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;",
                            "#endif",
                            "}",
                            "}",
                            "#endif",
                            "#if MAX_DIR_LIGHTS > 0",
                            "vec3 dirDiffuse = vec3( 0.0 );",
                            "vec3 dirSpecular = vec3( 0.0 );",
                            "for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",
                            "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
                            "vec3 dirVector = normalize( lDirection.xyz );",
                            "#ifdef WRAP_AROUND",
                            "float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
                            "float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",
                            "vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",
                            "#else",
                            "float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",
                            "#endif",
                            "dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;",
                            "vec3 dirHalfVector = normalize( dirVector + viewPosition );",
                            "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
                            "float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );",
                            "#ifdef PHYSICALLY_BASED_SHADING",
                            "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
                            "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
                            "dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",
                            "#else",
                            "dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;",
                            "#endif",
                            "}",
                            "#endif",
                            "#if MAX_HEMI_LIGHTS > 0",
                            "vec3 hemiDiffuse  = vec3( 0.0 );",
                            "vec3 hemiSpecular = vec3( 0.0 );",
                            "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
                            "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
                            "vec3 lVector = normalize( lDirection.xyz );",
                            "float dotProduct = dot( normal, lVector );",
                            "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
                            "vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
                            "hemiDiffuse += uDiffuseColor * hemiColor;",
                            "vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
                            "float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
                            "float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );",
                            "vec3 lVectorGround = -lVector;",
                            "vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
                            "float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
                            "float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );",
                            "#ifdef PHYSICALLY_BASED_SHADING",
                            "float dotProductGround = dot( normal, lVectorGround );",
                            "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
                            "vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
                            "vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
                            "hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",
                            "#else",
                            "hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;",
                            "#endif",
                            "}",
                            "#endif",
                            "vec3 totalDiffuse = vec3( 0.0 );",
                            "vec3 totalSpecular = vec3( 0.0 );",
                            "#if MAX_DIR_LIGHTS > 0",
                            "totalDiffuse += dirDiffuse;",
                            "totalSpecular += dirSpecular;",
                            "#endif",
                            "#if MAX_HEMI_LIGHTS > 0",
                            "totalDiffuse += hemiDiffuse;",
                            "totalSpecular += hemiSpecular;",
                            "#endif",
                            "#if MAX_POINT_LIGHTS > 0",
                            "totalDiffuse += pointDiffuse;",
                            "totalSpecular += pointSpecular;",
                            "#endif",
                            "#if MAX_SPOT_LIGHTS > 0",
                            "totalDiffuse += spotDiffuse;",
                            "totalSpecular += spotSpecular;",
                            "#endif",
                            "#ifdef METAL",
                            "gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );",
                            "#else",
                            "gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;",
                            "#endif",
                            "if ( enableReflection ) {",
                            "vec3 vReflect;",
                            "vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",
                            "if ( useRefract ) {",
                            "vReflect = refract( cameraToVertex, normal, uRefractionRatio );",
                            "} else {",
                            "vReflect = reflect( cameraToVertex, normal );",
                            "}",
                            "vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",
                            "#ifdef GAMMA_INPUT",
                            "cubeColor.xyz *= cubeColor.xyz;",
                            "#endif",
                            "gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );",
                            "}",
                            THREE.ShaderChunk.shadowmap_fragment,
                            THREE.ShaderChunk.linear_to_gamma_fragment,
                            THREE.ShaderChunk.fog_fragment,
                            "}",
                        ].join("\n"),
                        vertexShader: [
                            "attribute vec4 tangent;",
                            "uniform vec2 uOffset;",
                            "uniform vec2 uRepeat;",
                            "uniform bool enableDisplacement;",
                            "#ifdef VERTEX_TEXTURES",
                            "uniform sampler2D tDisplacement;",
                            "uniform float uDisplacementScale;",
                            "uniform float uDisplacementBias;",
                            "#endif",
                            "varying vec3 vTangent;",
                            "varying vec3 vBinormal;",
                            "varying vec3 vNormal;",
                            "varying vec2 vUv;",
                            "varying vec3 vWorldPosition;",
                            "varying vec3 vViewPosition;",
                            THREE.ShaderChunk.skinning_pars_vertex,
                            THREE.ShaderChunk.shadowmap_pars_vertex,
                            "void main() {",
                            THREE.ShaderChunk.skinbase_vertex,
                            THREE.ShaderChunk.skinnormal_vertex,
                            "#ifdef USE_SKINNING",
                            "vNormal = normalize( normalMatrix * skinnedNormal.xyz );",
                            "vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
                            "vTangent = normalize( normalMatrix * skinnedTangent.xyz );",
                            "#else",
                            "vNormal = normalize( normalMatrix * normal );",
                            "vTangent = normalize( normalMatrix * tangent.xyz );",
                            "#endif",
                            "vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",
                            "vUv = uv * uRepeat + uOffset;",
                            "vec3 displacedPosition;",
                            "#ifdef VERTEX_TEXTURES",
                            "if ( enableDisplacement ) {",
                            "vec3 dv = texture2D( tDisplacement, uv ).xyz;",
                            "float df = uDisplacementScale * dv.x + uDisplacementBias;",
                            "displacedPosition = position + normalize( normal ) * df;",
                            "} else {",
                            "#ifdef USE_SKINNING",
                            "vec4 skinVertex = vec4( position, 1.0 );",
                            "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
                            "skinned 	  += boneMatY * skinVertex * skinWeight.y;",
                            "displacedPosition  = skinned.xyz;",
                            "#else",
                            "displacedPosition = position;",
                            "#endif",
                            "}",
                            "#else",
                            "#ifdef USE_SKINNING",
                            "vec4 skinVertex = vec4( position, 1.0 );",
                            "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
                            "skinned 	  += boneMatY * skinVertex * skinWeight.y;",
                            "displacedPosition  = skinned.xyz;",
                            "#else",
                            "displacedPosition = position;",
                            "#endif",
                            "#endif",
                            "vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
                            "vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",
                            "gl_Position = projectionMatrix * mvPosition;",
                            "vWorldPosition = worldPosition.xyz;",
                            "vViewPosition = -mvPosition.xyz;",
                            "#ifdef USE_SHADOWMAP",
                            "for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
                            "vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",
                            "}",
                            "#endif",
                            "}",
                        ].join("\n"),
                    },
                    cube: {
                        uniforms: { tCube: { type: "t", value: null }, tFlip: { type: "f", value: -1 } },
                        vertexShader: [
                            "varying vec3 vWorldPosition;",
                            "void main() {",
                            "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
                            "vWorldPosition = worldPosition.xyz;",
                            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                            "}",
                        ].join("\n"),
                        fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", "void main() {", "gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", "}"].join(
                            "\n"
                        ),
                    },
                    depthRGBA: {
                        uniforms: {},
                        vertexShader: [
                            THREE.ShaderChunk.morphtarget_pars_vertex,
                            THREE.ShaderChunk.skinning_pars_vertex,
                            "void main() {",
                            THREE.ShaderChunk.skinbase_vertex,
                            THREE.ShaderChunk.morphtarget_vertex,
                            THREE.ShaderChunk.skinning_vertex,
                            THREE.ShaderChunk.default_vertex,
                            "}",
                        ].join("\n"),
                        fragmentShader: [
                            "vec4 pack_depth( const in float depth ) {",
                            "const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
                            "const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
                            "vec4 res = fract( depth * bit_shift );",
                            "res -= res.xxyz * bit_mask;",
                            "return res;",
                            "}",
                            "void main() {",
                            "gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",
                            "}",
                        ].join("\n"),
                    },
                }),
                (THREE.WebGLRenderer = function (e) {
                    function wt(e) {
                        (e.__webglVertexBuffer = V.createBuffer()), (e.__webglColorBuffer = V.createBuffer()), l.info.memory.geometries++;
                    }
                    function Et(e) {
                        (e.__webglVertexBuffer = V.createBuffer()), (e.__webglColorBuffer = V.createBuffer()), (e.__webglLineDistanceBuffer = V.createBuffer()), l.info.memory.geometries++;
                    }
                    function St(e) {
                        (e.__webglVertexBuffer = V.createBuffer()),
                            (e.__webglNormalBuffer = V.createBuffer()),
                            (e.__webglTangentBuffer = V.createBuffer()),
                            (e.__webglColorBuffer = V.createBuffer()),
                            (e.__webglUVBuffer = V.createBuffer()),
                            (e.__webglUV2Buffer = V.createBuffer()),
                            (e.__webglSkinIndicesBuffer = V.createBuffer()),
                            (e.__webglSkinWeightsBuffer = V.createBuffer()),
                            (e.__webglFaceBuffer = V.createBuffer()),
                            (e.__webglLineBuffer = V.createBuffer());
                        var t, n;
                        if (e.numMorphTargets) {
                            e.__webglMorphTargetsBuffers = [];
                            for (t = 0, n = e.numMorphTargets; t < n; t++) e.__webglMorphTargetsBuffers.push(V.createBuffer());
                        }
                        if (e.numMorphNormals) {
                            e.__webglMorphNormalsBuffers = [];
                            for (t = 0, n = e.numMorphNormals; t < n; t++) e.__webglMorphNormalsBuffers.push(V.createBuffer());
                        }
                        l.info.memory.geometries++;
                    }
                    function _t(e, t) {
                        var n = e.vertices.length,
                            r = t.material;
                        if (r.attributes) {
                            e.__webglCustomAttributesList === undefined && (e.__webglCustomAttributesList = []);
                            for (var i in r.attributes) {
                                var s = r.attributes[i];
                                if (!s.__webglInitialized || s.createUniqueBuffers) {
                                    s.__webglInitialized = !0;
                                    var o = 1;
                                    s.type === "v2" ? (o = 2) : s.type === "v3" ? (o = 3) : s.type === "v4" ? (o = 4) : s.type === "c" && (o = 3),
                                        (s.size = o),
                                        (s.array = new Float32Array(n * o)),
                                        (s.buffer = V.createBuffer()),
                                        (s.buffer.belongsToAttribute = i),
                                        (s.needsUpdate = !0);
                                }
                                e.__webglCustomAttributesList.push(s);
                            }
                        }
                    }
                    function Dt(e, t) {
                        var n = e.vertices.length;
                        (e.__vertexArray = new Float32Array(n * 3)), (e.__colorArray = new Float32Array(n * 3)), (e.__sortArray = []), (e.__webglParticleCount = n), _t(e, t);
                    }
                    function Pt(e, t) {
                        var n = e.vertices.length;
                        (e.__vertexArray = new Float32Array(n * 3)), (e.__colorArray = new Float32Array(n * 3)), (e.__lineDistanceArray = new Float32Array(n * 1)), (e.__webglLineCount = n), _t(e, t);
                    }
                    function Ht(e, t) {
                        var n = t.geometry,
                            r = e.faces3,
                            i = r.length * 3,
                            s = r.length * 1,
                            o = r.length * 3,
                            u = Bt(t, e),
                            a = qt(u),
                            f = Ft(u),
                            l = It(u);
                        (e.__vertexArray = new Float32Array(i * 3)),
                        f && (e.__normalArray = new Float32Array(i * 3)),
                        n.hasTangents && (e.__tangentArray = new Float32Array(i * 4)),
                        l && (e.__colorArray = new Float32Array(i * 3)),
                        a && (n.faceVertexUvs.length > 0 && (e.__uvArray = new Float32Array(i * 2)), n.faceVertexUvs.length > 1 && (e.__uv2Array = new Float32Array(i * 2))),
                        t.geometry.skinWeights.length && t.geometry.skinIndices.length && ((e.__skinIndexArray = new Float32Array(i * 4)), (e.__skinWeightArray = new Float32Array(i * 4))),
                            (e.__faceArray = new Uint16Array(s * 3)),
                            (e.__lineArray = new Uint16Array(o * 2));
                        var c, h;
                        if (e.numMorphTargets) {
                            e.__morphTargetsArrays = [];
                            for (c = 0, h = e.numMorphTargets; c < h; c++) e.__morphTargetsArrays.push(new Float32Array(i * 3));
                        }
                        if (e.numMorphNormals) {
                            e.__morphNormalsArrays = [];
                            for (c = 0, h = e.numMorphNormals; c < h; c++) e.__morphNormalsArrays.push(new Float32Array(i * 3));
                        }
                        (e.__webglFaceCount = s * 3), (e.__webglLineCount = o * 2);
                        if (u.attributes) {
                            e.__webglCustomAttributesList === undefined && (e.__webglCustomAttributesList = []);
                            for (var p in u.attributes) {
                                var d = u.attributes[p],
                                    v = {};
                                for (var m in d) v[m] = d[m];
                                if (!v.__webglInitialized || v.createUniqueBuffers) {
                                    v.__webglInitialized = !0;
                                    var g = 1;
                                    v.type === "v2" ? (g = 2) : v.type === "v3" ? (g = 3) : v.type === "v4" ? (g = 4) : v.type === "c" && (g = 3),
                                        (v.size = g),
                                        (v.array = new Float32Array(i * g)),
                                        (v.buffer = V.createBuffer()),
                                        (v.buffer.belongsToAttribute = p),
                                        (d.needsUpdate = !0),
                                        (v.__original = d);
                                }
                                e.__webglCustomAttributesList.push(v);
                            }
                        }
                        e.__inittedArrays = !0;
                    }
                    function Bt(e, t) {
                        return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[t.materialIndex] : e.material;
                    }
                    function jt(e) {
                        return e && e.shading !== undefined && e.shading === THREE.SmoothShading;
                    }
                    function Ft(e) {
                        return (e instanceof THREE.MeshBasicMaterial && !e.envMap) || e instanceof THREE.MeshDepthMaterial ? !1 : jt(e) ? THREE.SmoothShading : THREE.FlatShading;
                    }
                    function It(e) {
                        return e.vertexColors ? e.vertexColors : !1;
                    }
                    function qt(e) {
                        return e.map || e.lightMap || e.bumpMap || e.normalMap || e.specularMap || e instanceof THREE.ShaderMaterial ? !0 : !1;
                    }
                    function Rt(e) {
                        var t, n, r;
                        for (t in e.attributes)
                            t === "index" ? (r = V.ELEMENT_ARRAY_BUFFER) : (r = V.ARRAY_BUFFER),
                                (n = e.attributes[t]),
                            n.numItems === undefined && (n.numItems = n.array.length),
                                (n.buffer = V.createBuffer()),
                                V.bindBuffer(r, n.buffer),
                                V.bufferData(r, n.array, V.STATIC_DRAW);
                    }
                    function Ut(e, t, n) {
                        var r,
                            i,
                            s,
                            o,
                            u,
                            a,
                            f = e.vertices,
                            l = f.length,
                            c = e.colors,
                            h = c.length,
                            p = e.__vertexArray,
                            d = e.__colorArray,
                            v = e.__sortArray,
                            m = e.verticesNeedUpdate,
                            g = e.elementsNeedUpdate,
                            y = e.colorsNeedUpdate,
                            b = e.__webglCustomAttributesList,
                            w,
                            E,
                            S,
                            x,
                            T,
                            N,
                            C;
                        if (n.sortParticles) {
                            R.copy(q), R.multiply(n.matrixWorld);
                            for (r = 0; r < l; r++) (s = f[r]), U.copy(s), U.applyProjection(R), (v[r] = [U.z, r]);
                            v.sort(Qt);
                            for (r = 0; r < l; r++) (s = f[v[r][1]]), (o = r * 3), (p[o] = s.x), (p[o + 1] = s.y), (p[o + 2] = s.z);
                            for (i = 0; i < h; i++) (o = i * 3), (a = c[v[i][1]]), (d[o] = a.r), (d[o + 1] = a.g), (d[o + 2] = a.b);
                            if (b)
                                for (w = 0, E = b.length; w < E; w++) {
                                    C = b[w];
                                    if (C.boundTo !== undefined && C.boundTo !== "vertices") continue;
                                    (o = 0), (T = C.value.length);
                                    if (C.size === 1) for (x = 0; x < T; x++) (u = v[x][1]), (C.array[x] = C.value[u]);
                                    else if (C.size === 2) for (x = 0; x < T; x++) (u = v[x][1]), (N = C.value[u]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (o += 2);
                                    else if (C.size === 3)
                                        if (C.type === "c") for (x = 0; x < T; x++) (u = v[x][1]), (N = C.value[u]), (C.array[o] = N.r), (C.array[o + 1] = N.g), (C.array[o + 2] = N.b), (o += 3);
                                        else for (x = 0; x < T; x++) (u = v[x][1]), (N = C.value[u]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (C.array[o + 2] = N.z), (o += 3);
                                    else if (C.size === 4) for (x = 0; x < T; x++) (u = v[x][1]), (N = C.value[u]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (C.array[o + 2] = N.z), (C.array[o + 3] = N.w), (o += 4);
                                }
                        } else {
                            if (m) for (r = 0; r < l; r++) (s = f[r]), (o = r * 3), (p[o] = s.x), (p[o + 1] = s.y), (p[o + 2] = s.z);
                            if (y) for (i = 0; i < h; i++) (a = c[i]), (o = i * 3), (d[o] = a.r), (d[o + 1] = a.g), (d[o + 2] = a.b);
                            if (b)
                                for (w = 0, E = b.length; w < E; w++) {
                                    C = b[w];
                                    if (C.needsUpdate && (C.boundTo === undefined || C.boundTo === "vertices")) {
                                        (T = C.value.length), (o = 0);
                                        if (C.size === 1) for (x = 0; x < T; x++) C.array[x] = C.value[x];
                                        else if (C.size === 2) for (x = 0; x < T; x++) (N = C.value[x]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (o += 2);
                                        else if (C.size === 3)
                                            if (C.type === "c") for (x = 0; x < T; x++) (N = C.value[x]), (C.array[o] = N.r), (C.array[o + 1] = N.g), (C.array[o + 2] = N.b), (o += 3);
                                            else for (x = 0; x < T; x++) (N = C.value[x]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (C.array[o + 2] = N.z), (o += 3);
                                        else if (C.size === 4) for (x = 0; x < T; x++) (N = C.value[x]), (C.array[o] = N.x), (C.array[o + 1] = N.y), (C.array[o + 2] = N.z), (C.array[o + 3] = N.w), (o += 4);
                                    }
                                }
                        }
                        if (m || n.sortParticles) V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer), V.bufferData(V.ARRAY_BUFFER, p, t);
                        if (y || n.sortParticles) V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer), V.bufferData(V.ARRAY_BUFFER, d, t);
                        if (b)
                            for (w = 0, E = b.length; w < E; w++) {
                                C = b[w];
                                if (C.needsUpdate || n.sortParticles) V.bindBuffer(V.ARRAY_BUFFER, C.buffer), V.bufferData(V.ARRAY_BUFFER, C.array, t);
                            }
                    }
                    function zt(e, t) {
                        var n,
                            r,
                            i,
                            s,
                            o,
                            u,
                            a = e.vertices,
                            f = e.colors,
                            l = e.lineDistances,
                            c = a.length,
                            h = f.length,
                            p = l.length,
                            d = e.__vertexArray,
                            v = e.__colorArray,
                            m = e.__lineDistanceArray,
                            g = e.verticesNeedUpdate,
                            y = e.colorsNeedUpdate,
                            b = e.lineDistancesNeedUpdate,
                            w = e.__webglCustomAttributesList,
                            E,
                            S,
                            x,
                            T,
                            N,
                            C,
                            k;
                        if (g) {
                            for (n = 0; n < c; n++) (s = a[n]), (o = n * 3), (d[o] = s.x), (d[o + 1] = s.y), (d[o + 2] = s.z);
                            V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer), V.bufferData(V.ARRAY_BUFFER, d, t);
                        }
                        if (y) {
                            for (r = 0; r < h; r++) (u = f[r]), (o = r * 3), (v[o] = u.r), (v[o + 1] = u.g), (v[o + 2] = u.b);
                            V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer), V.bufferData(V.ARRAY_BUFFER, v, t);
                        }
                        if (b) {
                            for (i = 0; i < p; i++) m[i] = l[i];
                            V.bindBuffer(V.ARRAY_BUFFER, e.__webglLineDistanceBuffer), V.bufferData(V.ARRAY_BUFFER, m, t);
                        }
                        if (w)
                            for (E = 0, S = w.length; E < S; E++) {
                                k = w[E];
                                if (k.needsUpdate && (k.boundTo === undefined || k.boundTo === "vertices")) {
                                    (o = 0), (N = k.value.length);
                                    if (k.size === 1) for (T = 0; T < N; T++) k.array[T] = k.value[T];
                                    else if (k.size === 2) for (T = 0; T < N; T++) (C = k.value[T]), (k.array[o] = C.x), (k.array[o + 1] = C.y), (o += 2);
                                    else if (k.size === 3)
                                        if (k.type === "c") for (T = 0; T < N; T++) (C = k.value[T]), (k.array[o] = C.r), (k.array[o + 1] = C.g), (k.array[o + 2] = C.b), (o += 3);
                                        else for (T = 0; T < N; T++) (C = k.value[T]), (k.array[o] = C.x), (k.array[o + 1] = C.y), (k.array[o + 2] = C.z), (o += 3);
                                    else if (k.size === 4) for (T = 0; T < N; T++) (C = k.value[T]), (k.array[o] = C.x), (k.array[o + 1] = C.y), (k.array[o + 2] = C.z), (k.array[o + 3] = C.w), (o += 4);
                                    V.bindBuffer(V.ARRAY_BUFFER, k.buffer), V.bufferData(V.ARRAY_BUFFER, k.array, t);
                                }
                            }
                    }
                    function Wt(e, t, n, r, i) {
                        if (!e.__inittedArrays) return;
                        var s = Ft(i),
                            o = It(i),
                            u = qt(i),
                            a = s === THREE.SmoothShading,
                            f,
                            l,
                            c,
                            h,
                            p,
                            d,
                            v,
                            m,
                            g,
                            y,
                            b,
                            w,
                            E,
                            S,
                            x,
                            T,
                            N,
                            C,
                            k,
                            L,
                            A,
                            O,
                            M,
                            _,
                            D,
                            P,
                            H,
                            B,
                            j,
                            F,
                            I,
                            q,
                            R,
                            U,
                            z,
                            W,
                            X,
                            $,
                            J,
                            K,
                            Q,
                            G,
                            Y,
                            Z,
                            et,
                            tt,
                            nt,
                            rt,
                            it,
                            st,
                            ot,
                            ut,
                            at,
                            ft,
                            lt,
                            ct,
                            ht,
                            pt,
                            dt = 0,
                            vt = 0,
                            mt = 0,
                            gt = 0,
                            yt = 0,
                            bt = 0,
                            wt = 0,
                            Et = 0,
                            St = 0,
                            xt = 0,
                            Tt = 0,
                            Nt = 0,
                            Ct = 0,
                            kt,
                            Lt = e.__vertexArray,
                            At = e.__uvArray,
                            Ot = e.__uv2Array,
                            Mt = e.__normalArray,
                            _t = e.__tangentArray,
                            Dt = e.__colorArray,
                            Pt = e.__skinIndexArray,
                            Ht = e.__skinWeightArray,
                            Bt = e.__morphTargetsArrays,
                            jt = e.__morphNormalsArrays,
                            Rt = e.__webglCustomAttributesList,
                            Ut,
                            zt = e.__faceArray,
                            Wt = e.__lineArray,
                            Xt = t.geometry,
                            Vt = Xt.verticesNeedUpdate,
                            $t = Xt.elementsNeedUpdate,
                            Jt = Xt.uvsNeedUpdate,
                            Kt = Xt.normalsNeedUpdate,
                            Qt = Xt.tangentsNeedUpdate,
                            Gt = Xt.colorsNeedUpdate,
                            Yt = Xt.morphTargetsNeedUpdate,
                            Zt = Xt.vertices,
                            en = e.faces3,
                            tn = Xt.faces,
                            nn = Xt.faceVertexUvs[0],
                            rn = Xt.faceVertexUvs[1],
                            sn = Xt.colors,
                            on = Xt.skinIndices,
                            un = Xt.skinWeights,
                            an = Xt.morphTargets,
                            fn = Xt.morphNormals;
                        if (Vt) {
                            for (f = 0, l = en.length; f < l; f++)
                                (h = tn[en[f]]),
                                    (E = Zt[h.a]),
                                    (S = Zt[h.b]),
                                    (x = Zt[h.c]),
                                    (Lt[vt] = E.x),
                                    (Lt[vt + 1] = E.y),
                                    (Lt[vt + 2] = E.z),
                                    (Lt[vt + 3] = S.x),
                                    (Lt[vt + 4] = S.y),
                                    (Lt[vt + 5] = S.z),
                                    (Lt[vt + 6] = x.x),
                                    (Lt[vt + 7] = x.y),
                                    (Lt[vt + 8] = x.z),
                                    (vt += 9);
                            V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer), V.bufferData(V.ARRAY_BUFFER, Lt, n);
                        }
                        if (Yt)
                            for (ut = 0, at = an.length; ut < at; ut++) {
                                Tt = 0;
                                for (f = 0, l = en.length; f < l; f++)
                                    (ct = en[f]),
                                        (h = tn[ct]),
                                        (E = an[ut].vertices[h.a]),
                                        (S = an[ut].vertices[h.b]),
                                        (x = an[ut].vertices[h.c]),
                                        (ft = Bt[ut]),
                                        (ft[Tt] = E.x),
                                        (ft[Tt + 1] = E.y),
                                        (ft[Tt + 2] = E.z),
                                        (ft[Tt + 3] = S.x),
                                        (ft[Tt + 4] = S.y),
                                        (ft[Tt + 5] = S.z),
                                        (ft[Tt + 6] = x.x),
                                        (ft[Tt + 7] = x.y),
                                        (ft[Tt + 8] = x.z),
                                    i.morphNormals &&
                                    (a ? ((ht = fn[ut].vertexNormals[ct]), (A = ht.a), (O = ht.b), (M = ht.c)) : ((A = fn[ut].faceNormals[ct]), (O = A), (M = A)),
                                        (lt = jt[ut]),
                                        (lt[Tt] = A.x),
                                        (lt[Tt + 1] = A.y),
                                        (lt[Tt + 2] = A.z),
                                        (lt[Tt + 3] = O.x),
                                        (lt[Tt + 4] = O.y),
                                        (lt[Tt + 5] = O.z),
                                        (lt[Tt + 6] = M.x),
                                        (lt[Tt + 7] = M.y),
                                        (lt[Tt + 8] = M.z)),
                                        (Tt += 9);
                                V.bindBuffer(V.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[ut]),
                                    V.bufferData(V.ARRAY_BUFFER, Bt[ut], n),
                                i.morphNormals && (V.bindBuffer(V.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[ut]), V.bufferData(V.ARRAY_BUFFER, jt[ut], n));
                            }
                        if (un.length) {
                            for (f = 0, l = en.length; f < l; f++)
                                (h = tn[en[f]]),
                                    (j = un[h.a]),
                                    (F = un[h.b]),
                                    (I = un[h.c]),
                                    (Ht[xt] = j.x),
                                    (Ht[xt + 1] = j.y),
                                    (Ht[xt + 2] = j.z),
                                    (Ht[xt + 3] = j.w),
                                    (Ht[xt + 4] = F.x),
                                    (Ht[xt + 5] = F.y),
                                    (Ht[xt + 6] = F.z),
                                    (Ht[xt + 7] = F.w),
                                    (Ht[xt + 8] = I.x),
                                    (Ht[xt + 9] = I.y),
                                    (Ht[xt + 10] = I.z),
                                    (Ht[xt + 11] = I.w),
                                    (R = on[h.a]),
                                    (U = on[h.b]),
                                    (z = on[h.c]),
                                    (Pt[xt] = R.x),
                                    (Pt[xt + 1] = R.y),
                                    (Pt[xt + 2] = R.z),
                                    (Pt[xt + 3] = R.w),
                                    (Pt[xt + 4] = U.x),
                                    (Pt[xt + 5] = U.y),
                                    (Pt[xt + 6] = U.z),
                                    (Pt[xt + 7] = U.w),
                                    (Pt[xt + 8] = z.x),
                                    (Pt[xt + 9] = z.y),
                                    (Pt[xt + 10] = z.z),
                                    (Pt[xt + 11] = z.w),
                                    (xt += 12);
                            xt > 0 && (V.bindBuffer(V.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), V.bufferData(V.ARRAY_BUFFER, Pt, n), V.bindBuffer(V.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), V.bufferData(V.ARRAY_BUFFER, Ht, n));
                        }
                        if (Gt && o) {
                            for (f = 0, l = en.length; f < l; f++)
                                (h = tn[en[f]]),
                                    (m = h.vertexColors),
                                    (g = h.color),
                                    m.length === 3 && o === THREE.VertexColors ? ((D = m[0]), (P = m[1]), (H = m[2])) : ((D = g), (P = g), (H = g)),
                                    (Dt[St] = D.r),
                                    (Dt[St + 1] = D.g),
                                    (Dt[St + 2] = D.b),
                                    (Dt[St + 3] = P.r),
                                    (Dt[St + 4] = P.g),
                                    (Dt[St + 5] = P.b),
                                    (Dt[St + 6] = H.r),
                                    (Dt[St + 7] = H.g),
                                    (Dt[St + 8] = H.b),
                                    (St += 9);
                            St > 0 && (V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer), V.bufferData(V.ARRAY_BUFFER, Dt, n));
                        }
                        if (Qt && Xt.hasTangents) {
                            for (f = 0, l = en.length; f < l; f++)
                                (h = tn[en[f]]),
                                    (y = h.vertexTangents),
                                    (N = y[0]),
                                    (C = y[1]),
                                    (k = y[2]),
                                    (_t[wt] = N.x),
                                    (_t[wt + 1] = N.y),
                                    (_t[wt + 2] = N.z),
                                    (_t[wt + 3] = N.w),
                                    (_t[wt + 4] = C.x),
                                    (_t[wt + 5] = C.y),
                                    (_t[wt + 6] = C.z),
                                    (_t[wt + 7] = C.w),
                                    (_t[wt + 8] = k.x),
                                    (_t[wt + 9] = k.y),
                                    (_t[wt + 10] = k.z),
                                    (_t[wt + 11] = k.w),
                                    (wt += 12);
                            V.bindBuffer(V.ARRAY_BUFFER, e.__webglTangentBuffer), V.bufferData(V.ARRAY_BUFFER, _t, n);
                        }
                        if (Kt && s) {
                            for (f = 0, l = en.length; f < l; f++) {
                                (h = tn[en[f]]), (p = h.vertexNormals), (d = h.normal);
                                if (p.length === 3 && a) for (nt = 0; nt < 3; nt++) (it = p[nt]), (Mt[bt] = it.x), (Mt[bt + 1] = it.y), (Mt[bt + 2] = it.z), (bt += 3);
                                else for (nt = 0; nt < 3; nt++) (Mt[bt] = d.x), (Mt[bt + 1] = d.y), (Mt[bt + 2] = d.z), (bt += 3);
                            }
                            V.bindBuffer(V.ARRAY_BUFFER, e.__webglNormalBuffer), V.bufferData(V.ARRAY_BUFFER, Mt, n);
                        }
                        if (Jt && nn && u) {
                            for (f = 0, l = en.length; f < l; f++) {
                                (c = en[f]), (b = nn[c]);
                                if (b === undefined) continue;
                                for (nt = 0; nt < 3; nt++) (st = b[nt]), (At[mt] = st.x), (At[mt + 1] = st.y), (mt += 2);
                            }
                            mt > 0 && (V.bindBuffer(V.ARRAY_BUFFER, e.__webglUVBuffer), V.bufferData(V.ARRAY_BUFFER, At, n));
                        }
                        if (Jt && rn && u) {
                            for (f = 0, l = en.length; f < l; f++) {
                                (c = en[f]), (w = rn[c]);
                                if (w === undefined) continue;
                                for (nt = 0; nt < 3; nt++) (ot = w[nt]), (Ot[gt] = ot.x), (Ot[gt + 1] = ot.y), (gt += 2);
                            }
                            gt > 0 && (V.bindBuffer(V.ARRAY_BUFFER, e.__webglUV2Buffer), V.bufferData(V.ARRAY_BUFFER, Ot, n));
                        }
                        if ($t) {
                            for (f = 0, l = en.length; f < l; f++)
                                (zt[yt] = dt), (zt[yt + 1] = dt + 1), (zt[yt + 2] = dt + 2), (yt += 3), (Wt[Et] = dt), (Wt[Et + 1] = dt + 1), (Wt[Et + 2] = dt), (Wt[Et + 3] = dt + 2), (Wt[Et + 4] = dt + 1), (Wt[Et + 5] = dt + 2), (Et += 6), (dt += 3);
                            V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), V.bufferData(V.ELEMENT_ARRAY_BUFFER, zt, n), V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), V.bufferData(V.ELEMENT_ARRAY_BUFFER, Wt, n);
                        }
                        if (Rt)
                            for (nt = 0, rt = Rt.length; nt < rt; nt++) {
                                Ut = Rt[nt];
                                if (!Ut.__original.needsUpdate) continue;
                                (Nt = 0), (Ct = 0);
                                if (Ut.size === 1) {
                                    if (Ut.boundTo === undefined || Ut.boundTo === "vertices")
                                        for (f = 0, l = en.length; f < l; f++) (h = tn[en[f]]), (Ut.array[Nt] = Ut.value[h.a]), (Ut.array[Nt + 1] = Ut.value[h.b]), (Ut.array[Nt + 2] = Ut.value[h.c]), (Nt += 3);
                                    else if (Ut.boundTo === "faces") for (f = 0, l = en.length; f < l; f++) (kt = Ut.value[en[f]]), (Ut.array[Nt] = kt), (Ut.array[Nt + 1] = kt), (Ut.array[Nt + 2] = kt), (Nt += 3);
                                } else if (Ut.size === 2) {
                                    if (Ut.boundTo === undefined || Ut.boundTo === "vertices")
                                        for (f = 0, l = en.length; f < l; f++)
                                            (h = tn[en[f]]),
                                                (E = Ut.value[h.a]),
                                                (S = Ut.value[h.b]),
                                                (x = Ut.value[h.c]),
                                                (Ut.array[Nt] = E.x),
                                                (Ut.array[Nt + 1] = E.y),
                                                (Ut.array[Nt + 2] = S.x),
                                                (Ut.array[Nt + 3] = S.y),
                                                (Ut.array[Nt + 4] = x.x),
                                                (Ut.array[Nt + 5] = x.y),
                                                (Nt += 6);
                                    else if (Ut.boundTo === "faces")
                                        for (f = 0, l = en.length; f < l; f++)
                                            (kt = Ut.value[en[f]]),
                                                (E = kt),
                                                (S = kt),
                                                (x = kt),
                                                (Ut.array[Nt] = E.x),
                                                (Ut.array[Nt + 1] = E.y),
                                                (Ut.array[Nt + 2] = S.x),
                                                (Ut.array[Nt + 3] = S.y),
                                                (Ut.array[Nt + 4] = x.x),
                                                (Ut.array[Nt + 5] = x.y),
                                                (Nt += 6);
                                } else if (Ut.size === 3) {
                                    var ln;
                                    Ut.type === "c" ? (ln = ["r", "g", "b"]) : (ln = ["x", "y", "z"]);
                                    if (Ut.boundTo === undefined || Ut.boundTo === "vertices")
                                        for (f = 0, l = en.length; f < l; f++)
                                            (h = tn[en[f]]),
                                                (E = Ut.value[h.a]),
                                                (S = Ut.value[h.b]),
                                                (x = Ut.value[h.c]),
                                                (Ut.array[Nt] = E[ln[0]]),
                                                (Ut.array[Nt + 1] = E[ln[1]]),
                                                (Ut.array[Nt + 2] = E[ln[2]]),
                                                (Ut.array[Nt + 3] = S[ln[0]]),
                                                (Ut.array[Nt + 4] = S[ln[1]]),
                                                (Ut.array[Nt + 5] = S[ln[2]]),
                                                (Ut.array[Nt + 6] = x[ln[0]]),
                                                (Ut.array[Nt + 7] = x[ln[1]]),
                                                (Ut.array[Nt + 8] = x[ln[2]]),
                                                (Nt += 9);
                                    else if (Ut.boundTo === "faces")
                                        for (f = 0, l = en.length; f < l; f++)
                                            (kt = Ut.value[en[f]]),
                                                (E = kt),
                                                (S = kt),
                                                (x = kt),
                                                (Ut.array[Nt] = E[ln[0]]),
                                                (Ut.array[Nt + 1] = E[ln[1]]),
                                                (Ut.array[Nt + 2] = E[ln[2]]),
                                                (Ut.array[Nt + 3] = S[ln[0]]),
                                                (Ut.array[Nt + 4] = S[ln[1]]),
                                                (Ut.array[Nt + 5] = S[ln[2]]),
                                                (Ut.array[Nt + 6] = x[ln[0]]),
                                                (Ut.array[Nt + 7] = x[ln[1]]),
                                                (Ut.array[Nt + 8] = x[ln[2]]),
                                                (Nt += 9);
                                    else if (Ut.boundTo === "faceVertices")
                                        for (f = 0, l = en.length; f < l; f++)
                                            (kt = Ut.value[en[f]]),
                                                (E = kt[0]),
                                                (S = kt[1]),
                                                (x = kt[2]),
                                                (Ut.array[Nt] = E[ln[0]]),
                                                (Ut.array[Nt + 1] = E[ln[1]]),
                                                (Ut.array[Nt + 2] = E[ln[2]]),
                                                (Ut.array[Nt + 3] = S[ln[0]]),
                                                (Ut.array[Nt + 4] = S[ln[1]]),
                                                (Ut.array[Nt + 5] = S[ln[2]]),
                                                (Ut.array[Nt + 6] = x[ln[0]]),
                                                (Ut.array[Nt + 7] = x[ln[1]]),
                                                (Ut.array[Nt + 8] = x[ln[2]]),
                                                (Nt += 9);
                                } else if (Ut.size === 4)
                                    if (Ut.boundTo === undefined || Ut.boundTo === "vertices")
                                        for (f = 0, l = en.length; f < l; f++)
                                            (h = tn[en[f]]),
                                                (E = Ut.value[h.a]),
                                                (S = Ut.value[h.b]),
                                                (x = Ut.value[h.c]),
                                                (Ut.array[Nt] = E.x),
                                                (Ut.array[Nt + 1] = E.y),
                                                (Ut.array[Nt + 2] = E.z),
                                                (Ut.array[Nt + 3] = E.w),
                                                (Ut.array[Nt + 4] = S.x),
                                                (Ut.array[Nt + 5] = S.y),
                                                (Ut.array[Nt + 6] = S.z),
                                                (Ut.array[Nt + 7] = S.w),
                                                (Ut.array[Nt + 8] = x.x),
                                                (Ut.array[Nt + 9] = x.y),
                                                (Ut.array[Nt + 10] = x.z),
                                                (Ut.array[Nt + 11] = x.w),
                                                (Nt += 12);
                                    else if (Ut.boundTo === "faces")
                                        for (f = 0, l = en.length; f < l; f++)
                                            (kt = Ut.value[en[f]]),
                                                (E = kt),
                                                (S = kt),
                                                (x = kt),
                                                (Ut.array[Nt] = E.x),
                                                (Ut.array[Nt + 1] = E.y),
                                                (Ut.array[Nt + 2] = E.z),
                                                (Ut.array[Nt + 3] = E.w),
                                                (Ut.array[Nt + 4] = S.x),
                                                (Ut.array[Nt + 5] = S.y),
                                                (Ut.array[Nt + 6] = S.z),
                                                (Ut.array[Nt + 7] = S.w),
                                                (Ut.array[Nt + 8] = x.x),
                                                (Ut.array[Nt + 9] = x.y),
                                                (Ut.array[Nt + 10] = x.z),
                                                (Ut.array[Nt + 11] = x.w),
                                                (Nt += 12);
                                    else if (Ut.boundTo === "faceVertices")
                                        for (f = 0, l = en.length; f < l; f++)
                                            (kt = Ut.value[en[f]]),
                                                (E = kt[0]),
                                                (S = kt[1]),
                                                (x = kt[2]),
                                                (Ut.array[Nt] = E.x),
                                                (Ut.array[Nt + 1] = E.y),
                                                (Ut.array[Nt + 2] = E.z),
                                                (Ut.array[Nt + 3] = E.w),
                                                (Ut.array[Nt + 4] = S.x),
                                                (Ut.array[Nt + 5] = S.y),
                                                (Ut.array[Nt + 6] = S.z),
                                                (Ut.array[Nt + 7] = S.w),
                                                (Ut.array[Nt + 8] = x.x),
                                                (Ut.array[Nt + 9] = x.y),
                                                (Ut.array[Nt + 10] = x.z),
                                                (Ut.array[Nt + 11] = x.w),
                                                (Nt += 12);
                                V.bindBuffer(V.ARRAY_BUFFER, Ut.buffer), V.bufferData(V.ARRAY_BUFFER, Ut.array, n);
                            }
                        r &&
                        (delete e.__inittedArrays,
                            delete e.__colorArray,
                            delete e.__normalArray,
                            delete e.__tangentArray,
                            delete e.__uvArray,
                            delete e.__uv2Array,
                            delete e.__faceArray,
                            delete e.__vertexArray,
                            delete e.__lineArray,
                            delete e.__skinIndexArray,
                            delete e.__skinWeightArray);
                    }
                    function Xt(e, t, n) {
                        var r = e.attributes,
                            i,
                            s;
                        for (i in r)
                            (s = r[i]),
                            s.needsUpdate &&
                            (i === "index" ? (V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, s.buffer), V.bufferData(V.ELEMENT_ARRAY_BUFFER, s.array, t)) : (V.bindBuffer(V.ARRAY_BUFFER, s.buffer), V.bufferData(V.ARRAY_BUFFER, s.array, t)),
                                (s.needsUpdate = !1)),
                            n && !s.dynamic && (s.array = null);
                    }
                    function Vt(e) {
                        F[e] || (V.enableVertexAttribArray(e), (F[e] = !0));
                    }
                    function $t() {
                        for (var e in F) F[e] && (V.disableVertexAttribArray(e), (F[e] = !1));
                    }
                    function Jt(e, t, n) {
                        var r = e.program.attributes;
                        n.morphTargetBase !== -1 && r.position >= 0
                            ? (V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[n.morphTargetBase]), Vt(r.position), V.vertexAttribPointer(r.position, 3, V.FLOAT, !1, 0, 0))
                            : r.position >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, t.__webglVertexBuffer), Vt(r.position), V.vertexAttribPointer(r.position, 3, V.FLOAT, !1, 0, 0));
                        if (n.morphTargetForcedOrder.length) {
                            var i = 0,
                                s = n.morphTargetForcedOrder,
                                o = n.morphTargetInfluences;
                            while (i < e.numSupportedMorphTargets && i < s.length)
                                r["morphTarget" + i] >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[s[i]]), Vt(r["morphTarget" + i]), V.vertexAttribPointer(r["morphTarget" + i], 3, V.FLOAT, !1, 0, 0)),
                                r["morphNormal" + i] >= 0 && e.morphNormals && (V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphNormalsBuffers[s[i]]), Vt(r["morphNormal" + i]), V.vertexAttribPointer(r["morphNormal" + i], 3, V.FLOAT, !1, 0, 0)),
                                    (n.__webglMorphTargetInfluences[i] = o[s[i]]),
                                    i++;
                        } else {
                            var u,
                                a = [],
                                o = n.morphTargetInfluences,
                                f,
                                l = o.length;
                            for (f = 0; f < l; f++) (u = o[f]), u > 0 && a.push([u, f]);
                            a.length > e.numSupportedMorphTargets ? (a.sort(Qt), (a.length = e.numSupportedMorphTargets)) : a.length > e.numSupportedMorphNormals ? a.sort(Qt) : a.length === 0 && a.push([0, 0]);
                            var c,
                                i = 0;
                            while (i < e.numSupportedMorphTargets)
                                a[i]
                                    ? ((c = a[i][1]),
                                    r["morphTarget" + i] >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[c]), Vt(r["morphTarget" + i]), V.vertexAttribPointer(r["morphTarget" + i], 3, V.FLOAT, !1, 0, 0)),
                                    r["morphNormal" + i] >= 0 && e.morphNormals && (V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphNormalsBuffers[c]), Vt(r["morphNormal" + i]), V.vertexAttribPointer(r["morphNormal" + i], 3, V.FLOAT, !1, 0, 0)),
                                        (n.__webglMorphTargetInfluences[i] = o[c]))
                                    : (n.__webglMorphTargetInfluences[i] = 0),
                                    i++;
                        }
                        e.program.uniforms.morphTargetInfluences !== null && V.uniform1fv(e.program.uniforms.morphTargetInfluences, n.__webglMorphTargetInfluences);
                    }
                    function Kt(e, t) {
                        return e.z !== t.z ? t.z - e.z : e.id - t.id;
                    }
                    function Qt(e, t) {
                        return t[0] - e[0];
                    }
                    function Gt(e, t, n) {
                        if (!e.length) return;
                        for (var r = 0, i = e.length; r < i; r++)
                            (p = null),
                                (g = null),
                                (S = -1),
                                (C = -1),
                                (k = -1),
                                (w = -1),
                                (E = -1),
                                (m = -1),
                                (v = -1),
                                (W = !0),
                                e[r].render(t, n, B, j),
                                (p = null),
                                (g = null),
                                (S = -1),
                                (C = -1),
                                (k = -1),
                                (w = -1),
                                (E = -1),
                                (m = -1),
                                (v = -1),
                                (W = !0);
                    }
                    function Yt(e, t, n, r, i, s, o, u) {
                        var a, f, c, h, p, d, v;
                        t ? ((p = e.length - 1), (d = -1), (v = -1)) : ((p = 0), (d = e.length), (v = 1));
                        for (var m = p; m !== d; m += v) {
                            a = e[m];
                            if (a.render) {
                                (f = a.object), (c = a.buffer);
                                if (u) h = u;
                                else {
                                    h = a[n];
                                    if (!h) continue;
                                    o && l.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst), l.setDepthTest(h.depthTest), l.setDepthWrite(h.depthWrite), _n(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits);
                                }
                                l.setMaterialFaces(h), c instanceof THREE.BufferGeometry ? l.renderBufferDirect(r, i, s, h, c, f) : l.renderBuffer(r, i, s, h, c, f);
                            }
                        }
                    }
                    function Zt(e, t, n, r, i, s, o) {
                        var u, a, f, c;
                        for (var h = 0, p = e.length; h < p; h++) {
                            (u = e[h]), (a = u.object);
                            if (a.visible) {
                                if (o) f = o;
                                else {
                                    f = u[t];
                                    if (!f) continue;
                                    s && l.setBlending(f.blending, f.blendEquation, f.blendSrc, f.blendDst), l.setDepthTest(f.depthTest), l.setDepthWrite(f.depthWrite), _n(f.polygonOffset, f.polygonOffsetFactor, f.polygonOffsetUnits);
                                }
                                l.renderImmediateObject(n, r, i, f, a);
                            }
                        }
                    }
                    function en(e) {
                        var t = e.object,
                            n = t.material;
                        n.transparent ? ((e.transparent = n), (e.opaque = null)) : ((e.opaque = n), (e.transparent = null));
                    }
                    function tn(e) {
                        var t = e.object,
                            n = e.buffer,
                            r,
                            i,
                            s;
                        (s = t.material),
                            s instanceof THREE.MeshFaceMaterial
                                ? ((i = n.materialIndex), (r = s.materials[i]), r.transparent ? ((e.transparent = r), (e.opaque = null)) : ((e.opaque = r), (e.transparent = null)))
                                : ((r = s), r && (r.transparent ? ((e.transparent = r), (e.opaque = null)) : ((e.opaque = r), (e.transparent = null))));
                    }
                    function nn(e, t) {
                        var n,
                            r,
                            i,
                            s,
                            o,
                            u,
                            a = {},
                            f = e.morphTargets.length,
                            l = e.morphNormals.length,
                            c = t instanceof THREE.MeshFaceMaterial;
                        e.geometryGroups = {};
                        for (n = 0, r = e.faces.length; n < r; n++)
                            (i = e.faces[n]),
                                (s = c ? i.materialIndex : 0),
                            a[s] === undefined && (a[s] = { hash: s, counter: 0 }),
                                (u = a[s].hash + "_" + a[s].counter),
                            e.geometryGroups[u] === undefined && (e.geometryGroups[u] = { faces3: [], materialIndex: s, vertices: 0, numMorphTargets: f, numMorphNormals: l }),
                                (o = 3),
                            e.geometryGroups[u].vertices + o > 65535 &&
                            ((a[s].counter += 1), (u = a[s].hash + "_" + a[s].counter), e.geometryGroups[u] === undefined && (e.geometryGroups[u] = { faces3: [], materialIndex: s, vertices: 0, numMorphTargets: f, numMorphNormals: l })),
                                e.geometryGroups[u].faces3.push(n),
                                (e.geometryGroups[u].vertices += o);
                        e.geometryGroupsList = [];
                        for (var h in e.geometryGroups) (e.geometryGroups[h].id = y++), e.geometryGroupsList.push(e.geometryGroups[h]);
                    }
                    function rn(e, t) {
                        var n, r, i, s;
                        if (e.__webglInit === undefined) {
                            (e.__webglInit = !0),
                                (e._modelViewMatrix = new THREE.Matrix4()),
                                (e._normalMatrix = new THREE.Matrix3()),
                            e.geometry !== undefined && e.geometry.__webglInit === undefined && ((e.geometry.__webglInit = !0), e.geometry.addEventListener("dispose", xt)),
                                (r = e.geometry);
                            if (r !== undefined)
                                if (r instanceof THREE.BufferGeometry) Rt(r);
                                else if (e instanceof THREE.Mesh) {
                                    (i = e.material), r.geometryGroups === undefined && nn(r, i);
                                    for (n in r.geometryGroups)
                                        (s = r.geometryGroups[n]),
                                        s.__webglVertexBuffer ||
                                        (St(s),
                                            Ht(s, e),
                                            (r.verticesNeedUpdate = !0),
                                            (r.morphTargetsNeedUpdate = !0),
                                            (r.elementsNeedUpdate = !0),
                                            (r.uvsNeedUpdate = !0),
                                            (r.normalsNeedUpdate = !0),
                                            (r.tangentsNeedUpdate = !0),
                                            (r.colorsNeedUpdate = !0));
                                } else
                                    e instanceof THREE.Line
                                        ? r.__webglVertexBuffer || (Et(r), Pt(r, e), (r.verticesNeedUpdate = !0), (r.colorsNeedUpdate = !0), (r.lineDistancesNeedUpdate = !0))
                                        : e instanceof THREE.ParticleSystem && (r.__webglVertexBuffer || (wt(r), Dt(r, e), (r.verticesNeedUpdate = !0), (r.colorsNeedUpdate = !0)));
                        }
                        if (e.__webglActive === undefined) {
                            if (e instanceof THREE.Mesh) {
                                r = e.geometry;
                                if (r instanceof THREE.BufferGeometry) sn(t.__webglObjects, r, e);
                                else if (r instanceof THREE.Geometry) for (n in r.geometryGroups) (s = r.geometryGroups[n]), sn(t.__webglObjects, s, e);
                            } else
                                e instanceof THREE.Line || e instanceof THREE.ParticleSystem
                                    ? ((r = e.geometry), sn(t.__webglObjects, r, e))
                                    : e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback
                                    ? on(t.__webglObjectsImmediate, e)
                                    : e instanceof THREE.Sprite
                                        ? t.__webglSprites.push(e)
                                        : e instanceof THREE.LensFlare && t.__webglFlares.push(e);
                            e.__webglActive = !0;
                        }
                    }
                    function sn(e, t, n) {
                        e.push({ id: null, buffer: t, object: n, opaque: null, transparent: null, z: 0 });
                    }
                    function on(e, t) {
                        e.push({ id: null, object: t, opaque: null, transparent: null, z: 0 });
                    }
                    function un(e) {
                        var t = e.geometry,
                            n,
                            r,
                            i;
                        if (t instanceof THREE.BufferGeometry) Xt(t, V.DYNAMIC_DRAW, !t.dynamic);
                        else if (e instanceof THREE.Mesh) {
                            for (var s = 0, o = t.geometryGroupsList.length; s < o; s++)
                                (n = t.geometryGroupsList[s]),
                                    (i = Bt(e, n)),
                                t.buffersNeedUpdate && Ht(n, e),
                                    (r = i.attributes && an(i)),
                                (t.verticesNeedUpdate || t.morphTargetsNeedUpdate || t.elementsNeedUpdate || t.uvsNeedUpdate || t.normalsNeedUpdate || t.colorsNeedUpdate || t.tangentsNeedUpdate || r) && Wt(n, e, V.DYNAMIC_DRAW, !t.dynamic, i);
                            (t.verticesNeedUpdate = !1),
                                (t.morphTargetsNeedUpdate = !1),
                                (t.elementsNeedUpdate = !1),
                                (t.uvsNeedUpdate = !1),
                                (t.normalsNeedUpdate = !1),
                                (t.colorsNeedUpdate = !1),
                                (t.tangentsNeedUpdate = !1),
                                (t.buffersNeedUpdate = !1),
                            i.attributes && fn(i);
                        } else
                            e instanceof THREE.Line
                                ? ((i = Bt(e, t)),
                                    (r = i.attributes && an(i)),
                                (t.verticesNeedUpdate || t.colorsNeedUpdate || t.lineDistancesNeedUpdate || r) && zt(t, V.DYNAMIC_DRAW),
                                    (t.verticesNeedUpdate = !1),
                                    (t.colorsNeedUpdate = !1),
                                    (t.lineDistancesNeedUpdate = !1),
                                i.attributes && fn(i))
                                : e instanceof THREE.ParticleSystem &&
                                ((i = Bt(e, t)),
                                    (r = i.attributes && an(i)),
                                (t.verticesNeedUpdate || t.colorsNeedUpdate || e.sortParticles || r) && Ut(t, V.DYNAMIC_DRAW, e),
                                    (t.verticesNeedUpdate = !1),
                                    (t.colorsNeedUpdate = !1),
                                i.attributes && fn(i));
                    }
                    function an(e) {
                        for (var t in e.attributes) if (e.attributes[t].needsUpdate) return !0;
                        return !1;
                    }
                    function fn(e) {
                        for (var t in e.attributes) e.attributes[t].needsUpdate = !1;
                    }
                    function ln(e, t) {
                        e instanceof THREE.Mesh || e instanceof THREE.ParticleSystem || e instanceof THREE.Line
                            ? cn(t.__webglObjects, e)
                            : e instanceof THREE.Sprite
                            ? hn(t.__webglSprites, e)
                            : e instanceof THREE.LensFlare
                                ? hn(t.__webglFlares, e)
                                : (e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback) && cn(t.__webglObjectsImmediate, e),
                            delete e.__webglActive;
                    }
                    function cn(e, t) {
                        for (var n = e.length - 1; n >= 0; n--) e[n].object === t && e.splice(n, 1);
                    }
                    function hn(e, t) {
                        for (var n = e.length - 1; n >= 0; n--) e[n] === t && e.splice(n, 1);
                    }
                    function pn(e, t) {
                        (e.uniforms = THREE.UniformsUtils.clone(t.uniforms)), (e.vertexShader = t.vertexShader), (e.fragmentShader = t.fragmentShader);
                    }
                    function dn(e, t, n, r, i) {
                        (b = 0), r.needsUpdate && (r.program && Mt(r), l.initMaterial(r, t, n, i), (r.needsUpdate = !1)), r.morphTargets && (i.__webglMorphTargetInfluences || (i.__webglMorphTargetInfluences = new Float32Array(l.maxMorphTargets)));
                        var s = !1,
                            o = r.program,
                            u = o.uniforms,
                            a = r.uniforms;
                        o !== p && (V.useProgram(o), (p = o), (s = !0)), r.id !== v && ((v = r.id), (s = !0));
                        if (s || e !== g) V.uniformMatrix4fv(u.projectionMatrix, !1, e.projectionMatrix.elements), e !== g && (g = e);
                        if (r.skinning)
                            if (it && i.useVertexTexture) {
                                if (u.boneTexture !== null) {
                                    var f = Nn();
                                    V.uniform1i(u.boneTexture, f), l.setTexture(i.boneTexture, f);
                                }
                                u.boneTextureWidth !== null && V.uniform1i(u.boneTextureWidth, i.boneTextureWidth), u.boneTextureHeight !== null && V.uniform1i(u.boneTextureHeight, i.boneTextureHeight);
                            } else u.boneGlobalMatrices !== null && V.uniformMatrix4fv(u.boneGlobalMatrices, !1, i.boneMatrices);
                        if (s) {
                            n && r.fog && bn(a, n);
                            if (r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r.lights) W && (On(o, t), (W = !1)), Sn(a, X);
                            (r instanceof THREE.MeshBasicMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.MeshPhongMaterial) && vn(a, r),
                                r instanceof THREE.LineBasicMaterial
                                    ? mn(a, r)
                                    : r instanceof THREE.LineDashedMaterial
                                    ? (mn(a, r), gn(a, r))
                                    : r instanceof THREE.ParticleBasicMaterial
                                        ? yn(a, r)
                                        : r instanceof THREE.MeshPhongMaterial
                                            ? wn(a, r)
                                            : r instanceof THREE.MeshLambertMaterial
                                                ? En(a, r)
                                                : r instanceof THREE.MeshDepthMaterial
                                                    ? ((a.mNear.value = e.near), (a.mFar.value = e.far), (a.opacity.value = r.opacity))
                                                    : r instanceof THREE.MeshNormalMaterial && (a.opacity.value = r.opacity),
                            i.receiveShadow && !r._shadowPass && xn(a, t),
                                Cn(o, r.uniformsList),
                            (r instanceof THREE.ShaderMaterial || r instanceof THREE.MeshPhongMaterial || r.envMap) && u.cameraPosition !== null && (U.getPositionFromMatrix(e.matrixWorld), V.uniform3f(u.cameraPosition, U.x, U.y, U.z)),
                            (r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.ShaderMaterial || r.skinning) &&
                            u.viewMatrix !== null &&
                            V.uniformMatrix4fv(u.viewMatrix, !1, e.matrixWorldInverse.elements);
                        }
                        return Tn(u, i), u.modelMatrix !== null && V.uniformMatrix4fv(u.modelMatrix, !1, i.matrixWorld.elements), o;
                    }
                    function vn(e, t) {
                        (e.opacity.value = t.opacity),
                            l.gammaInput ? e.diffuse.value.copyGammaToLinear(t.color) : (e.diffuse.value = t.color),
                            (e.map.value = t.map),
                            (e.lightMap.value = t.lightMap),
                            (e.specularMap.value = t.specularMap),
                        t.bumpMap && ((e.bumpMap.value = t.bumpMap), (e.bumpScale.value = t.bumpScale)),
                        t.normalMap && ((e.normalMap.value = t.normalMap), e.normalScale.value.copy(t.normalScale));
                        var n;
                        t.map ? (n = t.map) : t.specularMap ? (n = t.specularMap) : t.normalMap ? (n = t.normalMap) : t.bumpMap && (n = t.bumpMap);
                        if (n !== undefined) {
                            var r = n.offset,
                                i = n.repeat;
                            e.offsetRepeat.value.set(r.x, r.y, i.x, i.y);
                        }
                        (e.envMap.value = t.envMap),
                            (e.flipEnvMap.value = t.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1),
                            l.gammaInput ? (e.reflectivity.value = t.reflectivity) : (e.reflectivity.value = t.reflectivity),
                            (e.refractionRatio.value = t.refractionRatio),
                            (e.combine.value = t.combine),
                            (e.useRefract.value = t.envMap && t.envMap.mapping instanceof THREE.CubeRefractionMapping);
                    }
                    function mn(e, t) {
                        (e.diffuse.value = t.color), (e.opacity.value = t.opacity);
                    }
                    function gn(e, t) {
                        (e.dashSize.value = t.dashSize), (e.totalSize.value = t.dashSize + t.gapSize), (e.scale.value = t.scale);
                    }
                    function yn(e, n) {
                        (e.psColor.value = n.color), (e.opacity.value = n.opacity), (e.size.value = n.size), (e.scale.value = t.height / 2), (e.map.value = n.map);
                    }
                    function bn(e, t) {
                        (e.fogColor.value = t.color), t instanceof THREE.Fog ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far)) : t instanceof THREE.FogExp2 && (e.fogDensity.value = t.density);
                    }
                    function wn(e, t) {
                        (e.shininess.value = t.shininess),
                            l.gammaInput
                                ? (e.ambient.value.copyGammaToLinear(t.ambient), e.emissive.value.copyGammaToLinear(t.emissive), e.specular.value.copyGammaToLinear(t.specular))
                                : ((e.ambient.value = t.ambient), (e.emissive.value = t.emissive), (e.specular.value = t.specular)),
                        t.wrapAround && e.wrapRGB.value.copy(t.wrapRGB);
                    }
                    function En(e, t) {
                        l.gammaInput ? (e.ambient.value.copyGammaToLinear(t.ambient), e.emissive.value.copyGammaToLinear(t.emissive)) : ((e.ambient.value = t.ambient), (e.emissive.value = t.emissive)), t.wrapAround && e.wrapRGB.value.copy(t.wrapRGB);
                    }
                    function Sn(e, t) {
                        (e.ambientLightColor.value = t.ambient),
                            (e.directionalLightColor.value = t.directional.colors),
                            (e.directionalLightDirection.value = t.directional.positions),
                            (e.pointLightColor.value = t.point.colors),
                            (e.pointLightPosition.value = t.point.positions),
                            (e.pointLightDistance.value = t.point.distances),
                            (e.spotLightColor.value = t.spot.colors),
                            (e.spotLightPosition.value = t.spot.positions),
                            (e.spotLightDistance.value = t.spot.distances),
                            (e.spotLightDirection.value = t.spot.directions),
                            (e.spotLightAngleCos.value = t.spot.anglesCos),
                            (e.spotLightExponent.value = t.spot.exponents),
                            (e.hemisphereLightSkyColor.value = t.hemi.skyColors),
                            (e.hemisphereLightGroundColor.value = t.hemi.groundColors),
                            (e.hemisphereLightDirection.value = t.hemi.positions);
                    }
                    function xn(e, t) {
                        if (e.shadowMatrix) {
                            var n = 0;
                            for (var r = 0, i = t.length; r < i; r++) {
                                var s = t[r];
                                if (!s.castShadow) continue;
                                if (s instanceof THREE.SpotLight || (s instanceof THREE.DirectionalLight && !s.shadowCascade))
                                    (e.shadowMap.value[n] = s.shadowMap),
                                        (e.shadowMapSize.value[n] = s.shadowMapSize),
                                        (e.shadowMatrix.value[n] = s.shadowMatrix),
                                        (e.shadowDarkness.value[n] = s.shadowDarkness),
                                        (e.shadowBias.value[n] = s.shadowBias),
                                        n++;
                            }
                        }
                    }
                    function Tn(e, t) {
                        V.uniformMatrix4fv(e.modelViewMatrix, !1, t._modelViewMatrix.elements), e.normalMatrix && V.uniformMatrix3fv(e.normalMatrix, !1, t._normalMatrix.elements);
                    }
                    function Nn() {
                        var e = b;
                        return e >= Y && console.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + Y), (b += 1), e;
                    }
                    function Cn(e, t) {
                        var n, r, i, s, o, u, a, f, c, h, p;
                        for (c = 0, h = t.length; c < h; c++) {
                            s = e.uniforms[t[c][1]];
                            if (!s) continue;
                            (n = t[c][0]), (i = n.type), (r = n.value);
                            if (i === "i") V.uniform1i(s, r);
                            else if (i === "f") V.uniform1f(s, r);
                            else if (i === "v2") V.uniform2f(s, r.x, r.y);
                            else if (i === "v3") V.uniform3f(s, r.x, r.y, r.z);
                            else if (i === "v4") V.uniform4f(s, r.x, r.y, r.z, r.w);
                            else if (i === "c") V.uniform3f(s, r.r, r.g, r.b);
                            else if (i === "iv1") V.uniform1iv(s, r);
                            else if (i === "iv") V.uniform3iv(s, r);
                            else if (i === "fv1") V.uniform1fv(s, r);
                            else if (i === "fv") V.uniform3fv(s, r);
                            else if (i === "v2v") {
                                n._array === undefined && (n._array = new Float32Array(2 * r.length));
                                for (a = 0, f = r.length; a < f; a++) (p = a * 2), (n._array[p] = r[a].x), (n._array[p + 1] = r[a].y);
                                V.uniform2fv(s, n._array);
                            } else if (i === "v3v") {
                                n._array === undefined && (n._array = new Float32Array(3 * r.length));
                                for (a = 0, f = r.length; a < f; a++) (p = a * 3), (n._array[p] = r[a].x), (n._array[p + 1] = r[a].y), (n._array[p + 2] = r[a].z);
                                V.uniform3fv(s, n._array);
                            } else if (i === "v4v") {
                                n._array === undefined && (n._array = new Float32Array(4 * r.length));
                                for (a = 0, f = r.length; a < f; a++) (p = a * 4), (n._array[p] = r[a].x), (n._array[p + 1] = r[a].y), (n._array[p + 2] = r[a].z), (n._array[p + 3] = r[a].w);
                                V.uniform4fv(s, n._array);
                            } else if (i === "m4") n._array === undefined && (n._array = new Float32Array(16)), r.flattenToArray(n._array), V.uniformMatrix4fv(s, !1, n._array);
                            else if (i === "m4v") {
                                n._array === undefined && (n._array = new Float32Array(16 * r.length));
                                for (a = 0, f = r.length; a < f; a++) r[a].flattenToArrayOffset(n._array, a * 16);
                                V.uniformMatrix4fv(s, !1, n._array);
                            } else if (i === "t") {
                                (o = r), (u = Nn()), V.uniform1i(s, u);
                                if (!o) continue;
                                o.image instanceof Array && o.image.length === 6 ? Un(o, u) : o instanceof THREE.WebGLRenderTargetCube ? zn(o, u) : l.setTexture(o, u);
                            } else if (i === "tv") {
                                n._array === undefined && (n._array = []);
                                for (a = 0, f = n.value.length; a < f; a++) n._array[a] = Nn();
                                V.uniform1iv(s, n._array);
                                for (a = 0, f = n.value.length; a < f; a++) {
                                    (o = n.value[a]), (u = n._array[a]);
                                    if (!o) continue;
                                    l.setTexture(o, u);
                                }
                            } else console.warn("THREE.WebGLRenderer: Unknown uniform type: " + i);
                        }
                    }
                    function kn(e, t) {
                        e._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, e.matrixWorld), e._normalMatrix.getNormalMatrix(e._modelViewMatrix);
                    }
                    function Ln(e, t, n, r) {
                        (e[t] = n.r * n.r * r), (e[t + 1] = n.g * n.g * r), (e[t + 2] = n.b * n.b * r);
                    }
                    function An(e, t, n, r) {
                        (e[t] = n.r * r), (e[t + 1] = n.g * r), (e[t + 2] = n.b * r);
                    }
                    function On(e, t) {
                        var n,
                            r,
                            i,
                            s,
                            o = 0,
                            u = 0,
                            a = 0,
                            f,
                            c,
                            h,
                            p,
                            d,
                            v,
                            m,
                            g = X,
                            y = g.directional.colors,
                            b = g.directional.positions,
                            w = g.point.colors,
                            E = g.point.positions,
                            S = g.point.distances,
                            x = g.spot.colors,
                            T = g.spot.positions,
                            N = g.spot.distances,
                            C = g.spot.directions,
                            k = g.spot.anglesCos,
                            L = g.spot.exponents,
                            A = g.hemi.skyColors,
                            O = g.hemi.groundColors,
                            M = g.hemi.positions,
                            _ = 0,
                            D = 0,
                            P = 0,
                            H = 0,
                            B = 0,
                            j = 0,
                            F = 0,
                            I = 0,
                            q = 0,
                            R = 0,
                            W = 0,
                            V = 0;
                        for (n = 0, r = t.length; n < r; n++) {
                            i = t[n];
                            if (i.onlyShadow) continue;
                            (f = i.color), (p = i.intensity), (m = i.distance);
                            if (i instanceof THREE.AmbientLight) {
                                if (!i.visible) continue;
                                l.gammaInput ? ((o += f.r * f.r), (u += f.g * f.g), (a += f.b * f.b)) : ((o += f.r), (u += f.g), (a += f.b));
                            } else if (i instanceof THREE.DirectionalLight) {
                                B += 1;
                                if (!i.visible) continue;
                                z.getPositionFromMatrix(i.matrixWorld), U.getPositionFromMatrix(i.target.matrixWorld), z.sub(U), z.normalize();
                                if (z.x === 0 && z.y === 0 && z.z === 0) continue;
                                (q = _ * 3), (b[q] = z.x), (b[q + 1] = z.y), (b[q + 2] = z.z), l.gammaInput ? Ln(y, q, f, p * p) : An(y, q, f, p), (_ += 1);
                            } else if (i instanceof THREE.PointLight) {
                                j += 1;
                                if (!i.visible) continue;
                                (R = D * 3), l.gammaInput ? Ln(w, R, f, p * p) : An(w, R, f, p), U.getPositionFromMatrix(i.matrixWorld), (E[R] = U.x), (E[R + 1] = U.y), (E[R + 2] = U.z), (S[D] = m), (D += 1);
                            } else if (i instanceof THREE.SpotLight) {
                                F += 1;
                                if (!i.visible) continue;
                                (W = P * 3),
                                    l.gammaInput ? Ln(x, W, f, p * p) : An(x, W, f, p),
                                    U.getPositionFromMatrix(i.matrixWorld),
                                    (T[W] = U.x),
                                    (T[W + 1] = U.y),
                                    (T[W + 2] = U.z),
                                    (N[P] = m),
                                    z.copy(U),
                                    U.getPositionFromMatrix(i.target.matrixWorld),
                                    z.sub(U),
                                    z.normalize(),
                                    (C[W] = z.x),
                                    (C[W + 1] = z.y),
                                    (C[W + 2] = z.z),
                                    (k[P] = Math.cos(i.angle)),
                                    (L[P] = i.exponent),
                                    (P += 1);
                            } else if (i instanceof THREE.HemisphereLight) {
                                I += 1;
                                if (!i.visible) continue;
                                z.getPositionFromMatrix(i.matrixWorld), z.normalize();
                                if (z.x === 0 && z.y === 0 && z.z === 0) continue;
                                (V = H * 3), (M[V] = z.x), (M[V + 1] = z.y), (M[V + 2] = z.z), (c = i.color), (h = i.groundColor), l.gammaInput ? ((d = p * p), Ln(A, V, c, d), Ln(O, V, h, d)) : (An(A, V, c, p), An(O, V, h, p)), (H += 1);
                            }
                        }
                        for (n = _ * 3, r = Math.max(y.length, B * 3); n < r; n++) y[n] = 0;
                        for (n = D * 3, r = Math.max(w.length, j * 3); n < r; n++) w[n] = 0;
                        for (n = P * 3, r = Math.max(x.length, F * 3); n < r; n++) x[n] = 0;
                        for (n = H * 3, r = Math.max(A.length, I * 3); n < r; n++) A[n] = 0;
                        for (n = H * 3, r = Math.max(O.length, I * 3); n < r; n++) O[n] = 0;
                        (g.directional.length = _), (g.point.length = D), (g.spot.length = P), (g.hemi.length = H), (g.ambient[0] = o), (g.ambient[1] = u), (g.ambient[2] = a);
                    }
                    function Mn(e) {
                        e !== M && (V.lineWidth(e), (M = e));
                    }
                    function _n(e, t, n) {
                        L !== e && (e ? V.enable(V.POLYGON_OFFSET_FILL) : V.disable(V.POLYGON_OFFSET_FILL), (L = e)), e && (A !== t || O !== n) && (V.polygonOffset(t, n), (A = t), (O = n));
                    }
                    function Dn(e) {
                        var t,
                            n,
                            r = [];
                        for (var i in e) {
                            t = e[i];
                            if (t === !1) continue;
                            (n = "#define " + i + " " + t), r.push(n);
                        }
                        return r.join("\n");
                    }
                    function Pn(e, t, r, i, s, o, u, a) {
                        var f,
                            p,
                            d,
                            v,
                            m,
                            g = [];
                        e ? g.push(e) : (g.push(t), g.push(r));
                        for (d in o) g.push(d), g.push(o[d]);
                        for (f in u) g.push(f), g.push(u[f]);
                        m = g.join();
                        for (f = 0, p = c.length; f < p; f++) {
                            var y = c[f];
                            if (y.code === m) return y.usedTimes++, y.program;
                        }
                        var b = "SHADOWMAP_TYPE_BASIC";
                        u.shadowMapType === THREE.PCFShadowMap ? (b = "SHADOWMAP_TYPE_PCF") : u.shadowMapType === THREE.PCFSoftShadowMap && (b = "SHADOWMAP_TYPE_PCF_SOFT");
                        var w = Dn(o);
                        v = V.createProgram();
                        var E = [
                                "precision " + n + " float;",
                                "precision " + n + " int;",
                                w,
                                rt ? "#define VERTEX_TEXTURES" : "",
                                l.gammaInput ? "#define GAMMA_INPUT" : "",
                                l.gammaOutput ? "#define GAMMA_OUTPUT" : "",
                                l.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",
                                "#define MAX_DIR_LIGHTS " + u.maxDirLights,
                                "#define MAX_POINT_LIGHTS " + u.maxPointLights,
                                "#define MAX_SPOT_LIGHTS " + u.maxSpotLights,
                                "#define MAX_HEMI_LIGHTS " + u.maxHemiLights,
                                "#define MAX_SHADOWS " + u.maxShadows,
                                "#define MAX_BONES " + u.maxBones,
                                u.map ? "#define USE_MAP" : "",
                                u.envMap ? "#define USE_ENVMAP" : "",
                                u.lightMap ? "#define USE_LIGHTMAP" : "",
                                u.bumpMap ? "#define USE_BUMPMAP" : "",
                                u.normalMap ? "#define USE_NORMALMAP" : "",
                                u.specularMap ? "#define USE_SPECULARMAP" : "",
                                u.vertexColors ? "#define USE_COLOR" : "",
                                u.skinning ? "#define USE_SKINNING" : "",
                                u.useVertexTexture ? "#define BONE_TEXTURE" : "",
                                u.morphTargets ? "#define USE_MORPHTARGETS" : "",
                                u.morphNormals ? "#define USE_MORPHNORMALS" : "",
                                u.perPixel ? "#define PHONG_PER_PIXEL" : "",
                                u.wrapAround ? "#define WRAP_AROUND" : "",
                                u.doubleSided ? "#define DOUBLE_SIDED" : "",
                                u.flipSided ? "#define FLIP_SIDED" : "",
                                u.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                                u.shadowMapEnabled ? "#define " + b : "",
                                u.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
                                u.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",
                                u.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                                "uniform mat4 modelMatrix;",
                                "uniform mat4 modelViewMatrix;",
                                "uniform mat4 projectionMatrix;",
                                "uniform mat4 viewMatrix;",
                                "uniform mat3 normalMatrix;",
                                "uniform vec3 cameraPosition;",
                                "attribute vec3 position;",
                                "attribute vec3 normal;",
                                "attribute vec2 uv;",
                                "attribute vec2 uv2;",
                                "#ifdef USE_COLOR",
                                "attribute vec3 color;",
                                "#endif",
                                "#ifdef USE_MORPHTARGETS",
                                "attribute vec3 morphTarget0;",
                                "attribute vec3 morphTarget1;",
                                "attribute vec3 morphTarget2;",
                                "attribute vec3 morphTarget3;",
                                "#ifdef USE_MORPHNORMALS",
                                "attribute vec3 morphNormal0;",
                                "attribute vec3 morphNormal1;",
                                "attribute vec3 morphNormal2;",
                                "attribute vec3 morphNormal3;",
                                "#else",
                                "attribute vec3 morphTarget4;",
                                "attribute vec3 morphTarget5;",
                                "attribute vec3 morphTarget6;",
                                "attribute vec3 morphTarget7;",
                                "#endif",
                                "#endif",
                                "#ifdef USE_SKINNING",
                                "attribute vec4 skinIndex;",
                                "attribute vec4 skinWeight;",
                                "#endif",
                                "",
                            ].join("\n"),
                            S = [
                                "precision " + n + " float;",
                                "precision " + n + " int;",
                                u.bumpMap || u.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "",
                                w,
                                "#define MAX_DIR_LIGHTS " + u.maxDirLights,
                                "#define MAX_POINT_LIGHTS " + u.maxPointLights,
                                "#define MAX_SPOT_LIGHTS " + u.maxSpotLights,
                                "#define MAX_HEMI_LIGHTS " + u.maxHemiLights,
                                "#define MAX_SHADOWS " + u.maxShadows,
                                u.alphaTest ? "#define ALPHATEST " + u.alphaTest : "",
                                l.gammaInput ? "#define GAMMA_INPUT" : "",
                                l.gammaOutput ? "#define GAMMA_OUTPUT" : "",
                                l.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",
                                u.useFog && u.fog ? "#define USE_FOG" : "",
                                u.useFog && u.fogExp ? "#define FOG_EXP2" : "",
                                u.map ? "#define USE_MAP" : "",
                                u.envMap ? "#define USE_ENVMAP" : "",
                                u.lightMap ? "#define USE_LIGHTMAP" : "",
                                u.bumpMap ? "#define USE_BUMPMAP" : "",
                                u.normalMap ? "#define USE_NORMALMAP" : "",
                                u.specularMap ? "#define USE_SPECULARMAP" : "",
                                u.vertexColors ? "#define USE_COLOR" : "",
                                u.metal ? "#define METAL" : "",
                                u.perPixel ? "#define PHONG_PER_PIXEL" : "",
                                u.wrapAround ? "#define WRAP_AROUND" : "",
                                u.doubleSided ? "#define DOUBLE_SIDED" : "",
                                u.flipSided ? "#define FLIP_SIDED" : "",
                                u.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                                u.shadowMapEnabled ? "#define " + b : "",
                                u.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
                                u.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",
                                "uniform mat4 viewMatrix;",
                                "uniform vec3 cameraPosition;",
                                "",
                            ].join("\n"),
                            x = Fn("vertex", E + r),
                            T = Fn("fragment", S + t);
                        V.attachShader(v, x),
                            V.attachShader(v, T),
                        a && V.bindAttribLocation(v, 0, a),
                            V.linkProgram(v),
                        V.getProgramParameter(v, V.LINK_STATUS) ||
                        (console.error("Could not initialise shader\nVALIDATE_STATUS: " + V.getProgramParameter(v, V.VALIDATE_STATUS) + ", gl error [" + V.getError() + "]"), console.error("Program Info Log: " + V.getProgramInfoLog(v))),
                            V.deleteShader(T),
                            V.deleteShader(x),
                            (v.uniforms = {}),
                            (v.attributes = {});
                        var N, C, k, L;
                        (N = ["viewMatrix", "modelViewMatrix", "projectionMatrix", "normalMatrix", "modelMatrix", "cameraPosition", "morphTargetInfluences"]),
                            u.useVertexTexture ? (N.push("boneTexture"), N.push("boneTextureWidth"), N.push("boneTextureHeight")) : N.push("boneGlobalMatrices");
                        for (C in i) N.push(C);
                        Hn(v, N), (N = ["position", "normal", "uv", "uv2", "tangent", "color", "skinIndex", "skinWeight", "lineDistance"]);
                        for (L = 0; L < u.maxMorphTargets; L++) N.push("morphTarget" + L);
                        for (L = 0; L < u.maxMorphNormals; L++) N.push("morphNormal" + L);
                        for (k in s) N.push(k);
                        return Bn(v, N), (v.id = h++), c.push({ program: v, code: m, usedTimes: 1 }), (l.info.memory.programs = c.length), v;
                    }
                    function Hn(e, t) {
                        var n, r, i;
                        for (n = 0, r = t.length; n < r; n++) (i = t[n]), (e.uniforms[i] = V.getUniformLocation(e, i));
                    }
                    function Bn(e, t) {
                        var n, r, i;
                        for (n = 0, r = t.length; n < r; n++) (i = t[n]), (e.attributes[i] = V.getAttribLocation(e, i));
                    }
                    function jn(e) {
                        var t = e.split("\n");
                        for (var n = 0, r = t.length; n < r; n++) t[n] = n + 1 + ": " + t[n];
                        return t.join("\n");
                    }
                    function Fn(e, t) {
                        var n;
                        return (
                            e === "fragment" ? (n = V.createShader(V.FRAGMENT_SHADER)) : e === "vertex" && (n = V.createShader(V.VERTEX_SHADER)),
                                V.shaderSource(n, t),
                                V.compileShader(n),
                                V.getShaderParameter(n, V.COMPILE_STATUS) ? n : (console.error(V.getShaderInfoLog(n)), console.error(jn(t)), null)
                        );
                    }
                    function In(e) {
                        return (e & (e - 1)) === 0;
                    }
                    function qn(e, t, n) {
                        n
                            ? (V.texParameteri(e, V.TEXTURE_WRAP_S, Jn(t.wrapS)), V.texParameteri(e, V.TEXTURE_WRAP_T, Jn(t.wrapT)), V.texParameteri(e, V.TEXTURE_MAG_FILTER, Jn(t.magFilter)), V.texParameteri(e, V.TEXTURE_MIN_FILTER, Jn(t.minFilter)))
                            : (V.texParameteri(e, V.TEXTURE_WRAP_S, V.CLAMP_TO_EDGE),
                                V.texParameteri(e, V.TEXTURE_WRAP_T, V.CLAMP_TO_EDGE),
                                V.texParameteri(e, V.TEXTURE_MAG_FILTER, $n(t.magFilter)),
                                V.texParameteri(e, V.TEXTURE_MIN_FILTER, $n(t.minFilter))),
                        Q && t.type !== THREE.FloatType && (t.anisotropy > 1 || t.__oldAnisotropy) && (V.texParameterf(e, Q.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, nt)), (t.__oldAnisotropy = t.anisotropy));
                    }
                    function Rn(e, t) {
                        if (e.width <= t && e.height <= t) return e;
                        var n = Math.max(e.width, e.height),
                            r = Math.floor((e.width * t) / n),
                            i = Math.floor((e.height * t) / n),
                            s = document.createElement("canvas");
                        (s.width = r), (s.height = i);
                        var o = s.getContext("2d");
                        return o.drawImage(e, 0, 0, e.width, e.height, 0, 0, r, i), s;
                    }
                    function Un(e, t) {
                        if (e.image.length === 6)
                            if (e.needsUpdate) {
                                e.image.__webglTextureCube || (e.addEventListener("dispose", Tt), (e.image.__webglTextureCube = V.createTexture()), l.info.memory.textures++),
                                    V.activeTexture(V.TEXTURE0 + t),
                                    V.bindTexture(V.TEXTURE_CUBE_MAP, e.image.__webglTextureCube),
                                    V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, e.flipY);
                                var n = e instanceof THREE.CompressedTexture,
                                    r = [];
                                for (var i = 0; i < 6; i++) l.autoScaleCubemaps && !n ? (r[i] = Rn(e.image[i], tt)) : (r[i] = e.image[i]);
                                var s = r[0],
                                    o = In(s.width) && In(s.height),
                                    u = Jn(e.format),
                                    a = Jn(e.type);
                                qn(V.TEXTURE_CUBE_MAP, e, o);
                                for (var i = 0; i < 6; i++)
                                    if (!n) V.texImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, u, u, a, r[i]);
                                    else {
                                        var f,
                                            c = r[i].mipmaps;
                                        for (var h = 0, p = c.length; h < p; h++)
                                            (f = c[h]),
                                                e.format !== THREE.RGBAFormat
                                                    ? V.compressedTexImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + i, h, u, f.width, f.height, 0, f.data)
                                                    : V.texImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + i, h, u, f.width, f.height, 0, u, a, f.data);
                                    }
                                e.generateMipmaps && o && V.generateMipmap(V.TEXTURE_CUBE_MAP), (e.needsUpdate = !1), e.onUpdate && e.onUpdate();
                            } else V.activeTexture(V.TEXTURE0 + t), V.bindTexture(V.TEXTURE_CUBE_MAP, e.image.__webglTextureCube);
                    }
                    function zn(e, t) {
                        V.activeTexture(V.TEXTURE0 + t), V.bindTexture(V.TEXTURE_CUBE_MAP, e.__webglTexture);
                    }
                    function Wn(e, t, n) {
                        V.bindFramebuffer(V.FRAMEBUFFER, e), V.framebufferTexture2D(V.FRAMEBUFFER, V.COLOR_ATTACHMENT0, n, t.__webglTexture, 0);
                    }
                    function Xn(e, t) {
                        V.bindRenderbuffer(V.RENDERBUFFER, e),
                            t.depthBuffer && !t.stencilBuffer
                                ? (V.renderbufferStorage(V.RENDERBUFFER, V.DEPTH_COMPONENT16, t.width, t.height), V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_ATTACHMENT, V.RENDERBUFFER, e))
                                : t.depthBuffer && t.stencilBuffer
                                ? (V.renderbufferStorage(V.RENDERBUFFER, V.DEPTH_STENCIL, t.width, t.height), V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_STENCIL_ATTACHMENT, V.RENDERBUFFER, e))
                                : V.renderbufferStorage(V.RENDERBUFFER, V.RGBA4, t.width, t.height);
                    }
                    function Vn(e) {
                        e instanceof THREE.WebGLRenderTargetCube
                            ? (V.bindTexture(V.TEXTURE_CUBE_MAP, e.__webglTexture), V.generateMipmap(V.TEXTURE_CUBE_MAP), V.bindTexture(V.TEXTURE_CUBE_MAP, null))
                            : (V.bindTexture(V.TEXTURE_2D, e.__webglTexture), V.generateMipmap(V.TEXTURE_2D), V.bindTexture(V.TEXTURE_2D, null));
                    }
                    function $n(e) {
                        return e === THREE.NearestFilter || e === THREE.NearestMipMapNearestFilter || e === THREE.NearestMipMapLinearFilter ? V.NEAREST : V.LINEAR;
                    }
                    function Jn(e) {
                        if (e === THREE.RepeatWrapping) return V.REPEAT;
                        if (e === THREE.ClampToEdgeWrapping) return V.CLAMP_TO_EDGE;
                        if (e === THREE.MirroredRepeatWrapping) return V.MIRRORED_REPEAT;
                        if (e === THREE.NearestFilter) return V.NEAREST;
                        if (e === THREE.NearestMipMapNearestFilter) return V.NEAREST_MIPMAP_NEAREST;
                        if (e === THREE.NearestMipMapLinearFilter) return V.NEAREST_MIPMAP_LINEAR;
                        if (e === THREE.LinearFilter) return V.LINEAR;
                        if (e === THREE.LinearMipMapNearestFilter) return V.LINEAR_MIPMAP_NEAREST;
                        if (e === THREE.LinearMipMapLinearFilter) return V.LINEAR_MIPMAP_LINEAR;
                        if (e === THREE.UnsignedByteType) return V.UNSIGNED_BYTE;
                        if (e === THREE.UnsignedShort4444Type) return V.UNSIGNED_SHORT_4_4_4_4;
                        if (e === THREE.UnsignedShort5551Type) return V.UNSIGNED_SHORT_5_5_5_1;
                        if (e === THREE.UnsignedShort565Type) return V.UNSIGNED_SHORT_5_6_5;
                        if (e === THREE.ByteType) return V.BYTE;
                        if (e === THREE.ShortType) return V.SHORT;
                        if (e === THREE.UnsignedShortType) return V.UNSIGNED_SHORT;
                        if (e === THREE.IntType) return V.INT;
                        if (e === THREE.UnsignedIntType) return V.UNSIGNED_INT;
                        if (e === THREE.FloatType) return V.FLOAT;
                        if (e === THREE.AlphaFormat) return V.ALPHA;
                        if (e === THREE.RGBFormat) return V.RGB;
                        if (e === THREE.RGBAFormat) return V.RGBA;
                        if (e === THREE.LuminanceFormat) return V.LUMINANCE;
                        if (e === THREE.LuminanceAlphaFormat) return V.LUMINANCE_ALPHA;
                        if (e === THREE.AddEquation) return V.FUNC_ADD;
                        if (e === THREE.SubtractEquation) return V.FUNC_SUBTRACT;
                        if (e === THREE.ReverseSubtractEquation) return V.FUNC_REVERSE_SUBTRACT;
                        if (e === THREE.ZeroFactor) return V.ZERO;
                        if (e === THREE.OneFactor) return V.ONE;
                        if (e === THREE.SrcColorFactor) return V.SRC_COLOR;
                        if (e === THREE.OneMinusSrcColorFactor) return V.ONE_MINUS_SRC_COLOR;
                        if (e === THREE.SrcAlphaFactor) return V.SRC_ALPHA;
                        if (e === THREE.OneMinusSrcAlphaFactor) return V.ONE_MINUS_SRC_ALPHA;
                        if (e === THREE.DstAlphaFactor) return V.DST_ALPHA;
                        if (e === THREE.OneMinusDstAlphaFactor) return V.ONE_MINUS_DST_ALPHA;
                        if (e === THREE.DstColorFactor) return V.DST_COLOR;
                        if (e === THREE.OneMinusDstColorFactor) return V.ONE_MINUS_DST_COLOR;
                        if (e === THREE.SrcAlphaSaturateFactor) return V.SRC_ALPHA_SATURATE;
                        if (G !== undefined) {
                            if (e === THREE.RGB_S3TC_DXT1_Format) return G.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (e === THREE.RGBA_S3TC_DXT1_Format) return G.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (e === THREE.RGBA_S3TC_DXT3_Format) return G.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (e === THREE.RGBA_S3TC_DXT5_Format) return G.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                        }
                        return 0;
                    }
                    function Kn(e) {
                        if (it && e && e.useVertexTexture) return 1024;
                        var t = V.getParameter(V.MAX_VERTEX_UNIFORM_VECTORS),
                            n = Math.floor((t - 20) / 4),
                            r = n;
                        return (
                            e !== undefined &&
                            e instanceof THREE.SkinnedMesh &&
                            ((r = Math.min(e.bones.length, r)), r < e.bones.length && console.warn("WebGLRenderer: too many bones - " + e.bones.length + ", this GPU supports just " + r + " (try OpenGL instead of ANGLE)")),
                                r
                        );
                    }
                    function Qn(e) {
                        var t = 0,
                            n = 0,
                            r = 0,
                            i = 0;
                        for (var s = 0, o = e.length; s < o; s++) {
                            var u = e[s];
                            if (u.onlyShadow) continue;
                            u instanceof THREE.DirectionalLight && t++, u instanceof THREE.PointLight && n++, u instanceof THREE.SpotLight && r++, u instanceof THREE.HemisphereLight && i++;
                        }
                        return { directional: t, point: n, spot: r, hemi: i };
                    }
                    function Gn(e) {
                        var t = 0;
                        for (var n = 0, r = e.length; n < r; n++) {
                            var i = e[n];
                            if (!i.castShadow) continue;
                            i instanceof THREE.SpotLight && t++, i instanceof THREE.DirectionalLight && !i.shadowCascade && t++;
                        }
                        return t;
                    }
                    function Yn() {
                        try {
                            var e = { alpha: r, premultipliedAlpha: i, antialias: s, stencil: o, preserveDrawingBuffer: u };
                            V = t.getContext("webgl", e) || t.getContext("experimental-webgl", e);
                            if (V === null) throw "Error creating WebGL context.";
                        } catch (n) {
                            console.error(n);
                        }
                        ($ = V.getExtension("OES_texture_float")),
                            (J = V.getExtension("OES_texture_float_linear")),
                            (K = V.getExtension("OES_standard_derivatives")),
                            (Q = V.getExtension("EXT_texture_filter_anisotropic") || V.getExtension("MOZ_EXT_texture_filter_anisotropic") || V.getExtension("WEBKIT_EXT_texture_filter_anisotropic")),
                            (G = V.getExtension("WEBGL_compressed_texture_s3tc") || V.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || V.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")),
                        $ || console.log("THREE.WebGLRenderer: Float textures not supported."),
                        K || console.log("THREE.WebGLRenderer: Standard derivatives not supported."),
                        Q || console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported."),
                        G || console.log("THREE.WebGLRenderer: S3TC compressed textures not supported."),
                        V.getShaderPrecisionFormat === undefined &&
                        (V.getShaderPrecisionFormat = function () {
                            return { rangeMin: 1, rangeMax: 1, precision: 1 };
                        });
                    }
                    function Zn() {
                        V.clearColor(0, 0, 0, 1),
                            V.clearDepth(1),
                            V.clearStencil(0),
                            V.enable(V.DEPTH_TEST),
                            V.depthFunc(V.LEQUAL),
                            V.frontFace(V.CCW),
                            V.cullFace(V.BACK),
                            V.enable(V.CULL_FACE),
                            V.enable(V.BLEND),
                            V.blendEquation(V.FUNC_ADD),
                            V.blendFunc(V.SRC_ALPHA, V.ONE_MINUS_SRC_ALPHA),
                            V.clearColor(a.r, a.g, a.b, f);
                    }
                    console.log("THREE.WebGLRenderer", THREE.REVISION), (e = e || {});
                    var t = e.canvas !== undefined ? e.canvas : document.createElement("canvas"),
                        n = e.precision !== undefined ? e.precision : "highp",
                        r = e.alpha !== undefined ? e.alpha : !0,
                        i = e.premultipliedAlpha !== undefined ? e.premultipliedAlpha : !0,
                        s = e.antialias !== undefined ? e.antialias : !1,
                        o = e.stencil !== undefined ? e.stencil : !0,
                        u = e.preserveDrawingBuffer !== undefined ? e.preserveDrawingBuffer : !1,
                        a = new THREE.Color(0),
                        f = 0;
                    (this.domElement = t),
                        (this.context = null),
                        (this.devicePixelRatio = e.devicePixelRatio !== undefined ? e.devicePixelRatio : self.devicePixelRatio !== undefined ? self.devicePixelRatio : 1),
                        (this.autoClear = !0),
                        (this.autoClearColor = !0),
                        (this.autoClearDepth = !0),
                        (this.autoClearStencil = !0),
                        (this.sortObjects = !0),
                        (this.autoUpdateObjects = !0),
                        (this.gammaInput = !1),
                        (this.gammaOutput = !1),
                        (this.physicallyBasedShading = !1),
                        (this.shadowMapEnabled = !1),
                        (this.shadowMapAutoUpdate = !0),
                        (this.shadowMapType = THREE.PCFShadowMap),
                        (this.shadowMapCullFace = THREE.CullFaceFront),
                        (this.shadowMapDebug = !1),
                        (this.shadowMapCascade = !1),
                        (this.maxMorphTargets = 8),
                        (this.maxMorphNormals = 4),
                        (this.autoScaleCubemaps = !0),
                        (this.renderPluginsPre = []),
                        (this.renderPluginsPost = []),
                        (this.info = { memory: { programs: 0, geometries: 0, textures: 0 }, render: { calls: 0, vertices: 0, faces: 0, points: 0 } });
                    var l = this,
                        c = [],
                        h = 0,
                        p = null,
                        d = null,
                        v = -1,
                        m = null,
                        g = null,
                        y = 0,
                        b = 0,
                        w = -1,
                        E = -1,
                        S = -1,
                        x = -1,
                        T = -1,
                        N = -1,
                        C = -1,
                        k = -1,
                        L = null,
                        A = null,
                        O = null,
                        M = null,
                        _ = 0,
                        D = 0,
                        P = 0,
                        H = 0,
                        B = 0,
                        j = 0,
                        F = {},
                        I = new THREE.Frustum(),
                        q = new THREE.Matrix4(),
                        R = new THREE.Matrix4(),
                        U = new THREE.Vector3(),
                        z = new THREE.Vector3(),
                        W = !0,
                        X = {
                            ambient: [0, 0, 0],
                            directional: { length: 0, colors: new Array(), positions: new Array() },
                            point: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },
                            spot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },
                            hemi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() },
                        },
                        V,
                        $,
                        J,
                        K,
                        Q,
                        G;
                    Yn(), Zn(), (this.context = V);
                    var Y = V.getParameter(V.MAX_TEXTURE_IMAGE_UNITS),
                        Z = V.getParameter(V.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                        et = V.getParameter(V.MAX_TEXTURE_SIZE),
                        tt = V.getParameter(V.MAX_CUBE_MAP_TEXTURE_SIZE),
                        nt = Q ? V.getParameter(Q.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
                        rt = Z > 0,
                        it = rt && $,
                        st = G ? V.getParameter(V.COMPRESSED_TEXTURE_FORMATS) : [],
                        ot = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.HIGH_FLOAT),
                        ut = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.MEDIUM_FLOAT),
                        at = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.LOW_FLOAT),
                        ft = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.HIGH_FLOAT),
                        lt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.MEDIUM_FLOAT),
                        ct = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.LOW_FLOAT),
                        ht = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.HIGH_INT),
                        pt = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.MEDIUM_INT),
                        dt = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.LOW_INT),
                        vt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.HIGH_INT),
                        mt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.MEDIUM_INT),
                        gt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.LOW_INT),
                        yt = ot.precision > 0 && ft.precision > 0,
                        bt = ut.precision > 0 && lt.precision > 0;
                    n === "highp" && !yt && (bt ? ((n = "mediump"), console.warn("WebGLRenderer: highp not supported, using mediump")) : ((n = "lowp"), console.warn("WebGLRenderer: highp and mediump not supported, using lowp"))),
                    n === "mediump" && !bt && ((n = "lowp"), console.warn("WebGLRenderer: mediump not supported, using lowp")),
                        (this.getContext = function () {
                            return V;
                        }),
                        (this.supportsVertexTextures = function () {
                            return rt;
                        }),
                        (this.supportsFloatTextures = function () {
                            return $;
                        }),
                        (this.supportsStandardDerivatives = function () {
                            return K;
                        }),
                        (this.supportsCompressedTextureS3TC = function () {
                            return G;
                        }),
                        (this.getMaxAnisotropy = function () {
                            return nt;
                        }),
                        (this.getPrecision = function () {
                            return n;
                        }),
                        (this.setSize = function (e, n, r) {
                            (t.width = e * this.devicePixelRatio), (t.height = n * this.devicePixelRatio), this.devicePixelRatio !== 1 && r !== !1 && ((t.style.width = e + "px"), (t.style.height = n + "px")), this.setViewport(0, 0, t.width, t.height);
                        }),
                        (this.setViewport = function (e, n, r, i) {
                            (_ = e !== undefined ? e : 0), (D = n !== undefined ? n : 0), (P = r !== undefined ? r : t.width), (H = i !== undefined ? i : t.height), V.viewport(_, D, P, H);
                        }),
                        (this.setScissor = function (e, t, n, r) {
                            V.scissor(e, t, n, r);
                        }),
                        (this.enableScissorTest = function (e) {
                            e ? V.enable(V.SCISSOR_TEST) : V.disable(V.SCISSOR_TEST);
                        }),
                        (this.setClearColor = function (e, t) {
                            a.set(e), (f = t !== undefined ? t : 1), V.clearColor(a.r, a.g, a.b, f);
                        }),
                        (this.setClearColorHex = function (e, t) {
                            console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t);
                        }),
                        (this.getClearColor = function () {
                            return a;
                        }),
                        (this.getClearAlpha = function () {
                            return f;
                        }),
                        (this.clear = function (e, t, n) {
                            var r = 0;
                            if (e === undefined || e) r |= V.COLOR_BUFFER_BIT;
                            if (t === undefined || t) r |= V.DEPTH_BUFFER_BIT;
                            if (n === undefined || n) r |= V.STENCIL_BUFFER_BIT;
                            V.clear(r);
                        }),
                        (this.clearTarget = function (e, t, n, r) {
                            this.setRenderTarget(e), this.clear(t, n, r);
                        }),
                        (this.addPostPlugin = function (e) {
                            e.init(this), this.renderPluginsPost.push(e);
                        }),
                        (this.addPrePlugin = function (e) {
                            e.init(this), this.renderPluginsPre.push(e);
                        }),
                        (this.updateShadowMap = function (e, t) {
                            (p = null), (S = -1), (C = -1), (k = -1), (m = -1), (v = -1), (W = !0), (w = -1), (E = -1), this.shadowMapPlugin.update(e, t);
                        });
                    var xt = function (e) {
                            var t = e.target;
                            t.removeEventListener("dispose", xt), Lt(t);
                        },
                        Tt = function (e) {
                            var t = e.target;
                            t.removeEventListener("dispose", Tt), At(t), l.info.memory.textures--;
                        },
                        Nt = function (e) {
                            var t = e.target;
                            t.removeEventListener("dispose", Nt), Ot(t), l.info.memory.textures--;
                        },
                        Ct = function (e) {
                            var t = e.target;
                            t.removeEventListener("dispose", Ct), Mt(t);
                        },
                        kt = function (e) {
                            e.__webglVertexBuffer !== undefined && V.deleteBuffer(e.__webglVertexBuffer),
                            e.__webglNormalBuffer !== undefined && V.deleteBuffer(e.__webglNormalBuffer),
                            e.__webglTangentBuffer !== undefined && V.deleteBuffer(e.__webglTangentBuffer),
                            e.__webglColorBuffer !== undefined && V.deleteBuffer(e.__webglColorBuffer),
                            e.__webglUVBuffer !== undefined && V.deleteBuffer(e.__webglUVBuffer),
                            e.__webglUV2Buffer !== undefined && V.deleteBuffer(e.__webglUV2Buffer),
                            e.__webglSkinIndicesBuffer !== undefined && V.deleteBuffer(e.__webglSkinIndicesBuffer),
                            e.__webglSkinWeightsBuffer !== undefined && V.deleteBuffer(e.__webglSkinWeightsBuffer),
                            e.__webglFaceBuffer !== undefined && V.deleteBuffer(e.__webglFaceBuffer),
                            e.__webglLineBuffer !== undefined && V.deleteBuffer(e.__webglLineBuffer),
                            e.__webglLineDistanceBuffer !== undefined && V.deleteBuffer(e.__webglLineDistanceBuffer);
                            if (e.__webglCustomAttributesList !== undefined) for (var t in e.__webglCustomAttributesList) V.deleteBuffer(e.__webglCustomAttributesList[t].buffer);
                            l.info.memory.geometries--;
                        },
                        Lt = function (e) {
                            e.__webglInit = undefined;
                            if (e instanceof THREE.BufferGeometry) {
                                var t = e.attributes;
                                for (var n in t) t[n].buffer !== undefined && V.deleteBuffer(t[n].buffer);
                                l.info.memory.geometries--;
                            } else if (e.geometryGroups !== undefined)
                                for (var r in e.geometryGroups) {
                                    var i = e.geometryGroups[r];
                                    if (i.numMorphTargets !== undefined) for (var s = 0, o = i.numMorphTargets; s < o; s++) V.deleteBuffer(i.__webglMorphTargetsBuffers[s]);
                                    if (i.numMorphNormals !== undefined) for (var s = 0, o = i.numMorphNormals; s < o; s++) V.deleteBuffer(i.__webglMorphNormalsBuffers[s]);
                                    kt(i);
                                }
                            else kt(e);
                        },
                        At = function (e) {
                            if (e.image && e.image.__webglTextureCube) V.deleteTexture(e.image.__webglTextureCube);
                            else {
                                if (!e.__webglInit) return;
                                (e.__webglInit = !1), V.deleteTexture(e.__webglTexture);
                            }
                        },
                        Ot = function (e) {
                            if (!e || !e.__webglTexture) return;
                            V.deleteTexture(e.__webglTexture);
                            if (e instanceof THREE.WebGLRenderTargetCube) for (var t = 0; t < 6; t++) V.deleteFramebuffer(e.__webglFramebuffer[t]), V.deleteRenderbuffer(e.__webglRenderbuffer[t]);
                            else V.deleteFramebuffer(e.__webglFramebuffer), V.deleteRenderbuffer(e.__webglRenderbuffer);
                        },
                        Mt = function (e) {
                            var t = e.program;
                            if (t === undefined) return;
                            e.program = undefined;
                            var n,
                                r,
                                i,
                                s = !1;
                            for (n = 0, r = c.length; n < r; n++) {
                                i = c[n];
                                if (i.program === t) {
                                    i.usedTimes--, i.usedTimes === 0 && (s = !0);
                                    break;
                                }
                            }
                            if (s === !0) {
                                var o = [];
                                for (n = 0, r = c.length; n < r; n++) (i = c[n]), i.program !== t && o.push(i);
                                (c = o), V.deleteProgram(t), l.info.memory.programs--;
                            }
                        };
                    (this.renderBufferImmediate = function (e, t, n) {
                        e.hasPositions && !e.__webglVertexBuffer && (e.__webglVertexBuffer = V.createBuffer()),
                        e.hasNormals && !e.__webglNormalBuffer && (e.__webglNormalBuffer = V.createBuffer()),
                        e.hasUvs && !e.__webglUvBuffer && (e.__webglUvBuffer = V.createBuffer()),
                        e.hasColors && !e.__webglColorBuffer && (e.__webglColorBuffer = V.createBuffer()),
                        e.hasPositions &&
                        (V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer),
                            V.bufferData(V.ARRAY_BUFFER, e.positionArray, V.DYNAMIC_DRAW),
                            V.enableVertexAttribArray(t.attributes.position),
                            V.vertexAttribPointer(t.attributes.position, 3, V.FLOAT, !1, 0, 0));
                        if (e.hasNormals) {
                            V.bindBuffer(V.ARRAY_BUFFER, e.__webglNormalBuffer);
                            if (n.shading === THREE.FlatShading) {
                                var r,
                                    i,
                                    s,
                                    o,
                                    u,
                                    a,
                                    f,
                                    l,
                                    c,
                                    h,
                                    p,
                                    d,
                                    v,
                                    m,
                                    g = e.count * 3;
                                for (m = 0; m < g; m += 9)
                                    (v = e.normalArray),
                                        (o = v[m]),
                                        (f = v[m + 1]),
                                        (h = v[m + 2]),
                                        (u = v[m + 3]),
                                        (l = v[m + 4]),
                                        (p = v[m + 5]),
                                        (a = v[m + 6]),
                                        (c = v[m + 7]),
                                        (d = v[m + 8]),
                                        (r = (o + u + a) / 3),
                                        (i = (f + l + c) / 3),
                                        (s = (h + p + d) / 3),
                                        (v[m] = r),
                                        (v[m + 1] = i),
                                        (v[m + 2] = s),
                                        (v[m + 3] = r),
                                        (v[m + 4] = i),
                                        (v[m + 5] = s),
                                        (v[m + 6] = r),
                                        (v[m + 7] = i),
                                        (v[m + 8] = s);
                            }
                            V.bufferData(V.ARRAY_BUFFER, e.normalArray, V.DYNAMIC_DRAW), V.enableVertexAttribArray(t.attributes.normal), V.vertexAttribPointer(t.attributes.normal, 3, V.FLOAT, !1, 0, 0);
                        }
                        e.hasUvs &&
                        n.map &&
                        (V.bindBuffer(V.ARRAY_BUFFER, e.__webglUvBuffer), V.bufferData(V.ARRAY_BUFFER, e.uvArray, V.DYNAMIC_DRAW), V.enableVertexAttribArray(t.attributes.uv), V.vertexAttribPointer(t.attributes.uv, 2, V.FLOAT, !1, 0, 0)),
                        e.hasColors &&
                        n.vertexColors !== THREE.NoColors &&
                        (V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer),
                            V.bufferData(V.ARRAY_BUFFER, e.colorArray, V.DYNAMIC_DRAW),
                            V.enableVertexAttribArray(t.attributes.color),
                            V.vertexAttribPointer(t.attributes.color, 3, V.FLOAT, !1, 0, 0)),
                            V.drawArrays(V.TRIANGLES, 0, e.count),
                            (e.count = 0);
                    }),
                        (this.renderBufferDirect = function (e, t, n, r, i, s) {
                            if (r.visible === !1) return;
                            var o,
                                u,
                                a,
                                f,
                                c,
                                h,
                                p,
                                d = dn(e, t, n, r, s),
                                v = d.attributes,
                                g = i.attributes,
                                y = !1,
                                b = r.wireframe ? 1 : 0,
                                w = i.id * 16777215 + d.id * 2 + b;
                            w !== m && ((m = w), (y = !0)), y && $t();
                            if (s instanceof THREE.Mesh) {
                                var E = g.index;
                                if (E) {
                                    var S = i.offsets;
                                    S.length > 1 && (y = !0);
                                    for (var x = 0, T = S.length; x < T; x++) {
                                        var N = S[x].index;
                                        if (y) {
                                            for (c in v)
                                                (h = v[c]),
                                                    (f = g[c]),
                                                h >= 0 &&
                                                (f
                                                    ? ((p = f.itemSize), V.bindBuffer(V.ARRAY_BUFFER, f.buffer), Vt(h), V.vertexAttribPointer(h, p, V.FLOAT, !1, 0, N * p * 4))
                                                    : r.defaultAttributeValues &&
                                                    (r.defaultAttributeValues[c].length === 2
                                                        ? V.vertexAttrib2fv(h, r.defaultAttributeValues[c])
                                                        : r.defaultAttributeValues[c].length === 3 && V.vertexAttrib3fv(h, r.defaultAttributeValues[c])));
                                            V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, E.buffer);
                                        }
                                        V.drawElements(V.TRIANGLES, S[x].count, V.UNSIGNED_SHORT, S[x].start * 2), l.info.render.calls++, (l.info.render.vertices += S[x].count), (l.info.render.faces += S[x].count / 3);
                                    }
                                } else {
                                    if (y)
                                        for (c in v) {
                                            if (c === "index") continue;
                                            (h = v[c]),
                                                (f = g[c]),
                                            h >= 0 &&
                                            (f
                                                ? ((p = f.itemSize), V.bindBuffer(V.ARRAY_BUFFER, f.buffer), Vt(h), V.vertexAttribPointer(h, p, V.FLOAT, !1, 0, 0))
                                                : r.defaultAttributeValues &&
                                                r.defaultAttributeValues[c] &&
                                                (r.defaultAttributeValues[c].length === 2 ? V.vertexAttrib2fv(h, r.defaultAttributeValues[c]) : r.defaultAttributeValues[c].length === 3 && V.vertexAttrib3fv(h, r.defaultAttributeValues[c])));
                                        }
                                    var C = i.attributes.position;
                                    V.drawArrays(V.TRIANGLES, 0, C.numItems / 3), l.info.render.calls++, (l.info.render.vertices += C.numItems / 3), (l.info.render.faces += C.numItems / 3 / 3);
                                }
                            } else if (s instanceof THREE.ParticleSystem) {
                                if (y) {
                                    for (c in v)
                                        (h = v[c]),
                                            (f = g[c]),
                                        h >= 0 &&
                                        (f
                                            ? ((p = f.itemSize), V.bindBuffer(V.ARRAY_BUFFER, f.buffer), Vt(h), V.vertexAttribPointer(h, p, V.FLOAT, !1, 0, 0))
                                            : r.defaultAttributeValues &&
                                            r.defaultAttributeValues[c] &&
                                            (r.defaultAttributeValues[c].length === 2 ? V.vertexAttrib2fv(h, r.defaultAttributeValues[c]) : r.defaultAttributeValues[c].length === 3 && V.vertexAttrib3fv(h, r.defaultAttributeValues[c])));
                                    var C = g.position;
                                    V.drawArrays(V.POINTS, 0, C.numItems / 3), l.info.render.calls++, (l.info.render.points += C.numItems / 3);
                                }
                            } else if (s instanceof THREE.Line && y) {
                                for (c in v)
                                    (h = v[c]),
                                        (f = g[c]),
                                    h >= 0 &&
                                    (f
                                        ? ((p = f.itemSize), V.bindBuffer(V.ARRAY_BUFFER, f.buffer), Vt(h), V.vertexAttribPointer(h, p, V.FLOAT, !1, 0, 0))
                                        : r.defaultAttributeValues &&
                                        r.defaultAttributeValues[c] &&
                                        (r.defaultAttributeValues[c].length === 2 ? V.vertexAttrib2fv(h, r.defaultAttributeValues[c]) : r.defaultAttributeValues[c].length === 3 && V.vertexAttrib3fv(h, r.defaultAttributeValues[c])));
                                var k = s.type === THREE.LineStrip ? V.LINE_STRIP : V.LINES;
                                Mn(r.linewidth);
                                var C = g.position;
                                V.drawArrays(k, 0, C.numItems / 3), l.info.render.calls++, (l.info.render.points += C.numItems);
                            }
                        }),
                        (this.renderBuffer = function (e, t, n, r, i, s) {
                            if (r.visible === !1) return;
                            var o,
                                u,
                                a,
                                f,
                                c,
                                h = dn(e, t, n, r, s),
                                p = h.attributes,
                                d = !1,
                                v = r.wireframe ? 1 : 0,
                                g = i.id * 16777215 + h.id * 2 + v;
                            g !== m && ((m = g), (d = !0)),
                            d && $t(),
                                !r.morphTargets && p.position >= 0 ? d && (V.bindBuffer(V.ARRAY_BUFFER, i.__webglVertexBuffer), Vt(p.position), V.vertexAttribPointer(p.position, 3, V.FLOAT, !1, 0, 0)) : s.morphTargetBase && Jt(r, i, s);
                            if (d) {
                                if (i.__webglCustomAttributesList)
                                    for (f = 0, c = i.__webglCustomAttributesList.length; f < c; f++)
                                        (a = i.__webglCustomAttributesList[f]),
                                        p[a.buffer.belongsToAttribute] >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, a.buffer), Vt(p[a.buffer.belongsToAttribute]), V.vertexAttribPointer(p[a.buffer.belongsToAttribute], a.size, V.FLOAT, !1, 0, 0));
                                p.color >= 0 &&
                                (s.geometry.colors.length > 0 || s.geometry.faces.length > 0
                                    ? (V.bindBuffer(V.ARRAY_BUFFER, i.__webglColorBuffer), Vt(p.color), V.vertexAttribPointer(p.color, 3, V.FLOAT, !1, 0, 0))
                                    : r.defaultAttributeValues && V.vertexAttrib3fv(p.color, r.defaultAttributeValues.color)),
                                p.normal >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, i.__webglNormalBuffer), Vt(p.normal), V.vertexAttribPointer(p.normal, 3, V.FLOAT, !1, 0, 0)),
                                p.tangent >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, i.__webglTangentBuffer), Vt(p.tangent), V.vertexAttribPointer(p.tangent, 4, V.FLOAT, !1, 0, 0)),
                                p.uv >= 0 &&
                                (s.geometry.faceVertexUvs[0]
                                    ? (V.bindBuffer(V.ARRAY_BUFFER, i.__webglUVBuffer), Vt(p.uv), V.vertexAttribPointer(p.uv, 2, V.FLOAT, !1, 0, 0))
                                    : r.defaultAttributeValues && V.vertexAttrib2fv(p.uv, r.defaultAttributeValues.uv)),
                                p.uv2 >= 0 &&
                                (s.geometry.faceVertexUvs[1]
                                    ? (V.bindBuffer(V.ARRAY_BUFFER, i.__webglUV2Buffer), Vt(p.uv2), V.vertexAttribPointer(p.uv2, 2, V.FLOAT, !1, 0, 0))
                                    : r.defaultAttributeValues && V.vertexAttrib2fv(p.uv2, r.defaultAttributeValues.uv2)),
                                r.skinning &&
                                p.skinIndex >= 0 &&
                                p.skinWeight >= 0 &&
                                (V.bindBuffer(V.ARRAY_BUFFER, i.__webglSkinIndicesBuffer),
                                    Vt(p.skinIndex),
                                    V.vertexAttribPointer(p.skinIndex, 4, V.FLOAT, !1, 0, 0),
                                    V.bindBuffer(V.ARRAY_BUFFER, i.__webglSkinWeightsBuffer),
                                    Vt(p.skinWeight),
                                    V.vertexAttribPointer(p.skinWeight, 4, V.FLOAT, !1, 0, 0)),
                                p.lineDistance >= 0 && (V.bindBuffer(V.ARRAY_BUFFER, i.__webglLineDistanceBuffer), Vt(p.lineDistance), V.vertexAttribPointer(p.lineDistance, 1, V.FLOAT, !1, 0, 0));
                            }
                            if (s instanceof THREE.Mesh)
                                r.wireframe
                                    ? (Mn(r.wireframeLinewidth), d && V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, i.__webglLineBuffer), V.drawElements(V.LINES, i.__webglLineCount, V.UNSIGNED_SHORT, 0))
                                    : (d && V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, i.__webglFaceBuffer), V.drawElements(V.TRIANGLES, i.__webglFaceCount, V.UNSIGNED_SHORT, 0)),
                                    l.info.render.calls++,
                                    (l.info.render.vertices += i.__webglFaceCount),
                                    (l.info.render.faces += i.__webglFaceCount / 3);
                            else if (s instanceof THREE.Line) {
                                var y = s.type === THREE.LineStrip ? V.LINE_STRIP : V.LINES;
                                Mn(r.linewidth), V.drawArrays(y, 0, i.__webglLineCount), l.info.render.calls++;
                            } else s instanceof THREE.ParticleSystem && (V.drawArrays(V.POINTS, 0, i.__webglParticleCount), l.info.render.calls++, (l.info.render.points += i.__webglParticleCount));
                        }),
                        (this.render = function (e, t, n, r) {
                            if (t instanceof THREE.Camera == 0) {
                                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                                return;
                            }
                            var i,
                                s,
                                o,
                                u,
                                a,
                                f = e.__lights,
                                c = e.fog;
                            (v = -1),
                                (W = !0),
                            e.autoUpdate === !0 && e.updateMatrixWorld(),
                            t.parent === undefined && t.updateMatrixWorld(),
                                t.matrixWorldInverse.getInverse(t.matrixWorld),
                                q.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                                I.setFromMatrix(q),
                            this.autoUpdateObjects && this.initWebGLObjects(e),
                                Gt(this.renderPluginsPre, e, t),
                                (l.info.render.calls = 0),
                                (l.info.render.vertices = 0),
                                (l.info.render.faces = 0),
                                (l.info.render.points = 0),
                                this.setRenderTarget(n),
                            (this.autoClear || r) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil),
                                (a = e.__webglObjects);
                            for (i = 0, s = a.length; i < s; i++)
                                (o = a[i]),
                                    (u = o.object),
                                    (o.id = i),
                                    (o.render = !1),
                                u.visible &&
                                (!(u instanceof THREE.Mesh || u instanceof THREE.ParticleSystem) || !u.frustumCulled || I.intersectsObject(u)) &&
                                (kn(u, t), tn(o), (o.render = !0), this.sortObjects === !0 && (u.renderDepth !== null ? (o.z = u.renderDepth) : (U.getPositionFromMatrix(u.matrixWorld), U.applyProjection(q), (o.z = U.z))));
                            this.sortObjects && a.sort(Kt), (a = e.__webglObjectsImmediate);
                            for (i = 0, s = a.length; i < s; i++) (o = a[i]), (u = o.object), u.visible && (kn(u, t), en(o));
                            if (e.overrideMaterial) {
                                var h = e.overrideMaterial;
                                this.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst),
                                    this.setDepthTest(h.depthTest),
                                    this.setDepthWrite(h.depthWrite),
                                    _n(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits),
                                    Yt(e.__webglObjects, !1, "", t, f, c, !0, h),
                                    Zt(e.__webglObjectsImmediate, "", t, f, c, !1, h);
                            } else {
                                var h = null;
                                this.setBlending(THREE.NoBlending),
                                    Yt(e.__webglObjects, !0, "opaque", t, f, c, !1, h),
                                    Zt(e.__webglObjectsImmediate, "opaque", t, f, c, !1, h),
                                    Yt(e.__webglObjects, !1, "transparent", t, f, c, !0, h),
                                    Zt(e.__webglObjectsImmediate, "transparent", t, f, c, !0, h);
                            }
                            Gt(this.renderPluginsPost, e, t), n && n.generateMipmaps && n.minFilter !== THREE.NearestFilter && n.minFilter !== THREE.LinearFilter && Vn(n), this.setDepthTest(!0), this.setDepthWrite(!0);
                        }),
                        (this.renderImmediateObject = function (e, t, n, r, i) {
                            var s = dn(e, t, n, r, i);
                            (m = -1),
                                l.setMaterialFaces(r),
                                i.immediateRenderCallback
                                    ? i.immediateRenderCallback(s, V, I)
                                    : i.render(function (e) {
                                        l.renderBufferImmediate(e, s, r);
                                    });
                        }),
                        (this.initWebGLObjects = function (e) {
                            e.__webglObjects || ((e.__webglObjects = []), (e.__webglObjectsImmediate = []), (e.__webglSprites = []), (e.__webglFlares = []));
                            while (e.__objectsAdded.length) rn(e.__objectsAdded[0], e), e.__objectsAdded.splice(0, 1);
                            while (e.__objectsRemoved.length) ln(e.__objectsRemoved[0], e), e.__objectsRemoved.splice(0, 1);
                            for (var t = 0, n = e.__webglObjects.length; t < n; t++) {
                                var r = e.__webglObjects[t].object;
                                r.__webglInit === undefined && (r.__webglActive !== undefined && ln(r, e), rn(r, e)), un(r);
                            }
                        }),
                        (this.initMaterial = function (e, t, n, r) {
                            e.addEventListener("dispose", Ct);
                            var i, s, o, u, a, f, l, c, h;
                            e instanceof THREE.MeshDepthMaterial
                                ? (h = "depth")
                                : e instanceof THREE.MeshNormalMaterial
                                ? (h = "normal")
                                : e instanceof THREE.MeshBasicMaterial
                                    ? (h = "basic")
                                    : e instanceof THREE.MeshLambertMaterial
                                        ? (h = "lambert")
                                        : e instanceof THREE.MeshPhongMaterial
                                            ? (h = "phong")
                                            : e instanceof THREE.LineBasicMaterial
                                                ? (h = "basic")
                                                : e instanceof THREE.LineDashedMaterial
                                                    ? (h = "dashed")
                                                    : e instanceof THREE.ParticleBasicMaterial && (h = "particle_basic"),
                            h && pn(e, THREE.ShaderLib[h]),
                                (f = Qn(t)),
                                (c = Gn(t)),
                                (l = Kn(r)),
                                (a = {
                                    map: !!e.map,
                                    envMap: !!e.envMap,
                                    lightMap: !!e.lightMap,
                                    bumpMap: !!e.bumpMap,
                                    normalMap: !!e.normalMap,
                                    specularMap: !!e.specularMap,
                                    vertexColors: e.vertexColors,
                                    fog: n,
                                    useFog: e.fog,
                                    fogExp: n instanceof THREE.FogExp2,
                                    sizeAttenuation: e.sizeAttenuation,
                                    skinning: e.skinning,
                                    maxBones: l,
                                    useVertexTexture: it && r && r.useVertexTexture,
                                    morphTargets: e.morphTargets,
                                    morphNormals: e.morphNormals,
                                    maxMorphTargets: this.maxMorphTargets,
                                    maxMorphNormals: this.maxMorphNormals,
                                    maxDirLights: f.directional,
                                    maxPointLights: f.point,
                                    maxSpotLights: f.spot,
                                    maxHemiLights: f.hemi,
                                    maxShadows: c,
                                    shadowMapEnabled: this.shadowMapEnabled && r.receiveShadow,
                                    shadowMapType: this.shadowMapType,
                                    shadowMapDebug: this.shadowMapDebug,
                                    shadowMapCascade: this.shadowMapCascade,
                                    alphaTest: e.alphaTest,
                                    metal: e.metal,
                                    perPixel: e.perPixel,
                                    wrapAround: e.wrapAround,
                                    doubleSided: e.side === THREE.DoubleSide,
                                    flipSided: e.side === THREE.BackSide,
                                }),
                                (e.program = Pn(h, e.fragmentShader, e.vertexShader, e.uniforms, e.attributes, e.defines, a, e.index0AttributeName));
                            var p = e.program.attributes;
                            if (e.morphTargets) {
                                e.numSupportedMorphTargets = 0;
                                var d,
                                    v = "morphTarget";
                                for (u = 0; u < this.maxMorphTargets; u++) (d = v + u), p[d] >= 0 && e.numSupportedMorphTargets++;
                            }
                            if (e.morphNormals) {
                                e.numSupportedMorphNormals = 0;
                                var d,
                                    v = "morphNormal";
                                for (u = 0; u < this.maxMorphNormals; u++) (d = v + u), p[d] >= 0 && e.numSupportedMorphNormals++;
                            }
                            e.uniformsList = [];
                            for (i in e.uniforms) e.uniformsList.push([e.uniforms[i], i]);
                        }),
                        (this.setFaceCulling = function (e, t) {
                            e === THREE.CullFaceNone
                                ? V.disable(V.CULL_FACE)
                                : (t === THREE.FrontFaceDirectionCW ? V.frontFace(V.CW) : V.frontFace(V.CCW),
                                    e === THREE.CullFaceBack ? V.cullFace(V.BACK) : e === THREE.CullFaceFront ? V.cullFace(V.FRONT) : V.cullFace(V.FRONT_AND_BACK),
                                    V.enable(V.CULL_FACE));
                        }),
                        (this.setMaterialFaces = function (e) {
                            var t = e.side === THREE.DoubleSide,
                                n = e.side === THREE.BackSide;
                            w !== t && (t ? V.disable(V.CULL_FACE) : V.enable(V.CULL_FACE), (w = t)), E !== n && (n ? V.frontFace(V.CW) : V.frontFace(V.CCW), (E = n));
                        }),
                        (this.setDepthTest = function (e) {
                            C !== e && (e ? V.enable(V.DEPTH_TEST) : V.disable(V.DEPTH_TEST), (C = e));
                        }),
                        (this.setDepthWrite = function (e) {
                            k !== e && (V.depthMask(e), (k = e));
                        }),
                        (this.setBlending = function (e, t, n, r) {
                            e !== S &&
                            (e === THREE.NoBlending
                                ? V.disable(V.BLEND)
                                : e === THREE.AdditiveBlending
                                    ? (V.enable(V.BLEND), V.blendEquation(V.FUNC_ADD), V.blendFunc(V.SRC_ALPHA, V.ONE))
                                    : e === THREE.SubtractiveBlending
                                        ? (V.enable(V.BLEND), V.blendEquation(V.FUNC_ADD), V.blendFunc(V.ZERO, V.ONE_MINUS_SRC_COLOR))
                                        : e === THREE.MultiplyBlending
                                            ? (V.enable(V.BLEND), V.blendEquation(V.FUNC_ADD), V.blendFunc(V.ZERO, V.SRC_COLOR))
                                            : e === THREE.CustomBlending
                                                ? V.enable(V.BLEND)
                                                : (V.enable(V.BLEND), V.blendEquationSeparate(V.FUNC_ADD, V.FUNC_ADD), V.blendFuncSeparate(V.SRC_ALPHA, V.ONE_MINUS_SRC_ALPHA, V.ONE, V.ONE_MINUS_SRC_ALPHA)),
                                (S = e));
                            if (e === THREE.CustomBlending) {
                                t !== x && (V.blendEquation(Jn(t)), (x = t));
                                if (n !== T || r !== N) V.blendFunc(Jn(n), Jn(r)), (T = n), (N = r);
                            } else (x = null), (T = null), (N = null);
                        }),
                        (this.setTexture = function (e, t) {
                            if (e.needsUpdate) {
                                e.__webglInit || ((e.__webglInit = !0), e.addEventListener("dispose", Tt), (e.__webglTexture = V.createTexture()), l.info.memory.textures++),
                                    V.activeTexture(V.TEXTURE0 + t),
                                    V.bindTexture(V.TEXTURE_2D, e.__webglTexture),
                                    V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, e.flipY),
                                    V.pixelStorei(V.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha),
                                    V.pixelStorei(V.UNPACK_ALIGNMENT, e.unpackAlignment);
                                var n = e.image,
                                    r = In(n.width) && In(n.height),
                                    i = Jn(e.format),
                                    s = Jn(e.type);
                                qn(V.TEXTURE_2D, e, r);
                                var o,
                                    u = e.mipmaps;
                                if (e instanceof THREE.DataTexture)
                                    if (u.length > 0 && r) {
                                        for (var a = 0, f = u.length; a < f; a++) (o = u[a]), V.texImage2D(V.TEXTURE_2D, a, i, o.width, o.height, 0, i, s, o.data);
                                        e.generateMipmaps = !1;
                                    } else V.texImage2D(V.TEXTURE_2D, 0, i, n.width, n.height, 0, i, s, n.data);
                                else if (e instanceof THREE.CompressedTexture)
                                    for (var a = 0, f = u.length; a < f; a++)
                                        (o = u[a]), e.format !== THREE.RGBAFormat ? V.compressedTexImage2D(V.TEXTURE_2D, a, i, o.width, o.height, 0, o.data) : V.texImage2D(V.TEXTURE_2D, a, i, o.width, o.height, 0, i, s, o.data);
                                else if (u.length > 0 && r) {
                                    for (var a = 0, f = u.length; a < f; a++) (o = u[a]), V.texImage2D(V.TEXTURE_2D, a, i, i, s, o);
                                    e.generateMipmaps = !1;
                                } else V.texImage2D(V.TEXTURE_2D, 0, i, i, s, e.image);
                                e.generateMipmaps && r && V.generateMipmap(V.TEXTURE_2D), (e.needsUpdate = !1), e.onUpdate && e.onUpdate();
                            } else V.activeTexture(V.TEXTURE0 + t), V.bindTexture(V.TEXTURE_2D, e.__webglTexture);
                        }),
                        (this.setRenderTarget = function (e) {
                            var t = e instanceof THREE.WebGLRenderTargetCube;
                            if (e && !e.__webglFramebuffer) {
                                e.depthBuffer === undefined && (e.depthBuffer = !0), e.stencilBuffer === undefined && (e.stencilBuffer = !0), e.addEventListener("dispose", Nt), (e.__webglTexture = V.createTexture()), l.info.memory.textures++;
                                var n = In(e.width) && In(e.height),
                                    r = Jn(e.format),
                                    i = Jn(e.type);
                                if (t) {
                                    (e.__webglFramebuffer = []), (e.__webglRenderbuffer = []), V.bindTexture(V.TEXTURE_CUBE_MAP, e.__webglTexture), qn(V.TEXTURE_CUBE_MAP, e, n);
                                    for (var s = 0; s < 6; s++)
                                        (e.__webglFramebuffer[s] = V.createFramebuffer()),
                                            (e.__webglRenderbuffer[s] = V.createRenderbuffer()),
                                            V.texImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, r, e.width, e.height, 0, r, i, null),
                                            Wn(e.__webglFramebuffer[s], e, V.TEXTURE_CUBE_MAP_POSITIVE_X + s),
                                            Xn(e.__webglRenderbuffer[s], e);
                                    n && V.generateMipmap(V.TEXTURE_CUBE_MAP);
                                } else
                                    (e.__webglFramebuffer = V.createFramebuffer()),
                                        e.shareDepthFrom ? (e.__webglRenderbuffer = e.shareDepthFrom.__webglRenderbuffer) : (e.__webglRenderbuffer = V.createRenderbuffer()),
                                        V.bindTexture(V.TEXTURE_2D, e.__webglTexture),
                                        qn(V.TEXTURE_2D, e, n),
                                        V.texImage2D(V.TEXTURE_2D, 0, r, e.width, e.height, 0, r, i, null),
                                        Wn(e.__webglFramebuffer, e, V.TEXTURE_2D),
                                        e.shareDepthFrom
                                            ? e.depthBuffer && !e.stencilBuffer
                                            ? V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_ATTACHMENT, V.RENDERBUFFER, e.__webglRenderbuffer)
                                            : e.depthBuffer && e.stencilBuffer && V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_STENCIL_ATTACHMENT, V.RENDERBUFFER, e.__webglRenderbuffer)
                                            : Xn(e.__webglRenderbuffer, e),
                                    n && V.generateMipmap(V.TEXTURE_2D);
                                t ? V.bindTexture(V.TEXTURE_CUBE_MAP, null) : V.bindTexture(V.TEXTURE_2D, null), V.bindRenderbuffer(V.RENDERBUFFER, null), V.bindFramebuffer(V.FRAMEBUFFER, null);
                            }
                            var o, u, a, f, c;
                            e ? (t ? (o = e.__webglFramebuffer[e.activeCubeFace]) : (o = e.__webglFramebuffer), (u = e.width), (a = e.height), (f = 0), (c = 0)) : ((o = null), (u = P), (a = H), (f = _), (c = D)),
                            o !== d && (V.bindFramebuffer(V.FRAMEBUFFER, o), V.viewport(f, c, u, a), (d = o)),
                                (B = u),
                                (j = a);
                        }),
                        (this.shadowMapPlugin = new THREE.ShadowMapPlugin()),
                        this.addPrePlugin(this.shadowMapPlugin),
                        this.addPostPlugin(new THREE.SpritePlugin()),
                        this.addPostPlugin(new THREE.LensFlarePlugin());
                }),
                (THREE.WebGLRenderTarget = function (e, t, n) {
                    (this.width = e),
                        (this.height = t),
                        (n = n || {}),
                        (this.wrapS = n.wrapS !== undefined ? n.wrapS : THREE.ClampToEdgeWrapping),
                        (this.wrapT = n.wrapT !== undefined ? n.wrapT : THREE.ClampToEdgeWrapping),
                        (this.magFilter = n.magFilter !== undefined ? n.magFilter : THREE.LinearFilter),
                        (this.minFilter = n.minFilter !== undefined ? n.minFilter : THREE.LinearMipMapLinearFilter),
                        (this.anisotropy = n.anisotropy !== undefined ? n.anisotropy : 1),
                        (this.offset = new THREE.Vector2(0, 0)),
                        (this.repeat = new THREE.Vector2(1, 1)),
                        (this.format = n.format !== undefined ? n.format : THREE.RGBAFormat),
                        (this.type = n.type !== undefined ? n.type : THREE.UnsignedByteType),
                        (this.depthBuffer = n.depthBuffer !== undefined ? n.depthBuffer : !0),
                        (this.stencilBuffer = n.stencilBuffer !== undefined ? n.stencilBuffer : !0),
                        (this.generateMipmaps = !0),
                        (this.shareDepthFrom = null);
                }),
                (THREE.WebGLRenderTarget.prototype = {
                    constructor: THREE.WebGLRenderTarget,
                    clone: function () {
                        var e = new THREE.WebGLRenderTarget(this.width, this.height);
                        return (
                            (e.wrapS = this.wrapS),
                                (e.wrapT = this.wrapT),
                                (e.magFilter = this.magFilter),
                                (e.minFilter = this.minFilter),
                                (e.anisotropy = this.anisotropy),
                                e.offset.copy(this.offset),
                                e.repeat.copy(this.repeat),
                                (e.format = this.format),
                                (e.type = this.type),
                                (e.depthBuffer = this.depthBuffer),
                                (e.stencilBuffer = this.stencilBuffer),
                                (e.generateMipmaps = this.generateMipmaps),
                                (e.shareDepthFrom = this.shareDepthFrom),
                                e
                        );
                    },
                    dispose: function () {
                        this.dispatchEvent({ type: "dispose" });
                    },
                }),
                THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype),
                (THREE.WebGLRenderTargetCube = function (e, t, n) {
                    THREE.WebGLRenderTarget.call(this, e, t, n), (this.activeCubeFace = 0);
                }),
                (THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype)),
                (THREE.RenderableVertex = function () {
                    (this.positionWorld = new THREE.Vector3()), (this.positionScreen = new THREE.Vector4()), (this.visible = !0);
                }),
                (THREE.RenderableVertex.prototype.copy = function (e) {
                    this.positionWorld.copy(e.positionWorld), this.positionScreen.copy(e.positionScreen);
                }),
                (THREE.RenderableFace3 = function () {
                    (this.id = 0),
                        (this.v1 = new THREE.RenderableVertex()),
                        (this.v2 = new THREE.RenderableVertex()),
                        (this.v3 = new THREE.RenderableVertex()),
                        (this.centroidModel = new THREE.Vector3()),
                        (this.normalModel = new THREE.Vector3()),
                        (this.normalModelView = new THREE.Vector3()),
                        (this.vertexNormalsLength = 0),
                        (this.vertexNormalsModel = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]),
                        (this.vertexNormalsModelView = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]),
                        (this.color = null),
                        (this.material = null),
                        (this.uvs = [[]]),
                        (this.z = 0);
                }),
                (THREE.RenderableObject = function () {
                    (this.id = 0), (this.object = null), (this.z = 0);
                }),
                (THREE.RenderableParticle = function () {
                    (this.id = 0), (this.object = null), (this.x = 0), (this.y = 0), (this.z = 0), (this.rotation = null), (this.scale = new THREE.Vector2()), (this.material = null);
                }),
                (THREE.RenderableLine = function () {
                    (this.id = 0), (this.v1 = new THREE.RenderableVertex()), (this.v2 = new THREE.RenderableVertex()), (this.vertexColors = [new THREE.Color(), new THREE.Color()]), (this.material = null), (this.z = 0);
                }),
                (THREE.GeometryUtils = {
                    merge: function (e, t, n) {
                        var r,
                            i,
                            s = e.vertices.length,
                            o = e.faceVertexUvs[0].length,
                            u = t instanceof THREE.Mesh ? t.geometry : t,
                            a = e.vertices,
                            f = u.vertices,
                            l = e.faces,
                            c = u.faces,
                            h = e.faceVertexUvs[0],
                            p = u.faceVertexUvs[0];
                        n === undefined && (n = 0), t instanceof THREE.Mesh && (t.matrixAutoUpdate && t.updateMatrix(), (r = t.matrix), (i = new THREE.Matrix3().getNormalMatrix(r)));
                        for (var d = 0, v = f.length; d < v; d++) {
                            var m = f[d],
                                g = m.clone();
                            r && g.applyMatrix4(r), a.push(g);
                        }
                        for (d = 0, v = c.length; d < v; d++) {
                            var y = c[d],
                                b,
                                w,
                                E,
                                S = y.vertexNormals,
                                x = y.vertexColors;
                            (b = new THREE.Face3(y.a + s, y.b + s, y.c + s)), b.normal.copy(y.normal), i && b.normal.applyMatrix3(i).normalize();
                            for (var T = 0, N = S.length; T < N; T++) (w = S[T].clone()), i && w.applyMatrix3(i).normalize(), b.vertexNormals.push(w);
                            b.color.copy(y.color);
                            for (var T = 0, N = x.length; T < N; T++) (E = x[T]), b.vertexColors.push(E.clone());
                            (b.materialIndex = y.materialIndex + n), b.centroid.copy(y.centroid), r && b.centroid.applyMatrix4(r), l.push(b);
                        }
                        for (d = 0, v = p.length; d < v; d++) {
                            var C = p[d],
                                k = [];
                            for (var T = 0, N = C.length; T < N; T++) k.push(new THREE.Vector2(C[T].x, C[T].y));
                            h.push(k);
                        }
                    },
                    randomPointInTriangle: (function () {
                        var e = new THREE.Vector3();
                        return function (t, n, r) {
                            var i = new THREE.Vector3(),
                                s = THREE.Math.random16(),
                                o = THREE.Math.random16();
                            s + o > 1 && ((s = 1 - s), (o = 1 - o));
                            var u = 1 - s - o;
                            return i.copy(t), i.multiplyScalar(s), e.copy(n), e.multiplyScalar(o), i.add(e), e.copy(r), e.multiplyScalar(u), i.add(e), i;
                        };
                    })(),
                    randomPointInFace: function (e, t, n) {
                        var r, i, s, o;
                        return (r = t.vertices[e.a]), (i = t.vertices[e.b]), (s = t.vertices[e.c]), THREE.GeometryUtils.randomPointInTriangle(r, i, s);
                    },
                    randomPointsInGeometry: function (e, t) {
                        function p(e) {
                            function t(n, r) {
                                if (r < n) return n;
                                var i = n + Math.floor((r - n) / 2);
                                return a[i] > e ? t(n, i - 1) : a[i] < e ? t(i + 1, r) : i;
                            }
                            var n = t(0, a.length - 1);
                            return n;
                        }
                        var n,
                            r,
                            i = e.faces,
                            s = e.vertices,
                            o = i.length,
                            u = 0,
                            a = [],
                            f,
                            l,
                            c,
                            h;
                        for (r = 0; r < o; r++) (n = i[r]), (f = s[n.a]), (l = s[n.b]), (c = s[n.c]), (n._area = THREE.GeometryUtils.triangleArea(f, l, c)), (u += n._area), (a[r] = u);
                        var d,
                            v,
                            m = [],
                            g = {};
                        for (r = 0; r < t; r++) (d = THREE.Math.random16() * u), (v = p(d)), (m[r] = THREE.GeometryUtils.randomPointInFace(i[v], e, !0)), g[v] ? (g[v] += 1) : (g[v] = 1);
                        return m;
                    },
                    triangleArea: (function () {
                        var e = new THREE.Vector3(),
                            t = new THREE.Vector3();
                        return function (n, r, i) {
                            return e.subVectors(r, n), t.subVectors(i, n), e.cross(t), 0.5 * e.length();
                        };
                    })(),
                    center: function (e) {
                        e.computeBoundingBox();
                        var t = e.boundingBox,
                            n = new THREE.Vector3();
                        return n.addVectors(t.min, t.max), n.multiplyScalar(-0.5), e.applyMatrix(new THREE.Matrix4().makeTranslation(n.x, n.y, n.z)), e.computeBoundingBox(), n;
                    },
                    triangulateQuads: function (e) {
                        var t,
                            n,
                            r,
                            i,
                            s = [],
                            o = [];
                        for (t = 0, n = e.faceVertexUvs.length; t < n; t++) o[t] = [];
                        for (t = 0, n = e.faces.length; t < n; t++) {
                            var u = e.faces[t];
                            s.push(u);
                            for (r = 0, i = e.faceVertexUvs.length; r < i; r++) o[r].push(e.faceVertexUvs[r][t]);
                        }
                        (e.faces = s), (e.faceVertexUvs = o), e.computeCentroids(), e.computeFaceNormals(), e.computeVertexNormals(), e.hasTangents && e.computeTangents();
                    },
                }),
                (THREE.ImageUtils = {
                    crossOrigin: "anonymous",
                    loadTexture: function (e, t, n, r) {
                        var i = new THREE.ImageLoader();
                        i.crossOrigin = this.crossOrigin;
                        var s = new THREE.Texture(undefined, t),
                            o = i.load(e, function () {
                                (s.needsUpdate = !0), n && n(s);
                            });
                        return (s.image = o), (s.sourceFile = e), s;
                    },
                    loadCompressedTexture: function (e, t, n, r) {
                        var i = new THREE.CompressedTexture();
                        i.mapping = t;
                        var s = new XMLHttpRequest();
                        return (
                            (s.onload = function () {
                                var e = s.response,
                                    t = THREE.ImageUtils.parseDDS(e, !0);
                                (i.format = t.format), (i.mipmaps = t.mipmaps), (i.image.width = t.width), (i.image.height = t.height), (i.generateMipmaps = !1), (i.needsUpdate = !0), n && n(i);
                            }),
                                (s.onerror = r),
                                s.open("GET", e, !0),
                                (s.responseType = "arraybuffer"),
                                s.send(null),
                                i
                        );
                    },
                    loadTextureCube: function (e, t, n, r) {
                        var i = [];
                        i.loadCount = 0;
                        var s = new THREE.Texture();
                        (s.image = i), t !== undefined && (s.mapping = t), (s.flipY = !1);
                        for (var o = 0, u = e.length; o < u; ++o) {
                            var a = new Image();
                            (i[o] = a),
                                (a.onload = function () {
                                    (i.loadCount += 1), i.loadCount === 6 && ((s.needsUpdate = !0), n && n(s));
                                }),
                                (a.onerror = r),
                                (a.crossOrigin = this.crossOrigin),
                                (a.src = e[o]);
                        }
                        return s;
                    },
                    loadCompressedTextureCube: function (e, t, n, r) {
                        var i = [];
                        i.loadCount = 0;
                        var s = new THREE.CompressedTexture();
                        (s.image = i), t !== undefined && (s.mapping = t), (s.flipY = !1), (s.generateMipmaps = !1);
                        var o = function (e, t) {
                            return function () {
                                var r = e.response,
                                    o = THREE.ImageUtils.parseDDS(r, !0);
                                (t.format = o.format), (t.mipmaps = o.mipmaps), (t.width = o.width), (t.height = o.height), (i.loadCount += 1), i.loadCount === 6 && ((s.format = o.format), (s.needsUpdate = !0), n && n(s));
                            };
                        };
                        if (e instanceof Array)
                            for (var u = 0, a = e.length; u < a; ++u) {
                                var f = {};
                                i[u] = f;
                                var l = new XMLHttpRequest();
                                (l.onload = o(l, f)), (l.onerror = r);
                                var c = e[u];
                                l.open("GET", c, !0), (l.responseType = "arraybuffer"), l.send(null);
                            }
                        else {
                            var c = e,
                                l = new XMLHttpRequest();
                            (l.onload = function () {
                                var e = l.response,
                                    t = THREE.ImageUtils.parseDDS(e, !0);
                                if (t.isCubemap) {
                                    var r = t.mipmaps.length / t.mipmapCount;
                                    for (var o = 0; o < r; o++) {
                                        i[o] = { mipmaps: [] };
                                        for (var u = 0; u < t.mipmapCount; u++) i[o].mipmaps.push(t.mipmaps[o * t.mipmapCount + u]), (i[o].format = t.format), (i[o].width = t.width), (i[o].height = t.height);
                                    }
                                    (s.format = t.format), (s.needsUpdate = !0), n && n(s);
                                }
                            }),
                                (l.onerror = r),
                                l.open("GET", c, !0),
                                (l.responseType = "arraybuffer"),
                                l.send(null);
                        }
                        return s;
                    },
                    loadDDSTexture: function (e, t, n, r) {
                        var i = [];
                        i.loadCount = 0;
                        var s = new THREE.CompressedTexture();
                        (s.image = i), t !== undefined && (s.mapping = t), (s.flipY = !1), (s.generateMipmaps = !1);
                        var o = new XMLHttpRequest();
                        return (
                            (o.onload = function () {
                                var e = o.response,
                                    t = THREE.ImageUtils.parseDDS(e, !0);
                                if (t.isCubemap) {
                                    var r = t.mipmaps.length / t.mipmapCount;
                                    for (var u = 0; u < r; u++) {
                                        i[u] = { mipmaps: [] };
                                        for (var a = 0; a < t.mipmapCount; a++) i[u].mipmaps.push(t.mipmaps[u * t.mipmapCount + a]), (i[u].format = t.format), (i[u].width = t.width), (i[u].height = t.height);
                                    }
                                } else (s.image.width = t.width), (s.image.height = t.height), (s.mipmaps = t.mipmaps);
                                (s.format = t.format), (s.needsUpdate = !0), n && n(s);
                            }),
                                (o.onerror = r),
                                o.open("GET", e, !0),
                                (o.responseType = "arraybuffer"),
                                o.send(null),
                                s
                        );
                    },
                    parseDDS: function (e, t) {
                        function A(e) {
                            return e.charCodeAt(0) + (e.charCodeAt(1) << 8) + (e.charCodeAt(2) << 16) + (e.charCodeAt(3) << 24);
                        }
                        function O(e) {
                            return String.fromCharCode(e & 255, (e >> 8) & 255, (e >> 16) & 255, (e >> 24) & 255);
                        }
                        function M(e, t, n, r) {
                            var i = n * r * 4,
                                s = new Uint8Array(e, t, i),
                                o = new Uint8Array(i),
                                u = 0,
                                a = 0;
                            for (var f = 0; f < r; f++)
                                for (var l = 0; l < n; l++) {
                                    var c = s[a];
                                    a++;
                                    var h = s[a];
                                    a++;
                                    var p = s[a];
                                    a++;
                                    var d = s[a];
                                    a++, (o[u] = p), u++, (o[u] = h), u++, (o[u] = c), u++, (o[u] = d), u++;
                                }
                            return o;
                        }
                        var n = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 },
                            r = 542327876,
                            i = 1,
                            s = 2,
                            o = 4,
                            u = 8,
                            a = 4096,
                            f = 131072,
                            l = 524288,
                            c = 8388608,
                            h = 8,
                            p = 4194304,
                            d = 4096,
                            v = 512,
                            m = 1024,
                            g = 2048,
                            y = 4096,
                            b = 8192,
                            w = 16384,
                            E = 32768,
                            S = 2097152,
                            x = 1,
                            T = 2,
                            N = 4,
                            C = 64,
                            k = 512,
                            L = 131072,
                            _ = A("DXT1"),
                            D = A("DXT3"),
                            P = A("DXT5"),
                            H = 31,
                            B = 0,
                            j = 1,
                            F = 2,
                            I = 3,
                            q = 4,
                            R = 7,
                            U = 20,
                            z = 21,
                            W = 22,
                            X = 23,
                            V = 24,
                            $ = 25,
                            J = 26,
                            K = 27,
                            Q = 28,
                            G = 29,
                            Y = 30,
                            Z = new Int32Array(e, 0, H);
                        if (Z[B] !== r) return console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"), n;
                        if (!Z[U] & N) return console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"), n;
                        var et,
                            tt = Z[z],
                            nt = !1;
                        switch (tt) {
                            case _:
                                (et = 8), (n.format = THREE.RGB_S3TC_DXT1_Format);
                                break;
                            case D:
                                (et = 16), (n.format = THREE.RGBA_S3TC_DXT3_Format);
                                break;
                            case P:
                                (et = 16), (n.format = THREE.RGBA_S3TC_DXT5_Format);
                                break;
                            default:
                                if (!(Z[W] == 32 && Z[X] & 16711680 && Z[V] & 65280 && Z[$] & 255 && Z[J] & 4278190080)) return console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ", O(tt)), n;
                                (nt = !0), (et = 64), (n.format = THREE.RGBAFormat);
                        }
                        (n.mipmapCount = 1), Z[F] & f && t !== !1 && (n.mipmapCount = Math.max(1, Z[R])), (n.isCubemap = Z[Q] & v ? !0 : !1), (n.width = Z[q]), (n.height = Z[I]);
                        var rt = Z[j] + 4,
                            it = n.width,
                            st = n.height,
                            ot = n.isCubemap ? 6 : 1;
                        for (var ut = 0; ut < ot; ut++) {
                            for (var at = 0; at < n.mipmapCount; at++) {
                                if (nt)
                                    var ft = M(e, rt, it, st),
                                        lt = ft.length;
                                else
                                    var lt = (((Math.max(4, it) / 4) * Math.max(4, st)) / 4) * et,
                                        ft = new Uint8Array(e, rt, lt);
                                var ct = { data: ft, width: it, height: st };
                                n.mipmaps.push(ct), (rt += lt), (it = Math.max(it * 0.5, 1)), (st = Math.max(st * 0.5, 1));
                            }
                            (it = n.width), (st = n.height);
                        }
                        return n;
                    },
                    getNormalMap: function (e, t) {
                        var n = function (e, t) {
                                return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
                            },
                            r = function (e, t) {
                                return [e[0] - t[0], e[1] - t[1], e[2] - t[2]];
                            },
                            i = function (e) {
                                var t = Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
                                return [e[0] / t, e[1] / t, e[2] / t];
                            };
                        t |= 1;
                        var s = e.width,
                            o = e.height,
                            u = document.createElement("canvas");
                        (u.width = s), (u.height = o);
                        var a = u.getContext("2d");
                        a.drawImage(e, 0, 0);
                        var f = a.getImageData(0, 0, s, o).data,
                            l = a.createImageData(s, o),
                            c = l.data;
                        for (var h = 0; h < s; h++)
                            for (var p = 0; p < o; p++) {
                                var d = p - 1 < 0 ? 0 : p - 1,
                                    v = p + 1 > o - 1 ? o - 1 : p + 1,
                                    m = h - 1 < 0 ? 0 : h - 1,
                                    g = h + 1 > s - 1 ? s - 1 : h + 1,
                                    y = [],
                                    b = [0, 0, (f[(p * s + h) * 4] / 255) * t];
                                y.push([-1, 0, (f[(p * s + m) * 4] / 255) * t]),
                                    y.push([-1, -1, (f[(d * s + m) * 4] / 255) * t]),
                                    y.push([0, -1, (f[(d * s + h) * 4] / 255) * t]),
                                    y.push([1, -1, (f[(d * s + g) * 4] / 255) * t]),
                                    y.push([1, 0, (f[(p * s + g) * 4] / 255) * t]),
                                    y.push([1, 1, (f[(v * s + g) * 4] / 255) * t]),
                                    y.push([0, 1, (f[(v * s + h) * 4] / 255) * t]),
                                    y.push([-1, 1, (f[(v * s + m) * 4] / 255) * t]);
                                var w = [],
                                    E = y.length;
                                for (var S = 0; S < E; S++) {
                                    var x = y[S],
                                        T = y[(S + 1) % E];
                                    (x = r(x, b)), (T = r(T, b)), w.push(i(n(x, T)));
                                }
                                var N = [0, 0, 0];
                                for (var S = 0; S < w.length; S++) (N[0] += w[S][0]), (N[1] += w[S][1]), (N[2] += w[S][2]);
                                (N[0] /= w.length), (N[1] /= w.length), (N[2] /= w.length);
                                var C = (p * s + h) * 4;
                                (c[C] = (((N[0] + 1) / 2) * 255) | 0), (c[C + 1] = (((N[1] + 1) / 2) * 255) | 0), (c[C + 2] = (N[2] * 255) | 0), (c[C + 3] = 255);
                            }
                        return a.putImageData(l, 0, 0), u;
                    },
                    generateDataTexture: function (e, t, n) {
                        var r = e * t,
                            i = new Uint8Array(3 * r),
                            s = Math.floor(n.r * 255),
                            o = Math.floor(n.g * 255),
                            u = Math.floor(n.b * 255);
                        for (var a = 0; a < r; a++) (i[a * 3] = s), (i[a * 3 + 1] = o), (i[a * 3 + 2] = u);
                        var f = new THREE.DataTexture(i, e, t, THREE.RGBFormat);
                        return (f.needsUpdate = !0), f;
                    },
                }),
                (THREE.SceneUtils = {
                    createMultiMaterialObject: function (e, t) {
                        var n = new THREE.Object3D();
                        for (var r = 0, i = t.length; r < i; r++) n.add(new THREE.Mesh(e, t[r]));
                        return n;
                    },
                    detach: function (e, t, n) {
                        e.applyMatrix(t.matrixWorld), t.remove(e), n.add(e);
                    },
                    attach: function (e, t, n) {
                        var r = new THREE.Matrix4();
                        r.getInverse(n.matrixWorld), e.applyMatrix(r), t.remove(e), n.add(e);
                    },
                }),
                (THREE.FontUtils = {
                    faces: {},
                    face: "helvetiker",
                    weight: "normal",
                    style: "normal",
                    size: 150,
                    divisions: 10,
                    getFace: function () {
                        return this.faces[this.face][this.weight][this.style];
                    },
                    loadFace: function (e) {
                        var t = e.familyName.toLowerCase(),
                            n = this;
                        (n.faces[t] = n.faces[t] || {}), (n.faces[t][e.cssFontWeight] = n.faces[t][e.cssFontWeight] || {}), (n.faces[t][e.cssFontWeight][e.cssFontStyle] = e);
                        var r = (n.faces[t][e.cssFontWeight][e.cssFontStyle] = e);
                        return e;
                    },
                    drawText: function (e) {
                        var t = [],
                            n = [],
                            r,
                            i,
                            s = this.getFace(),
                            o = this.size / s.resolution,
                            u = 0,
                            a = String(e).split(""),
                            f = a.length,
                            l = [];
                        for (r = 0; r < f; r++) {
                            var c = new THREE.Path(),
                                h = this.extractGlyphPoints(a[r], s, o, u, c);
                            (u += h.offset), l.push(h.path);
                        }
                        var p = u / 2;
                        return { paths: l, offset: p };
                    },
                    extractGlyphPoints: function (e, t, n, r, i) {
                        var s = [],
                            o,
                            u,
                            a,
                            f,
                            l,
                            c,
                            h,
                            p,
                            d,
                            v,
                            m,
                            g,
                            y,
                            b,
                            w,
                            E,
                            S,
                            x,
                            T,
                            N = t.glyphs[e] || t.glyphs["?"];
                        if (!N) return;
                        if (N.o) {
                            (f = N._cachedOutline || (N._cachedOutline = N.o.split(" "))), (c = f.length), (h = n), (p = n);
                            for (o = 0; o < c; ) {
                                l = f[o++];
                                switch (l) {
                                    case "m":
                                        (d = f[o++] * h + r), (v = f[o++] * p), i.moveTo(d, v);
                                        break;
                                    case "l":
                                        (d = f[o++] * h + r), (v = f[o++] * p), i.lineTo(d, v);
                                        break;
                                    case "q":
                                        (m = f[o++] * h + r), (g = f[o++] * p), (w = f[o++] * h + r), (E = f[o++] * p), i.quadraticCurveTo(w, E, m, g), (T = s[s.length - 1]);
                                        if (T) {
                                            (y = T.x), (b = T.y);
                                            for (u = 1, a = this.divisions; u <= a; u++) var C = u / a, k = THREE.Shape.Utils.b2(C, y, w, m), L = THREE.Shape.Utils.b2(C, b, E, g);
                                        }
                                        break;
                                    case "b":
                                        (m = f[o++] * h + r), (g = f[o++] * p), (w = f[o++] * h + r), (E = f[o++] * -p), (S = f[o++] * h + r), (x = f[o++] * -p), i.bezierCurveTo(m, g, w, E, S, x), (T = s[s.length - 1]);
                                        if (T) {
                                            (y = T.x), (b = T.y);
                                            for (u = 1, a = this.divisions; u <= a; u++) var C = u / a, k = THREE.Shape.Utils.b3(C, y, w, S, m), L = THREE.Shape.Utils.b3(C, b, E, x, g);
                                        }
                                }
                            }
                        }
                        return { offset: N.ha * n, path: i };
                    },
                }),
                (THREE.FontUtils.generateShapes = function (e, t) {
                    t = t || {};
                    var n = t.size !== undefined ? t.size : 100,
                        r = t.curveSegments !== undefined ? t.curveSegments : 4,
                        i = t.font !== undefined ? t.font : "helvetiker",
                        s = t.weight !== undefined ? t.weight : "normal",
                        o = t.style !== undefined ? t.style : "normal";
                    (THREE.FontUtils.size = n), (THREE.FontUtils.divisions = r), (THREE.FontUtils.face = i), (THREE.FontUtils.weight = s), (THREE.FontUtils.style = o);
                    var u = THREE.FontUtils.drawText(e),
                        a = u.paths,
                        f = [];
                    for (var l = 0, c = a.length; l < c; l++) Array.prototype.push.apply(f, a[l].toShapes());
                    return f;
                }),
                (function (e) {
                    var t = 1e-10,
                        n = function (e, t) {
                            var n = e.length;
                            if (n < 3) return null;
                            var s = [],
                                o = [],
                                u = [],
                                a,
                                f,
                                l;
                            if (r(e) > 0) for (f = 0; f < n; f++) o[f] = f;
                            else for (f = 0; f < n; f++) o[f] = n - 1 - f;
                            var c = n,
                                h = 2 * c;
                            for (f = c - 1; c > 2; ) {
                                if (h-- <= 0) return console.log("Warning, unable to triangulate polygon!"), t ? u : s;
                                (a = f), c <= a && (a = 0), (f = a + 1), c <= f && (f = 0), (l = f + 1), c <= l && (l = 0);
                                if (i(e, a, f, l, c, o)) {
                                    var p, d, v, m, g;
                                    (p = o[a]), (d = o[f]), (v = o[l]), s.push([e[p], e[d], e[v]]), u.push([o[a], o[f], o[l]]);
                                    for (m = f, g = f + 1; g < c; m++, g++) o[m] = o[g];
                                    c--, (h = 2 * c);
                                }
                            }
                            return t ? u : s;
                        },
                        r = function (e) {
                            var t = e.length,
                                n = 0;
                            for (var r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
                            return n * 0.5;
                        },
                        i = function (e, n, r, i, s, o) {
                            var u, a, f, l, c, h, p, d, v;
                            (a = e[o[n]].x), (f = e[o[n]].y), (l = e[o[r]].x), (c = e[o[r]].y), (h = e[o[i]].x), (p = e[o[i]].y);
                            if (t > (l - a) * (p - f) - (c - f) * (h - a)) return !1;
                            var m, g, y, b, w, E, S, x, T, N, C, k, L, A, O;
                            (m = h - l), (g = p - c), (y = a - h), (b = f - p), (w = l - a), (E = c - f);
                            for (u = 0; u < s; u++) {
                                if (u === n || u === r || u === i) continue;
                                (d = e[o[u]].x), (v = e[o[u]].y), (S = d - a), (x = v - f), (T = d - l), (N = v - c), (C = d - h), (k = v - p), (O = m * N - g * T), (L = w * x - E * S), (A = y * k - b * C);
                                if (O >= -t && A >= -t && L >= -t) return !1;
                            }
                            return !0;
                        };
                    return (e.Triangulate = n), (e.Triangulate.area = r), e;
                })(THREE.FontUtils),
                (self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace }),
                (THREE.typeface_js = self._typeface_js),
                (THREE.Curve = function () {}),
                (THREE.Curve.prototype.getPoint = function (e) {
                    return console.log("Warning, getPoint() not implemented!"), null;
                }),
                (THREE.Curve.prototype.getPointAt = function (e) {
                    var t = this.getUtoTmapping(e);
                    return this.getPoint(t);
                }),
                (THREE.Curve.prototype.getPoints = function (e) {
                    e || (e = 5);
                    var t,
                        n = [];
                    for (t = 0; t <= e; t++) n.push(this.getPoint(t / e));
                    return n;
                }),
                (THREE.Curve.prototype.getSpacedPoints = function (e) {
                    e || (e = 5);
                    var t,
                        n = [];
                    for (t = 0; t <= e; t++) n.push(this.getPointAt(t / e));
                    return n;
                }),
                (THREE.Curve.prototype.getLength = function () {
                    var e = this.getLengths();
                    return e[e.length - 1];
                }),
                (THREE.Curve.prototype.getLengths = function (e) {
                    e || (e = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
                    if (this.cacheArcLengths && this.cacheArcLengths.length == e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var t = [],
                        n,
                        r = this.getPoint(0),
                        i,
                        s = 0;
                    t.push(0);
                    for (i = 1; i <= e; i++) (n = this.getPoint(i / e)), (s += n.distanceTo(r)), t.push(s), (r = n);
                    return (this.cacheArcLengths = t), t;
                }),
                (THREE.Curve.prototype.updateArcLengths = function () {
                    (this.needsUpdate = !0), this.getLengths();
                }),
                (THREE.Curve.prototype.getUtoTmapping = function (e, t) {
                    var n = this.getLengths(),
                        r = 0,
                        i = n.length,
                        s;
                    t ? (s = t) : (s = e * n[i - 1]);
                    var o = 0,
                        u = i - 1,
                        a;
                    while (o <= u) {
                        (r = Math.floor(o + (u - o) / 2)), (a = n[r] - s);
                        if (a < 0) {
                            o = r + 1;
                            continue;
                        }
                        if (a > 0) {
                            u = r - 1;
                            continue;
                        }
                        u = r;
                        break;
                    }
                    r = u;
                    if (n[r] == s) {
                        var f = r / (i - 1);
                        return f;
                    }
                    var l = n[r],
                        c = n[r + 1],
                        h = c - l,
                        p = (s - l) / h,
                        f = (r + p) / (i - 1);
                    return f;
                }),
                (THREE.Curve.prototype.getTangent = function (e) {
                    var t = 1e-4,
                        n = e - t,
                        r = e + t;
                    n < 0 && (n = 0), r > 1 && (r = 1);
                    var i = this.getPoint(n),
                        s = this.getPoint(r),
                        o = s.clone().sub(i);
                    return o.normalize();
                }),
                (THREE.Curve.prototype.getTangentAt = function (e) {
                    var t = this.getUtoTmapping(e);
                    return this.getTangent(t);
                }),
                (THREE.Curve.Utils = {
                    tangentQuadraticBezier: function (e, t, n, r) {
                        return 2 * (1 - e) * (n - t) + 2 * e * (r - n);
                    },
                    tangentCubicBezier: function (e, t, n, r, i) {
                        return -3 * t * (1 - e) * (1 - e) + 3 * n * (1 - e) * (1 - e) - 6 * e * n * (1 - e) + 6 * e * r * (1 - e) - 3 * e * e * r + 3 * e * e * i;
                    },
                    tangentSpline: function (e, t, n, r, i) {
                        var s = 6 * e * e - 6 * e,
                            o = 3 * e * e - 4 * e + 1,
                            u = -6 * e * e + 6 * e,
                            a = 3 * e * e - 2 * e;
                        return s + o + u + a;
                    },
                    interpolate: function (e, t, n, r, i) {
                        var s = (n - e) * 0.5,
                            o = (r - t) * 0.5,
                            u = i * i,
                            a = i * u;
                        return (2 * t - 2 * n + s + o) * a + (-3 * t + 3 * n - 2 * s - o) * u + s * i + t;
                    },
                }),
                (THREE.Curve.create = function (e, t) {
                    return (e.prototype = Object.create(THREE.Curve.prototype)), (e.prototype.getPoint = t), e;
                }),
                (THREE.CurvePath = function () {
                    (this.curves = []), (this.bends = []), (this.autoClose = !1);
                }),
                (THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype)),
                (THREE.CurvePath.prototype.add = function (e) {
                    this.curves.push(e);
                }),
                (THREE.CurvePath.prototype.checkConnection = function () {}),
                (THREE.CurvePath.prototype.closePath = function () {
                    var e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new THREE.LineCurve(t, e));
                }),
                (THREE.CurvePath.prototype.getPoint = function (e) {
                    var t = e * this.getLength(),
                        n = this.getCurveLengths(),
                        r = 0,
                        i,
                        s;
                    while (r < n.length) {
                        if (n[r] >= t) {
                            (i = n[r] - t), (s = this.curves[r]);
                            var o = 1 - i / s.getLength();
                            return s.getPointAt(o);
                        }
                        r++;
                    }
                    return null;
                }),
                (THREE.CurvePath.prototype.getLength = function () {
                    var e = this.getCurveLengths();
                    return e[e.length - 1];
                }),
                (THREE.CurvePath.prototype.getCurveLengths = function () {
                    if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
                    var e = [],
                        t = 0,
                        n,
                        r = this.curves.length;
                    for (n = 0; n < r; n++) (t += this.curves[n].getLength()), e.push(t);
                    return (this.cacheLengths = e), e;
                }),
                (THREE.CurvePath.prototype.getBoundingBox = function () {
                    var e = this.getPoints(),
                        t,
                        n,
                        r,
                        i,
                        s,
                        o;
                    (t = n = Number.NEGATIVE_INFINITY), (i = s = Number.POSITIVE_INFINITY);
                    var u,
                        a,
                        f,
                        l,
                        c = e[0] instanceof THREE.Vector3;
                    l = c ? new THREE.Vector3() : new THREE.Vector2();
                    for (a = 0, f = e.length; a < f; a++) (u = e[a]), u.x > t ? (t = u.x) : u.x < i && (i = u.x), u.y > n ? (n = u.y) : u.y < s && (s = u.y), c && (u.z > r ? (r = u.z) : u.z < o && (o = u.z)), l.add(u);
                    var h = { minX: i, minY: s, maxX: t, maxY: n, centroid: l.divideScalar(f) };
                    return c && ((h.maxZ = r), (h.minZ = o)), h;
                }),
                (THREE.CurvePath.prototype.createPointsGeometry = function (e) {
                    var t = this.getPoints(e, !0);
                    return this.createGeometry(t);
                }),
                (THREE.CurvePath.prototype.createSpacedPointsGeometry = function (e) {
                    var t = this.getSpacedPoints(e, !0);
                    return this.createGeometry(t);
                }),
                (THREE.CurvePath.prototype.createGeometry = function (e) {
                    var t = new THREE.Geometry();
                    for (var n = 0; n < e.length; n++) t.vertices.push(new THREE.Vector3(e[n].x, e[n].y, e[n].z || 0));
                    return t;
                }),
                (THREE.CurvePath.prototype.addWrapPath = function (e) {
                    this.bends.push(e);
                }),
                (THREE.CurvePath.prototype.getTransformedPoints = function (e, t) {
                    var n = this.getPoints(e),
                        r,
                        i;
                    t || (t = this.bends);
                    for (r = 0, i = t.length; r < i; r++) n = this.getWrapPoints(n, t[r]);
                    return n;
                }),
                (THREE.CurvePath.prototype.getTransformedSpacedPoints = function (e, t) {
                    var n = this.getSpacedPoints(e),
                        r,
                        i;
                    t || (t = this.bends);
                    for (r = 0, i = t.length; r < i; r++) n = this.getWrapPoints(n, t[r]);
                    return n;
                }),
                (THREE.CurvePath.prototype.getWrapPoints = function (e, t) {
                    var n = this.getBoundingBox(),
                        r,
                        i,
                        s,
                        o,
                        u,
                        a;
                    for (r = 0, i = e.length; r < i; r++) {
                        (s = e[r]), (o = s.x), (u = s.y), (a = o / n.maxX), (a = t.getUtoTmapping(a, o));
                        var f = t.getPoint(a),
                            l = t.getNormalVector(a).multiplyScalar(u);
                        (s.x = f.x + l.x), (s.y = f.y + l.y);
                    }
                    return e;
                }),
                (THREE.Gyroscope = function () {
                    THREE.Object3D.call(this);
                }),
                (THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.Gyroscope.prototype.updateMatrixWorld = function (e) {
                    this.matrixAutoUpdate && this.updateMatrix();
                    if (this.matrixWorldNeedsUpdate || e)
                        this.parent
                            ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                                this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld),
                                this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject),
                                this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld))
                            : this.matrixWorld.copy(this.matrix),
                            (this.matrixWorldNeedsUpdate = !1),
                            (e = !0);
                    for (var t = 0, n = this.children.length; t < n; t++) this.children[t].updateMatrixWorld(e);
                }),
                (THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3()),
                (THREE.Gyroscope.prototype.translationObject = new THREE.Vector3()),
                (THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion()),
                (THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion()),
                (THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3()),
                (THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3()),
                (THREE.Path = function (e) {
                    THREE.CurvePath.call(this), (this.actions = []), e && this.fromPoints(e);
                }),
                (THREE.Path.prototype = Object.create(THREE.CurvePath.prototype)),
                (THREE.PathActions = { MOVE_TO: "moveTo", LINE_TO: "lineTo", QUADRATIC_CURVE_TO: "quadraticCurveTo", BEZIER_CURVE_TO: "bezierCurveTo", CSPLINE_THRU: "splineThru", ARC: "arc", ELLIPSE: "ellipse" }),
                (THREE.Path.prototype.fromPoints = function (e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                }),
                (THREE.Path.prototype.moveTo = function (e, t) {
                    var n = Array.prototype.slice.call(arguments);
                    this.actions.push({ action: THREE.PathActions.MOVE_TO, args: n });
                }),
                (THREE.Path.prototype.lineTo = function (e, t) {
                    var n = Array.prototype.slice.call(arguments),
                        r = this.actions[this.actions.length - 1].args,
                        i = r[r.length - 2],
                        s = r[r.length - 1],
                        o = new THREE.LineCurve(new THREE.Vector2(i, s), new THREE.Vector2(e, t));
                    this.curves.push(o), this.actions.push({ action: THREE.PathActions.LINE_TO, args: n });
                }),
                (THREE.Path.prototype.quadraticCurveTo = function (e, t, n, r) {
                    var i = Array.prototype.slice.call(arguments),
                        s = this.actions[this.actions.length - 1].args,
                        o = s[s.length - 2],
                        u = s[s.length - 1],
                        a = new THREE.QuadraticBezierCurve(new THREE.Vector2(o, u), new THREE.Vector2(e, t), new THREE.Vector2(n, r));
                    this.curves.push(a), this.actions.push({ action: THREE.PathActions.QUADRATIC_CURVE_TO, args: i });
                }),
                (THREE.Path.prototype.bezierCurveTo = function (e, t, n, r, i, s) {
                    var o = Array.prototype.slice.call(arguments),
                        u = this.actions[this.actions.length - 1].args,
                        a = u[u.length - 2],
                        f = u[u.length - 1],
                        l = new THREE.CubicBezierCurve(new THREE.Vector2(a, f), new THREE.Vector2(e, t), new THREE.Vector2(n, r), new THREE.Vector2(i, s));
                    this.curves.push(l), this.actions.push({ action: THREE.PathActions.BEZIER_CURVE_TO, args: o });
                }),
                (THREE.Path.prototype.splineThru = function (e) {
                    var t = Array.prototype.slice.call(arguments),
                        n = this.actions[this.actions.length - 1].args,
                        r = n[n.length - 2],
                        i = n[n.length - 1],
                        s = [new THREE.Vector2(r, i)];
                    Array.prototype.push.apply(s, e);
                    var o = new THREE.SplineCurve(s);
                    this.curves.push(o), this.actions.push({ action: THREE.PathActions.CSPLINE_THRU, args: t });
                }),
                (THREE.Path.prototype.arc = function (e, t, n, r, i, s) {
                    var o = this.actions[this.actions.length - 1].args,
                        u = o[o.length - 2],
                        a = o[o.length - 1];
                    this.absarc(e + u, t + a, n, r, i, s);
                }),
                (THREE.Path.prototype.absarc = function (e, t, n, r, i, s) {
                    this.absellipse(e, t, n, n, r, i, s);
                }),
                (THREE.Path.prototype.ellipse = function (e, t, n, r, i, s, o) {
                    var u = this.actions[this.actions.length - 1].args,
                        a = u[u.length - 2],
                        f = u[u.length - 1];
                    this.absellipse(e + a, t + f, n, r, i, s, o);
                }),
                (THREE.Path.prototype.absellipse = function (e, t, n, r, i, s, o) {
                    var u = Array.prototype.slice.call(arguments),
                        a = new THREE.EllipseCurve(e, t, n, r, i, s, o);
                    this.curves.push(a);
                    var f = a.getPoint(1);
                    u.push(f.x), u.push(f.y), this.actions.push({ action: THREE.PathActions.ELLIPSE, args: u });
                }),
                (THREE.Path.prototype.getSpacedPoints = function (e, t) {
                    e || (e = 40);
                    var n = [];
                    for (var r = 0; r < e; r++) n.push(this.getPoint(r / e));
                    return n;
                }),
                (THREE.Path.prototype.getPoints = function (e, t) {
                    if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(e, t);
                    e = e || 12;
                    var n = [],
                        r,
                        i,
                        s,
                        o,
                        u,
                        a,
                        f,
                        l,
                        c,
                        h,
                        p,
                        d,
                        v,
                        m,
                        g,
                        y,
                        b,
                        w;
                    for (r = 0, i = this.actions.length; r < i; r++) {
                        (s = this.actions[r]), (o = s.action), (u = s.args);
                        switch (o) {
                            case THREE.PathActions.MOVE_TO:
                                n.push(new THREE.Vector2(u[0], u[1]));
                                break;
                            case THREE.PathActions.LINE_TO:
                                n.push(new THREE.Vector2(u[0], u[1]));
                                break;
                            case THREE.PathActions.QUADRATIC_CURVE_TO:
                                (a = u[2]), (f = u[3]), (h = u[0]), (p = u[1]), n.length > 0 ? ((m = n[n.length - 1]), (d = m.x), (v = m.y)) : ((m = this.actions[r - 1].args), (d = m[m.length - 2]), (v = m[m.length - 1]));
                                for (g = 1; g <= e; g++) (y = g / e), (b = THREE.Shape.Utils.b2(y, d, h, a)), (w = THREE.Shape.Utils.b2(y, v, p, f)), n.push(new THREE.Vector2(b, w));
                                break;
                            case THREE.PathActions.BEZIER_CURVE_TO:
                                (a = u[4]), (f = u[5]), (h = u[0]), (p = u[1]), (l = u[2]), (c = u[3]), n.length > 0 ? ((m = n[n.length - 1]), (d = m.x), (v = m.y)) : ((m = this.actions[r - 1].args), (d = m[m.length - 2]), (v = m[m.length - 1]));
                                for (g = 1; g <= e; g++) (y = g / e), (b = THREE.Shape.Utils.b3(y, d, h, l, a)), (w = THREE.Shape.Utils.b3(y, v, p, c, f)), n.push(new THREE.Vector2(b, w));
                                break;
                            case THREE.PathActions.CSPLINE_THRU:
                                m = this.actions[r - 1].args;
                                var E = new THREE.Vector2(m[m.length - 2], m[m.length - 1]),
                                    S = [E],
                                    x = e * u[0].length;
                                S = S.concat(u[0]);
                                var T = new THREE.SplineCurve(S);
                                for (g = 1; g <= x; g++) n.push(T.getPointAt(g / x));
                                break;
                            case THREE.PathActions.ARC:
                                var N = u[0],
                                    C = u[1],
                                    k = u[2],
                                    L = u[3],
                                    A = u[4],
                                    O = !!u[5],
                                    M = A - L,
                                    _,
                                    D = e * 2;
                                for (g = 1; g <= D; g++) (y = g / D), O || (y = 1 - y), (_ = L + y * M), (b = N + k * Math.cos(_)), (w = C + k * Math.sin(_)), n.push(new THREE.Vector2(b, w));
                                break;
                            case THREE.PathActions.ELLIPSE:
                                var N = u[0],
                                    C = u[1],
                                    P = u[2],
                                    H = u[3],
                                    L = u[4],
                                    A = u[5],
                                    O = !!u[6],
                                    M = A - L,
                                    _,
                                    D = e * 2;
                                for (g = 1; g <= D; g++) (y = g / D), O || (y = 1 - y), (_ = L + y * M), (b = N + P * Math.cos(_)), (w = C + H * Math.sin(_)), n.push(new THREE.Vector2(b, w));
                        }
                    }
                    var B = n[n.length - 1],
                        j = 1e-10;
                    return Math.abs(B.x - n[0].x) < j && Math.abs(B.y - n[0].y) < j && n.splice(n.length - 1, 1), t && n.push(n[0]), n;
                }),
                (THREE.Path.prototype.toShapes = function (e) {
                    var t,
                        n,
                        r,
                        i,
                        s,
                        o = [],
                        u = new THREE.Path();
                    for (t = 0, n = this.actions.length; t < n; t++) (r = this.actions[t]), (s = r.args), (i = r.action), i == THREE.PathActions.MOVE_TO && u.actions.length != 0 && (o.push(u), (u = new THREE.Path())), u[i].apply(u, s);
                    u.actions.length != 0 && o.push(u);
                    if (o.length == 0) return [];
                    var a,
                        f,
                        l,
                        c = [];
                    if (o.length == 1) return (f = o[0]), (l = new THREE.Shape()), (l.actions = f.actions), (l.curves = f.curves), c.push(l), c;
                    var h = !THREE.Shape.Utils.isClockWise(o[0].getPoints());
                    h = e ? !h : h;
                    if (h) {
                        l = new THREE.Shape();
                        for (t = 0, n = o.length; t < n; t++) (f = o[t]), (a = THREE.Shape.Utils.isClockWise(f.getPoints())), (a = e ? !a : a), a ? ((l.actions = f.actions), (l.curves = f.curves), c.push(l), (l = new THREE.Shape())) : l.holes.push(f);
                    } else {
                        l = undefined;
                        for (t = 0, n = o.length; t < n; t++)
                            (f = o[t]), (a = THREE.Shape.Utils.isClockWise(f.getPoints())), (a = e ? !a : a), a ? (l && c.push(l), (l = new THREE.Shape()), (l.actions = f.actions), (l.curves = f.curves)) : l.holes.push(f);
                        c.push(l);
                    }
                    return c;
                }),
                (THREE.Shape = function () {
                    THREE.Path.apply(this, arguments), (this.holes = []);
                }),
                (THREE.Shape.prototype = Object.create(THREE.Path.prototype)),
                (THREE.Shape.prototype.extrude = function (e) {
                    var t = new THREE.ExtrudeGeometry(this, e);
                    return t;
                }),
                (THREE.Shape.prototype.makeGeometry = function (e) {
                    var t = new THREE.ShapeGeometry(this, e);
                    return t;
                }),
                (THREE.Shape.prototype.getPointsHoles = function (e) {
                    var t,
                        n = this.holes.length,
                        r = [];
                    for (t = 0; t < n; t++) r[t] = this.holes[t].getTransformedPoints(e, this.bends);
                    return r;
                }),
                (THREE.Shape.prototype.getSpacedPointsHoles = function (e) {
                    var t,
                        n = this.holes.length,
                        r = [];
                    for (t = 0; t < n; t++) r[t] = this.holes[t].getTransformedSpacedPoints(e, this.bends);
                    return r;
                }),
                (THREE.Shape.prototype.extractAllPoints = function (e) {
                    return { shape: this.getTransformedPoints(e), holes: this.getPointsHoles(e) };
                }),
                (THREE.Shape.prototype.extractPoints = function (e) {
                    return this.useSpacedPoints ? this.extractAllSpacedPoints(e) : this.extractAllPoints(e);
                }),
                (THREE.Shape.prototype.extractAllSpacedPoints = function (e) {
                    return { shape: this.getTransformedSpacedPoints(e), holes: this.getSpacedPointsHoles(e) };
                }),
                (THREE.Shape.Utils = {
                    removeHoles: function (e, t) {
                        var n = e.concat(),
                            r = n.concat(),
                            i,
                            s,
                            o,
                            u,
                            a,
                            f,
                            l,
                            c,
                            h,
                            p,
                            d,
                            v,
                            m,
                            g,
                            y,
                            b,
                            w,
                            E,
                            S,
                            x,
                            T = [];
                        for (h = 0; h < t.length; h++) {
                            (d = t[h]), Array.prototype.push.apply(r, d), (v = Number.POSITIVE_INFINITY);
                            for (p = 0; p < d.length; p++) {
                                y = d[p];
                                var N = [];
                                for (g = 0; g < n.length; g++) (b = n[g]), (m = y.distanceToSquared(b)), N.push(m), m < v && ((v = m), (a = p), (f = g));
                            }
                            (i = f - 1 >= 0 ? f - 1 : n.length - 1), (o = a - 1 >= 0 ? a - 1 : d.length - 1);
                            var C = [d[a], n[f], n[i]],
                                k = THREE.FontUtils.Triangulate.area(C),
                                L = [d[a], d[o], n[f]],
                                A = THREE.FontUtils.Triangulate.area(L),
                                O = 1,
                                M = -1,
                                _ = f,
                                D = a;
                            (f += O), (a += M), f < 0 && (f += n.length), (f %= n.length), a < 0 && (a += d.length), (a %= d.length), (i = f - 1 >= 0 ? f - 1 : n.length - 1), (o = a - 1 >= 0 ? a - 1 : d.length - 1), (C = [d[a], n[f], n[i]]);
                            var P = THREE.FontUtils.Triangulate.area(C);
                            L = [d[a], d[o], n[f]];
                            var H = THREE.FontUtils.Triangulate.area(L);
                            k + A > P + H && ((f = _), (a = D), f < 0 && (f += n.length), (f %= n.length), a < 0 && (a += d.length), (a %= d.length), (i = f - 1 >= 0 ? f - 1 : n.length - 1), (o = a - 1 >= 0 ? a - 1 : d.length - 1)),
                                (w = n.slice(0, f)),
                                (E = n.slice(f)),
                                (S = d.slice(a)),
                                (x = d.slice(0, a));
                            var B = [d[a], n[f], n[i]],
                                j = [d[a], d[o], n[f]];
                            T.push(B), T.push(j), (n = w.concat(S).concat(x).concat(E));
                        }
                        return { shape: n, isolatedPts: T, allpoints: r };
                    },
                    triangulateShape: function (e, t) {
                        var n = THREE.Shape.Utils.removeHoles(e, t),
                            r = n.shape,
                            i = n.allpoints,
                            s = n.isolatedPts,
                            o = THREE.FontUtils.Triangulate(r, !1),
                            u,
                            a,
                            f,
                            l,
                            c,
                            h,
                            p = {},
                            d = {};
                        for (u = 0, a = i.length; u < a; u++) (c = i[u].x + ":" + i[u].y), p[c] !== undefined && console.log("Duplicate point", c), (p[c] = u);
                        for (u = 0, a = o.length; u < a; u++) {
                            l = o[u];
                            for (f = 0; f < 3; f++) (c = l[f].x + ":" + l[f].y), (h = p[c]), h !== undefined && (l[f] = h);
                        }
                        for (u = 0, a = s.length; u < a; u++) {
                            l = s[u];
                            for (f = 0; f < 3; f++) (c = l[f].x + ":" + l[f].y), (h = p[c]), h !== undefined && (l[f] = h);
                        }
                        return o.concat(s);
                    },
                    isClockWise: function (e) {
                        return THREE.FontUtils.Triangulate.area(e) < 0;
                    },
                    b2p0: function (e, t) {
                        var n = 1 - e;
                        return n * n * t;
                    },
                    b2p1: function (e, t) {
                        return 2 * (1 - e) * e * t;
                    },
                    b2p2: function (e, t) {
                        return e * e * t;
                    },
                    b2: function (e, t, n, r) {
                        return this.b2p0(e, t) + this.b2p1(e, n) + this.b2p2(e, r);
                    },
                    b3p0: function (e, t) {
                        var n = 1 - e;
                        return n * n * n * t;
                    },
                    b3p1: function (e, t) {
                        var n = 1 - e;
                        return 3 * n * n * e * t;
                    },
                    b3p2: function (e, t) {
                        var n = 1 - e;
                        return 3 * n * e * e * t;
                    },
                    b3p3: function (e, t) {
                        return e * e * e * t;
                    },
                    b3: function (e, t, n, r, i) {
                        return this.b3p0(e, t) + this.b3p1(e, n) + this.b3p2(e, r) + this.b3p3(e, i);
                    },
                }),
                (THREE.LineCurve = function (e, t) {
                    (this.v1 = e), (this.v2 = t);
                }),
                (THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype)),
                (THREE.LineCurve.prototype.getPoint = function (e) {
                    var t = this.v2.clone().sub(this.v1);
                    return t.multiplyScalar(e).add(this.v1), t;
                }),
                (THREE.LineCurve.prototype.getPointAt = function (e) {
                    return this.getPoint(e);
                }),
                (THREE.LineCurve.prototype.getTangent = function (e) {
                    var t = this.v2.clone().sub(this.v1);
                    return t.normalize();
                }),
                (THREE.QuadraticBezierCurve = function (e, t, n) {
                    (this.v0 = e), (this.v1 = t), (this.v2 = n);
                }),
                (THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype)),
                (THREE.QuadraticBezierCurve.prototype.getPoint = function (e) {
                    var t, n;
                    return (t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x)), (n = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y)), new THREE.Vector2(t, n);
                }),
                (THREE.QuadraticBezierCurve.prototype.getTangent = function (e) {
                    var t, n;
                    (t = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.x, this.v1.x, this.v2.x)), (n = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.y, this.v1.y, this.v2.y));
                    var r = new THREE.Vector2(t, n);
                    return r.normalize(), r;
                }),
                (THREE.CubicBezierCurve = function (e, t, n, r) {
                    (this.v0 = e), (this.v1 = t), (this.v2 = n), (this.v3 = r);
                }),
                (THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype)),
                (THREE.CubicBezierCurve.prototype.getPoint = function (e) {
                    var t, n;
                    return (t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x)), (n = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y)), new THREE.Vector2(t, n);
                }),
                (THREE.CubicBezierCurve.prototype.getTangent = function (e) {
                    var t, n;
                    (t = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x)), (n = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
                    var r = new THREE.Vector2(t, n);
                    return r.normalize(), r;
                }),
                (THREE.SplineCurve = function (e) {
                    this.points = e == undefined ? [] : e;
                }),
                (THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype)),
                (THREE.SplineCurve.prototype.getPoint = function (e) {
                    var t = new THREE.Vector2(),
                        n = [],
                        r = this.points,
                        i,
                        s,
                        o;
                    return (
                        (i = (r.length - 1) * e),
                            (s = Math.floor(i)),
                            (o = i - s),
                            (n[0] = s == 0 ? s : s - 1),
                            (n[1] = s),
                            (n[2] = s > r.length - 2 ? r.length - 1 : s + 1),
                            (n[3] = s > r.length - 3 ? r.length - 1 : s + 2),
                            (t.x = THREE.Curve.Utils.interpolate(r[n[0]].x, r[n[1]].x, r[n[2]].x, r[n[3]].x, o)),
                            (t.y = THREE.Curve.Utils.interpolate(r[n[0]].y, r[n[1]].y, r[n[2]].y, r[n[3]].y, o)),
                            t
                    );
                }),
                (THREE.EllipseCurve = function (e, t, n, r, i, s, o) {
                    (this.aX = e), (this.aY = t), (this.xRadius = n), (this.yRadius = r), (this.aStartAngle = i), (this.aEndAngle = s), (this.aClockwise = o);
                }),
                (THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype)),
                (THREE.EllipseCurve.prototype.getPoint = function (e) {
                    var t,
                        n = this.aEndAngle - this.aStartAngle;
                    n < 0 && (n += Math.PI * 2), n > Math.PI * 2 && (n -= Math.PI * 2), this.aClockwise === !0 ? (t = this.aEndAngle + (1 - e) * (Math.PI * 2 - n)) : (t = this.aStartAngle + e * n);
                    var r = this.aX + this.xRadius * Math.cos(t),
                        i = this.aY + this.yRadius * Math.sin(t);
                    return new THREE.Vector2(r, i);
                }),
                (THREE.ArcCurve = function (e, t, n, r, i, s) {
                    THREE.EllipseCurve.call(this, e, t, n, n, r, i, s);
                }),
                (THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype)),
                (THREE.LineCurve3 = THREE.Curve.create(
                    function (e, t) {
                        (this.v1 = e), (this.v2 = t);
                    },
                    function (e) {
                        var t = new THREE.Vector3();
                        return t.subVectors(this.v2, this.v1), t.multiplyScalar(e), t.add(this.v1), t;
                    }
                )),
                (THREE.QuadraticBezierCurve3 = THREE.Curve.create(
                    function (e, t, n) {
                        (this.v0 = e), (this.v1 = t), (this.v2 = n);
                    },
                    function (e) {
                        var t, n, r;
                        return (t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x)), (n = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y)), (r = THREE.Shape.Utils.b2(e, this.v0.z, this.v1.z, this.v2.z)), new THREE.Vector3(t, n, r);
                    }
                )),
                (THREE.CubicBezierCurve3 = THREE.Curve.create(
                    function (e, t, n, r) {
                        (this.v0 = e), (this.v1 = t), (this.v2 = n), (this.v3 = r);
                    },
                    function (e) {
                        var t, n, r;
                        return (
                            (t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x)),
                                (n = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y)),
                                (r = THREE.Shape.Utils.b3(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z)),
                                new THREE.Vector3(t, n, r)
                        );
                    }
                )),
                (THREE.SplineCurve3 = THREE.Curve.create(
                    function (e) {
                        this.points = e == undefined ? [] : e;
                    },
                    function (e) {
                        var t = new THREE.Vector3(),
                            n = [],
                            r = this.points,
                            i,
                            s,
                            o;
                        (i = (r.length - 1) * e), (s = Math.floor(i)), (o = i - s), (n[0] = s == 0 ? s : s - 1), (n[1] = s), (n[2] = s > r.length - 2 ? r.length - 1 : s + 1), (n[3] = s > r.length - 3 ? r.length - 1 : s + 2);
                        var u = r[n[0]],
                            a = r[n[1]],
                            f = r[n[2]],
                            l = r[n[3]];
                        return (t.x = THREE.Curve.Utils.interpolate(u.x, a.x, f.x, l.x, o)), (t.y = THREE.Curve.Utils.interpolate(u.y, a.y, f.y, l.y, o)), (t.z = THREE.Curve.Utils.interpolate(u.z, a.z, f.z, l.z, o)), t;
                    }
                )),
                (THREE.ClosedSplineCurve3 = THREE.Curve.create(
                    function (e) {
                        this.points = e == undefined ? [] : e;
                    },
                    function (e) {
                        var t = new THREE.Vector3(),
                            n = [],
                            r = this.points,
                            i,
                            s,
                            o;
                        return (
                            (i = (r.length - 0) * e),
                                (s = Math.floor(i)),
                                (o = i - s),
                                (s += s > 0 ? 0 : (Math.floor(Math.abs(s) / r.length) + 1) * r.length),
                                (n[0] = (s - 1) % r.length),
                                (n[1] = s % r.length),
                                (n[2] = (s + 1) % r.length),
                                (n[3] = (s + 2) % r.length),
                                (t.x = THREE.Curve.Utils.interpolate(r[n[0]].x, r[n[1]].x, r[n[2]].x, r[n[3]].x, o)),
                                (t.y = THREE.Curve.Utils.interpolate(r[n[0]].y, r[n[1]].y, r[n[2]].y, r[n[3]].y, o)),
                                (t.z = THREE.Curve.Utils.interpolate(r[n[0]].z, r[n[1]].z, r[n[2]].z, r[n[3]].z, o)),
                                t
                        );
                    }
                )),
                (THREE.AnimationHandler = (function () {
                    var e = [],
                        t = {},
                        n = {};
                    (n.update = function (t) {
                        for (var n = 0; n < e.length; n++) e[n].update(t);
                    }),
                        (n.addToUpdate = function (t) {
                            e.indexOf(t) === -1 && e.push(t);
                        }),
                        (n.removeFromUpdate = function (t) {
                            var n = e.indexOf(t);
                            n !== -1 && e.splice(n, 1);
                        }),
                        (n.add = function (e) {
                            t[e.name] !== undefined && console.log("THREE.AnimationHandler.add: Warning! " + e.name + " already exists in library. Overwriting."), (t[e.name] = e), i(e);
                        }),
                        (n.get = function (e) {
                            if (typeof e == "string") return t[e] ? t[e] : (console.log("THREE.AnimationHandler.get: Couldn't find animation " + e), null);
                        }),
                        (n.parse = function (e) {
                            var t = [];
                            if (e instanceof THREE.SkinnedMesh) for (var n = 0; n < e.bones.length; n++) t.push(e.bones[n]);
                            else r(e, t);
                            return t;
                        });
                    var r = function (e, t) {
                            t.push(e);
                            for (var n = 0; n < e.children.length; n++) r(e.children[n], t);
                        },
                        i = function (e) {
                            if (e.initialized === !0) return;
                            for (var t = 0; t < e.hierarchy.length; t++) {
                                for (var n = 0; n < e.hierarchy[t].keys.length; n++) {
                                    e.hierarchy[t].keys[n].time < 0 && (e.hierarchy[t].keys[n].time = 0);
                                    if (e.hierarchy[t].keys[n].rot !== undefined && !(e.hierarchy[t].keys[n].rot instanceof THREE.Quaternion)) {
                                        var r = e.hierarchy[t].keys[n].rot;
                                        e.hierarchy[t].keys[n].rot = new THREE.Quaternion(r[0], r[1], r[2], r[3]);
                                    }
                                }
                                if (e.hierarchy[t].keys.length && e.hierarchy[t].keys[0].morphTargets !== undefined) {
                                    var i = {};
                                    for (var n = 0; n < e.hierarchy[t].keys.length; n++)
                                        for (var s = 0; s < e.hierarchy[t].keys[n].morphTargets.length; s++) {
                                            var o = e.hierarchy[t].keys[n].morphTargets[s];
                                            i[o] = -1;
                                        }
                                    e.hierarchy[t].usedMorphTargets = i;
                                    for (var n = 0; n < e.hierarchy[t].keys.length; n++) {
                                        var u = {};
                                        for (var o in i) {
                                            for (var s = 0; s < e.hierarchy[t].keys[n].morphTargets.length; s++)
                                                if (e.hierarchy[t].keys[n].morphTargets[s] === o) {
                                                    u[o] = e.hierarchy[t].keys[n].morphTargetsInfluences[s];
                                                    break;
                                                }
                                            s === e.hierarchy[t].keys[n].morphTargets.length && (u[o] = 0);
                                        }
                                        e.hierarchy[t].keys[n].morphTargetsInfluences = u;
                                    }
                                }
                                for (var n = 1; n < e.hierarchy[t].keys.length; n++) e.hierarchy[t].keys[n].time === e.hierarchy[t].keys[n - 1].time && (e.hierarchy[t].keys.splice(n, 1), n--);
                                for (var n = 0; n < e.hierarchy[t].keys.length; n++) e.hierarchy[t].keys[n].index = n;
                            }
                            var a = parseInt(e.length * e.fps, 10);
                            (e.JIT = {}), (e.JIT.hierarchy = []);
                            for (var t = 0; t < e.hierarchy.length; t++) e.JIT.hierarchy.push(new Array(a));
                            e.initialized = !0;
                        };
                    return (n.LINEAR = 0), (n.CATMULLROM = 1), (n.CATMULLROM_FORWARD = 2), n;
                })()),
                (THREE.Animation = function (e, t, n) {
                    (this.root = e),
                        (this.data = THREE.AnimationHandler.get(t)),
                        (this.hierarchy = THREE.AnimationHandler.parse(e)),
                        (this.currentTime = 0),
                        (this.timeScale = 1),
                        (this.isPlaying = !1),
                        (this.isPaused = !0),
                        (this.loop = !0),
                        (this.interpolationType = n !== undefined ? n : THREE.AnimationHandler.LINEAR),
                        (this.points = []),
                        (this.target = new THREE.Vector3());
                }),
                (THREE.Animation.prototype.play = function (e, t) {
                    if (this.isPlaying === !1) {
                        (this.isPlaying = !0), (this.loop = e !== undefined ? e : !0), (this.currentTime = t !== undefined ? t : 0);
                        var n,
                            r = this.hierarchy.length,
                            i;
                        for (n = 0; n < r; n++) {
                            (i = this.hierarchy[n]),
                                (i.matrixAutoUpdate = !0),
                            i.animationCache === undefined &&
                            ((i.animationCache = {}),
                                (i.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 }),
                                (i.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 }),
                                (i.animationCache.originalMatrix = i instanceof THREE.Bone ? i.skinMatrix : i.matrix));
                            var s = i.animationCache.prevKey,
                                o = i.animationCache.nextKey;
                            (s.pos = this.data.hierarchy[n].keys[0]),
                                (s.rot = this.data.hierarchy[n].keys[0]),
                                (s.scl = this.data.hierarchy[n].keys[0]),
                                (o.pos = this.getNextKeyWith("pos", n, 1)),
                                (o.rot = this.getNextKeyWith("rot", n, 1)),
                                (o.scl = this.getNextKeyWith("scl", n, 1));
                        }
                        this.update(0);
                    }
                    (this.isPaused = !1), THREE.AnimationHandler.addToUpdate(this);
                }),
                (THREE.Animation.prototype.pause = function () {
                    this.isPaused === !0 ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this), (this.isPaused = !this.isPaused);
                }),
                (THREE.Animation.prototype.stop = function () {
                    (this.isPlaying = !1), (this.isPaused = !1), THREE.AnimationHandler.removeFromUpdate(this);
                }),
                (THREE.Animation.prototype.update = function (e) {
                    if (this.isPlaying === !1) return;
                    var t = ["pos", "rot", "scl"],
                        n,
                        r,
                        i,
                        s,
                        o,
                        u,
                        a,
                        f,
                        l,
                        c,
                        h = this.data.JIT.hierarchy,
                        p,
                        d,
                        v,
                        m,
                        g;
                    (this.currentTime += e * this.timeScale), (d = this.currentTime), (p = this.currentTime = this.currentTime % this.data.length), (c = parseInt(Math.min(p * this.data.fps, this.data.length * this.data.fps), 10));
                    for (var y = 0, b = this.hierarchy.length; y < b; y++) {
                        (f = this.hierarchy[y]), (l = f.animationCache);
                        for (var w = 0; w < 3; w++) {
                            (n = t[w]), (u = l.prevKey[n]), (a = l.nextKey[n]);
                            if (a.time <= d) {
                                if (p < d) {
                                    if (!this.loop) {
                                        this.stop();
                                        return;
                                    }
                                    (u = this.data.hierarchy[y].keys[0]), (a = this.getNextKeyWith(n, y, 1));
                                    while (a.time < p) (u = a), (a = this.getNextKeyWith(n, y, a.index + 1));
                                } else
                                    do (u = a), (a = this.getNextKeyWith(n, y, a.index + 1));
                                    while (a.time < p);
                                (l.prevKey[n] = u), (l.nextKey[n] = a);
                            }
                            (f.matrixAutoUpdate = !0), (f.matrixWorldNeedsUpdate = !0), (r = (p - u.time) / (a.time - u.time)), (s = u[n]), (o = a[n]);
                            if (r < 0 || r > 1) console.log("THREE.Animation.update: Warning! Scale out of bounds:" + r + " on bone " + y), (r = r < 0 ? 0 : 1);
                            if (n === "pos") {
                                i = f.position;
                                if (this.interpolationType === THREE.AnimationHandler.LINEAR) (i.x = s[0] + (o[0] - s[0]) * r), (i.y = s[1] + (o[1] - s[1]) * r), (i.z = s[2] + (o[2] - s[2]) * r);
                                else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD)
                                    (this.points[0] = this.getPrevKeyWith("pos", y, u.index - 1).pos),
                                        (this.points[1] = s),
                                        (this.points[2] = o),
                                        (this.points[3] = this.getNextKeyWith("pos", y, a.index + 1).pos),
                                        (r = r * 0.33 + 0.33),
                                        (v = this.interpolateCatmullRom(this.points, r)),
                                        (i.x = v[0]),
                                        (i.y = v[1]),
                                        (i.z = v[2]),
                                    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD &&
                                    ((m = this.interpolateCatmullRom(this.points, r * 1.01)),
                                        this.target.set(m[0], m[1], m[2]),
                                        this.target.sub(i),
                                        (this.target.y = 0),
                                        this.target.normalize(),
                                        (g = Math.atan2(this.target.x, this.target.z)),
                                        f.rotation.set(0, g, 0));
                            } else n === "rot" ? THREE.Quaternion.slerp(s, o, f.quaternion, r) : n === "scl" && ((i = f.scale), (i.x = s[0] + (o[0] - s[0]) * r), (i.y = s[1] + (o[1] - s[1]) * r), (i.z = s[2] + (o[2] - s[2]) * r));
                        }
                    }
                }),
                (THREE.Animation.prototype.interpolateCatmullRom = function (e, t) {
                    var n = [],
                        r = [],
                        i,
                        s,
                        o,
                        u,
                        a,
                        f,
                        l,
                        c,
                        h;
                    return (
                        (i = (e.length - 1) * t),
                            (s = Math.floor(i)),
                            (o = i - s),
                            (n[0] = s === 0 ? s : s - 1),
                            (n[1] = s),
                            (n[2] = s > e.length - 2 ? s : s + 1),
                            (n[3] = s > e.length - 3 ? s : s + 2),
                            (f = e[n[0]]),
                            (l = e[n[1]]),
                            (c = e[n[2]]),
                            (h = e[n[3]]),
                            (u = o * o),
                            (a = o * u),
                            (r[0] = this.interpolate(f[0], l[0], c[0], h[0], o, u, a)),
                            (r[1] = this.interpolate(f[1], l[1], c[1], h[1], o, u, a)),
                            (r[2] = this.interpolate(f[2], l[2], c[2], h[2], o, u, a)),
                            r
                    );
                }),
                (THREE.Animation.prototype.interpolate = function (e, t, n, r, i, s, o) {
                    var u = (n - e) * 0.5,
                        a = (r - t) * 0.5;
                    return (2 * (t - n) + u + a) * o + (-3 * (t - n) - 2 * u - a) * s + u * i + t;
                }),
                (THREE.Animation.prototype.getNextKeyWith = function (e, t, n) {
                    var r = this.data.hierarchy[t].keys;
                    this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? (n = n < r.length - 1 ? n : r.length - 1) : (n %= r.length);
                    for (; n < r.length; n++) if (r[n][e] !== undefined) return r[n];
                    return this.data.hierarchy[t].keys[0];
                }),
                (THREE.Animation.prototype.getPrevKeyWith = function (e, t, n) {
                    var r = this.data.hierarchy[t].keys;
                    this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? (n = n > 0 ? n : 0) : (n = n >= 0 ? n : n + r.length);
                    for (; n >= 0; n--) if (r[n][e] !== undefined) return r[n];
                    return this.data.hierarchy[t].keys[r.length - 1];
                }),
                (THREE.KeyFrameAnimation = function (e, t, n) {
                    (this.root = e),
                        (this.data = THREE.AnimationHandler.get(t)),
                        (this.hierarchy = THREE.AnimationHandler.parse(e)),
                        (this.currentTime = 0),
                        (this.timeScale = 0.001),
                        (this.isPlaying = !1),
                        (this.isPaused = !0),
                        (this.loop = !0),
                        (this.JITCompile = n !== undefined ? n : !0);
                    for (var r = 0, i = this.hierarchy.length; r < i; r++) {
                        var s = this.data.hierarchy[r].keys,
                            o = this.data.hierarchy[r].sids,
                            u = this.hierarchy[r];
                        if (s.length && o) {
                            for (var a = 0; a < o.length; a++) {
                                var f = o[a],
                                    l = this.getNextKeyWith(f, r, 0);
                                l && l.apply(f);
                            }
                            (u.matrixAutoUpdate = !1), this.data.hierarchy[r].node.updateMatrix(), (u.matrixWorldNeedsUpdate = !0);
                        }
                    }
                }),
                (THREE.KeyFrameAnimation.prototype.play = function (e, t) {
                    if (!this.isPlaying) {
                        (this.isPlaying = !0), (this.loop = e !== undefined ? e : !0), (this.currentTime = t !== undefined ? t : 0), (this.startTimeMs = t), (this.startTime = 1e7), (this.endTime = -this.startTime);
                        var n,
                            r = this.hierarchy.length,
                            i,
                            s;
                        for (n = 0; n < r; n++) {
                            (i = this.hierarchy[n]),
                                (s = this.data.hierarchy[n]),
                            s.animationCache === undefined && ((s.animationCache = {}), (s.animationCache.prevKey = null), (s.animationCache.nextKey = null), (s.animationCache.originalMatrix = i instanceof THREE.Bone ? i.skinMatrix : i.matrix));
                            var o = this.data.hierarchy[n].keys;
                            o.length && ((s.animationCache.prevKey = o[0]), (s.animationCache.nextKey = o[1]), (this.startTime = Math.min(o[0].time, this.startTime)), (this.endTime = Math.max(o[o.length - 1].time, this.endTime)));
                        }
                        this.update(0);
                    }
                    (this.isPaused = !1), THREE.AnimationHandler.addToUpdate(this);
                }),
                (THREE.KeyFrameAnimation.prototype.pause = function () {
                    this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this), (this.isPaused = !this.isPaused);
                }),
                (THREE.KeyFrameAnimation.prototype.stop = function () {
                    (this.isPlaying = !1), (this.isPaused = !1), THREE.AnimationHandler.removeFromUpdate(this);
                    for (var e = 0; e < this.data.hierarchy.length; e++) {
                        var t = this.hierarchy[e],
                            n = this.data.hierarchy[e];
                        if (n.animationCache !== undefined) {
                            var r = n.animationCache.originalMatrix;
                            t instanceof THREE.Bone ? (r.copy(t.skinMatrix), (t.skinMatrix = r)) : (r.copy(t.matrix), (t.matrix = r)), delete n.animationCache;
                        }
                    }
                }),
                (THREE.KeyFrameAnimation.prototype.update = function (e) {
                    if (!this.isPlaying) return;
                    var t,
                        n,
                        r,
                        i,
                        s,
                        o = this.data.JIT.hierarchy,
                        u,
                        a,
                        f;
                    (this.currentTime += e * this.timeScale),
                        (a = this.currentTime),
                        (u = this.currentTime = this.currentTime % this.data.length),
                    u < this.startTimeMs && (u = this.currentTime = this.startTimeMs + u),
                        (s = parseInt(Math.min(u * this.data.fps, this.data.length * this.data.fps), 10)),
                        (f = u < a);
                    if (f && !this.loop) {
                        for (var l = 0, c = this.hierarchy.length; l < c; l++) {
                            var h = this.data.hierarchy[l].keys,
                                p = this.data.hierarchy[l].sids,
                                d = h.length - 1,
                                v = this.hierarchy[l];
                            if (h.length) {
                                for (var m = 0; m < p.length; m++) {
                                    var g = p[m],
                                        y = this.getPrevKeyWith(g, l, d);
                                    y && y.apply(g);
                                }
                                this.data.hierarchy[l].node.updateMatrix(), (v.matrixWorldNeedsUpdate = !0);
                            }
                        }
                        this.stop();
                        return;
                    }
                    if (u < this.startTime) return;
                    for (var l = 0, c = this.hierarchy.length; l < c; l++) {
                        (r = this.hierarchy[l]), (i = this.data.hierarchy[l]);
                        var h = i.keys,
                            b = i.animationCache;
                        if (this.JITCompile && o[l][s] !== undefined) r instanceof THREE.Bone ? ((r.skinMatrix = o[l][s]), (r.matrixWorldNeedsUpdate = !1)) : ((r.matrix = o[l][s]), (r.matrixWorldNeedsUpdate = !0));
                        else if (h.length) {
                            this.JITCompile && b && (r instanceof THREE.Bone ? (r.skinMatrix = b.originalMatrix) : (r.matrix = b.originalMatrix)), (t = b.prevKey), (n = b.nextKey);
                            if (t && n) {
                                if (n.time <= a) {
                                    if (f && this.loop) {
                                        (t = h[0]), (n = h[1]);
                                        while (n.time < u) (t = n), (n = h[t.index + 1]);
                                    } else if (!f) {
                                        var w = h.length - 1;
                                        while (n.time < u && n.index !== w) (t = n), (n = h[t.index + 1]);
                                    }
                                    (b.prevKey = t), (b.nextKey = n);
                                }
                                n.time >= u ? t.interpolate(n, u) : t.interpolate(n, n.time);
                            }
                            this.data.hierarchy[l].node.updateMatrix(), (r.matrixWorldNeedsUpdate = !0);
                        }
                    }
                    if (this.JITCompile && o[0][s] === undefined) {
                        this.hierarchy[0].updateMatrixWorld(!0);
                        for (var l = 0; l < this.hierarchy.length; l++) this.hierarchy[l] instanceof THREE.Bone ? (o[l][s] = this.hierarchy[l].skinMatrix.clone()) : (o[l][s] = this.hierarchy[l].matrix.clone());
                    }
                }),
                (THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (e, t, n) {
                    var r = this.data.hierarchy[t].keys;
                    n %= r.length;
                    for (; n < r.length; n++) if (r[n].hasTarget(e)) return r[n];
                    return r[0];
                }),
                (THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (e, t, n) {
                    var r = this.data.hierarchy[t].keys;
                    n = n >= 0 ? n : n + r.length;
                    for (; n >= 0; n--) if (r[n].hasTarget(e)) return r[n];
                    return r[r.length - 1];
                }),
                (THREE.CubeCamera = function (e, t, n) {
                    THREE.Object3D.call(this);
                    var r = 90,
                        i = 1,
                        s = new THREE.PerspectiveCamera(r, i, e, t);
                    s.up.set(0, -1, 0), s.lookAt(new THREE.Vector3(1, 0, 0)), this.add(s);
                    var o = new THREE.PerspectiveCamera(r, i, e, t);
                    o.up.set(0, -1, 0), o.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(o);
                    var u = new THREE.PerspectiveCamera(r, i, e, t);
                    u.up.set(0, 0, 1), u.lookAt(new THREE.Vector3(0, 1, 0)), this.add(u);
                    var a = new THREE.PerspectiveCamera(r, i, e, t);
                    a.up.set(0, 0, -1), a.lookAt(new THREE.Vector3(0, -1, 0)), this.add(a);
                    var f = new THREE.PerspectiveCamera(r, i, e, t);
                    f.up.set(0, -1, 0), f.lookAt(new THREE.Vector3(0, 0, 1)), this.add(f);
                    var l = new THREE.PerspectiveCamera(r, i, e, t);
                    l.up.set(0, -1, 0),
                        l.lookAt(new THREE.Vector3(0, 0, -1)),
                        this.add(l),
                        (this.renderTarget = new THREE.WebGLRenderTargetCube(n, n, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter })),
                        (this.updateCubeMap = function (e, t) {
                            var n = this.renderTarget,
                                r = n.generateMipmaps;
                            (n.generateMipmaps = !1),
                                (n.activeCubeFace = 0),
                                e.render(t, s, n),
                                (n.activeCubeFace = 1),
                                e.render(t, o, n),
                                (n.activeCubeFace = 2),
                                e.render(t, u, n),
                                (n.activeCubeFace = 3),
                                e.render(t, a, n),
                                (n.activeCubeFace = 4),
                                e.render(t, f, n),
                                (n.generateMipmaps = r),
                                (n.activeCubeFace = 5),
                                e.render(t, l, n);
                        });
                }),
                (THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.CombinedCamera = function (e, t, n, r, i, s, o) {
                    THREE.Camera.call(this),
                        (this.fov = n),
                        (this.left = -e / 2),
                        (this.right = e / 2),
                        (this.top = t / 2),
                        (this.bottom = -t / 2),
                        (this.cameraO = new THREE.OrthographicCamera(e / -2, e / 2, t / 2, t / -2, s, o)),
                        (this.cameraP = new THREE.PerspectiveCamera(n, e / t, r, i)),
                        (this.zoom = 1),
                        this.toPerspective();
                    var u = e / t;
                }),
                (THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype)),
                (THREE.CombinedCamera.prototype.toPerspective = function () {
                    (this.near = this.cameraP.near),
                        (this.far = this.cameraP.far),
                        (this.cameraP.fov = this.fov / this.zoom),
                        this.cameraP.updateProjectionMatrix(),
                        (this.projectionMatrix = this.cameraP.projectionMatrix),
                        (this.inPerspectiveMode = !0),
                        (this.inOrthographicMode = !1);
                }),
                (THREE.CombinedCamera.prototype.toOrthographic = function () {
                    var e = this.fov,
                        t = this.cameraP.aspect,
                        n = this.cameraP.near,
                        r = this.cameraP.far,
                        i = (n + r) / 2,
                        s = Math.tan(e / 2) * i,
                        o = 2 * s,
                        u = o * t,
                        a = u / 2;
                    (s /= this.zoom),
                        (a /= this.zoom),
                        (this.cameraO.left = -a),
                        (this.cameraO.right = a),
                        (this.cameraO.top = s),
                        (this.cameraO.bottom = -s),
                        this.cameraO.updateProjectionMatrix(),
                        (this.near = this.cameraO.near),
                        (this.far = this.cameraO.far),
                        (this.projectionMatrix = this.cameraO.projectionMatrix),
                        (this.inPerspectiveMode = !1),
                        (this.inOrthographicMode = !0);
                }),
                (THREE.CombinedCamera.prototype.setSize = function (e, t) {
                    (this.cameraP.aspect = e / t), (this.left = -e / 2), (this.right = e / 2), (this.top = t / 2), (this.bottom = -t / 2);
                }),
                (THREE.CombinedCamera.prototype.setFov = function (e) {
                    (this.fov = e), this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
                }),
                (THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {
                    this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(), this.toOrthographic());
                }),
                (THREE.CombinedCamera.prototype.setLens = function (e, t) {
                    t === undefined && (t = 24);
                    var n = 2 * THREE.Math.radToDeg(Math.atan(t / (e * 2)));
                    return this.setFov(n), n;
                }),
                (THREE.CombinedCamera.prototype.setZoom = function (e) {
                    (this.zoom = e), this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
                }),
                (THREE.CombinedCamera.prototype.toFrontView = function () {
                    (this.rotation.x = 0), (this.rotation.y = 0), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
                }),
                (THREE.CombinedCamera.prototype.toBackView = function () {
                    (this.rotation.x = 0), (this.rotation.y = Math.PI), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
                }),
                (THREE.CombinedCamera.prototype.toLeftView = function () {
                    (this.rotation.x = 0), (this.rotation.y = -Math.PI / 2), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
                }),
                (THREE.CombinedCamera.prototype.toRightView = function () {
                    (this.rotation.x = 0), (this.rotation.y = Math.PI / 2), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
                }),
                (THREE.CombinedCamera.prototype.toTopView = function () {
                    (this.rotation.x = -Math.PI / 2), (this.rotation.y = 0), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
                }),
                (THREE.CombinedCamera.prototype.toBottomView = function () {
                    (this.rotation.x = Math.PI / 2), (this.rotation.y = 0), (this.rotation.z = 0), (this.rotationAutoUpdate = !1);
                }),
                (THREE.CircleGeometry = function (e, t, n, r) {
                    THREE.Geometry.call(this), (this.radius = e = e || 50), (this.segments = t = t !== undefined ? Math.max(3, t) : 8), (this.thetaStart = n = n !== undefined ? n : 0), (this.thetaLength = r = r !== undefined ? r : Math.PI * 2);
                    var i,
                        s = [],
                        o = new THREE.Vector3(),
                        u = new THREE.Vector2(0.5, 0.5);
                    this.vertices.push(o), s.push(u);
                    for (i = 0; i <= t; i++) {
                        var a = new THREE.Vector3(),
                            f = n + (i / t) * r;
                        (a.x = e * Math.cos(f)), (a.y = e * Math.sin(f)), this.vertices.push(a), s.push(new THREE.Vector2((a.x / e + 1) / 2, (a.y / e + 1) / 2));
                    }
                    var l = new THREE.Vector3(0, 0, 1);
                    for (i = 1; i <= t; i++) {
                        var c = i,
                            h = i + 1,
                            p = 0;
                        this.faces.push(new THREE.Face3(c, h, p, [l, l, l])), this.faceVertexUvs[0].push([s[i], s[i + 1], u]);
                    }
                    this.computeCentroids(), this.computeFaceNormals(), (this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), e));
                }),
                (THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.CubeGeometry = function (e, t, n, r, i, s) {
                    function l(e, t, n, r, i, s, u, a) {
                        var f,
                            l,
                            c,
                            h = o.widthSegments,
                            p = o.heightSegments,
                            d = i / 2,
                            v = s / 2,
                            m = o.vertices.length;
                        if ((e === "x" && t === "y") || (e === "y" && t === "x")) f = "z";
                        else if ((e === "x" && t === "z") || (e === "z" && t === "x")) (f = "y"), (p = o.depthSegments);
                        else if ((e === "z" && t === "y") || (e === "y" && t === "z")) (f = "x"), (h = o.depthSegments);
                        var g = h + 1,
                            y = p + 1,
                            b = i / h,
                            w = s / p,
                            E = new THREE.Vector3();
                        E[f] = u > 0 ? 1 : -1;
                        for (c = 0; c < y; c++)
                            for (l = 0; l < g; l++) {
                                var S = new THREE.Vector3();
                                (S[e] = (l * b - d) * n), (S[t] = (c * w - v) * r), (S[f] = u), o.vertices.push(S);
                            }
                        for (c = 0; c < p; c++)
                            for (l = 0; l < h; l++) {
                                var x = l + g * c,
                                    T = l + g * (c + 1),
                                    N = l + 1 + g * (c + 1),
                                    C = l + 1 + g * c,
                                    k = new THREE.Vector2(l / h, 1 - c / p),
                                    L = new THREE.Vector2(l / h, 1 - (c + 1) / p),
                                    A = new THREE.Vector2((l + 1) / h, 1 - (c + 1) / p),
                                    O = new THREE.Vector2((l + 1) / h, 1 - c / p),
                                    M = new THREE.Face3(x + m, T + m, C + m);
                                M.normal.copy(E),
                                    M.vertexNormals.push(E.clone(), E.clone(), E.clone()),
                                    (M.materialIndex = a),
                                    o.faces.push(M),
                                    o.faceVertexUvs[0].push([k, L, O]),
                                    (M = new THREE.Face3(T + m, N + m, C + m)),
                                    M.normal.copy(E),
                                    M.vertexNormals.push(E.clone(), E.clone(), E.clone()),
                                    (M.materialIndex = a),
                                    o.faces.push(M),
                                    o.faceVertexUvs[0].push([L.clone(), A, O.clone()]);
                            }
                    }
                    THREE.Geometry.call(this);
                    var o = this;
                    (this.width = e), (this.height = t), (this.depth = n), (this.widthSegments = r || 1), (this.heightSegments = i || 1), (this.depthSegments = s || 1);
                    var u = this.width / 2,
                        a = this.height / 2,
                        f = this.depth / 2;
                    l("z", "y", -1, -1, this.depth, this.height, u, 0),
                        l("z", "y", 1, -1, this.depth, this.height, -u, 1),
                        l("x", "z", 1, 1, this.width, this.depth, a, 2),
                        l("x", "z", 1, -1, this.width, this.depth, -a, 3),
                        l("x", "y", 1, -1, this.width, this.height, f, 4),
                        l("x", "y", -1, -1, this.width, this.height, -f, 5),
                        this.computeCentroids(),
                        this.mergeVertices();
                }),
                (THREE.CubeGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.CylinderGeometry = function (e, t, n, r, i, s) {
                    THREE.Geometry.call(this),
                        (this.radiusTop = e = e !== undefined ? e : 20),
                        (this.radiusBottom = t = t !== undefined ? t : 20),
                        (this.height = n = n !== undefined ? n : 100),
                        (this.radialSegments = r = r || 8),
                        (this.heightSegments = i = i || 1),
                        (this.openEnded = s = s !== undefined ? s : !1);
                    var o = n / 2,
                        u,
                        a,
                        f = [],
                        l = [];
                    for (a = 0; a <= i; a++) {
                        var c = [],
                            h = [],
                            p = a / i,
                            d = p * (t - e) + e;
                        for (u = 0; u <= r; u++) {
                            var v = u / r,
                                m = new THREE.Vector3();
                            (m.x = d * Math.sin(v * Math.PI * 2)), (m.y = -p * n + o), (m.z = d * Math.cos(v * Math.PI * 2)), this.vertices.push(m), c.push(this.vertices.length - 1), h.push(new THREE.Vector2(v, 1 - p));
                        }
                        f.push(c), l.push(h);
                    }
                    var g = (t - e) / n,
                        y,
                        b;
                    for (u = 0; u < r; u++) {
                        e !== 0 ? ((y = this.vertices[f[0][u]].clone()), (b = this.vertices[f[0][u + 1]].clone())) : ((y = this.vertices[f[1][u]].clone()), (b = this.vertices[f[1][u + 1]].clone())),
                            y.setY(Math.sqrt(y.x * y.x + y.z * y.z) * g).normalize(),
                            b.setY(Math.sqrt(b.x * b.x + b.z * b.z) * g).normalize();
                        for (a = 0; a < i; a++) {
                            var w = f[a][u],
                                E = f[a + 1][u],
                                S = f[a + 1][u + 1],
                                x = f[a][u + 1],
                                T = y.clone(),
                                N = y.clone(),
                                C = b.clone(),
                                k = b.clone(),
                                L = l[a][u].clone(),
                                A = l[a + 1][u].clone(),
                                O = l[a + 1][u + 1].clone(),
                                M = l[a][u + 1].clone();
                            this.faces.push(new THREE.Face3(w, E, x, [T, N, k])), this.faceVertexUvs[0].push([L, A, M]), this.faces.push(new THREE.Face3(E, S, x, [N, C, k])), this.faceVertexUvs[0].push([A, O, M]);
                        }
                    }
                    if (s === !1 && e > 0) {
                        this.vertices.push(new THREE.Vector3(0, o, 0));
                        for (u = 0; u < r; u++) {
                            var w = f[0][u],
                                E = f[0][u + 1],
                                S = this.vertices.length - 1,
                                T = new THREE.Vector3(0, 1, 0),
                                N = new THREE.Vector3(0, 1, 0),
                                C = new THREE.Vector3(0, 1, 0),
                                L = l[0][u].clone(),
                                A = l[0][u + 1].clone(),
                                O = new THREE.Vector2(A.u, 0);
                            this.faces.push(new THREE.Face3(w, E, S, [T, N, C])), this.faceVertexUvs[0].push([L, A, O]);
                        }
                    }
                    if (s === !1 && t > 0) {
                        this.vertices.push(new THREE.Vector3(0, -o, 0));
                        for (u = 0; u < r; u++) {
                            var w = f[a][u + 1],
                                E = f[a][u],
                                S = this.vertices.length - 1,
                                T = new THREE.Vector3(0, -1, 0),
                                N = new THREE.Vector3(0, -1, 0),
                                C = new THREE.Vector3(0, -1, 0),
                                L = l[a][u + 1].clone(),
                                A = l[a][u].clone(),
                                O = new THREE.Vector2(A.u, 1);
                            this.faces.push(new THREE.Face3(w, E, S, [T, N, C])), this.faceVertexUvs[0].push([L, A, O]);
                        }
                    }
                    this.computeCentroids(), this.computeFaceNormals();
                }),
                (THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.ExtrudeGeometry = function (e, t) {
                    if (typeof e == "undefined") {
                        e = [];
                        return;
                    }
                    THREE.Geometry.call(this), (e = e instanceof Array ? e : [e]), (this.shapebb = e[e.length - 1].getBoundingBox()), this.addShapeList(e, t), this.computeCentroids(), this.computeFaceNormals();
                }),
                (THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.ExtrudeGeometry.prototype.addShapeList = function (e, t) {
                    var n = e.length;
                    for (var r = 0; r < n; r++) {
                        var i = e[r];
                        this.addShape(i, t);
                    }
                }),
                (THREE.ExtrudeGeometry.prototype.addShape = function (e, t) {
                    function _(e, t, n) {
                        return t || console.log("die"), t.clone().multiplyScalar(n).add(e);
                    }
                    function W(e, t, n) {
                        return V(e, t, n);
                    }
                    function X(e, t, n) {
                        var r = Math.atan2(t.y - e.y, t.x - e.x),
                            i = Math.atan2(n.y - e.y, n.x - e.x);
                        r > i && (i += Math.PI * 2);
                        var s = (r + i) / 2,
                            o = -Math.cos(s),
                            u = -Math.sin(s),
                            a = new THREE.Vector2(o, u);
                        return a;
                    }
                    function V(e, t, n) {
                        var r = THREE.ExtrudeGeometry.__v1,
                            i = THREE.ExtrudeGeometry.__v2,
                            s = THREE.ExtrudeGeometry.__v3,
                            o = THREE.ExtrudeGeometry.__v4,
                            u = THREE.ExtrudeGeometry.__v5,
                            a = THREE.ExtrudeGeometry.__v6,
                            f,
                            l,
                            c,
                            h,
                            p,
                            d;
                        return (
                            r.set(e.x - t.x, e.y - t.y),
                                i.set(e.x - n.x, e.y - n.y),
                                (f = r.normalize()),
                                (l = i.normalize()),
                                s.set(-f.y, f.x),
                                o.set(l.y, -l.x),
                                u.copy(e).add(s),
                                a.copy(e).add(o),
                                u.equals(a)
                                    ? o.clone()
                                    : (u.copy(t).add(s),
                                        a.copy(n).add(o),
                                        (c = f.dot(o)),
                                        (h = a.sub(u).dot(o)),
                                    c === 0 && (console.log("Either infinite or no solutions!"), h === 0 ? console.log("Its finite solutions.") : console.log("Too bad, no solutions.")),
                                        (p = h / c),
                                        p < 0 ? X(e, t, n) : ((d = f.multiplyScalar(p).add(u)), d.sub(e).clone()))
                        );
                    }
                    function st() {
                        if (o) {
                            var e = 0,
                                t = F * e;
                            for (J = 0; J < q; J++) (I = O[J]), ft(I[2] + t, I[1] + t, I[0] + t, !0);
                            (e = a + s * 2), (t = F * e);
                            for (J = 0; J < q; J++) (I = O[J]), ft(I[0] + t, I[1] + t, I[2] + t, !1);
                        } else {
                            for (J = 0; J < q; J++) (I = O[J]), ft(I[2], I[1], I[0], !0);
                            for (J = 0; J < q; J++) (I = O[J]), ft(I[0] + F * a, I[1] + F * a, I[2] + F * a, !1);
                        }
                    }
                    function ot() {
                        var e = 0;
                        ut(M, e), (e += M.length);
                        for (E = 0, S = L.length; E < S; E++) (w = L[E]), ut(w, e), (e += w.length);
                    }
                    function ut(e, t) {
                        var n, r;
                        J = e.length;
                        while (--J >= 0) {
                            (n = J), (r = J - 1), r < 0 && (r = e.length - 1);
                            var i = 0,
                                o = a + s * 2;
                            for (i = 0; i < o; i++) {
                                var u = F * i,
                                    f = F * (i + 1),
                                    l = t + n + u,
                                    c = t + r + u,
                                    h = t + r + f,
                                    p = t + n + f;
                                lt(l, c, h, p, e, i, o, n, r);
                            }
                        }
                    }
                    function at(e, t, n) {
                        x.vertices.push(new THREE.Vector3(e, t, n));
                    }
                    function ft(n, r, i, s) {
                        (n += N), (r += N), (i += N), x.faces.push(new THREE.Face3(n, r, i, null, null, h));
                        var o = s ? d.generateBottomUV(x, e, t, n, r, i) : d.generateTopUV(x, e, t, n, r, i);
                        x.faceVertexUvs[0].push(o);
                    }
                    function lt(n, r, i, s, o, u, a, f, l) {
                        (n += N), (r += N), (i += N), (s += N), x.faces.push(new THREE.Face3(n, r, s, null, null, p)), x.faces.push(new THREE.Face3(r, i, s, null, null, p));
                        var c = d.generateSideWallUV(x, e, o, t, n, r, i, s, u, a, f, l);
                        x.faceVertexUvs[0].push([c[0], c[1], c[3]]), x.faceVertexUvs[0].push([c[1], c[2], c[3]]);
                    }
                    var n = t.amount !== undefined ? t.amount : 100,
                        r = t.bevelThickness !== undefined ? t.bevelThickness : 6,
                        i = t.bevelSize !== undefined ? t.bevelSize : r - 2,
                        s = t.bevelSegments !== undefined ? t.bevelSegments : 3,
                        o = t.bevelEnabled !== undefined ? t.bevelEnabled : !0,
                        u = t.curveSegments !== undefined ? t.curveSegments : 12,
                        a = t.steps !== undefined ? t.steps : 1,
                        f = t.extrudePath,
                        l,
                        c = !1,
                        h = t.material,
                        p = t.extrudeMaterial,
                        d = t.UVGenerator !== undefined ? t.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator,
                        v = this.shapebb,
                        m,
                        g,
                        y,
                        b;
                    f && ((l = f.getSpacedPoints(a)), (c = !0), (o = !1), (m = t.frames !== undefined ? t.frames : new THREE.TubeGeometry.FrenetFrames(f, a, !1)), (g = new THREE.Vector3()), (y = new THREE.Vector3()), (b = new THREE.Vector3())),
                    o || ((s = 0), (r = 0), (i = 0));
                    var w,
                        E,
                        S,
                        x = this,
                        T = [],
                        N = this.vertices.length,
                        C = e.extractPoints(u),
                        k = C.shape,
                        L = C.holes,
                        A = !THREE.Shape.Utils.isClockWise(k);
                    if (A) {
                        k = k.reverse();
                        for (E = 0, S = L.length; E < S; E++) (w = L[E]), THREE.Shape.Utils.isClockWise(w) && (L[E] = w.reverse());
                        A = !1;
                    }
                    var O = THREE.Shape.Utils.triangulateShape(k, L),
                        M = k;
                    for (E = 0, S = L.length; E < S; E++) (w = L[E]), (k = k.concat(w));
                    var D,
                        P,
                        H,
                        B,
                        j,
                        F = k.length,
                        I,
                        q = O.length,
                        R,
                        U = M.length,
                        z = 180 / Math.PI,
                        $ = [];
                    for (var J = 0, K = M.length, Q = K - 1, G = J + 1; J < K; J++, Q++, G++) {
                        Q === K && (Q = 0), G === K && (G = 0);
                        var Y = M[J],
                            Z = M[Q],
                            et = M[G];
                        $[J] = W(M[J], M[Q], M[G]);
                    }
                    var tt = [],
                        nt,
                        rt = $.concat();
                    for (E = 0, S = L.length; E < S; E++) {
                        (w = L[E]), (nt = []);
                        for (J = 0, K = w.length, Q = K - 1, G = J + 1; J < K; J++, Q++, G++) Q === K && (Q = 0), G === K && (G = 0), (nt[J] = W(w[J], w[Q], w[G]));
                        tt.push(nt), (rt = rt.concat(nt));
                    }
                    for (D = 0; D < s; D++) {
                        (H = D / s), (B = r * (1 - H)), (P = i * Math.sin((H * Math.PI) / 2));
                        for (J = 0, K = M.length; J < K; J++) (j = _(M[J], $[J], P)), at(j.x, j.y, -B);
                        for (E = 0, S = L.length; E < S; E++) {
                            (w = L[E]), (nt = tt[E]);
                            for (J = 0, K = w.length; J < K; J++) (j = _(w[J], nt[J], P)), at(j.x, j.y, -B);
                        }
                    }
                    P = i;
                    for (J = 0; J < F; J++) (j = o ? _(k[J], rt[J], P) : k[J]), c ? (y.copy(m.normals[0]).multiplyScalar(j.x), g.copy(m.binormals[0]).multiplyScalar(j.y), b.copy(l[0]).add(y).add(g), at(b.x, b.y, b.z)) : at(j.x, j.y, 0);
                    var it;
                    for (it = 1; it <= a; it++)
                        for (J = 0; J < F; J++)
                            (j = o ? _(k[J], rt[J], P) : k[J]), c ? (y.copy(m.normals[it]).multiplyScalar(j.x), g.copy(m.binormals[it]).multiplyScalar(j.y), b.copy(l[it]).add(y).add(g), at(b.x, b.y, b.z)) : at(j.x, j.y, (n / a) * it);
                    for (D = s - 1; D >= 0; D--) {
                        (H = D / s), (B = r * (1 - H)), (P = i * Math.sin((H * Math.PI) / 2));
                        for (J = 0, K = M.length; J < K; J++) (j = _(M[J], $[J], P)), at(j.x, j.y, n + B);
                        for (E = 0, S = L.length; E < S; E++) {
                            (w = L[E]), (nt = tt[E]);
                            for (J = 0, K = w.length; J < K; J++) (j = _(w[J], nt[J], P)), c ? at(j.x, j.y + l[a - 1].y, l[a - 1].x + B) : at(j.x, j.y, n + B);
                        }
                    }
                    st(), ot();
                }),
                (THREE.ExtrudeGeometry.WorldUVGenerator = {
                    generateTopUV: function (e, t, n, r, i, s) {
                        var o = e.vertices[r].x,
                            u = e.vertices[r].y,
                            a = e.vertices[i].x,
                            f = e.vertices[i].y,
                            l = e.vertices[s].x,
                            c = e.vertices[s].y;
                        return [new THREE.Vector2(o, u), new THREE.Vector2(a, f), new THREE.Vector2(l, c)];
                    },
                    generateBottomUV: function (e, t, n, r, i, s) {
                        return this.generateTopUV(e, t, n, r, i, s);
                    },
                    generateSideWallUV: function (e, t, n, r, i, s, o, u, a, f, l, c) {
                        var h = e.vertices[i].x,
                            p = e.vertices[i].y,
                            d = e.vertices[i].z,
                            v = e.vertices[s].x,
                            m = e.vertices[s].y,
                            g = e.vertices[s].z,
                            y = e.vertices[o].x,
                            b = e.vertices[o].y,
                            w = e.vertices[o].z,
                            E = e.vertices[u].x,
                            S = e.vertices[u].y,
                            x = e.vertices[u].z;
                        return Math.abs(p - m) < 0.01
                            ? [new THREE.Vector2(h, 1 - d), new THREE.Vector2(v, 1 - g), new THREE.Vector2(y, 1 - w), new THREE.Vector2(E, 1 - x)]
                            : [new THREE.Vector2(p, 1 - d), new THREE.Vector2(m, 1 - g), new THREE.Vector2(b, 1 - w), new THREE.Vector2(S, 1 - x)];
                    },
                }),
                (THREE.ExtrudeGeometry.__v1 = new THREE.Vector2()),
                (THREE.ExtrudeGeometry.__v2 = new THREE.Vector2()),
                (THREE.ExtrudeGeometry.__v3 = new THREE.Vector2()),
                (THREE.ExtrudeGeometry.__v4 = new THREE.Vector2()),
                (THREE.ExtrudeGeometry.__v5 = new THREE.Vector2()),
                (THREE.ExtrudeGeometry.__v6 = new THREE.Vector2()),
                (THREE.ShapeGeometry = function (e, t) {
                    THREE.Geometry.call(this), e instanceof Array == 0 && (e = [e]), (this.shapebb = e[e.length - 1].getBoundingBox()), this.addShapeList(e, t), this.computeCentroids(), this.computeFaceNormals();
                }),
                (THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.ShapeGeometry.prototype.addShapeList = function (e, t) {
                    for (var n = 0, r = e.length; n < r; n++) this.addShape(e[n], t);
                    return this;
                }),
                (THREE.ShapeGeometry.prototype.addShape = function (e, t) {
                    t === undefined && (t = {});
                    var n = t.curveSegments !== undefined ? t.curveSegments : 12,
                        r = t.material,
                        i = t.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : t.UVGenerator,
                        s = this.shapebb,
                        o,
                        u,
                        a,
                        f,
                        l = this.vertices.length,
                        c = e.extractPoints(n),
                        h = c.shape,
                        p = c.holes,
                        d = !THREE.Shape.Utils.isClockWise(h);
                    if (d) {
                        h = h.reverse();
                        for (o = 0, u = p.length; o < u; o++) (a = p[o]), THREE.Shape.Utils.isClockWise(a) && (p[o] = a.reverse());
                        d = !1;
                    }
                    var v = THREE.Shape.Utils.triangulateShape(h, p),
                        m = h;
                    for (o = 0, u = p.length; o < u; o++) (a = p[o]), (h = h.concat(a));
                    var g,
                        y = h.length,
                        b,
                        w = v.length,
                        E,
                        S = m.length;
                    for (o = 0; o < y; o++) (g = h[o]), this.vertices.push(new THREE.Vector3(g.x, g.y, 0));
                    for (o = 0; o < w; o++) {
                        b = v[o];
                        var x = b[0] + l,
                            T = b[1] + l,
                            N = b[2] + l;
                        this.faces.push(new THREE.Face3(x, T, N, null, null, r)), this.faceVertexUvs[0].push(i.generateBottomUV(this, e, t, x, T, N));
                    }
                }),
                (THREE.LatheGeometry = function (e, t, n, r) {
                    THREE.Geometry.call(this), (t = t || 12), (n = n || 0), (r = r || 2 * Math.PI);
                    var i = 1 / (e.length - 1),
                        s = 1 / t;
                    for (var o = 0, u = t; o <= u; o++) {
                        var a = n + o * s * r,
                            f = Math.cos(a),
                            l = Math.sin(a);
                        for (var c = 0, h = e.length; c < h; c++) {
                            var p = e[c],
                                d = new THREE.Vector3();
                            (d.x = f * p.x - l * p.y), (d.y = l * p.x + f * p.y), (d.z = p.z), this.vertices.push(d);
                        }
                    }
                    var v = e.length;
                    for (var o = 0, u = t; o < u; o++)
                        for (var c = 0, h = e.length - 1; c < h; c++) {
                            var m = c + v * o,
                                g = m,
                                y = m + v,
                                f = m + 1 + v,
                                b = m + 1,
                                w = o * s,
                                E = c * i,
                                S = w + s,
                                x = E + i;
                            this.faces.push(new THREE.Face3(g, y, b)),
                                this.faceVertexUvs[0].push([new THREE.Vector2(w, E), new THREE.Vector2(S, E), new THREE.Vector2(w, x)]),
                                this.faces.push(new THREE.Face3(y, f, b)),
                                this.faceVertexUvs[0].push([new THREE.Vector2(S, E), new THREE.Vector2(S, x), new THREE.Vector2(w, x)]);
                        }
                    this.mergeVertices(), this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals();
                }),
                (THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.PlaneGeometry = function (e, t, n, r) {
                    THREE.Geometry.call(this), (this.width = e), (this.height = t), (this.widthSegments = n || 1), (this.heightSegments = r || 1);
                    var i,
                        s,
                        o = e / 2,
                        u = t / 2,
                        a = this.widthSegments,
                        f = this.heightSegments,
                        l = a + 1,
                        c = f + 1,
                        h = this.width / a,
                        p = this.height / f,
                        d = new THREE.Vector3(0, 0, 1);
                    for (s = 0; s < c; s++)
                        for (i = 0; i < l; i++) {
                            var v = i * h - o,
                                m = s * p - u;
                            this.vertices.push(new THREE.Vector3(v, -m, 0));
                        }
                    for (s = 0; s < f; s++)
                        for (i = 0; i < a; i++) {
                            var g = i + l * s,
                                y = i + l * (s + 1),
                                b = i + 1 + l * (s + 1),
                                w = i + 1 + l * s,
                                E = new THREE.Vector2(i / a, 1 - s / f),
                                S = new THREE.Vector2(i / a, 1 - (s + 1) / f),
                                x = new THREE.Vector2((i + 1) / a, 1 - (s + 1) / f),
                                T = new THREE.Vector2((i + 1) / a, 1 - s / f),
                                N = new THREE.Face3(g, y, w);
                            N.normal.copy(d),
                                N.vertexNormals.push(d.clone(), d.clone(), d.clone()),
                                this.faces.push(N),
                                this.faceVertexUvs[0].push([E, S, T]),
                                (N = new THREE.Face3(y, b, w)),
                                N.normal.copy(d),
                                N.vertexNormals.push(d.clone(), d.clone(), d.clone()),
                                this.faces.push(N),
                                this.faceVertexUvs[0].push([S.clone(), x, T.clone()]);
                        }
                    this.computeCentroids();
                }),
                (THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.RingGeometry = function (e, t, n, r, i, s) {
                    THREE.Geometry.call(this), (e = e || 0), (t = t || 50), (i = i !== undefined ? i : 0), (s = s !== undefined ? s : Math.PI * 2), (n = n !== undefined ? Math.max(3, n) : 8), (r = r !== undefined ? Math.max(3, r) : 8);
                    var o,
                        u,
                        a = [],
                        f = e,
                        l = (t - e) / r;
                    for (o = 0; o <= r; o++) {
                        for (u = 0; u <= n; u++) {
                            var c = new THREE.Vector3(),
                                h = i + (u / n) * s;
                            (c.x = f * Math.cos(h)), (c.y = f * Math.sin(h)), this.vertices.push(c), a.push(new THREE.Vector2((c.x / f + 1) / 2, -(c.y / f + 1) / 2 + 1));
                        }
                        f += l;
                    }
                    var p = new THREE.Vector3(0, 0, 1);
                    for (o = 0; o < r; o++) {
                        var d = o * n;
                        for (u = 0; u <= n; u++) {
                            var h = u + d,
                                v = h + o,
                                m = h + n + o,
                                g = h + n + 1 + o;
                            this.faces.push(new THREE.Face3(v, m, g, [p, p, p])),
                                this.faceVertexUvs[0].push([a[v], a[m], a[g]]),
                                (v = h + o),
                                (m = h + n + 1 + o),
                                (g = h + 1 + o),
                                this.faces.push(new THREE.Face3(v, m, g, [p, p, p])),
                                this.faceVertexUvs[0].push([a[v], a[m], a[g]]);
                        }
                    }
                    this.computeCentroids(), this.computeFaceNormals(), (this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), f));
                }),
                (THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.SphereGeometry = function (e, t, n, r, i, s, o) {
                    THREE.Geometry.call(this),
                        (this.radius = e = e || 50),
                        (this.widthSegments = t = Math.max(3, Math.floor(t) || 8)),
                        (this.heightSegments = n = Math.max(2, Math.floor(n) || 6)),
                        (this.phiStart = r = r !== undefined ? r : 0),
                        (this.phiLength = i = i !== undefined ? i : Math.PI * 2),
                        (this.thetaStart = s = s !== undefined ? s : 0),
                        (this.thetaLength = o = o !== undefined ? o : Math.PI);
                    var u,
                        a,
                        f = [],
                        l = [];
                    for (a = 0; a <= n; a++) {
                        var c = [],
                            h = [];
                        for (u = 0; u <= t; u++) {
                            var p = u / t,
                                d = a / n,
                                v = new THREE.Vector3();
                            (v.x = -e * Math.cos(r + p * i) * Math.sin(s + d * o)),
                                (v.y = e * Math.cos(s + d * o)),
                                (v.z = e * Math.sin(r + p * i) * Math.sin(s + d * o)),
                                this.vertices.push(v),
                                c.push(this.vertices.length - 1),
                                h.push(new THREE.Vector2(p, 1 - d));
                        }
                        f.push(c), l.push(h);
                    }
                    for (a = 0; a < this.heightSegments; a++)
                        for (u = 0; u < this.widthSegments; u++) {
                            var m = f[a][u + 1],
                                g = f[a][u],
                                y = f[a + 1][u],
                                b = f[a + 1][u + 1],
                                w = this.vertices[m].clone().normalize(),
                                E = this.vertices[g].clone().normalize(),
                                S = this.vertices[y].clone().normalize(),
                                x = this.vertices[b].clone().normalize(),
                                T = l[a][u + 1].clone(),
                                N = l[a][u].clone(),
                                C = l[a + 1][u].clone(),
                                k = l[a + 1][u + 1].clone();
                            Math.abs(this.vertices[m].y) === this.radius
                                ? (this.faces.push(new THREE.Face3(m, y, b, [w, S, x])), this.faceVertexUvs[0].push([T, C, k]))
                                : Math.abs(this.vertices[y].y) === this.radius
                                ? (this.faces.push(new THREE.Face3(m, g, y, [w, E, S])), this.faceVertexUvs[0].push([T, N, C]))
                                : (this.faces.push(new THREE.Face3(m, g, b, [w, E, x])), this.faceVertexUvs[0].push([T, N, k]), this.faces.push(new THREE.Face3(g, y, b, [E, S, x])), this.faceVertexUvs[0].push([N.clone(), C, k.clone()]));
                        }
                    this.computeCentroids(), this.computeFaceNormals(), (this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), e));
                }),
                (THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.TextGeometry = function (e, t) {
                    t = t || {};
                    var n = THREE.FontUtils.generateShapes(e, t);
                    (t.amount = t.height !== undefined ? t.height : 50),
                    t.bevelThickness === undefined && (t.bevelThickness = 10),
                    t.bevelSize === undefined && (t.bevelSize = 8),
                    t.bevelEnabled === undefined && (t.bevelEnabled = !1),
                        THREE.ExtrudeGeometry.call(this, n, t);
                }),
                (THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype)),
                (THREE.TorusGeometry = function (e, t, n, r, i) {
                    THREE.Geometry.call(this);
                    var s = this;
                    (this.radius = e || 100), (this.tube = t || 40), (this.radialSegments = n || 8), (this.tubularSegments = r || 6), (this.arc = i || Math.PI * 2);
                    var o = new THREE.Vector3(),
                        u = [],
                        a = [];
                    for (var f = 0; f <= this.radialSegments; f++)
                        for (var l = 0; l <= this.tubularSegments; l++) {
                            var c = (l / this.tubularSegments) * this.arc,
                                h = (f / this.radialSegments) * Math.PI * 2;
                            (o.x = this.radius * Math.cos(c)), (o.y = this.radius * Math.sin(c));
                            var p = new THREE.Vector3();
                            (p.x = (this.radius + this.tube * Math.cos(h)) * Math.cos(c)),
                                (p.y = (this.radius + this.tube * Math.cos(h)) * Math.sin(c)),
                                (p.z = this.tube * Math.sin(h)),
                                this.vertices.push(p),
                                u.push(new THREE.Vector2(l / this.tubularSegments, f / this.radialSegments)),
                                a.push(p.clone().sub(o).normalize());
                        }
                    for (var f = 1; f <= this.radialSegments; f++)
                        for (var l = 1; l <= this.tubularSegments; l++) {
                            var d = (this.tubularSegments + 1) * f + l - 1,
                                v = (this.tubularSegments + 1) * (f - 1) + l - 1,
                                m = (this.tubularSegments + 1) * (f - 1) + l,
                                g = (this.tubularSegments + 1) * f + l,
                                y = new THREE.Face3(d, v, g, [a[d], a[v], a[g]]);
                            y.normal.add(a[d]),
                                y.normal.add(a[v]),
                                y.normal.add(a[g]),
                                y.normal.normalize(),
                                this.faces.push(y),
                                this.faceVertexUvs[0].push([u[d].clone(), u[v].clone(), u[g].clone()]),
                                (y = new THREE.Face3(v, m, g, [a[v], a[m], a[g]])),
                                y.normal.add(a[v]),
                                y.normal.add(a[m]),
                                y.normal.add(a[g]),
                                y.normal.normalize(),
                                this.faces.push(y),
                                this.faceVertexUvs[0].push([u[v].clone(), u[m].clone(), u[g].clone()]);
                        }
                    this.computeCentroids();
                }),
                (THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.TorusKnotGeometry = function (e, t, n, r, i, s, o) {
                    function O(e, t, n, r, i) {
                        var s = Math.cos(e),
                            o = Math.sin(e),
                            u = (t / n) * e,
                            a = Math.cos(u),
                            f = r * (2 + a) * 0.5 * s,
                            l = r * (2 + a) * o * 0.5,
                            c = i * r * Math.sin(u) * 0.5;
                        return new THREE.Vector3(f, l, c);
                    }
                    THREE.Geometry.call(this);
                    var u = this;
                    (this.radius = e || 100), (this.tube = t || 40), (this.radialSegments = n || 64), (this.tubularSegments = r || 8), (this.p = i || 2), (this.q = s || 3), (this.heightScale = o || 1), (this.grid = new Array(this.radialSegments));
                    var a = new THREE.Vector3(),
                        f = new THREE.Vector3(),
                        l = new THREE.Vector3();
                    for (var c = 0; c < this.radialSegments; ++c) {
                        this.grid[c] = new Array(this.tubularSegments);
                        var h = (c / this.radialSegments) * 2 * this.p * Math.PI,
                            p = O(h, this.q, this.p, this.radius, this.heightScale),
                            d = O(h + 0.01, this.q, this.p, this.radius, this.heightScale);
                        a.subVectors(d, p), f.addVectors(d, p), l.crossVectors(a, f), f.crossVectors(l, a), l.normalize(), f.normalize();
                        for (var v = 0; v < this.tubularSegments; ++v) {
                            var m = (v / this.tubularSegments) * 2 * Math.PI,
                                g = -this.tube * Math.cos(m),
                                y = this.tube * Math.sin(m),
                                b = new THREE.Vector3();
                            (b.x = p.x + g * f.x + y * l.x), (b.y = p.y + g * f.y + y * l.y), (b.z = p.z + g * f.z + y * l.z), (this.grid[c][v] = u.vertices.push(b) - 1);
                        }
                    }
                    for (var c = 0; c < this.radialSegments; ++c)
                        for (var v = 0; v < this.tubularSegments; ++v) {
                            var w = (c + 1) % this.radialSegments,
                                E = (v + 1) % this.tubularSegments,
                                S = this.grid[c][v],
                                x = this.grid[w][v],
                                T = this.grid[w][E],
                                N = this.grid[c][E],
                                C = new THREE.Vector2(c / this.radialSegments, v / this.tubularSegments),
                                k = new THREE.Vector2((c + 1) / this.radialSegments, v / this.tubularSegments),
                                L = new THREE.Vector2((c + 1) / this.radialSegments, (v + 1) / this.tubularSegments),
                                A = new THREE.Vector2(c / this.radialSegments, (v + 1) / this.tubularSegments);
                            this.faces.push(new THREE.Face3(S, x, N)), this.faceVertexUvs[0].push([C, k, A]), this.faces.push(new THREE.Face3(x, T, N)), this.faceVertexUvs[0].push([k.clone(), L, A.clone()]);
                        }
                    this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals();
                }),
                (THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.TubeGeometry = function (e, t, n, r, i) {
                    function F(e, t, n) {
                        return s.vertices.push(new THREE.Vector3(e, t, n)) - 1;
                    }
                    THREE.Geometry.call(this), (this.path = e), (this.segments = t || 64), (this.radius = n || 1), (this.radialSegments = r || 8), (this.closed = i || !1), (this.grid = []);
                    var s = this,
                        o,
                        u,
                        a,
                        f = this.segments + 1,
                        l,
                        c,
                        h,
                        p,
                        d,
                        v,
                        m,
                        g,
                        y,
                        b,
                        w,
                        E = new THREE.Vector3(),
                        S,
                        x,
                        T,
                        N,
                        C,
                        k,
                        L,
                        A,
                        O,
                        M,
                        _,
                        D,
                        P = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed),
                        H = P.tangents,
                        B = P.normals,
                        j = P.binormals;
                    (this.tangents = H), (this.normals = B), (this.binormals = j);
                    for (S = 0; S < f; S++) {
                        (this.grid[S] = []), (m = S / (f - 1)), (w = e.getPointAt(m)), (o = H[S]), (u = B[S]), (a = j[S]);
                        for (x = 0; x < this.radialSegments; x++)
                            (g = (x / this.radialSegments) * 2 * Math.PI),
                                (y = -this.radius * Math.cos(g)),
                                (b = this.radius * Math.sin(g)),
                                E.copy(w),
                                (E.x += y * u.x + b * a.x),
                                (E.y += y * u.y + b * a.y),
                                (E.z += y * u.z + b * a.z),
                                (this.grid[S][x] = F(E.x, E.y, E.z));
                    }
                    for (S = 0; S < this.segments; S++)
                        for (x = 0; x < this.radialSegments; x++)
                            (T = this.closed ? (S + 1) % this.segments : S + 1),
                                (N = (x + 1) % this.radialSegments),
                                (C = this.grid[S][x]),
                                (k = this.grid[T][x]),
                                (L = this.grid[T][N]),
                                (A = this.grid[S][N]),
                                (O = new THREE.Vector2(S / this.segments, x / this.radialSegments)),
                                (M = new THREE.Vector2((S + 1) / this.segments, x / this.radialSegments)),
                                (_ = new THREE.Vector2((S + 1) / this.segments, (x + 1) / this.radialSegments)),
                                (D = new THREE.Vector2(S / this.segments, (x + 1) / this.radialSegments)),
                                this.faces.push(new THREE.Face3(C, k, A)),
                                this.faceVertexUvs[0].push([O, M, D]),
                                this.faces.push(new THREE.Face3(k, L, A)),
                                this.faceVertexUvs[0].push([M.clone(), _, D.clone()]);
                    this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals();
                }),
                (THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.TubeGeometry.FrenetFrames = function (e, t, n) {
                    function E(e) {
                        (u[0] = new THREE.Vector3()), (a[0] = new THREE.Vector3()), e === undefined && (e = new THREE.Vector3(0, 0, 1)), u[0].crossVectors(e, o[0]).normalize(), a[0].crossVectors(o[0], u[0]).normalize();
                    }
                    function S() {
                        var t = e.getTangentAt(p);
                        (u[0] = new THREE.Vector3().subVectors(t, o[0]).normalize()), (a[0] = new THREE.Vector3().crossVectors(o[0], u[0])), u[0].crossVectors(a[0], o[0]).normalize(), a[0].crossVectors(o[0], u[0]).normalize();
                    }
                    function x() {
                        (u[0] = new THREE.Vector3()),
                            (a[0] = new THREE.Vector3()),
                            (d = Number.MAX_VALUE),
                            (v = Math.abs(o[0].x)),
                            (m = Math.abs(o[0].y)),
                            (g = Math.abs(o[0].z)),
                        v <= d && ((d = v), i.set(1, 0, 0)),
                        m <= d && ((d = m), i.set(0, 1, 0)),
                        g <= d && i.set(0, 0, 1),
                            f.crossVectors(o[0], i).normalize(),
                            u[0].crossVectors(o[0], f),
                            a[0].crossVectors(o[0], u[0]);
                    }
                    var r = new THREE.Vector3(),
                        i = new THREE.Vector3(),
                        s = new THREE.Vector3(),
                        o = [],
                        u = [],
                        a = [],
                        f = new THREE.Vector3(),
                        l = new THREE.Matrix4(),
                        c = t + 1,
                        h,
                        p = 1e-4,
                        d,
                        v,
                        m,
                        g,
                        y,
                        b,
                        w;
                    (this.tangents = o), (this.normals = u), (this.binormals = a);
                    for (y = 0; y < c; y++) (b = y / (c - 1)), (o[y] = e.getTangentAt(b)), o[y].normalize();
                    x();
                    for (y = 1; y < c; y++)
                        (u[y] = u[y - 1].clone()),
                            (a[y] = a[y - 1].clone()),
                            f.crossVectors(o[y - 1], o[y]),
                        f.length() > p && (f.normalize(), (h = Math.acos(THREE.Math.clamp(o[y - 1].dot(o[y]), -1, 1))), u[y].applyMatrix4(l.makeRotationAxis(f, h))),
                            a[y].crossVectors(o[y], u[y]);
                    if (n) {
                        (h = Math.acos(THREE.Math.clamp(u[0].dot(u[c - 1]), -1, 1))), (h /= c - 1), o[0].dot(f.crossVectors(u[0], u[c - 1])) > 0 && (h = -h);
                        for (y = 1; y < c; y++) u[y].applyMatrix4(l.makeRotationAxis(o[y], h * y)), a[y].crossVectors(o[y], u[y]);
                    }
                }),
                (THREE.PolyhedronGeometry = function (e, t, n, r) {
                    function b(e) {
                        var t = e.normalize().clone();
                        t.index = i.vertices.push(t) - 1;
                        var n = S(e) / 2 / Math.PI + 0.5,
                            r = x(e) / Math.PI + 0.5;
                        return (t.uv = new THREE.Vector2(n, 1 - r)), t;
                    }
                    function w(e, t, n) {
                        var r = new THREE.Face3(e.index, t.index, n.index, [e.clone(), t.clone(), n.clone()]);
                        r.centroid.add(e).add(t).add(n).divideScalar(3), i.faces.push(r);
                        var s = S(r.centroid);
                        i.faceVertexUvs[0].push([T(e.uv, e, s), T(t.uv, t, s), T(n.uv, n, s)]);
                    }
                    function E(e, t) {
                        var n = Math.pow(2, t),
                            r = Math.pow(4, t),
                            s = b(i.vertices[e.a]),
                            o = b(i.vertices[e.b]),
                            u = b(i.vertices[e.c]),
                            a = [];
                        for (var f = 0; f <= n; f++) {
                            a[f] = [];
                            var l = b(s.clone().lerp(u, f / n)),
                                c = b(o.clone().lerp(u, f / n)),
                                h = n - f;
                            for (var p = 0; p <= h; p++) p == 0 && f == n ? (a[f][p] = l) : (a[f][p] = b(l.clone().lerp(c, p / h)));
                        }
                        for (var f = 0; f < n; f++)
                            for (var p = 0; p < 2 * (n - f) - 1; p++) {
                                var d = Math.floor(p / 2);
                                p % 2 == 0 ? w(a[f][d + 1], a[f + 1][d], a[f][d]) : w(a[f][d + 1], a[f + 1][d + 1], a[f + 1][d]);
                            }
                    }
                    function S(e) {
                        return Math.atan2(e.z, -e.x);
                    }
                    function x(e) {
                        return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z));
                    }
                    function T(e, t, n) {
                        return n < 0 && e.x === 1 && (e = new THREE.Vector2(e.x - 1, e.y)), t.x === 0 && t.z === 0 && (e = new THREE.Vector2(n / 2 / Math.PI + 0.5, e.y)), e.clone();
                    }
                    THREE.Geometry.call(this), (n = n || 1), (r = r || 0);
                    var i = this;
                    for (var s = 0, o = e.length; s < o; s++) b(new THREE.Vector3(e[s][0], e[s][1], e[s][2]));
                    var u = [],
                        a = this.vertices,
                        f = [];
                    for (var s = 0, o = t.length; s < o; s++) {
                        var l = a[t[s][0]],
                            c = a[t[s][1]],
                            h = a[t[s][2]];
                        f[s] = new THREE.Face3(l.index, c.index, h.index, [l.clone(), c.clone(), h.clone()]);
                    }
                    for (var s = 0, o = f.length; s < o; s++) E(f[s], r);
                    for (var s = 0, o = this.faceVertexUvs[0].length; s < o; s++) {
                        var p = this.faceVertexUvs[0][s],
                            d = p[0].x,
                            v = p[1].x,
                            m = p[2].x,
                            g = Math.max(d, Math.max(v, m)),
                            y = Math.min(d, Math.min(v, m));
                        g > 0.9 && y < 0.1 && (d < 0.2 && (p[0].x += 1), v < 0.2 && (p[1].x += 1), m < 0.2 && (p[2].x += 1));
                    }
                    for (var s = 0, o = this.vertices.length; s < o; s++) this.vertices[s].multiplyScalar(n);
                    this.mergeVertices(), this.computeCentroids(), this.computeFaceNormals(), (this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), n));
                }),
                (THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.IcosahedronGeometry = function (e, t) {
                    (this.radius = e), (this.detail = t);
                    var n = (1 + Math.sqrt(5)) / 2,
                        r = [
                            [-1, n, 0],
                            [1, n, 0],
                            [-1, -n, 0],
                            [1, -n, 0],
                            [0, -1, n],
                            [0, 1, n],
                            [0, -1, -n],
                            [0, 1, -n],
                            [n, 0, -1],
                            [n, 0, 1],
                            [-n, 0, -1],
                            [-n, 0, 1],
                        ],
                        i = [
                            [0, 11, 5],
                            [0, 5, 1],
                            [0, 1, 7],
                            [0, 7, 10],
                            [0, 10, 11],
                            [1, 5, 9],
                            [5, 11, 4],
                            [11, 10, 2],
                            [10, 7, 6],
                            [7, 1, 8],
                            [3, 9, 4],
                            [3, 4, 2],
                            [3, 2, 6],
                            [3, 6, 8],
                            [3, 8, 9],
                            [4, 9, 5],
                            [2, 4, 11],
                            [6, 2, 10],
                            [8, 6, 7],
                            [9, 8, 1],
                        ];
                    THREE.PolyhedronGeometry.call(this, r, i, e, t);
                }),
                (THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.OctahedronGeometry = function (e, t) {
                    var n = [
                            [1, 0, 0],
                            [-1, 0, 0],
                            [0, 1, 0],
                            [0, -1, 0],
                            [0, 0, 1],
                            [0, 0, -1],
                        ],
                        r = [
                            [0, 2, 4],
                            [0, 4, 3],
                            [0, 3, 5],
                            [0, 5, 2],
                            [1, 2, 5],
                            [1, 5, 3],
                            [1, 3, 4],
                            [1, 4, 2],
                        ];
                    THREE.PolyhedronGeometry.call(this, n, r, e, t);
                }),
                (THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.TetrahedronGeometry = function (e, t) {
                    var n = [
                            [1, 1, 1],
                            [-1, -1, 1],
                            [-1, 1, -1],
                            [1, -1, -1],
                        ],
                        r = [
                            [2, 1, 0],
                            [0, 3, 2],
                            [1, 3, 0],
                            [2, 3, 1],
                        ];
                    THREE.PolyhedronGeometry.call(this, n, r, e, t);
                }),
                (THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.ParametricGeometry = function (e, t, n) {
                    THREE.Geometry.call(this);
                    var r = this.vertices,
                        i = this.faces,
                        s = this.faceVertexUvs[0],
                        o,
                        u,
                        a,
                        f,
                        l,
                        c,
                        h = n + 1,
                        p = t + 1;
                    for (o = 0; o <= n; o++) {
                        c = o / n;
                        for (a = 0; a <= t; a++) (l = a / t), (f = e(l, c)), r.push(f);
                    }
                    var d, v, m, g, y, b, w, E;
                    for (o = 0; o < n; o++)
                        for (a = 0; a < t; a++)
                            (d = o * p + a),
                                (v = o * p + a + 1),
                                (m = (o + 1) * p + a + 1),
                                (g = (o + 1) * p + a),
                                (y = new THREE.Vector2(a / t, o / n)),
                                (b = new THREE.Vector2((a + 1) / t, o / n)),
                                (w = new THREE.Vector2((a + 1) / t, (o + 1) / n)),
                                (E = new THREE.Vector2(a / t, (o + 1) / n)),
                                i.push(new THREE.Face3(d, v, g)),
                                s.push([y, b, E]),
                                i.push(new THREE.Face3(v, m, g)),
                                s.push([b.clone(), w, E.clone()]);
                    this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals();
                }),
                (THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype)),
                (THREE.AxisHelper = function (e) {
                    e = e || 1;
                    var t = new THREE.Geometry();
                    t.vertices.push(new THREE.Vector3(), new THREE.Vector3(e, 0, 0), new THREE.Vector3(), new THREE.Vector3(0, e, 0), new THREE.Vector3(), new THREE.Vector3(0, 0, e)),
                        t.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));
                    var n = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
                    THREE.Line.call(this, t, n, THREE.LinePieces);
                }),
                (THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype)),
                (THREE.ArrowHelper = function (e, t, n, r) {
                    THREE.Object3D.call(this), r === undefined && (r = 16776960), n === undefined && (n = 1), (this.position = t);
                    var i = new THREE.Geometry();
                    i.vertices.push(new THREE.Vector3(0, 0, 0)), i.vertices.push(new THREE.Vector3(0, 1, 0)), (this.line = new THREE.Line(i, new THREE.LineBasicMaterial({ color: r }))), (this.line.matrixAutoUpdate = !1), this.add(this.line);
                    var s = new THREE.CylinderGeometry(0, 0.05, 0.25, 5, 1);
                    s.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.875, 0)),
                        (this.cone = new THREE.Mesh(s, new THREE.MeshBasicMaterial({ color: r }))),
                        (this.cone.matrixAutoUpdate = !1),
                        this.add(this.cone),
                        this.setDirection(e),
                        this.setLength(n);
                }),
                (THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.ArrowHelper.prototype.setDirection = (function () {
                    var e = new THREE.Vector3(),
                        t;
                    return function (n) {
                        n.y > 0.99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -0.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), (t = Math.acos(n.y)), this.quaternion.setFromAxisAngle(e, t));
                    };
                })()),
                (THREE.ArrowHelper.prototype.setLength = function (e) {
                    this.scale.set(e, e, e);
                }),
                (THREE.ArrowHelper.prototype.setColor = function (e) {
                    this.line.material.color.setHex(e), this.cone.material.color.setHex(e);
                }),
                (THREE.BoxHelper = function (e) {
                    var t = [
                        new THREE.Vector3(1, 1, 1),
                        new THREE.Vector3(-1, 1, 1),
                        new THREE.Vector3(-1, -1, 1),
                        new THREE.Vector3(1, -1, 1),
                        new THREE.Vector3(1, 1, -1),
                        new THREE.Vector3(-1, 1, -1),
                        new THREE.Vector3(-1, -1, -1),
                        new THREE.Vector3(1, -1, -1),
                    ];
                    this.vertices = t;
                    var n = new THREE.Geometry();
                    n.vertices.push(t[0], t[1], t[1], t[2], t[2], t[3], t[3], t[0], t[4], t[5], t[5], t[6], t[6], t[7], t[7], t[4], t[0], t[4], t[1], t[5], t[2], t[6], t[3], t[7]),
                        THREE.Line.call(this, n, new THREE.LineBasicMaterial({ color: 16776960 }), THREE.LinePieces),
                    e !== undefined && this.update(e);
                }),
                (THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype)),
                (THREE.BoxHelper.prototype.update = function (e) {
                    var t = e.geometry;
                    t.boundingBox === null && t.computeBoundingBox();
                    var n = t.boundingBox.min,
                        r = t.boundingBox.max,
                        i = this.vertices;
                    i[0].set(r.x, r.y, r.z),
                        i[1].set(n.x, r.y, r.z),
                        i[2].set(n.x, n.y, r.z),
                        i[3].set(r.x, n.y, r.z),
                        i[4].set(r.x, r.y, n.z),
                        i[5].set(n.x, r.y, n.z),
                        i[6].set(n.x, n.y, n.z),
                        i[7].set(r.x, n.y, n.z),
                        this.geometry.computeBoundingSphere(),
                        (this.geometry.verticesNeedUpdate = !0),
                        (this.matrixAutoUpdate = !1),
                        (this.matrixWorld = e.matrixWorld);
                }),
                (THREE.BoundingBoxHelper = function (e, t) {
                    var n = t || 8947848;
                    (this.object = e), (this.box = new THREE.Box3()), THREE.Mesh.call(this, new THREE.CubeGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: n, wireframe: !0 }));
                }),
                (THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype)),
                (THREE.BoundingBoxHelper.prototype.update = function () {
                    this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position);
                }),
                (THREE.CameraHelper = function (e) {
                    function f(e, t, n) {
                        l(e, n), l(t, n);
                    }
                    function l(e, n) {
                        t.vertices.push(new THREE.Vector3()), t.colors.push(new THREE.Color(n)), r[e] === undefined && (r[e] = []), r[e].push(t.vertices.length - 1);
                    }
                    var t = new THREE.Geometry(),
                        n = new THREE.LineBasicMaterial({ color: 16777215, vertexColors: THREE.FaceColors }),
                        r = {},
                        i = 16755200,
                        s = 16711680,
                        o = 43775,
                        u = 16777215,
                        a = 3355443;
                    f("n1", "n2", i),
                        f("n2", "n4", i),
                        f("n4", "n3", i),
                        f("n3", "n1", i),
                        f("f1", "f2", i),
                        f("f2", "f4", i),
                        f("f4", "f3", i),
                        f("f3", "f1", i),
                        f("n1", "f1", i),
                        f("n2", "f2", i),
                        f("n3", "f3", i),
                        f("n4", "f4", i),
                        f("p", "n1", s),
                        f("p", "n2", s),
                        f("p", "n3", s),
                        f("p", "n4", s),
                        f("u1", "u2", o),
                        f("u2", "u3", o),
                        f("u3", "u1", o),
                        f("c", "t", u),
                        f("p", "c", a),
                        f("cn1", "cn2", a),
                        f("cn3", "cn4", a),
                        f("cf1", "cf2", a),
                        f("cf3", "cf4", a),
                        THREE.Line.call(this, t, n, THREE.LinePieces),
                        (this.camera = e),
                        (this.matrixWorld = e.matrixWorld),
                        (this.matrixAutoUpdate = !1),
                        (this.pointMap = r),
                        this.update();
                }),
                (THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype)),
                (THREE.CameraHelper.prototype.update = (function () {
                    var e = new THREE.Vector3(),
                        t = new THREE.Camera(),
                        n = new THREE.Projector();
                    return function () {
                        function o(i, s, o, u) {
                            e.set(s, o, u), n.unprojectVector(e, t);
                            var a = r.pointMap[i];
                            if (a !== undefined) for (var f = 0, l = a.length; f < l; f++) r.geometry.vertices[a[f]].copy(e);
                        }
                        var r = this,
                            i = 1,
                            s = 1;
                        t.projectionMatrix.copy(this.camera.projectionMatrix),
                            o("c", 0, 0, -1),
                            o("t", 0, 0, 1),
                            o("n1", -i, -s, -1),
                            o("n2", i, -s, -1),
                            o("n3", -i, s, -1),
                            o("n4", i, s, -1),
                            o("f1", -i, -s, 1),
                            o("f2", i, -s, 1),
                            o("f3", -i, s, 1),
                            o("f4", i, s, 1),
                            o("u1", i * 0.7, s * 1.1, -1),
                            o("u2", -i * 0.7, s * 1.1, -1),
                            o("u3", 0, s * 2, -1),
                            o("cf1", -i, 0, 1),
                            o("cf2", i, 0, 1),
                            o("cf3", 0, -s, 1),
                            o("cf4", 0, s, 1),
                            o("cn1", -i, 0, -1),
                            o("cn2", i, 0, -1),
                            o("cn3", 0, -s, -1),
                            o("cn4", 0, s, -1),
                            (this.geometry.verticesNeedUpdate = !0);
                    };
                })()),
                (THREE.DirectionalLightHelper = function (e, t) {
                    THREE.Object3D.call(this), (this.light = e), this.light.updateMatrixWorld(), (this.matrixWorld = e.matrixWorld), (this.matrixAutoUpdate = !1);
                    var n = new THREE.PlaneGeometry(t, t),
                        r = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 });
                    r.color.copy(this.light.color).multiplyScalar(this.light.intensity),
                        (this.lightPlane = new THREE.Mesh(n, r)),
                        this.add(this.lightPlane),
                        (n = new THREE.Geometry()),
                        n.vertices.push(new THREE.Vector3()),
                        n.vertices.push(new THREE.Vector3()),
                        n.computeLineDistances(),
                        (r = new THREE.LineBasicMaterial({ fog: !1 })),
                        r.color.copy(this.light.color).multiplyScalar(this.light.intensity),
                        (this.targetLine = new THREE.Line(n, r)),
                        this.add(this.targetLine),
                        this.update();
                }),
                (THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.DirectionalLightHelper.prototype.dispose = function () {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
                }),
                (THREE.DirectionalLightHelper.prototype.update = (function () {
                    var e = new THREE.Vector3();
                    return function () {
                        e.getPositionFromMatrix(this.light.matrixWorld).negate(),
                            this.lightPlane.lookAt(e),
                            this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity),
                            this.targetLine.geometry.vertices[1].copy(e),
                            (this.targetLine.geometry.verticesNeedUpdate = !0),
                            this.targetLine.material.color.copy(this.lightPlane.material.color);
                    };
                })()),
                (THREE.FaceNormalsHelper = function (e, t, n, r) {
                    (this.object = e), (this.size = t || 1);
                    var i = n || 16776960,
                        s = r || 1,
                        o = new THREE.Geometry(),
                        u = this.object.geometry.faces;
                    for (var a = 0, f = u.length; a < f; a++) o.vertices.push(new THREE.Vector3()), o.vertices.push(new THREE.Vector3());
                    THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: i, linewidth: s }), THREE.LinePieces), (this.matrixAutoUpdate = !1), (this.normalMatrix = new THREE.Matrix3()), this.update();
                }),
                (THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype)),
                (THREE.FaceNormalsHelper.prototype.update = (function (e) {
                    var t = new THREE.Vector3();
                    return function (e) {
                        this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
                        var n = this.geometry.vertices,
                            r = this.object.geometry.faces,
                            i = this.object.matrixWorld;
                        for (var s = 0, o = r.length; s < o; s++) {
                            var u = r[s];
                            t.copy(u.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
                            var a = 2 * s;
                            n[a].copy(u.centroid).applyMatrix4(i), n[a + 1].addVectors(n[a], t);
                        }
                        return (this.geometry.verticesNeedUpdate = !0), this;
                    };
                })()),
                (THREE.GridHelper = function (e, t) {
                    var n = new THREE.Geometry(),
                        r = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
                    (this.color1 = new THREE.Color(4473924)), (this.color2 = new THREE.Color(8947848));
                    for (var i = -e; i <= e; i += t) {
                        n.vertices.push(new THREE.Vector3(-e, 0, i), new THREE.Vector3(e, 0, i), new THREE.Vector3(i, 0, -e), new THREE.Vector3(i, 0, e));
                        var s = i === 0 ? this.color1 : this.color2;
                        n.colors.push(s, s, s, s);
                    }
                    THREE.Line.call(this, n, r, THREE.LinePieces);
                }),
                (THREE.GridHelper.prototype = Object.create(THREE.Line.prototype)),
                (THREE.GridHelper.prototype.setColors = function (e, t) {
                    this.color1.set(e), this.color2.set(t), (this.geometry.colorsNeedUpdate = !0);
                }),
                (THREE.HemisphereLightHelper = function (e, t, n, r) {
                    THREE.Object3D.call(this), (this.light = e), this.light.updateMatrixWorld(), (this.matrixWorld = e.matrixWorld), (this.matrixAutoUpdate = !1), (this.colors = [new THREE.Color(), new THREE.Color()]);
                    var i = new THREE.SphereGeometry(t, 4, 2);
                    i.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
                    for (var s = 0, o = 8; s < o; s++) i.faces[s].color = this.colors[s < 4 ? 0 : 1];
                    var u = new THREE.MeshBasicMaterial({ vertexColors: THREE.FaceColors, wireframe: !0 });
                    (this.lightSphere = new THREE.Mesh(i, u)), this.add(this.lightSphere), this.update();
                }),
                (THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.HemisphereLightHelper.prototype.dispose = function () {
                    this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose();
                }),
                (THREE.HemisphereLightHelper.prototype.update = (function () {
                    var e = new THREE.Vector3();
                    return function () {
                        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity),
                            this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity),
                            this.lightSphere.lookAt(e.getPositionFromMatrix(this.light.matrixWorld).negate()),
                            (this.lightSphere.geometry.colorsNeedUpdate = !0);
                    };
                })()),
                (THREE.PointLightHelper = function (e, t) {
                    (this.light = e), this.light.updateMatrixWorld();
                    var n = new THREE.SphereGeometry(t, 4, 2),
                        r = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 });
                    r.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, n, r), (this.matrixWorld = this.light.matrixWorld), (this.matrixAutoUpdate = !1);
                }),
                (THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype)),
                (THREE.PointLightHelper.prototype.dispose = function () {
                    this.geometry.dispose(), this.material.dispose();
                }),
                (THREE.PointLightHelper.prototype.update = function () {
                    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                }),
                (THREE.SpotLightHelper = function (e) {
                    THREE.Object3D.call(this), (this.light = e), this.light.updateMatrixWorld(), (this.matrixWorld = e.matrixWorld), (this.matrixAutoUpdate = !1);
                    var t = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
                    t.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0)), t.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
                    var n = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 });
                    (this.cone = new THREE.Mesh(t, n)), this.add(this.cone), this.update();
                }),
                (THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.SpotLightHelper.prototype.dispose = function () {
                    this.cone.geometry.dispose(), this.cone.material.dispose();
                }),
                (THREE.SpotLightHelper.prototype.update = (function () {
                    var e = new THREE.Vector3(),
                        t = new THREE.Vector3();
                    return function () {
                        var n = this.light.distance ? this.light.distance : 1e4,
                            r = n * Math.tan(this.light.angle);
                        this.cone.scale.set(r, r, n),
                            e.getPositionFromMatrix(this.light.matrixWorld),
                            t.getPositionFromMatrix(this.light.target.matrixWorld),
                            this.cone.lookAt(t.sub(e)),
                            this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                    };
                })()),
                (THREE.VertexNormalsHelper = function (e, t, n, r) {
                    (this.object = e), (this.size = t || 1);
                    var i = n || 16711680,
                        s = r || 1,
                        o = new THREE.Geometry(),
                        u = e.geometry.vertices,
                        a = e.geometry.faces;
                    for (var f = 0, l = a.length; f < l; f++) {
                        var c = a[f];
                        for (var h = 0, p = c.vertexNormals.length; h < p; h++) o.vertices.push(new THREE.Vector3()), o.vertices.push(new THREE.Vector3());
                    }
                    THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: i, linewidth: s }), THREE.LinePieces), (this.matrixAutoUpdate = !1), (this.normalMatrix = new THREE.Matrix3()), this.update();
                }),
                (THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype)),
                (THREE.VertexNormalsHelper.prototype.update = (function (e) {
                    var t = new THREE.Vector3();
                    return function (e) {
                        var n = ["a", "b", "c", "d"];
                        this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
                        var r = this.geometry.vertices,
                            i = this.object.geometry.vertices,
                            s = this.object.geometry.faces,
                            o = this.object.matrixWorld,
                            u = 0;
                        for (var a = 0, f = s.length; a < f; a++) {
                            var l = s[a];
                            for (var c = 0, h = l.vertexNormals.length; c < h; c++) {
                                var p = l[n[c]],
                                    d = i[p],
                                    v = l.vertexNormals[c];
                                r[u].copy(d).applyMatrix4(o), t.copy(v).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), t.add(r[u]), (u += 1), r[u].copy(t), (u += 1);
                            }
                        }
                        return (this.geometry.verticesNeedUpdate = !0), this;
                    };
                })()),
                (THREE.VertexTangentsHelper = function (e, t, n, r) {
                    (this.object = e), (this.size = t || 1);
                    var i = n || 255,
                        s = r || 1,
                        o = new THREE.Geometry(),
                        u = e.geometry.vertices,
                        a = e.geometry.faces;
                    for (var f = 0, l = a.length; f < l; f++) {
                        var c = a[f];
                        for (var h = 0, p = c.vertexTangents.length; h < p; h++) o.vertices.push(new THREE.Vector3()), o.vertices.push(new THREE.Vector3());
                    }
                    THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: i, linewidth: s }), THREE.LinePieces), (this.matrixAutoUpdate = !1), this.update();
                }),
                (THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype)),
                (THREE.VertexTangentsHelper.prototype.update = (function (e) {
                    var t = new THREE.Vector3();
                    return function (e) {
                        var n = ["a", "b", "c", "d"];
                        this.object.updateMatrixWorld(!0);
                        var r = this.geometry.vertices,
                            i = this.object.geometry.vertices,
                            s = this.object.geometry.faces,
                            o = this.object.matrixWorld,
                            u = 0;
                        for (var a = 0, f = s.length; a < f; a++) {
                            var l = s[a];
                            for (var c = 0, h = l.vertexTangents.length; c < h; c++) {
                                var p = l[n[c]],
                                    d = i[p],
                                    v = l.vertexTangents[c];
                                r[u].copy(d).applyMatrix4(o), t.copy(v).transformDirection(o).multiplyScalar(this.size), t.add(r[u]), (u += 1), r[u].copy(t), (u += 1);
                            }
                        }
                        return (this.geometry.verticesNeedUpdate = !0), this;
                    };
                })()),
                (THREE.WireframeHelper = function (e) {
                    var t = [0, 0],
                        n = {},
                        r = function (e, t) {
                            return e - t;
                        },
                        i = ["a", "b", "c", "d"],
                        s = new THREE.Geometry(),
                        o = e.geometry.vertices,
                        u = e.geometry.faces;
                    for (var a = 0, f = u.length; a < f; a++) {
                        var l = u[a];
                        for (var c = 0; c < 3; c++) {
                            (t[0] = l[i[c]]), (t[1] = l[i[(c + 1) % 3]]), t.sort(r);
                            var h = t.toString();
                            n[h] === undefined && (s.vertices.push(o[t[0]]), s.vertices.push(o[t[1]]), (n[h] = !0));
                        }
                    }
                    THREE.Line.call(this, s, new THREE.LineBasicMaterial({ color: 16777215 }), THREE.LinePieces), (this.matrixAutoUpdate = !1), (this.matrixWorld = e.matrixWorld);
                }),
                (THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype)),
                (THREE.ImmediateRenderObject = function () {
                    THREE.Object3D.call(this), (this.render = function (e) {});
                }),
                (THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.LensFlare = function (e, t, n, r, i) {
                    THREE.Object3D.call(this), (this.lensFlares = []), (this.positionScreen = new THREE.Vector3()), (this.customUpdateCallback = undefined), e !== undefined && this.add(e, t, n, r, i);
                }),
                (THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype)),
                (THREE.LensFlare.prototype.add = function (e, t, n, r, i, s) {
                    t === undefined && (t = -1),
                    n === undefined && (n = 0),
                    s === undefined && (s = 1),
                    i === undefined && (i = new THREE.Color(16777215)),
                    r === undefined && (r = THREE.NormalBlending),
                        (n = Math.min(n, Math.max(0, n))),
                        this.lensFlares.push({ texture: e, size: t, distance: n, x: 0, y: 0, z: 0, scale: 1, rotation: 1, opacity: s, color: i, blending: r });
                }),
                (THREE.LensFlare.prototype.updateLensFlares = function () {
                    var e,
                        t = this.lensFlares.length,
                        n,
                        r = -this.positionScreen.x * 2,
                        i = -this.positionScreen.y * 2;
                    for (e = 0; e < t; e++)
                        (n = this.lensFlares[e]), (n.x = this.positionScreen.x + r * n.distance), (n.y = this.positionScreen.y + i * n.distance), (n.wantedRotation = n.x * Math.PI * 0.25), (n.rotation += (n.wantedRotation - n.rotation) * 0.25);
                }),
                (THREE.MorphBlendMesh = function (e, t) {
                    THREE.Mesh.call(this, e, t), (this.animationsMap = {}), (this.animationsList = []);
                    var n = this.geometry.morphTargets.length,
                        r = "__default",
                        i = 0,
                        s = n - 1,
                        o = n / 1;
                    this.createAnimation(r, i, s, o), this.setAnimationWeight(r, 1);
                }),
                (THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype)),
                (THREE.MorphBlendMesh.prototype.createAnimation = function (e, t, n, r) {
                    var i = { startFrame: t, endFrame: n, length: n - t + 1, fps: r, duration: (n - t) / r, lastFrame: 0, currentFrame: 0, active: !1, time: 0, direction: 1, weight: 1, directionBackwards: !1, mirroredLoop: !1 };
                    (this.animationsMap[e] = i), this.animationsList.push(i);
                }),
                (THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (e) {
                    var t = /([a-z]+)(\d+)/,
                        n,
                        r = {},
                        i = this.geometry;
                    for (var s = 0, o = i.morphTargets.length; s < o; s++) {
                        var u = i.morphTargets[s],
                            a = u.name.match(t);
                        if (a && a.length > 1) {
                            var f = a[1],
                                l = a[2];
                            r[f] || (r[f] = { start: Infinity, end: -Infinity });
                            var c = r[f];
                            s < c.start && (c.start = s), s > c.end && (c.end = s), n || (n = f);
                        }
                    }
                    for (var f in r) {
                        var c = r[f];
                        this.createAnimation(f, c.start, c.end, e);
                    }
                    this.firstAnimation = n;
                }),
                (THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (e) {
                    var t = this.animationsMap[e];
                    t && ((t.direction = 1), (t.directionBackwards = !1));
                }),
                (THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (e) {
                    var t = this.animationsMap[e];
                    t && ((t.direction = -1), (t.directionBackwards = !0));
                }),
                (THREE.MorphBlendMesh.prototype.setAnimationFPS = function (e, t) {
                    var n = this.animationsMap[e];
                    n && ((n.fps = t), (n.duration = (n.end - n.start) / n.fps));
                }),
                (THREE.MorphBlendMesh.prototype.setAnimationDuration = function (e, t) {
                    var n = this.animationsMap[e];
                    n && ((n.duration = t), (n.fps = (n.end - n.start) / n.duration));
                }),
                (THREE.MorphBlendMesh.prototype.setAnimationWeight = function (e, t) {
                    var n = this.animationsMap[e];
                    n && (n.weight = t);
                }),
                (THREE.MorphBlendMesh.prototype.setAnimationTime = function (e, t) {
                    var n = this.animationsMap[e];
                    n && (n.time = t);
                }),
                (THREE.MorphBlendMesh.prototype.getAnimationTime = function (e) {
                    var t = 0,
                        n = this.animationsMap[e];
                    return n && (t = n.time), t;
                }),
                (THREE.MorphBlendMesh.prototype.getAnimationDuration = function (e) {
                    var t = -1,
                        n = this.animationsMap[e];
                    return n && (t = n.duration), t;
                }),
                (THREE.MorphBlendMesh.prototype.playAnimation = function (e) {
                    var t = this.animationsMap[e];
                    t ? ((t.time = 0), (t.active = !0)) : console.warn("animation[" + e + "] undefined");
                }),
                (THREE.MorphBlendMesh.prototype.stopAnimation = function (e) {
                    var t = this.animationsMap[e];
                    t && (t.active = !1);
                }),
                (THREE.MorphBlendMesh.prototype.update = function (e) {
                    for (var t = 0, n = this.animationsList.length; t < n; t++) {
                        var r = this.animationsList[t];
                        if (!r.active) continue;
                        var i = r.duration / r.length;
                        r.time += r.direction * e;
                        if (r.mirroredLoop) {
                            if (r.time > r.duration || r.time < 0) (r.direction *= -1), r.time > r.duration && ((r.time = r.duration), (r.directionBackwards = !0)), r.time < 0 && ((r.time = 0), (r.directionBackwards = !1));
                        } else (r.time = r.time % r.duration), r.time < 0 && (r.time += r.duration);
                        var s = r.startFrame + THREE.Math.clamp(Math.floor(r.time / i), 0, r.length - 1),
                            o = r.weight;
                        s !== r.currentFrame && ((this.morphTargetInfluences[r.lastFrame] = 0), (this.morphTargetInfluences[r.currentFrame] = 1 * o), (this.morphTargetInfluences[s] = 0), (r.lastFrame = r.currentFrame), (r.currentFrame = s));
                        var u = (r.time % i) / i;
                        r.directionBackwards && (u = 1 - u), (this.morphTargetInfluences[r.currentFrame] = u * o), (this.morphTargetInfluences[r.lastFrame] = (1 - u) * o);
                    }
                }),
                (THREE.LensFlarePlugin = function () {
                    function i(t, n) {
                        var r = e.createProgram(),
                            i = e.createShader(e.FRAGMENT_SHADER),
                            s = e.createShader(e.VERTEX_SHADER),
                            o = "precision " + n + " float;\n";
                        return e.shaderSource(i, o + t.fragmentShader), e.shaderSource(s, o + t.vertexShader), e.compileShader(i), e.compileShader(s), e.attachShader(r, i), e.attachShader(r, s), e.linkProgram(r), r;
                    }
                    var e,
                        t,
                        n,
                        r = {};
                    (this.init = function (s) {
                        (e = s.context), (t = s), (n = s.getPrecision()), (r.vertices = new Float32Array(16)), (r.faces = new Uint16Array(6));
                        var o = 0;
                        (r.vertices[o++] = -1),
                            (r.vertices[o++] = -1),
                            (r.vertices[o++] = 0),
                            (r.vertices[o++] = 0),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = -1),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = 0),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = -1),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = 0),
                            (r.vertices[o++] = 1),
                            (o = 0),
                            (r.faces[o++] = 0),
                            (r.faces[o++] = 1),
                            (r.faces[o++] = 2),
                            (r.faces[o++] = 0),
                            (r.faces[o++] = 2),
                            (r.faces[o++] = 3),
                            (r.vertexBuffer = e.createBuffer()),
                            (r.elementBuffer = e.createBuffer()),
                            e.bindBuffer(e.ARRAY_BUFFER, r.vertexBuffer),
                            e.bufferData(e.ARRAY_BUFFER, r.vertices, e.STATIC_DRAW),
                            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r.elementBuffer),
                            e.bufferData(e.ELEMENT_ARRAY_BUFFER, r.faces, e.STATIC_DRAW),
                            (r.tempTexture = e.createTexture()),
                            (r.occlusionTexture = e.createTexture()),
                            e.bindTexture(e.TEXTURE_2D, r.tempTexture),
                            e.texImage2D(e.TEXTURE_2D, 0, e.RGB, 16, 16, 0, e.RGB, e.UNSIGNED_BYTE, null),
                            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
                            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
                            e.bindTexture(e.TEXTURE_2D, r.occlusionTexture),
                            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 16, 16, 0, e.RGBA, e.UNSIGNED_BYTE, null),
                            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
                            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
                            e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS) <= 0
                                ? ((r.hasVertexTexture = !1), (r.program = i(THREE.ShaderFlares.lensFlare, n)))
                                : ((r.hasVertexTexture = !0), (r.program = i(THREE.ShaderFlares.lensFlareVertexTexture, n))),
                            (r.attributes = {}),
                            (r.uniforms = {}),
                            (r.attributes.vertex = e.getAttribLocation(r.program, "position")),
                            (r.attributes.uv = e.getAttribLocation(r.program, "uv")),
                            (r.uniforms.renderType = e.getUniformLocation(r.program, "renderType")),
                            (r.uniforms.map = e.getUniformLocation(r.program, "map")),
                            (r.uniforms.occlusionMap = e.getUniformLocation(r.program, "occlusionMap")),
                            (r.uniforms.opacity = e.getUniformLocation(r.program, "opacity")),
                            (r.uniforms.color = e.getUniformLocation(r.program, "color")),
                            (r.uniforms.scale = e.getUniformLocation(r.program, "scale")),
                            (r.uniforms.rotation = e.getUniformLocation(r.program, "rotation")),
                            (r.uniforms.screenPosition = e.getUniformLocation(r.program, "screenPosition"));
                    }),
                        (this.render = function (n, i, s, o) {
                            var u = n.__webglFlares,
                                a = u.length;
                            if (!a) return;
                            var f = new THREE.Vector3(),
                                l = o / s,
                                c = s * 0.5,
                                h = o * 0.5,
                                p = 16 / o,
                                d = new THREE.Vector2(p * l, p),
                                v = new THREE.Vector3(1, 1, 0),
                                m = new THREE.Vector2(1, 1),
                                g = r.uniforms,
                                y = r.attributes;
                            e.useProgram(r.program),
                                e.enableVertexAttribArray(r.attributes.vertex),
                                e.enableVertexAttribArray(r.attributes.uv),
                                e.uniform1i(g.occlusionMap, 0),
                                e.uniform1i(g.map, 1),
                                e.bindBuffer(e.ARRAY_BUFFER, r.vertexBuffer),
                                e.vertexAttribPointer(y.vertex, 2, e.FLOAT, !1, 16, 0),
                                e.vertexAttribPointer(y.uv, 2, e.FLOAT, !1, 16, 8),
                                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r.elementBuffer),
                                e.disable(e.CULL_FACE),
                                e.depthMask(!1);
                            var b, w, E, S, x;
                            for (b = 0; b < a; b++) {
                                (p = 16 / o),
                                    d.set(p * l, p),
                                    (S = u[b]),
                                    f.set(S.matrixWorld.elements[12], S.matrixWorld.elements[13], S.matrixWorld.elements[14]),
                                    f.applyMatrix4(i.matrixWorldInverse),
                                    f.applyProjection(i.projectionMatrix),
                                    v.copy(f),
                                    (m.x = v.x * c + c),
                                    (m.y = v.y * h + h);
                                if (r.hasVertexTexture || (m.x > 0 && m.x < s && m.y > 0 && m.y < o)) {
                                    e.activeTexture(e.TEXTURE1),
                                        e.bindTexture(e.TEXTURE_2D, r.tempTexture),
                                        e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGB, m.x - 8, m.y - 8, 16, 16, 0),
                                        e.uniform1i(g.renderType, 0),
                                        e.uniform2f(g.scale, d.x, d.y),
                                        e.uniform3f(g.screenPosition, v.x, v.y, v.z),
                                        e.disable(e.BLEND),
                                        e.enable(e.DEPTH_TEST),
                                        e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                                        e.activeTexture(e.TEXTURE0),
                                        e.bindTexture(e.TEXTURE_2D, r.occlusionTexture),
                                        e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, m.x - 8, m.y - 8, 16, 16, 0),
                                        e.uniform1i(g.renderType, 1),
                                        e.disable(e.DEPTH_TEST),
                                        e.activeTexture(e.TEXTURE1),
                                        e.bindTexture(e.TEXTURE_2D, r.tempTexture),
                                        e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                                        S.positionScreen.copy(v),
                                        S.customUpdateCallback ? S.customUpdateCallback(S) : S.updateLensFlares(),
                                        e.uniform1i(g.renderType, 2),
                                        e.enable(e.BLEND);
                                    for (w = 0, E = S.lensFlares.length; w < E; w++)
                                        (x = S.lensFlares[w]),
                                        x.opacity > 0.001 &&
                                        x.scale > 0.001 &&
                                        ((v.x = x.x),
                                            (v.y = x.y),
                                            (v.z = x.z),
                                            (p = (x.size * x.scale) / o),
                                            (d.x = p * l),
                                            (d.y = p),
                                            e.uniform3f(g.screenPosition, v.x, v.y, v.z),
                                            e.uniform2f(g.scale, d.x, d.y),
                                            e.uniform1f(g.rotation, x.rotation),
                                            e.uniform1f(g.opacity, x.opacity),
                                            e.uniform3f(g.color, x.color.r, x.color.g, x.color.b),
                                            t.setBlending(x.blending, x.blendEquation, x.blendSrc, x.blendDst),
                                            t.setTexture(x.texture, 1),
                                            e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
                                }
                            }
                            e.enable(e.CULL_FACE), e.enable(e.DEPTH_TEST), e.depthMask(!0);
                        });
                }),
                (THREE.ShadowMapPlugin = function () {
                    function c(e, t) {
                        var n = new THREE.DirectionalLight();
                        (n.isVirtual = !0),
                            (n.onlyShadow = !0),
                            (n.castShadow = !0),
                            (n.shadowCameraNear = e.shadowCameraNear),
                            (n.shadowCameraFar = e.shadowCameraFar),
                            (n.shadowCameraLeft = e.shadowCameraLeft),
                            (n.shadowCameraRight = e.shadowCameraRight),
                            (n.shadowCameraBottom = e.shadowCameraBottom),
                            (n.shadowCameraTop = e.shadowCameraTop),
                            (n.shadowCameraVisible = e.shadowCameraVisible),
                            (n.shadowDarkness = e.shadowDarkness),
                            (n.shadowBias = e.shadowCascadeBias[t]),
                            (n.shadowMapWidth = e.shadowCascadeWidth[t]),
                            (n.shadowMapHeight = e.shadowCascadeHeight[t]),
                            (n.pointsWorld = []),
                            (n.pointsFrustum = []);
                        var r = n.pointsWorld,
                            i = n.pointsFrustum;
                        for (var s = 0; s < 8; s++) (r[s] = new THREE.Vector3()), (i[s] = new THREE.Vector3());
                        var o = e.shadowCascadeNearZ[t],
                            u = e.shadowCascadeFarZ[t];
                        return i[0].set(-1, -1, o), i[1].set(1, -1, o), i[2].set(-1, 1, o), i[3].set(1, 1, o), i[4].set(-1, -1, u), i[5].set(1, -1, u), i[6].set(-1, 1, u), i[7].set(1, 1, u), n;
                    }
                    function h(e, t) {
                        var n = e.shadowCascadeArray[t];
                        n.position.copy(e.position), n.target.position.copy(e.target.position), n.lookAt(n.target), (n.shadowCameraVisible = e.shadowCameraVisible), (n.shadowDarkness = e.shadowDarkness), (n.shadowBias = e.shadowCascadeBias[t]);
                        var r = e.shadowCascadeNearZ[t],
                            i = e.shadowCascadeFarZ[t],
                            s = n.pointsFrustum;
                        (s[0].z = r), (s[1].z = r), (s[2].z = r), (s[3].z = r), (s[4].z = i), (s[5].z = i), (s[6].z = i), (s[7].z = i);
                    }
                    function p(e, t) {
                        var n = t.shadowCamera,
                            r = t.pointsFrustum,
                            i = t.pointsWorld;
                        a.set(Infinity, Infinity, Infinity), f.set(-Infinity, -Infinity, -Infinity);
                        for (var s = 0; s < 8; s++) {
                            var o = i[s];
                            o.copy(r[s]),
                                THREE.ShadowMapPlugin.__projector.unprojectVector(o, e),
                                o.applyMatrix4(n.matrixWorldInverse),
                            o.x < a.x && (a.x = o.x),
                            o.x > f.x && (f.x = o.x),
                            o.y < a.y && (a.y = o.y),
                            o.y > f.y && (f.y = o.y),
                            o.z < a.z && (a.z = o.z),
                            o.z > f.z && (f.z = o.z);
                        }
                        (n.left = a.x), (n.right = f.x), (n.top = f.y), (n.bottom = a.y), n.updateProjectionMatrix();
                    }
                    function d(e) {
                        return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[0] : e.material;
                    }
                    var e,
                        t,
                        n,
                        r,
                        i,
                        s,
                        o = new THREE.Frustum(),
                        u = new THREE.Matrix4(),
                        a = new THREE.Vector3(),
                        f = new THREE.Vector3(),
                        l = new THREE.Vector3();
                    (this.init = function (o) {
                        (e = o.context), (t = o);
                        var u = THREE.ShaderLib.depthRGBA,
                            a = THREE.UniformsUtils.clone(u.uniforms);
                        (n = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a })),
                            (r = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, morphTargets: !0 })),
                            (i = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, skinning: !0 })),
                            (s = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, morphTargets: !0, skinning: !0 })),
                            (n._shadowPass = !0),
                            (r._shadowPass = !0),
                            (i._shadowPass = !0),
                            (s._shadowPass = !0);
                    }),
                        (this.render = function (e, n) {
                            if (!t.shadowMapEnabled || !t.shadowMapAutoUpdate) return;
                            this.update(e, n);
                        }),
                        (this.update = function (a, f) {
                            var v,
                                m,
                                g,
                                y,
                                b,
                                w,
                                E,
                                S,
                                x,
                                T,
                                N,
                                C,
                                k,
                                L,
                                A,
                                O = [],
                                M = 0,
                                _ = null;
                            e.clearColor(1, 1, 1, 1), e.disable(e.BLEND), e.enable(e.CULL_FACE), e.frontFace(e.CCW), t.shadowMapCullFace === THREE.CullFaceFront ? e.cullFace(e.FRONT) : e.cullFace(e.BACK), t.setDepthTest(!0);
                            for (v = 0, m = a.__lights.length; v < m; v++) {
                                L = a.__lights[v];
                                if (!L.castShadow) continue;
                                if (L instanceof THREE.DirectionalLight && L.shadowCascade)
                                    for (b = 0; b < L.shadowCascadeCount; b++) {
                                        var D;
                                        if (!L.shadowCascadeArray[b]) {
                                            (D = c(L, b)), (D.originalCamera = f);
                                            var P = new THREE.Gyroscope();
                                            (P.position = L.shadowCascadeOffset), P.add(D), P.add(D.target), f.add(P), (L.shadowCascadeArray[b] = D), console.log("Created virtualLight", D);
                                        } else D = L.shadowCascadeArray[b];
                                        h(L, b), (O[M] = D), M++;
                                    }
                                else (O[M] = L), M++;
                            }
                            for (v = 0, m = O.length; v < m; v++) {
                                L = O[v];
                                if (!L.shadowMap) {
                                    var H = THREE.LinearFilter;
                                    t.shadowMapType === THREE.PCFSoftShadowMap && (H = THREE.NearestFilter);
                                    var B = { minFilter: H, magFilter: H, format: THREE.RGBAFormat };
                                    (L.shadowMap = new THREE.WebGLRenderTarget(L.shadowMapWidth, L.shadowMapHeight, B)), (L.shadowMapSize = new THREE.Vector2(L.shadowMapWidth, L.shadowMapHeight)), (L.shadowMatrix = new THREE.Matrix4());
                                }
                                if (!L.shadowCamera) {
                                    if (L instanceof THREE.SpotLight) L.shadowCamera = new THREE.PerspectiveCamera(L.shadowCameraFov, L.shadowMapWidth / L.shadowMapHeight, L.shadowCameraNear, L.shadowCameraFar);
                                    else {
                                        if (!(L instanceof THREE.DirectionalLight)) {
                                            console.error("Unsupported light type for shadow");
                                            continue;
                                        }
                                        L.shadowCamera = new THREE.OrthographicCamera(L.shadowCameraLeft, L.shadowCameraRight, L.shadowCameraTop, L.shadowCameraBottom, L.shadowCameraNear, L.shadowCameraFar);
                                    }
                                    a.add(L.shadowCamera), a.autoUpdate === !0 && a.updateMatrixWorld();
                                }
                                L.shadowCameraVisible && !L.cameraHelper && ((L.cameraHelper = new THREE.CameraHelper(L.shadowCamera)), L.shadowCamera.add(L.cameraHelper)),
                                L.isVirtual && D.originalCamera == f && p(f, L),
                                    (w = L.shadowMap),
                                    (E = L.shadowMatrix),
                                    (S = L.shadowCamera),
                                    S.position.getPositionFromMatrix(L.matrixWorld),
                                    l.getPositionFromMatrix(L.target.matrixWorld),
                                    S.lookAt(l),
                                    S.updateMatrixWorld(),
                                    S.matrixWorldInverse.getInverse(S.matrixWorld),
                                L.cameraHelper && (L.cameraHelper.visible = L.shadowCameraVisible),
                                L.shadowCameraVisible && L.cameraHelper.update(),
                                    E.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
                                    E.multiply(S.projectionMatrix),
                                    E.multiply(S.matrixWorldInverse),
                                    u.multiplyMatrices(S.projectionMatrix, S.matrixWorldInverse),
                                    o.setFromMatrix(u),
                                    t.setRenderTarget(w),
                                    t.clear(),
                                    (A = a.__webglObjects);
                                for (g = 0, y = A.length; g < y; g++)
                                    (C = A[g]),
                                        (k = C.object),
                                        (C.render = !1),
                                    k.visible &&
                                    k.castShadow &&
                                    (!(k instanceof THREE.Mesh || k instanceof THREE.ParticleSystem) || !k.frustumCulled || o.intersectsObject(k)) &&
                                    (k._modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, k.matrixWorld), (C.render = !0));
                                var j, F, I;
                                for (g = 0, y = A.length; g < y; g++)
                                    (C = A[g]),
                                    C.render &&
                                    ((k = C.object),
                                        (T = C.buffer),
                                        (j = d(k)),
                                        (F = k.geometry.morphTargets.length > 0 && j.morphTargets),
                                        (I = k instanceof THREE.SkinnedMesh && j.skinning),
                                        k.customDepthMaterial ? (N = k.customDepthMaterial) : I ? (N = F ? s : i) : F ? (N = r) : (N = n),
                                        T instanceof THREE.BufferGeometry ? t.renderBufferDirect(S, a.__lights, _, N, T, k) : t.renderBuffer(S, a.__lights, _, N, T, k));
                                A = a.__webglObjectsImmediate;
                                for (g = 0, y = A.length; g < y; g++) (C = A[g]), (k = C.object), k.visible && k.castShadow && (k._modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, k.matrixWorld), t.renderImmediateObject(S, a.__lights, _, n, k));
                            }
                            var q = t.getClearColor(),
                                R = t.getClearAlpha();
                            e.clearColor(q.r, q.g, q.b, R), e.enable(e.BLEND), t.shadowMapCullFace === THREE.CullFaceFront && e.cullFace(e.BACK);
                        });
                }),
                (THREE.ShadowMapPlugin.__projector = new THREE.Projector()),
                (THREE.SpritePlugin = function () {
                    function i(t, n) {
                        var r = e.createProgram(),
                            i = e.createShader(e.FRAGMENT_SHADER),
                            s = e.createShader(e.VERTEX_SHADER),
                            o = "precision " + n + " float;\n";
                        return e.shaderSource(i, o + t.fragmentShader), e.shaderSource(s, o + t.vertexShader), e.compileShader(i), e.compileShader(s), e.attachShader(r, i), e.attachShader(r, s), e.linkProgram(r), r;
                    }
                    function s(e, t) {
                        return e.z !== t.z ? t.z - e.z : t.id - e.id;
                    }
                    var e,
                        t,
                        n,
                        r = {};
                    (this.init = function (s) {
                        (e = s.context), (t = s), (n = s.getPrecision()), (r.vertices = new Float32Array(16)), (r.faces = new Uint16Array(6));
                        var o = 0;
                        (r.vertices[o++] = -1),
                            (r.vertices[o++] = -1),
                            (r.vertices[o++] = 0),
                            (r.vertices[o++] = 0),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = -1),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = 0),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = -1),
                            (r.vertices[o++] = 1),
                            (r.vertices[o++] = 0),
                            (r.vertices[o++] = 1),
                            (o = 0),
                            (r.faces[o++] = 0),
                            (r.faces[o++] = 1),
                            (r.faces[o++] = 2),
                            (r.faces[o++] = 0),
                            (r.faces[o++] = 2),
                            (r.faces[o++] = 3),
                            (r.vertexBuffer = e.createBuffer()),
                            (r.elementBuffer = e.createBuffer()),
                            e.bindBuffer(e.ARRAY_BUFFER, r.vertexBuffer),
                            e.bufferData(e.ARRAY_BUFFER, r.vertices, e.STATIC_DRAW),
                            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r.elementBuffer),
                            e.bufferData(e.ELEMENT_ARRAY_BUFFER, r.faces, e.STATIC_DRAW),
                            (r.program = i(THREE.ShaderSprite.sprite, n)),
                            (r.attributes = {}),
                            (r.uniforms = {}),
                            (r.attributes.position = e.getAttribLocation(r.program, "position")),
                            (r.attributes.uv = e.getAttribLocation(r.program, "uv")),
                            (r.uniforms.uvOffset = e.getUniformLocation(r.program, "uvOffset")),
                            (r.uniforms.uvScale = e.getUniformLocation(r.program, "uvScale")),
                            (r.uniforms.rotation = e.getUniformLocation(r.program, "rotation")),
                            (r.uniforms.scale = e.getUniformLocation(r.program, "scale")),
                            (r.uniforms.alignment = e.getUniformLocation(r.program, "alignment")),
                            (r.uniforms.color = e.getUniformLocation(r.program, "color")),
                            (r.uniforms.map = e.getUniformLocation(r.program, "map")),
                            (r.uniforms.opacity = e.getUniformLocation(r.program, "opacity")),
                            (r.uniforms.useScreenCoordinates = e.getUniformLocation(r.program, "useScreenCoordinates")),
                            (r.uniforms.sizeAttenuation = e.getUniformLocation(r.program, "sizeAttenuation")),
                            (r.uniforms.screenPosition = e.getUniformLocation(r.program, "screenPosition")),
                            (r.uniforms.modelViewMatrix = e.getUniformLocation(r.program, "modelViewMatrix")),
                            (r.uniforms.projectionMatrix = e.getUniformLocation(r.program, "projectionMatrix")),
                            (r.uniforms.fogType = e.getUniformLocation(r.program, "fogType")),
                            (r.uniforms.fogDensity = e.getUniformLocation(r.program, "fogDensity")),
                            (r.uniforms.fogNear = e.getUniformLocation(r.program, "fogNear")),
                            (r.uniforms.fogFar = e.getUniformLocation(r.program, "fogFar")),
                            (r.uniforms.fogColor = e.getUniformLocation(r.program, "fogColor")),
                            (r.uniforms.alphaTest = e.getUniformLocation(r.program, "alphaTest"));
                    }),
                        (this.render = function (n, i, o, u) {
                            var a = n.__webglSprites,
                                f = a.length;
                            if (!f) return;
                            var l = r.attributes,
                                c = r.uniforms,
                                h = u / o,
                                p = o * 0.5,
                                d = u * 0.5;
                            e.useProgram(r.program),
                                e.enableVertexAttribArray(l.position),
                                e.enableVertexAttribArray(l.uv),
                                e.disable(e.CULL_FACE),
                                e.enable(e.BLEND),
                                e.bindBuffer(e.ARRAY_BUFFER, r.vertexBuffer),
                                e.vertexAttribPointer(l.position, 2, e.FLOAT, !1, 16, 0),
                                e.vertexAttribPointer(l.uv, 2, e.FLOAT, !1, 16, 8),
                                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r.elementBuffer),
                                e.uniformMatrix4fv(c.projectionMatrix, !1, i.projectionMatrix.elements),
                                e.activeTexture(e.TEXTURE0),
                                e.uniform1i(c.map, 0);
                            var v = 0,
                                m = 0,
                                g = n.fog;
                            g
                                ? (e.uniform3f(c.fogColor, g.color.r, g.color.g, g.color.b),
                                    g instanceof THREE.Fog
                                        ? (e.uniform1f(c.fogNear, g.near), e.uniform1f(c.fogFar, g.far), e.uniform1i(c.fogType, 1), (v = 1), (m = 1))
                                        : g instanceof THREE.FogExp2 && (e.uniform1f(c.fogDensity, g.density), e.uniform1i(c.fogType, 2), (v = 2), (m = 2)))
                                : (e.uniform1i(c.fogType, 0), (v = 0), (m = 0));
                            var y,
                                b,
                                w,
                                E,
                                S,
                                x,
                                T = [];
                            for (y = 0; y < f; y++) {
                                (b = a[y]), (w = b.material);
                                if (!b.visible || w.opacity === 0) continue;
                                w.useScreenCoordinates ? (b.z = -b.position.z) : (b._modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, b.matrixWorld), (b.z = -b._modelViewMatrix.elements[14]));
                            }
                            a.sort(s);
                            for (y = 0; y < f; y++) {
                                (b = a[y]), (w = b.material);
                                if (!b.visible || w.opacity === 0) continue;
                                w.map &&
                                w.map.image &&
                                w.map.image.width &&
                                (e.uniform1f(c.alphaTest, w.alphaTest),
                                    w.useScreenCoordinates === !0
                                        ? (e.uniform1i(c.useScreenCoordinates, 1),
                                            e.uniform3f(c.screenPosition, (b.position.x * t.devicePixelRatio - p) / p, (d - b.position.y * t.devicePixelRatio) / d, Math.max(0, Math.min(1, b.position.z))),
                                            (T[0] = t.devicePixelRatio),
                                            (T[1] = t.devicePixelRatio))
                                        : (e.uniform1i(c.useScreenCoordinates, 0), e.uniform1i(c.sizeAttenuation, w.sizeAttenuation ? 1 : 0), e.uniformMatrix4fv(c.modelViewMatrix, !1, b._modelViewMatrix.elements), (T[0] = 1), (T[1] = 1)),
                                    n.fog && w.fog ? (x = m) : (x = 0),
                                v !== x && (e.uniform1i(c.fogType, x), (v = x)),
                                    (S = 1 / (w.scaleByViewport ? u : 1)),
                                    (T[0] *= S * h * b.scale.x),
                                    (T[1] *= S * b.scale.y),
                                    e.uniform2f(c.uvScale, w.uvScale.x, w.uvScale.y),
                                    e.uniform2f(c.uvOffset, w.uvOffset.x, w.uvOffset.y),
                                    e.uniform2f(c.alignment, w.alignment.x, w.alignment.y),
                                    e.uniform1f(c.opacity, w.opacity),
                                    e.uniform3f(c.color, w.color.r, w.color.g, w.color.b),
                                    e.uniform1f(c.rotation, b.rotation),
                                    e.uniform2fv(c.scale, T),
                                    t.setBlending(w.blending, w.blendEquation, w.blendSrc, w.blendDst),
                                    t.setDepthTest(w.depthTest),
                                    t.setDepthWrite(w.depthWrite),
                                    t.setTexture(w.map, 0),
                                    e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
                            }
                            e.enable(e.CULL_FACE);
                        });
                }),
                (THREE.DepthPassPlugin = function () {
                    function a(e) {
                        return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[0] : e.material;
                    }
                    (this.enabled = !1), (this.renderTarget = null);
                    var e,
                        t,
                        n,
                        r,
                        i,
                        s,
                        o = new THREE.Frustum(),
                        u = new THREE.Matrix4();
                    (this.init = function (o) {
                        (e = o.context), (t = o);
                        var u = THREE.ShaderLib.depthRGBA,
                            a = THREE.UniformsUtils.clone(u.uniforms);
                        (n = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a })),
                            (r = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, morphTargets: !0 })),
                            (i = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, skinning: !0 })),
                            (s = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, morphTargets: !0, skinning: !0 })),
                            (n._shadowPass = !0),
                            (r._shadowPass = !0),
                            (i._shadowPass = !0),
                            (s._shadowPass = !0);
                    }),
                        (this.render = function (e, t) {
                            if (!this.enabled) return;
                            this.update(e, t);
                        }),
                        (this.update = function (f, l) {
                            var c,
                                h,
                                p,
                                d,
                                v,
                                m,
                                g,
                                y,
                                b,
                                w,
                                E,
                                S,
                                x = null;
                            e.clearColor(1, 1, 1, 1),
                                e.disable(e.BLEND),
                                t.setDepthTest(!0),
                            f.autoUpdate === !0 && f.updateMatrixWorld(),
                                l.matrixWorldInverse.getInverse(l.matrixWorld),
                                u.multiplyMatrices(l.projectionMatrix, l.matrixWorldInverse),
                                o.setFromMatrix(u),
                                t.setRenderTarget(this.renderTarget),
                                t.clear(),
                                (S = f.__webglObjects);
                            for (p = 0, d = S.length; p < d; p++)
                                (b = S[p]),
                                    (w = b.object),
                                    (b.render = !1),
                                w.visible &&
                                (!(w instanceof THREE.Mesh || w instanceof THREE.ParticleSystem) || !w.frustumCulled || o.intersectsObject(w)) &&
                                (w._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, w.matrixWorld), (b.render = !0));
                            var T, N, C;
                            for (p = 0, d = S.length; p < d; p++) {
                                b = S[p];
                                if (b.render) {
                                    (w = b.object), (g = b.buffer);
                                    if (w instanceof THREE.ParticleSystem && !w.customDepthMaterial) continue;
                                    (T = a(w)),
                                    T && t.setMaterialFaces(w.material),
                                        (N = w.geometry.morphTargets.length > 0 && T.morphTargets),
                                        (C = w instanceof THREE.SkinnedMesh && T.skinning),
                                        w.customDepthMaterial ? (y = w.customDepthMaterial) : C ? (y = N ? s : i) : N ? (y = r) : (y = n),
                                        g instanceof THREE.BufferGeometry ? t.renderBufferDirect(l, f.__lights, x, y, g, w) : t.renderBuffer(l, f.__lights, x, y, g, w);
                                }
                            }
                            S = f.__webglObjectsImmediate;
                            for (p = 0, d = S.length; p < d; p++) (b = S[p]), (w = b.object), w.visible && (w._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, w.matrixWorld), t.renderImmediateObject(l, f.__lights, x, n, w));
                            var k = t.getClearColor(),
                                L = t.getClearAlpha();
                            e.clearColor(k.r, k.g, k.b, L), e.enable(e.BLEND);
                        });
                }),
                (THREE.ShaderFlares = {
                    lensFlareVertexTexture: {
                        vertexShader: [
                            "uniform lowp int renderType;",
                            "uniform vec3 screenPosition;",
                            "uniform vec2 scale;",
                            "uniform float rotation;",
                            "uniform sampler2D occlusionMap;",
                            "attribute vec2 position;",
                            "attribute vec2 uv;",
                            "varying vec2 vUV;",
                            "varying float vVisibility;",
                            "void main() {",
                            "vUV = uv;",
                            "vec2 pos = position;",
                            "if( renderType == 2 ) {",
                            "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
                            "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
                            "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
                            "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
                            "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
                            "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
                            "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
                            "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
                            "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
                            "vVisibility =        visibility.r / 9.0;",
                            "vVisibility *= 1.0 - visibility.g / 9.0;",
                            "vVisibility *=       visibility.b / 9.0;",
                            "vVisibility *= 1.0 - visibility.a / 9.0;",
                            "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                            "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
                            "}",
                            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
                            "}",
                        ].join("\n"),
                        fragmentShader: [
                            "uniform lowp int renderType;",
                            "uniform sampler2D map;",
                            "uniform float opacity;",
                            "uniform vec3 color;",
                            "varying vec2 vUV;",
                            "varying float vVisibility;",
                            "void main() {",
                            "if( renderType == 0 ) {",
                            "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
                            "} else if( renderType == 1 ) {",
                            "gl_FragColor = texture2D( map, vUV );",
                            "} else {",
                            "vec4 texture = texture2D( map, vUV );",
                            "texture.a *= opacity * vVisibility;",
                            "gl_FragColor = texture;",
                            "gl_FragColor.rgb *= color;",
                            "}",
                            "}",
                        ].join("\n"),
                    },
                    lensFlare: {
                        vertexShader: [
                            "uniform lowp int renderType;",
                            "uniform vec3 screenPosition;",
                            "uniform vec2 scale;",
                            "uniform float rotation;",
                            "attribute vec2 position;",
                            "attribute vec2 uv;",
                            "varying vec2 vUV;",
                            "void main() {",
                            "vUV = uv;",
                            "vec2 pos = position;",
                            "if( renderType == 2 ) {",
                            "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                            "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
                            "}",
                            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
                            "}",
                        ].join("\n"),
                        fragmentShader: [
                            "precision mediump float;",
                            "uniform lowp int renderType;",
                            "uniform sampler2D map;",
                            "uniform sampler2D occlusionMap;",
                            "uniform float opacity;",
                            "uniform vec3 color;",
                            "varying vec2 vUV;",
                            "void main() {",
                            "if( renderType == 0 ) {",
                            "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",
                            "} else if( renderType == 1 ) {",
                            "gl_FragColor = texture2D( map, vUV );",
                            "} else {",
                            "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
                            "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
                            "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
                            "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
                            "visibility = ( 1.0 - visibility / 4.0 );",
                            "vec4 texture = texture2D( map, vUV );",
                            "texture.a *= opacity * visibility;",
                            "gl_FragColor = texture;",
                            "gl_FragColor.rgb *= color;",
                            "}",
                            "}",
                        ].join("\n"),
                    },
                }),
                (THREE.ShaderSprite = {
                    sprite: {
                        vertexShader: [
                            "uniform int useScreenCoordinates;",
                            "uniform int sizeAttenuation;",
                            "uniform vec3 screenPosition;",
                            "uniform mat4 modelViewMatrix;",
                            "uniform mat4 projectionMatrix;",
                            "uniform float rotation;",
                            "uniform vec2 scale;",
                            "uniform vec2 alignment;",
                            "uniform vec2 uvOffset;",
                            "uniform vec2 uvScale;",
                            "attribute vec2 position;",
                            "attribute vec2 uv;",
                            "varying vec2 vUV;",
                            "void main() {",
                            "vUV = uvOffset + uv * uvScale;",
                            "vec2 alignedPosition = position + alignment;",
                            "vec2 rotatedPosition;",
                            "rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;",
                            "rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;",
                            "vec4 finalPosition;",
                            "if( useScreenCoordinates != 0 ) {",
                            "finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );",
                            "} else {",
                            "finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );",
                            "finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );",
                            "}",
                            "gl_Position = finalPosition;",
                            "}",
                        ].join("\n"),
                        fragmentShader: [
                            "uniform vec3 color;",
                            "uniform sampler2D map;",
                            "uniform float opacity;",
                            "uniform int fogType;",
                            "uniform vec3 fogColor;",
                            "uniform float fogDensity;",
                            "uniform float fogNear;",
                            "uniform float fogFar;",
                            "uniform float alphaTest;",
                            "varying vec2 vUV;",
                            "void main() {",
                            "vec4 texture = texture2D( map, vUV );",
                            "if ( texture.a < alphaTest ) discard;",
                            "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );",
                            "if ( fogType > 0 ) {",
                            "float depth = gl_FragCoord.z / gl_FragCoord.w;",
                            "float fogFactor = 0.0;",
                            "if ( fogType == 1 ) {",
                            "fogFactor = smoothstep( fogNear, fogFar, depth );",
                            "} else {",
                            "const float LOG2 = 1.442695;",
                            "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
                            "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
                            "}",
                            "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
                            "}",
                            "}",
                        ].join("\n"),
                    },
                }),
                define("three", (function (e) {
                    return function () {
                        var t, n;
                        return t || e.THREE;
                    };
                })(this)),
                (THREE.OrbitControls = function (e, t) {
                    function E() {
                        return ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed;
                    }
                    function S() {
                        return Math.pow(0.95, n.zoomSpeed);
                    }
                    function x(e) {
                        if (n.enabled === !1) return;
                        e.preventDefault();
                        if (e.button === 0) {
                            if (n.noRotate === !0) return;
                            (b = y.ROTATE), i.set(e.clientX, e.clientY);
                        } else if (e.button === 1) {
                            if (n.noZoom === !0) return;
                            (b = y.DOLLY), l.set(e.clientX, e.clientY);
                        } else if (e.button === 2) {
                            if (n.noPan === !0) return;
                            (b = y.PAN), u.set(e.clientX, e.clientY);
                        }
                        n.domElement.addEventListener("mousemove", T, !1), n.domElement.addEventListener("mouseup", N, !1);
                    }
                    function T(e) {
                        if (n.enabled === !1) return;
                        e.preventDefault();
                        var t = n.domElement === document ? n.domElement.body : n.domElement;
                        if (b === y.ROTATE) {
                            if (n.noRotate === !0) return;
                            s.set(e.clientX, e.clientY), o.subVectors(s, i), n.rotateLeft(((2 * Math.PI * o.x) / t.clientWidth) * n.rotateSpeed), n.rotateUp(((2 * Math.PI * o.y) / t.clientHeight) * n.rotateSpeed), i.copy(s);
                        } else if (b === y.DOLLY) {
                            if (n.noZoom === !0) return;
                            c.set(e.clientX, e.clientY), h.subVectors(c, l), h.y > 0 ? n.dollyIn() : n.dollyOut(), l.copy(c);
                        } else if (b === y.PAN) {
                            if (n.noPan === !0) return;
                            a.set(e.clientX, e.clientY), f.subVectors(a, u), n.pan(f), u.copy(a);
                        }
                        n.update();
                    }
                    function N() {
                        if (n.enabled === !1) return;
                        n.domElement.removeEventListener("mousemove", T, !1), n.domElement.removeEventListener("mouseup", N, !1), (b = y.NONE);
                    }
                    function C(e) {
                        if (n.enabled === !1 || n.noZoom === !0) return;
                        var t = 0;
                        e.wheelDelta ? (t = e.wheelDelta) : e.detail && (t = -e.detail), t > 0 ? n.dollyOut() : n.dollyIn();
                    }
                    function k(e) {
                        if (n.enabled === !1) return;
                        if (n.noKeys === !0) return;
                        if (n.noPan === !0) return;
                        var t = !1;
                        switch (e.keyCode) {
                            case n.keys.UP:
                                n.pan(new THREE.Vector2(0, n.keyPanSpeed)), (t = !0);
                                break;
                            case n.keys.BOTTOM:
                                n.pan(new THREE.Vector2(0, -n.keyPanSpeed)), (t = !0);
                                break;
                            case n.keys.LEFT:
                                n.pan(new THREE.Vector2(n.keyPanSpeed, 0)), (t = !0);
                                break;
                            case n.keys.RIGHT:
                                n.pan(new THREE.Vector2(-n.keyPanSpeed, 0)), (t = !0);
                        }
                        t && n.update();
                    }
                    function L(e) {
                        if (n.enabled === !1) return;
                        switch (e.touches.length) {
                            case 1:
                                if (n.noRotate === !0) return;
                                (b = y.TOUCH_ROTATE), i.set(e.touches[0].pageX, e.touches[0].pageY);
                                break;
                            case 2:
                                if (n.noZoom === !0) return;
                                b = y.TOUCH_DOLLY;
                                var t = e.touches[0].pageX - e.touches[1].pageX,
                                    r = e.touches[0].pageY - e.touches[1].pageY,
                                    s = Math.sqrt(t * t + r * r);
                                l.set(0, s);
                                break;
                            case 3:
                                if (n.noPan === !0) return;
                                (b = y.TOUCH_PAN), u.set(e.touches[0].pageX, e.touches[0].pageY);
                                break;
                            default:
                                b = y.NONE;
                        }
                    }
                    function A(e) {
                        if (n.enabled === !1) return;
                        e.preventDefault(), e.stopPropagation();
                        var t = n.domElement === document ? n.domElement.body : n.domElement;
                        switch (e.touches.length) {
                            case 1:
                                if (n.noRotate === !0) return;
                                if (b !== y.TOUCH_ROTATE) return;
                                s.set(e.touches[0].pageX, e.touches[0].pageY), o.subVectors(s, i), n.rotateLeft(((2 * Math.PI * o.x) / t.clientWidth) * n.rotateSpeed), n.rotateUp(((2 * Math.PI * o.y) / t.clientHeight) * n.rotateSpeed), i.copy(s);
                                break;
                            case 2:
                                if (n.noZoom === !0) return;
                                if (b !== y.TOUCH_DOLLY) return;
                                var r = e.touches[0].pageX - e.touches[1].pageX,
                                    p = e.touches[0].pageY - e.touches[1].pageY,
                                    d = Math.sqrt(r * r + p * p);
                                c.set(0, d), h.subVectors(c, l), h.y > 0 ? n.dollyOut() : n.dollyIn(), l.copy(c);
                                break;
                            case 3:
                                if (n.noPan === !0) return;
                                if (b !== y.TOUCH_PAN) return;
                                a.set(e.touches[0].pageX, e.touches[0].pageY), f.subVectors(a, u), n.pan(f), u.copy(a);
                                break;
                            default:
                                b = y.NONE;
                        }
                    }
                    function O() {
                        if (n.enabled === !1) return;
                        b = y.NONE;
                    }
                    (this.object = e),
                        (this.domElement = t !== undefined ? t : document),
                        (this.enabled = !0),
                        (this.target = new THREE.Vector3()),
                        (this.center = this.target),
                        (this.noZoom = !1),
                        (this.zoomSpeed = 1),
                        (this.minDistance = 0),
                        (this.maxDistance = Infinity),
                        (this.noRotate = !1),
                        (this.rotateSpeed = 1),
                        (this.noPan = !1),
                        (this.keyPanSpeed = 7),
                        (this.autoRotate = !1),
                        (this.autoRotateSpeed = 2),
                        (this.minPolarAngle = 0),
                        (this.maxPolarAngle = Math.PI),
                        (this.noKeys = !1),
                        (this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 });
                    var n = this,
                        r = 1e-6,
                        i = new THREE.Vector2(),
                        s = new THREE.Vector2(),
                        o = new THREE.Vector2(),
                        u = new THREE.Vector2(),
                        a = new THREE.Vector2(),
                        f = new THREE.Vector2(),
                        l = new THREE.Vector2(),
                        c = new THREE.Vector2(),
                        h = new THREE.Vector2(),
                        p = 0,
                        d = 0,
                        v = 1,
                        m = new THREE.Vector3(),
                        g = new THREE.Vector3(),
                        y = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 },
                        b = y.NONE,
                        w = { type: "change" };
                    (this.rotateLeft = function (e) {
                        e === undefined && (e = E()), (d -= e);
                    }),
                        (this.rotateUp = function (e) {
                            e === undefined && (e = E()), (p -= e);
                        }),
                        (this.panLeft = function (e) {
                            var t = new THREE.Vector3(),
                                n = this.object.matrix.elements;
                            t.set(n[0], n[1], n[2]), t.multiplyScalar(-e), m.add(t);
                        }),
                        (this.panUp = function (e) {
                            var t = new THREE.Vector3(),
                                n = this.object.matrix.elements;
                            t.set(n[4], n[5], n[6]), t.multiplyScalar(e), m.add(t);
                        }),
                        (this.pan = function (e) {
                            var t = n.domElement === document ? n.domElement.body : n.domElement;
                            if (n.object.fov !== undefined) {
                                var r = n.object.position,
                                    i = r.clone().sub(n.target),
                                    s = i.length();
                                (s *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)), n.panLeft((2 * e.x * s) / t.clientHeight), n.panUp((2 * e.y * s) / t.clientHeight);
                            } else
                                n.object.top !== undefined
                                    ? (n.panLeft((e.x * (n.object.right - n.object.left)) / t.clientWidth), n.panUp((e.y * (n.object.top - n.object.bottom)) / t.clientHeight))
                                    : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
                        }),
                        (this.dollyIn = function (e) {
                            e === undefined && (e = S()), (v /= e);
                        }),
                        (this.dollyOut = function (e) {
                            e === undefined && (e = S()), (v *= e);
                        }),
                        (this.update = function () {
                            var e = this.object.position,
                                t = e.clone().sub(this.target),
                                n = Math.atan2(t.x, t.z),
                                i = Math.atan2(Math.sqrt(t.x * t.x + t.z * t.z), t.y);
                            this.autoRotate && this.rotateLeft(E()), (n += d), (i += p), (i = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, i))), (i = Math.max(r, Math.min(Math.PI - r, i)));
                            var s = t.length() * v;
                            (s = Math.max(this.minDistance, Math.min(this.maxDistance, s))),
                                this.target.add(m),
                                (t.x = s * Math.sin(i) * Math.sin(n)),
                                (t.y = s * Math.cos(i)),
                                (t.z = s * Math.sin(i) * Math.cos(n)),
                                e.copy(this.target).add(t),
                                this.object.lookAt(this.target),
                                (d = 0),
                                (p = 0),
                                (v = 1),
                                m.set(0, 0, 0),
                            g.distanceTo(this.object.position) > 0 && (this.dispatchEvent(w), g.copy(this.object.position));
                        }),
                        this.domElement.addEventListener(
                            "contextmenu",
                            function (e) {
                                e.preventDefault();
                            },
                            !1
                        ),
                        this.domElement.addEventListener("mousedown", x, !1),
                        this.domElement.addEventListener("mousewheel", C, !1),
                        this.domElement.addEventListener("DOMMouseScroll", C, !1),
                        this.domElement.addEventListener("keydown", k, !1),
                        this.domElement.addEventListener("touchstart", L, !1),
                        this.domElement.addEventListener("touchend", O, !1),
                        this.domElement.addEventListener("touchmove", A, !1);
                }),
                (THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype)),
                define("orbitcontrols", ["three"], function () {}),
                (THREE.EffectComposer = function (e, t) {
                    this.renderer = e;
                    if (t === undefined) {
                        var n = WIDTH || 1,
                            r = HEIGHT || 1,
                            i = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: !1 };
                        t = new THREE.WebGLRenderTarget(n, r, i);
                    }
                    (this.renderTarget1 = t),
                        (this.renderTarget2 = t.clone()),
                        (this.writeBuffer = this.renderTarget1),
                        (this.readBuffer = this.renderTarget2),
                        (this.passes = []),
                    THREE.CopyShader === undefined && console.error("THREE.EffectComposer relies on THREE.CopyShader"),
                        (this.copyPass = new THREE.ShaderPass(THREE.CopyShader));
                }),
                (THREE.EffectComposer.prototype = {
                    swapBuffers: function () {
                        var e = this.readBuffer;
                        (this.readBuffer = this.writeBuffer), (this.writeBuffer = e);
                    },
                    addPass: function (e) {
                        this.passes.push(e);
                    },
                    insertPass: function (e, t) {
                        this.passes.splice(t, 0, e);
                    },
                    render: function (e) {
                        (this.writeBuffer = this.renderTarget1), (this.readBuffer = this.renderTarget2);
                        var t = !1,
                            n,
                            r,
                            i = this.passes.length;
                        for (r = 0; r < i; r++) {
                            n = this.passes[r];
                            if (!n.enabled) continue;
                            n.render(this.renderer, this.writeBuffer, this.readBuffer, e, t);
                            if (n.needsSwap) {
                                if (t) {
                                    var s = this.renderer.context;
                                    s.stencilFunc(s.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), s.stencilFunc(s.EQUAL, 1, 4294967295);
                                }
                                this.swapBuffers();
                            }
                            n instanceof THREE.MaskPass ? (t = !0) : n instanceof THREE.ClearMaskPass && (t = !1);
                        }
                    },
                    reset: function (e) {
                        e === undefined && ((e = this.renderTarget1.clone()), (e.width = WIDTH), (e.height = HEIGHT)),
                            (this.renderTarget1 = e),
                            (this.renderTarget2 = e.clone()),
                            (this.writeBuffer = this.renderTarget1),
                            (this.readBuffer = this.renderTarget2);
                    },
                    setSize: function (e, t) {
                        var n = this.renderTarget1.clone();
                        (n.width = e), (n.height = t), this.reset(n);
                    },
                }),
                (THREE.EffectComposer.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1)),
                (THREE.EffectComposer.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null)),
                (THREE.EffectComposer.scene = new THREE.Scene()),
                THREE.EffectComposer.scene.add(THREE.EffectComposer.quad),
                (THREE.RenderPass = function (e, t, n, r, i) {
                    (this.scene = e),
                        (this.camera = t),
                        (this.overrideMaterial = n),
                        (this.clearColor = r),
                        (this.clearAlpha = i !== undefined ? i : 1),
                        (this.oldClearColor = new THREE.Color()),
                        (this.oldClearAlpha = 1),
                        (this.enabled = !0),
                        (this.clear = !0),
                        (this.needsSwap = !1);
                }),
                (THREE.RenderPass.prototype = {
                    render: function (e, t, n, r) {
                        (this.scene.overrideMaterial = this.overrideMaterial),
                        this.clearColor && (this.oldClearColor.copy(e.getClearColor()), (this.oldClearAlpha = e.getClearAlpha()), e.setClearColor(this.clearColor, this.clearAlpha)),
                            e.render(this.scene, this.camera, n, this.clear),
                        this.clearColor && e.setClearColor(this.oldClearColor, this.oldClearAlpha),
                            (this.scene.overrideMaterial = null);
                    },
                }),
                (THREE.ShaderPass = function (e, t) {
                    (this.textureID = t !== undefined ? t : "tDiffuse"),
                        (this.uniforms = THREE.UniformsUtils.clone(e.uniforms)),
                        (this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })),
                        (this.renderToScreen = !1),
                        (this.enabled = !0),
                        (this.needsSwap = !0),
                        (this.clear = !1);
                }),
                (THREE.ShaderPass.prototype = {
                    render: function (e, t, n, r) {
                        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n),
                            (THREE.EffectComposer.quad.material = this.material),
                            this.renderToScreen ? e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera) : e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, t, this.clear);
                    },
                }),
                (THREE.MaskPass = function (e, t) {
                    (this.scene = e), (this.camera = t), (this.enabled = !0), (this.clear = !0), (this.needsSwap = !1), (this.inverse = !1);
                }),
                (THREE.MaskPass.prototype = {
                    render: function (e, t, n, r) {
                        var i = e.context;
                        i.colorMask(!1, !1, !1, !1), i.depthMask(!1);
                        var s, o;
                        this.inverse ? ((s = 0), (o = 1)) : ((s = 1), (o = 0)),
                            i.enable(i.STENCIL_TEST),
                            i.stencilOp(i.REPLACE, i.REPLACE, i.REPLACE),
                            i.stencilFunc(i.ALWAYS, s, 4294967295),
                            i.clearStencil(o),
                            e.render(this.scene, this.camera, n, this.clear),
                            e.render(this.scene, this.camera, t, this.clear),
                            i.colorMask(!0, !0, !0, !0),
                            i.depthMask(!0),
                            i.stencilFunc(i.EQUAL, 1, 4294967295),
                            i.stencilOp(i.KEEP, i.KEEP, i.KEEP);
                    },
                }),
                (THREE.ClearMaskPass = function () {
                    this.enabled = !0;
                }),
                (THREE.ClearMaskPass.prototype = {
                    render: function (e, t, n, r) {
                        var i = e.context;
                        i.disable(i.STENCIL_TEST);
                    },
                }),
                (THREE.BloomPass = function (e, t, n, r) {
                    (e = e !== undefined ? e : 1), (t = t !== undefined ? t : 25), (n = n !== undefined ? n : 4), (r = r !== undefined ? r : 256);
                    var i = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
                    (this.renderTargetX = new THREE.WebGLRenderTarget(r, r, i)), (this.renderTargetY = new THREE.WebGLRenderTarget(r, r, i)), THREE.CopyShader === undefined && console.error("THREE.BloomPass relies on THREE.CopyShader");
                    var s = THREE.CopyShader;
                    (this.copyUniforms = THREE.UniformsUtils.clone(s.uniforms)),
                        (this.copyUniforms.opacity.value = e),
                        (this.materialCopy = new THREE.ShaderMaterial({ uniforms: this.copyUniforms, vertexShader: s.vertexShader, fragmentShader: s.fragmentShader, blending: THREE.AdditiveBlending, transparent: !0 })),
                    THREE.ConvolutionShader === undefined && console.error("THREE.BloomPass relies on THREE.ConvolutionShader");
                    var o = THREE.ConvolutionShader;
                    (this.convolutionUniforms = THREE.UniformsUtils.clone(o.uniforms)),
                        (this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurx),
                        (this.convolutionUniforms.cKernel.value = THREE.ConvolutionShader.buildKernel(n)),
                        (this.materialConvolution = new THREE.ShaderMaterial({
                            uniforms: this.convolutionUniforms,
                            vertexShader: o.vertexShader,
                            fragmentShader: o.fragmentShader,
                            defines: { KERNEL_SIZE_FLOAT: t.toFixed(1), KERNEL_SIZE_INT: t.toFixed(0) },
                        })),
                        (this.enabled = !0),
                        (this.needsSwap = !1),
                        (this.clear = !1);
                }),
                (THREE.BloomPass.prototype = {
                    render: function (e, t, n, r, i) {
                        i && e.context.disable(e.context.STENCIL_TEST),
                            (THREE.EffectComposer.quad.material = this.materialConvolution),
                            (this.convolutionUniforms.tDiffuse.value = n),
                            (this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurX),
                            e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetX, !0),
                            (this.convolutionUniforms.tDiffuse.value = this.renderTargetX),
                            (this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurY),
                            e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetY, !0),
                            (THREE.EffectComposer.quad.material = this.materialCopy),
                            (this.copyUniforms.tDiffuse.value = this.renderTargetY),
                        i && e.context.enable(e.context.STENCIL_TEST),
                            e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, n, this.clear);
                    },
                }),
                (THREE.BloomPass.blurX = new THREE.Vector2(0.001953125, 0)),
                (THREE.BloomPass.blurY = new THREE.Vector2(0, 0.001953125)),
                (THREE.SavePass = function (e) {
                    THREE.CopyShader === undefined && console.error("THREE.SavePass relies on THREE.CopyShader");
                    var t = THREE.CopyShader;
                    (this.textureID = "tDiffuse"),
                        (this.uniforms = THREE.UniformsUtils.clone(t.uniforms)),
                        (this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader })),
                        (this.renderTarget = e),
                    this.renderTarget === undefined &&
                    ((this.renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: !1 }),
                        (this.renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, this.renderTargetParameters))),
                        (this.enabled = !0),
                        (this.needsSwap = !1),
                        (this.clear = !1);
                }),
                (THREE.SavePass.prototype = {
                    render: function (e, t, n, r) {
                        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n), (THREE.EffectComposer.quad.material = this.material), e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTarget, this.clear);
                    },
                }),
                (THREE.NormalBlendPass = function (e, t) {
                    var n = THREE.NormalBlendShader;
                    (this.target1 = e),
                        (this.target2 = t),
                        (this.uniforms = THREE.UniformsUtils.clone(n.uniforms)),
                        (this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: n.vertexShader, fragmentShader: n.fragmentShader })),
                        (this.renderToScreen = !1),
                        (this.enabled = !0),
                        (this.needsSwap = !0),
                        (this.clear = !1);
                }),
                (THREE.NormalBlendPass.prototype = {
                    render: function (e, t, n, r) {
                        (this.uniforms.tDiffuse1.value = this.target1),
                            (this.uniforms.tDiffuse2.value = this.target2),
                            (THREE.EffectComposer.quad.material = this.material),
                            e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, t, this.clear);
                    },
                }),
                (THREE.AdditiveBlendPass = function (e, t, n) {
                    var r = THREE.AdditiveBlendShader;
                    (this.target1 = e),
                        (this.target2 = t),
                        (this.opacity = n),
                        (this.uniforms = THREE.UniformsUtils.clone(r.uniforms)),
                        (this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: r.vertexShader, fragmentShader: r.fragmentShader })),
                        (this.renderToScreen = !1),
                        (this.enabled = !0),
                        (this.needsSwap = !0),
                        (this.clear = !1);
                }),
                (THREE.AdditiveBlendPass.prototype = {
                    render: function (e, t, n, r) {
                        (this.uniforms.tDiffuse1.value = this.target1 || n),
                            (this.uniforms.tDiffuse2.value = this.target2),
                            (this.uniforms.opacity.value = this.opacity),
                            (THREE.EffectComposer.quad.material = this.material),
                            e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, t, this.clear);
                    },
                }),
                (THREE.CopyPass = function (e) {
                    var t = THREE.CopyShader;
                    (this.target = e),
                        (this.uniforms = THREE.UniformsUtils.clone(t.uniforms)),
                        (this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader })),
                        (this.renderToScreen = !1),
                        (this.enabled = !0),
                        (this.needsSwap = !0),
                        (this.clear = !1);
                }),
                (THREE.CopyPass.prototype = {
                    render: function (e, t, n, r) {
                        (this.uniforms.tDiffuse.value = this.target || n), (THREE.EffectComposer.quad.material = this.material), e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, t, this.clear);
                    },
                }),
                define("effectcomposer", ["three"], function () {}),
                (THREE.CopyShader = {
                    uniforms: { tDiffuse: { type: "t", value: null }, opacity: { type: "f", value: 1 } },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n"),
                }),
                (THREE.RGBShiftShader = {
                    uniforms: { tDiffuse: { type: "t", value: null }, amount: { type: "f", value: 0.005 }, angle: { type: "f", value: 0 } },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: [
                        "uniform sampler2D tDiffuse;",
                        "uniform float amount;",
                        "uniform float angle;",
                        "varying vec2 vUv;",
                        "void main() {",
                        "vec2 offset = amount * vec2( cos(angle), sin(angle));",
                        "vec4 cr = texture2D(tDiffuse, vUv + offset);",
                        "vec4 cga = texture2D(tDiffuse, vUv);",
                        "vec4 cb = texture2D(tDiffuse, vUv - offset);",
                        "gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",
                        "}",
                    ].join("\n"),
                }),
                (THREE.ConvolutionShader = {
                    defines: { KERNEL_SIZE_FLOAT: "25.0", KERNEL_SIZE_INT: "25" },
                    uniforms: { tDiffuse: { type: "t", value: null }, uImageIncrement: { type: "v2", value: new THREE.Vector2(0.001953125, 0) }, cKernel: { type: "fv1", value: [] } },
                    vertexShader: [
                        "uniform vec2 uImageIncrement;",
                        "varying vec2 vUv;",
                        "void main() {",
                        "vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;",
                        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                        "}",
                    ].join("\n"),
                    fragmentShader: [
                        "uniform float cKernel[ KERNEL_SIZE_INT ];",
                        "uniform sampler2D tDiffuse;",
                        "uniform vec2 uImageIncrement;",
                        "varying vec2 vUv;",
                        "void main() {",
                        "vec2 imageCoord = vUv;",
                        "vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );",
                        "for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {",
                        "sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];",
                        "imageCoord += uImageIncrement;",
                        "}",
                        "gl_FragColor = sum;",
                        "}",
                    ].join("\n"),
                    buildKernel: function (e) {
                        function t(e, t) {
                            return Math.exp(-(e * e) / (2 * t * t));
                        }
                        var n,
                            r,
                            i,
                            s,
                            o = 25,
                            u = 2 * Math.ceil(e * 3) + 1;
                        u > o && (u = o), (s = (u - 1) * 0.5), (r = new Array(u)), (i = 0);
                        for (n = 0; n < u; ++n) (r[n] = t(n - s, e)), (i += r[n]);
                        for (n = 0; n < u; ++n) r[n] /= i;
                        return r;
                    },
                }),
                (THREE.FXAAShader = {
                    uniforms: { tDiffuse: { type: "t", value: null }, resolution: { type: "v2", value: new THREE.Vector2(1 / 1024, 1 / 512) } },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: [
                        "uniform sampler2D tDiffuse;",
                        "uniform vec2 resolution;",
                        "varying vec2 vUv;",
                        "#define FXAA_REDUCE_MIN   (1.0/128.0)",
                        "#define FXAA_REDUCE_MUL   (1.0/8.0)",
                        "#define FXAA_SPAN_MAX     8.0",
                        "void main() {",
                        "vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;",
                        "vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;",
                        "vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;",
                        "vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;",
                        "vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );",
                        "vec3 rgbM  = rgbaM.xyz;",
                        "float opacity  = rgbaM.w;",
                        "vec3 luma = vec3( 0.299, 0.587, 0.114 );",
                        "float lumaNW = dot( rgbNW, luma );",
                        "float lumaNE = dot( rgbNE, luma );",
                        "float lumaSW = dot( rgbSW, luma );",
                        "float lumaSE = dot( rgbSE, luma );",
                        "float lumaM  = dot( rgbM,  luma );",
                        "float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
                        "float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",
                        "vec2 dir;",
                        "dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
                        "dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",
                        "float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",
                        "float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
                        "dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
                        "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
                        "dir * rcpDirMin)) * resolution;",
                        "vec3 rgbA = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz;",
                        "rgbA += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz;",
                        "rgbA *= 0.5;",
                        "vec3 rgbB = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz;",
                        "rgbB += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz;",
                        "rgbB *= 0.25;",
                        "rgbB += rgbA * 0.5;",
                        "float lumaB = dot( rgbB, luma );",
                        "if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",
                        "gl_FragColor = vec4( rgbA, opacity );",
                        "} else {",
                        "gl_FragColor = vec4( rgbB, opacity );",
                        "}",
                        "}",
                    ].join("\n"),
                }),
                (THREE.HorizontalDofShader = {
                    uniforms: { tDiffuse: { type: "t", value: null }, tDepth: { type: "t", value: null }, h: { type: "f", value: 1 / 512 } },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: [
                        "uniform sampler2D tDiffuse;",
                        "uniform sampler2D tDepth;",
                        "uniform float h;",
                        "varying vec2 vUv;",
                        "void main() {",
                        "vec4 sum = vec4( 0.0 );",
                        "float depth = clamp(texture2D(tDepth, vUv.xy).r - 0.5, 0.0, 0.5) / 0.5;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;",
                        "vec4 diffuse = texture2D(tDiffuse, vUv.xy);",
                        "vec4 color = mix(sum, diffuse, depth);",
                        "gl_FragColor = color;",
                        "}",
                    ].join("\n"),
                }),
                (THREE.VerticalDofShader = {
                    uniforms: { tDiffuse: { type: "t", value: null }, tDepth: { type: "t", value: null }, v: { type: "f", value: 1 / 512 } },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: [
                        "uniform sampler2D tDiffuse;",
                        "uniform sampler2D tDepth;",
                        "uniform float v;",
                        "varying vec2 vUv;",
                        "void main() {",
                        "vec4 sum = vec4( 0.0 );",
                        "float depth = clamp(texture2D(tDepth, vUv.xy).r - 0.5, 0.0, 0.5) / 0.5;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;",
                        "vec4 diffuse = texture2D(tDiffuse, vUv.xy);",
                        "vec4 color = mix(sum, diffuse, depth);",
                        "gl_FragColor = color;",
                        "}",
                    ].join("\n"),
                }),
                (THREE.HorizontalBlurShader = {
                    uniforms: { tDiffuse: { type: "t", value: null }, h: { type: "f", value: 1 / 512 } },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: [
                        "uniform sampler2D tDiffuse;",
                        "uniform float h;",
                        "varying vec2 vUv;",
                        "void main() {",
                        "vec4 sum = vec4( 0.0 );",
                        "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;",
                        "gl_FragColor = sum;",
                        "}",
                    ].join("\n"),
                }),
                (THREE.VerticalBlurShader = {
                    uniforms: { tDiffuse: { type: "t", value: null }, v: { type: "f", value: 1 / 512 } },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: [
                        "uniform sampler2D tDiffuse;",
                        "uniform float v;",
                        "varying vec2 vUv;",
                        "void main() {",
                        "vec4 sum = vec4( 0.0 );",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;",
                        "gl_FragColor = sum;",
                        "}",
                    ].join("\n"),
                }),
                (THREE.NormalBlendShader = {
                    uniforms: { tDiffuse1: { type: "t", value: null }, tDiffuse2: { type: "t", value: null } },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: [
                        "uniform sampler2D tDiffuse1;",
                        "uniform sampler2D tDiffuse2;",
                        "varying vec2 vUv;",
                        "void main() {",
                        "vec4 texel1 = texture2D( tDiffuse1, vUv );",
                        "vec4 texel2 = texture2D( tDiffuse2, vUv );",
                        "gl_FragColor = mix( texel1, texel2, texel2.a );",
                        "}",
                    ].join("\n"),
                }),
                (THREE.AdditiveBlendShader = {
                    uniforms: { tDiffuse1: { type: "t", value: null }, tDiffuse2: { type: "t", value: null }, opacity: { type: "f", value: 1 } },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: [
                        "uniform sampler2D tDiffuse1;",
                        "uniform sampler2D tDiffuse2;",
                        "uniform float opacity;",
                        "varying vec2 vUv;",
                        "void main() {",
                        "vec4 texel1 = texture2D( tDiffuse1, vUv );",
                        "vec4 texel2 = texture2D( tDiffuse2, vUv );",
                        "gl_FragColor = texel1 + texel2 * opacity;",
                        "}",
                    ].join("\n"),
                }),
                (THREE.StrokeShader = {
                    uniforms: { tDiffuse: { type: "t", value: null }, h: { type: "f", value: 1 / 512 }, cells: { type: "v2v", value: [] } },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: [
                        "uniform sampler2D tDiffuse;",
                        "uniform float h;",
                        "uniform vec2 cells[8];",
                        "const float PI = 3.14159265358979323846264;",
                        "varying vec2 vUv;",
                        "void main() {",
                        "vec4 color = vec4( 0.0 );",
                        "gl_FragColor = color;",
                        "for (int i = 0; i < 8; i++) {",
                        "vec2 pos = cells[i] * h;",
                        "vec4 texel = texture2D(tDiffuse, vUv + pos);",
                        "if (texel.g > 0.0) {",
                        "gl_FragColor = vec4(0.0236, 0.58, 0.467, 1.0);",
                        "break;",
                        "}",
                        "}",
                        "}",
                    ].join("\n"),
                }),
                (THREE.BlendShader = {
                    uniforms: { tDiffuse: { type: "t", value: null }, tDiffuse2: { type: "t", value: null } },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: [
                        "uniform sampler2D tDiffuse;",
                        "uniform sampler2D tDiffuse2;",
                        "varying vec2 vUv;",
                        "void main() {",
                        "vec4 texel1 = texture2D( tDiffuse, vUv );",
                        "vec4 texel2 = texture2D( tDiffuse2, vUv );",
                        "gl_FragColor = texel1;",
                        "if (texel2.g > 0.0) {",
                        "gl_FragColor = texel2;",
                        "}",
                        "}",
                    ].join("\n"),
                }),
                define("compositingshaders", ["three"], function () {}),
                define("neons/app", ["class", "./objects", "./textures", "./models", "./neons", "orbitcontrols", "effectcomposer", "compositingshaders"], function (e, t, n, r, i) {
                    var s = e.extend({
                        initialize: function (e) {
                            (this.name = "neons"),
                                (this.description = '#01  Based on <a target="_blank" href="http://vimeo.com/49241313">Bitsweep</a> by Beeple'),
                                (this.renderer = e.renderer),
                                (this.container = e.container),
                                (this.clock = new THREE.Clock(!1)),
                                (this.compositing = e.enableCompositing);
                        },
                        initWorld: function () {
                            $.when(n.loadAll(), r.loadAll()).done(
                                _.bind(function () {
                                    (this.world = new i({ renderer: this.renderer })),
                                        this.world.initHelpers(),
                                        this.world.toggleHelpers(),
                                        this.initCompositing(),
                                        this.world.on(
                                            "started",
                                            _.bind(function () {
                                                this.trigger("ready");
                                            }, this)
                                        );
                                }, this)
                            );
                        },
                        initCompositing: function () {
                            (this.composer = new THREE.EffectComposer(this.renderer)), this.world.setupCompositing(this.composer);
                            var e = new THREE.ShaderPass(THREE.CopyShader);
                            (e.renderToScreen = !0), this.composer.addPass(e);
                        },
                        render: function () {
                            this.compositing && this.composer ? this.composer.render(this.clock.getDelta()) : this.renderer.render(this.world.scene, this.world.camera);
                        },
                        update: function () {
                            var e = this.clock.getDelta(),
                                t = this.clock.getElapsedTime();
                            this.paused || (requestAnimationFrame(this.update.bind(this)), this.stats && this.stats.begin(), this.world.update(t, e), this.render(), this.stats && this.stats.end());
                        },
                        pause: function () {
                            this.clock.stop(), (this.paused = !0);
                        },
                        resume: function () {
                            this.clock.start(), (this.paused = !1);
                        },
                        toggleGUIMode: function () {
                            this.stats && this.datGUI && ($(this.stats.domElement).toggle(), $(this.datGUI.domElement).toggle());
                        },
                        resize: function (e, t) {
                            this.world.setAspectRatio(e / t);
                        },
                    });
                    return s;
                }),
                define("canyon/objects", [], function () {
                    var e = {};
                    return (
                        (e.createGrid = function (e) {
                            var e = _.extend({ size: 100, step: 10, color: 0, opacity: 0.2, linewidth: 1, heights: [] }, e),
                                t = new THREE.Geometry(),
                                n = e.size;
                            for (var r = -n; r <= n; r += e.step) t.vertices.push(new THREE.Vector3(-n, 0, r)), t.vertices.push(new THREE.Vector3(n, 0, r)), t.vertices.push(new THREE.Vector3(r, 0, -n)), t.vertices.push(new THREE.Vector3(r, 0, n));
                            if (!e.material) var i = new THREE.LineBasicMaterial({ color: e.color, opacity: e.opacity, linewidth: e.linewidth });
                            else var i = e.material;
                            var s = new THREE.Line(t, i);
                            return (s.type = THREE.LinePieces), s;
                        }),
                            (e.createPlaneGrid = function (e) {
                                var t = new THREE.Geometry(),
                                    n = e.plane;
                                for (var r = 0; r < 64; r++)
                                    for (var i = 0; i < 64; i++) {
                                        var s = i + r * 64,
                                            o = n.geometry.vertices[s];
                                        t.vertices.push(o.clone()), i !== 0 && i !== 63 && t.vertices.push(o.clone());
                                    }
                                for (var i = 0; i < 64; i++)
                                    for (var r = 0; r < 64; r++) {
                                        var s = i + r * 64,
                                            o = n.geometry.vertices[s];
                                        t.vertices.push(o.clone()), r !== 0 && r !== 63 && t.vertices.push(o.clone());
                                    }
                                if (!e.material) var u = new THREE.LineBasicMaterial({ color: e.color, opacity: e.opacity, linewidth: e.linewidth });
                                else var u = e.material;
                                var a = new THREE.Line(t, u);
                                return (a.type = THREE.LinePieces), a;
                            }),
                            (e.createCross = function (e) {
                                var e = _.extend({ size: 10, color: 0 }, e),
                                    t = e.size,
                                    n = new THREE.Mesh(new THREE.PlaneGeometry(t, t, 1, 1), null);
                                return n;
                            }),
                            e
                    );
                }),
                define("canyon/textures", ["../textureloader"], function (e) {
                    var t = "textures/canyon/",
                        n = { blackcircle: "black-sprite.png", terrain: "displacement.png" },
                        r = new e({ files: n, path: t });
                    return { loadAll: r.loadAllFiles.bind(r), get: r.getById.bind(r) };
                }),
                define("canyon/shaders/shader", ["three", "../../class"], function (e, t) {
                    var n = t.extend({
                        initialize: function () {
                            (this.uniforms = e.UniformsUtils.clone(this.uniforms)),
                                (this.material = new e.ShaderMaterial({
                                    attributes: this.attributes || {},
                                    defines: _.clone(this.defines) || {},
                                    uniforms: e.UniformsUtils.clone(this.uniforms) || {},
                                    vertexShader: this.vertexShader,
                                    fragmentShader: this.fragmentShader,
                                }));
                        },
                    });
                    return n;
                }),
                define("text", {
                    load: function (e) {
                        throw new Error("Dynamic load not allowed: " + e);
                    },
                }),
                define("text!canyon/shaders/vertex/terrain.vs", [], function () {
                    return "varying vec2 vUv;\nvarying vec4 worldCoord;\n\nvoid main() {\n  vUv = uv;\n  worldCoord = vec4(position, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
                }),
                define("text!canyon/shaders/fragment/terrain.fs", [], function () {
                    return "varying vec4 worldCoord;\n\nuniform vec3 color1;\nuniform vec3 color2;\nuniform float beamPosition;\nuniform float wHeight;\nuniform vec3 lineColor1;\nuniform vec3 lineColor2;\n\nconst float brightness = BRIGHTNESS;\nconst float groundPos = GROUND_POS;\nconst float lineThickness = LINE_THICKNESS;\nconst float midPoint = MIDPOINT;\nconst float beamWidth = BEAM_WIDTH;\nconst float beamBrightness = BEAM_BRIGHTNESS;\n\nvoid main() {\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n  gl_FragColor = vec4(vec3(0.0), 1.0);\n\n  #ifdef NORMAL_MODE\n    float d = depth / 500.0;\n    float yModifier = 1.4 - (gl_FragCoord.y / wHeight);\n    vec3 color = mix(color1 * yModifier, color2, d);\n    float beamFar = beamPosition + (beamWidth / 2.0);\n    float beamNear = beamPosition - (beamWidth / 2.0);\n    float beam = 0.0;\n\n    if (depth < beamFar && depth > beamNear) {\n      beam = clamp(beamBrightness - (depth / 2000.0), 0.0, 1.0);\n    }\n\n    gl_FragColor = vec4(color + vec3(beam), 1.0);\n  #endif\n\n  // draw a line at ground level\n  if (worldCoord.z < (groundPos + (lineThickness / 2.0)) && worldCoord.z > (groundPos - (lineThickness / 2.0))) {\n    vec3 color = mix(lineColor1, lineColor2, clamp(depth / midPoint, 0.0, 1.0));\n\n    gl_FragColor = vec4(color, 1.0);\n  }\n}";
                }),
                define("canyon/shaders/terrain", ["./shader", "text!./vertex/terrain.vs", "text!./fragment/terrain.fs"], function (e, t, n) {
                    var r = e.extend({
                        BEAM_SPEED: 125,
                        vertexShader: t,
                        fragmentShader: n,
                        defines: { NORMAL_MODE: "", BRIGHTNESS: "0.25", GROUND_POS: "10.0", LINE_THICKNESS: "0.3", MIDPOINT: "300.0", BEAM_WIDTH: "50.0", BEAM_BRIGHTNESS: "0.25" },
                        uniforms: {
                            color1: { type: "c", value: new THREE.Color(994137) },
                            color2: { type: "c", value: new THREE.Color(0) },
                            beamPosition: { type: "f", value: 0 },
                            wHeight: { type: "f", value: HEIGHT },
                            lineColor1: { type: "c", value: new THREE.Color(1496519) },
                            lineColor2: { type: "c", value: new THREE.Color(431223) },
                        },
                        initialize: function (t) {
                            e.prototype.initialize.call(this), t && t.beamWidth && (this.material.uniforms.beamWidth.value = t.beamWidth);
                        },
                        animateBeam: function (e) {
                            (this.material.uniforms.beamPosition.value += e * this.BEAM_SPEED), this.material.uniforms.beamPosition.value > 400 && (this.material.uniforms.beamPosition.value = 0);
                        },
                        update: function (e) {
                            this.animateBeam(e);
                        },
                    });
                    return r;
                }),
                define("text!canyon/shaders/vertex/grid.vs", [], function () {
                    return "void main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
                }),
                define("text!canyon/shaders/fragment/grid.fs", [], function () {
                    return "uniform vec3 color1;\nuniform vec3 color2;\nuniform float midpoint;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\n\nvoid main() {\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n  vec3 color = mix(color1, color2, clamp(depth / midpoint, 0.0, 1.0));\n\n  gl_FragColor = vec4(color, 1.0);\n}";
                }),
                define("canyon/shaders/grid", ["./shader", "text!./vertex/grid.vs", "text!./fragment/grid.fs"], function (e, t, n) {
                    var r = e.extend({
                        vertexShader: t,
                        fragmentShader: n,
                        uniforms: {
                            color1: { type: "c", value: new THREE.Color(1496519) },
                            color2: { type: "c", value: new THREE.Color(431223) },
                            midpoint: { type: "f", value: 300 },
                            fogColor: { type: "c", value: new THREE.Color(0) },
                            fogDensity: { type: "f", value: 25e-5 },
                            fogNear: { type: "f", value: 1 },
                            fogFar: { type: "f", value: 2e3 },
                        },
                        initialize: function (t) {
                            e.prototype.initialize.call(this), THREE.LineBasicMaterial.call(this.material), (this.material.linewidth = t.thickLines ? Math.ceil(WIDTH / 500) : 1);
                        },
                    });
                    return r;
                }),
                define("canyon/landscape", ["./objects", "./textures", "./shaders/terrain", "./shaders/grid"], function (e, t, n, r) {
                    function i(i) {
                        var o = new THREE.Object3D();
                        o.terrainShader = new n();
                        var u = o.terrainShader.material,
                            a = (this.ground = new THREE.Mesh(new THREE.PlaneGeometry(1e3, 3e3, 1, 1), u));
                        (a.name = "ground"), (a.rotation.x = -Math.PI / 2), a.position.set(0, 0, -1e3), o.add(a);
                        var f = (this.peaks = new THREE.Mesh(new THREE.PlaneGeometry(1e3, 1e3, 63, 63), u));
                        (f.name = "peaks"), (f.position.y = -10), (f.rotation.x = -Math.PI / 2), o.add(f);
                        var l = (this.peaks2 = f.clone());
                        (l.name = "peaks2"), l.position.set(0, -10, -1e3), o.add(l);
                        var c = (this.peaks2 = f.clone());
                        (c.name = "peaks3"), c.position.set(0, -10, -2e3), o.add(c);
                        var h = new r({ thickLines: i.thickLines }),
                            p = (this.groundGrid = e.createGrid({ size: 500, step: 4e3 / 63, opacity: 1, color: 3915433, material: h.material }));
                        (p.name = "groundGrid"), p.position.set(10, 0.1, 0), o.add(p);
                        var d = (this.groundGrid2 = p.clone());
                        (d.name = "groundGrid2"), d.position.set(10, 0.1, -1e3), o.add(d);
                        var v = (this.groundGrid3 = p.clone());
                        v.position.set(10, 0.1, -2e3), (v.name = "groundGrid3"), o.add(v);
                        var m = t.get("terrain").image,
                            g = document.createElement("canvas");
                        (g.width = 64), (g.height = 64);
                        var y = g.getContext("2d");
                        y.drawImage(m, 0, 0, g.width, g.height);
                        var b = y.getImageData(0, 0, g.width, g.height),
                            w = [];
                        for (var E = 0; E < b.height; E++) for (var S = 0; S < b.width; S++) w.push(s(b, S, E));
                        var x = 250;
                        _.each(f.geometry.vertices, function (e, t) {
                            e.z = (w[t] / 255) * x;
                        }),
                            (f.geometry.dynamic = !0),
                            (f.geometry.verticesNeedUpdate = !0),
                            f.geometry.computeFaceNormals(),
                            (f.geometry.normalsNeedUpdate = !0);
                        var T = e.createPlaneGrid({ plane: f, material: h.material });
                        return (
                            (T.position.y = -0.25),
                                (T.position.z = 0.15),
                                f.add(T),
                                _.each(f.children, function (e) {
                                    l.add(e.clone());
                                }),
                                _.each(f.children, function (e) {
                                    c.add(e.clone());
                                }),
                                o
                        );
                    }
                    function s(e, t, n) {
                        var r = (n * e.width + t) * 4;
                        return e.data[r];
                    }
                    return i;
                }),
                define("text!canyon/shaders/vertex/basic.vs", [], function () {
                    return "varying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
                }),
                define("text!canyon/shaders/fragment/sky.fs", [], function () {
                    return "varying vec2 vUv;\n\nvec3 color = vec3(0.0);\n\nuniform float aspect;\n\n// Gradient\nuniform float midpoint;\nuniform vec3 color1;\nuniform vec3 color2;\n\n// Lines\nuniform float offset;\nuniform float offsetY;\nuniform float screenHeight;\n\n// Circles\nconst int MAX_CIRCLES = 20;\nuniform vec2 centers[MAX_CIRCLES];\nuniform float radii[MAX_CIRCLES];\nuniform vec3 colors[MAX_CIRCLES];\nuniform int alive[MAX_CIRCLES];\nuniform vec2 circleOffset;\n\nvoid drawGradient() {\n  float bottom = midpoint - 0.1;\n  float top = midpoint + 0.15;\n\n  if (vUv.y < bottom) {\n    color = color1;\n  } else if (vUv.y > top) {\n    color = color2;\n  } else {\n    float height = top - bottom;\n    color = mix(color1, color2, (vUv.y - bottom) / height);\n  }\n}\n\nvoid drawLines() {\n  const float spread = 35.0;\n  const float maxThickness = 15.0;\n  const float minThickness = 4.0;\n  const float darkenFactor = 1.4;\n\n  float y = 1.0 - vUv.y + offsetY;\n  float lineHeight = max(maxThickness * y, minThickness);\n\n  if (mod(gl_FragCoord.y + offset - (offsetY * screenHeight), spread) < lineHeight) {\n    color -= color * (y - offsetY) * darkenFactor;\n  }\n}\n\nvoid drawCircles() {\n  float border = 0.001; // border smoothing length\n\n  for (int i = 0; i < MAX_CIRCLES; i++) {\n\n    if (alive[i] == 0) {\n      continue;\n    }\n\n    float r = radii[i]; // circle radius\n    vec3 c = colors[i]; // circle color\n    vec2 uv = vec2(vUv.x * aspect, vUv.y);\n    vec2 center = vec2(centers[i].x * aspect, centers[i].y) + circleOffset;\n    float dc = distance(uv, center); // distance from circle center\n    float db = r - dc; // distance from border\n\n    if (dc < r + border) {\n      if (db > border) {\n        color = c;\n      } else {\n        float t = 0.0;\n        t = clamp(db / border, 0.0, 1.0); // smooth border\n        color = mix(color, c, t);\n      }\n    }\n  }\n}\n\nvoid main() {\n  drawGradient();\n  drawLines();\n  drawCircles();\n\n  gl_FragColor = vec4(color, 1.0);\n}";
                }),
                (function (e) {
                    var t = (function () {
                        "use strict";
                        function t(e, t) {
                            var n;
                            for (n in e) Object.hasOwnProperty.call(e, n) && t(n);
                        }
                        function n(e, n) {
                            return (
                                t(n, function (t) {
                                    e[t] = n[t];
                                }),
                                    e
                            );
                        }
                        function r(e, n) {
                            return (
                                t(n, function (t) {
                                    e[t] === void 0 && (e[t] = n[t]);
                                }),
                                    e
                            );
                        }
                        function i(e, t, n, r, i, o, u) {
                            var a,
                                f = (e - o) / i;
                            for (a in t) t.hasOwnProperty(a) && r.hasOwnProperty(a) && (t[a] = s(n[a], r[a], p[u[a]], f));
                            return t;
                        }
                        function s(e, t, n, r) {
                            return e + (t - e) * n(r);
                        }
                        function o(e, n, r) {
                            var i = f.prototype.filter;
                            t(i, function (t) {
                                i[t][n] && i[t][n].apply(e, r);
                            });
                        }
                        function u(e, t, n, r, s, a, f, l) {
                            var c = t + n,
                                p = Math.min(h(), c),
                                d = p >= c;
                            e._isTweening &&
                            (d ||
                            (e._loopId = setTimeout(function () {
                                u(e, t, n, r, s, a, f, l);
                            }, 1e3 / e.fps)),
                                o(e, "beforeTween", [r, s, a, f]),
                                i(p, r, s, a, n, t, f),
                                o(e, "afterTween", [r, s, a, f]),
                            l && l(r)),
                            (d || !e._isTweening) && e.stop(!0);
                        }
                        function a(e, n) {
                            var r = {};
                            return (
                                "string" == typeof n
                                    ? t(e, function (e) {
                                        r[e] = n;
                                    })
                                    : t(e, function (e) {
                                        r[e] || (r[e] = n[e] || l);
                                    }),
                                    r
                            );
                        }
                        function f(e) {
                            var t = e || {};
                            return (this.data = {}), (this.fps = t.fps || 60), (this._currentState = t.initialState || {}), this;
                        }
                        var l = "linear",
                            c = 500,
                            h = function () {
                                return +new Date();
                            };
                        (f.prototype.tween = function (e) {
                            if (!this._isTweening) {
                                (this._loopId = 0),
                                    (this._pausedAtTime = null),
                                    (this._step = e.step),
                                    (this._callback = e.callback),
                                    (this._targetState = e.to || {}),
                                    (this._duration = e.duration || c),
                                    (this._currentState = e.from || this.get()),
                                    (this._timestamp = h());
                                var t = this._currentState,
                                    i = this._targetState;
                                r(t, i), r(i, t), (this._easing = a(t, e.easing || l));
                                var s = (this._originalState = n({}, t));
                                return o(this, "tweenCreated", [t, s, i, this._easing]), this.resume();
                            }
                        }),
                            (f.prototype.get = function () {
                                return n({}, this._currentState);
                            }),
                            (f.prototype.set = function (e) {
                                this._currentState = e;
                            }),
                            (f.prototype.stop = function (e) {
                                return (
                                    clearTimeout(this._loopId),
                                        (this._isTweening = !1),
                                        (this._isPaused = !1),
                                    e &&
                                    (n(this._currentState, this._targetState),
                                        o(this, "afterTweenEnd", [this._currentState, this._originalState, this._targetState, this._easing]),
                                    this._callback && this._callback.call(this._currentState, this._currentState)),
                                        this
                                );
                            }),
                            (f.prototype.pause = function () {
                                return clearTimeout(this._loopId), (this._pausedAtTime = h()), (this._isPaused = !0), this;
                            }),
                            (f.prototype.resume = function () {
                                return (
                                    this._isPaused && (this._timestamp += h() - this._pausedAtTime),
                                        (this._isPaused = !1),
                                        (this._isTweening = !0),
                                        u(this, this._timestamp, this._duration, this._currentState, this._originalState, this._targetState, this._easing, this._step),
                                        this
                                );
                            }),
                            (f.prototype.isPlaying = function () {
                                return this._isTweening && !this._isPaused;
                            }),
                            (f.prototype.filter = {}),
                            n(f, { now: h, each: t, tweenProps: i, tweenProp: s, applyFilter: o, shallowCopy: n, defaults: r, composeEasingObject: a }),
                            (f.prototype.formula = {
                                linear: function (e) {
                                    return e;
                                },
                            });
                        var p = f.prototype.formula;
                        return (
                            "object" == typeof exports
                                ? (module.exports = f)
                                : "function" == typeof define && define.amd
                                ? define("shifty", [], function () {
                                    return f;
                                })
                                : e.Tweenable === void 0 && (e.Tweenable = f),
                                f
                        );
                    })();
                    (function () {
                        t.shallowCopy(t.prototype.formula, {
                            easeInQuad: function (e) {
                                return Math.pow(e, 2);
                            },
                            easeOutQuad: function (e) {
                                return -(Math.pow(e - 1, 2) - 1);
                            },
                            easeInOutQuad: function (e) {
                                return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 2) : -0.5 * ((e -= 2) * e - 2);
                            },
                            easeInCubic: function (e) {
                                return Math.pow(e, 3);
                            },
                            easeOutCubic: function (e) {
                                return Math.pow(e - 1, 3) + 1;
                            },
                            easeInOutCubic: function (e) {
                                return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 3) : 0.5 * (Math.pow(e - 2, 3) + 2);
                            },
                            easeInQuart: function (e) {
                                return Math.pow(e, 4);
                            },
                            easeOutQuart: function (e) {
                                return -(Math.pow(e - 1, 4) - 1);
                            },
                            easeInOutQuart: function (e) {
                                return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 4) : -0.5 * ((e -= 2) * Math.pow(e, 3) - 2);
                            },
                            easeInQuint: function (e) {
                                return Math.pow(e, 5);
                            },
                            easeOutQuint: function (e) {
                                return Math.pow(e - 1, 5) + 1;
                            },
                            easeInOutQuint: function (e) {
                                return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 5) : 0.5 * (Math.pow(e - 2, 5) + 2);
                            },
                            easeInSine: function (e) {
                                return -Math.cos(e * (Math.PI / 2)) + 1;
                            },
                            easeOutSine: function (e) {
                                return Math.sin(e * (Math.PI / 2));
                            },
                            easeInOutSine: function (e) {
                                return -0.5 * (Math.cos(Math.PI * e) - 1);
                            },
                            easeInExpo: function (e) {
                                return 0 === e ? 0 : Math.pow(2, 10 * (e - 1));
                            },
                            easeOutExpo: function (e) {
                                return 1 === e ? 1 : -Math.pow(2, -10 * e) + 1;
                            },
                            easeInOutExpo: function (e) {
                                return 0 === e ? 0 : 1 === e ? 1 : 1 > (e /= 0.5) ? 0.5 * Math.pow(2, 10 * (e - 1)) : 0.5 * (-Math.pow(2, -10 * --e) + 2);
                            },
                            easeInCirc: function (e) {
                                return -(Math.sqrt(1 - e * e) - 1);
                            },
                            easeOutCirc: function (e) {
                                return Math.sqrt(1 - Math.pow(e - 1, 2));
                            },
                            easeInOutCirc: function (e) {
                                return 1 > (e /= 0.5) ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
                            },
                            easeOutBounce: function (e) {
                                return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
                            },
                            easeInBack: function (e) {
                                var t = 1.70158;
                                return e * e * ((t + 1) * e - t);
                            },
                            easeOutBack: function (e) {
                                var t = 1.70158;
                                return (e -= 1) * e * ((t + 1) * e + t) + 1;
                            },
                            easeInOutBack: function (e) {
                                var t = 1.70158;
                                return 1 > (e /= 0.5) ? 0.5 * e * e * (((t *= 1.525) + 1) * e - t) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
                            },
                            elastic: function (e) {
                                return -1 * Math.pow(4, -8 * e) * Math.sin(((6 * e - 1) * 2 * Math.PI) / 2) + 1;
                            },
                            swingFromTo: function (e) {
                                var t = 1.70158;
                                return 1 > (e /= 0.5) ? 0.5 * e * e * (((t *= 1.525) + 1) * e - t) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
                            },
                            swingFrom: function (e) {
                                var t = 1.70158;
                                return e * e * ((t + 1) * e - t);
                            },
                            swingTo: function (e) {
                                var t = 1.70158;
                                return (e -= 1) * e * ((t + 1) * e + t) + 1;
                            },
                            bounce: function (e) {
                                return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
                            },
                            bouncePast: function (e) {
                                return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 2 - (7.5625 * (e -= 1.5 / 2.75) * e + 0.75) : 2.5 / 2.75 > e ? 2 - (7.5625 * (e -= 2.25 / 2.75) * e + 0.9375) : 2 - (7.5625 * (e -= 2.625 / 2.75) * e + 0.984375);
                            },
                            easeFromTo: function (e) {
                                return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 4) : -0.5 * ((e -= 2) * Math.pow(e, 3) - 2);
                            },
                            easeFrom: function (e) {
                                return Math.pow(e, 4);
                            },
                            easeTo: function (e) {
                                return Math.pow(e, 0.25);
                            },
                        });
                    })(),
                        (function () {
                            function e(e, r, i, s, o) {
                                return t.tweenProps(s, r, e, i, 1, 0, o);
                            }
                            (t.interpolate = function (r, i, s, o) {
                                var u, a, f;
                                r && r.from && ((i = r.to), (s = r.position), (o = r.easing), (r = r.from)), (f = new t()), (f.easing = o || "linear"), (u = t.shallowCopy({}, r));
                                var l = t.composeEasingObject(r, f.easing);
                                return t.applyFilter(f, "tweenCreated", [u, r, i, l]), t.applyFilter(f, "beforeTween", [u, r, i, l]), (a = e(r, u, i, s, l)), t.applyFilter(f, "afterTween", [a, r, i, l]), a;
                            }),
                                (t.prototype.interpolate = function (e, r, i) {
                                    var s;
                                    return (s = t.interpolate(this.get(), e, r, i)), this.set(s), s;
                                });
                        })(),
                        (function (e) {
                            function t(e, t) {
                                var n,
                                    r = e.length,
                                    i = [];
                                for (n = 0; r > n; n++) i.push("_" + t + "_" + n);
                                return i;
                            }
                            function n(e) {
                                var t = e.match(w);
                                return 1 === t.length && t.unshift(""), t.join(N);
                            }
                            function r(t) {
                                e.each(t, function (e) {
                                    var n = t[e];
                                    "string" == typeof n && n.match(T) && (t[e] = i(n));
                                });
                            }
                            function i(e) {
                                return a(T, e, s);
                            }
                            function s(e) {
                                var t = o(e);
                                return "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")";
                            }
                            function o(e) {
                                return (e = e.replace(/#/, "")), 3 === e.length && ((e = e.split("")), (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2])), [u(e.substr(0, 2)), u(e.substr(2, 2)), u(e.substr(4, 2))];
                            }
                            function u(e) {
                                return parseInt(e, 16);
                            }
                            function a(e, t, n) {
                                var r = t.match(e),
                                    i = t.replace(e, N);
                                if (r) for (var s, o = r.length, u = 0; o > u; u++) (s = r.shift()), (i = i.replace(N, n(s)));
                                return i;
                            }
                            function f(e) {
                                return a(S, e, l);
                            }
                            function l(e) {
                                for (var t = e.match(E), n = t.length, r = e.match(x)[0], i = 0; n > i; i++) r += parseInt(t[i], 10) + ",";
                                return (r = r.slice(0, -1) + ")");
                            }
                            function c(r) {
                                var i = {};
                                return (
                                    e.each(r, function (e) {
                                        var s = r[e];
                                        if ("string" == typeof s) {
                                            var o = g(s);
                                            i[e] = { formatString: n(s), chunkNames: t(o, e) };
                                        }
                                    }),
                                        i
                                );
                            }
                            function h(t, n) {
                                e.each(n, function (e) {
                                    for (var r = t[e], i = g(r), s = i.length, o = 0; s > o; o++) t[n[e].chunkNames[o]] = +i[o];
                                    delete t[e];
                                });
                            }
                            function p(t, n) {
                                e.each(n, function (e) {
                                    var r = t[e],
                                        i = d(t, n[e].chunkNames),
                                        s = v(i, n[e].chunkNames);
                                    (r = m(n[e].formatString, s)), (t[e] = f(r));
                                });
                            }
                            function d(e, t) {
                                for (var n, r = {}, i = t.length, s = 0; i > s; s++) (n = t[s]), (r[n] = e[n]), delete e[n];
                                return r;
                            }
                            function v(e, t) {
                                for (var n = [], r = t.length, i = 0; r > i; i++) n.push(e[t[i]]);
                                return n;
                            }
                            function m(e, t) {
                                for (var n = e, r = t.length, i = 0; r > i; i++) n = n.replace(N, +t[i].toFixed(4));
                                return n;
                            }
                            function g(e) {
                                return e.match(E);
                            }
                            function y(t, n) {
                                e.each(n, function (e) {
                                    for (var r = n[e], i = r.chunkNames, s = i.length, o = t[e].split(" "), u = o[o.length - 1], a = 0; s > a; a++) t[i[a]] = o[a] || u;
                                    delete t[e];
                                });
                            }
                            function b(t, n) {
                                e.each(n, function (e) {
                                    for (var r = n[e], i = r.chunkNames, s = i.length, o = "", u = 0; s > u; u++) (o += " " + t[i[u]]), delete t[i[u]];
                                    (o = o.substr(1)), (t[e] = o);
                                });
                            }
                            var w = /([^\-0-9\.]+)/g,
                                E = /[0-9.\-]+/g,
                                S = RegExp("rgb\\(" + E.source + /,\s*/.source + E.source + /,\s*/.source + E.source + "\\)", "g"),
                                x = /^.*\(/,
                                T = /#([0-9]|[a-f]){3,6}/g,
                                N = "VAL";
                            e.prototype.filter.token = {
                                tweenCreated: function (e, t, n) {
                                    r(e), r(t), r(n), (this._tokenData = c(e));
                                },
                                beforeTween: function (e, t, n, r) {
                                    y(r, this._tokenData), h(e, this._tokenData), h(t, this._tokenData), h(n, this._tokenData);
                                },
                                afterTween: function (e, t, n, r) {
                                    p(e, this._tokenData), p(t, this._tokenData), p(n, this._tokenData), b(r, this._tokenData);
                                },
                            };
                        })(t);
                })(this),
                define("tween", ["class", "shifty"], function (e, t) {
                    var n = e.extend({
                        initialize: function (e) {
                            (this.from = e.from), (this.to = e.to), (this.duration = e.duration / 1e3), (this.easing = e.easing), (this.step = e.step), (this.callback = e.callback), (this.elapsedTime = 0), (this.alive = !0);
                        },
                        update: function (e) {
                            if (!this.alive) return;
                            (this.elapsedTime += e), this.step && this.step(t.interpolate(this.from, this.to, this.elapsedTime / this.duration, this.easing)), this.elapsedTime > this.duration && (this.stop(), this.callback && this.callback());
                        },
                        stop: function () {
                            (this.elapsedTime = 0), (this.alive = !1);
                        },
                        start: function () {
                            this.alive = !0;
                        },
                    });
                    return n;
                }),
                define("canyon/shaders/sky", ["./shader", "text!./vertex/basic.vs", "text!./fragment/sky.fs", "../../tween"], function (e, t, n, r) {
                    function s() {
                        var e = [
                            { color: new THREE.Color(60139), radius: 0.25 * THREE.Math.randFloat(0.5, 1), speedFactor: 0.7, lifespan: 3 },
                            { color: new THREE.Color(60139), radius: 0.06, speedFactor: 0.9, lifespan: 1.1 },
                            { color: new THREE.Color(8267233), radius: 0.1, speedFactor: 0.8, lifespan: 0.6 },
                            { color: new THREE.Color(12193781), radius: 0.12, speedFactor: 0.6, lifespan: 1.8 },
                        ];
                        return e[THREE.Math.randInt(0, e.length - 1)];
                    }
                    var i = e.extend({
                        LINES_SPEED: 120,
                        MAX_CIRCLES: 20,
                        CIRCLE_SPAWN_DELAY: 0.17,
                        CIRCLE_SPEED_X: 0.05,
                        CIRCLE_SPEED_Y: 0.5,
                        vertexShader: t,
                        fragmentShader: n,
                        uniforms: {
                            aspect: { type: "f", value: WIDTH / HEIGHT },
                            midpoint: { type: "f", value: 0.7 },
                            color1: { type: "c", value: new THREE.Color(16758630) },
                            color2: { type: "c", value: new THREE.Color(14490108) },
                            offset: { type: "f", value: 0 },
                            offsetY: { type: "f", value: 0 },
                            screenHeight: { type: "f", value: HEIGHT },
                            centers: { type: "v2v", value: [] },
                            colors: { type: "v3v", value: [] },
                            radii: { type: "fv1", value: [] },
                            alive: { type: "iv1", value: [] },
                            circleOffset: { type: "v2", value: new THREE.Vector2(0, 0) },
                        },
                        initialize: function (t) {
                            e.prototype.initialize.call(this),
                            t && t.height && (this.material.uniforms.height.value = t.height),
                                (this.circles = []),
                                _.times(
                                    this.MAX_CIRCLES,
                                    _.bind(function () {
                                        this.circles.push({ alive: !1, position: new THREE.Vector2(0, 0), color: new THREE.Color(0), direction: Math.random() > 0.5 ? 1 : -1, radius: 0 });
                                    }, this)
                                ),
                                (this.lastSpawnTime = 0),
                                (this.material.depthWrite = !1);
                        },
                        update: function (e, t) {
                            this.animateLines(t), this.animateCircles(e, t), this.updateGradient();
                        },
                        updateGradient: function () {
                            var e = this.material.uniforms.midpoint.value,
                                t = 0.7 + mouseY * 0.25;
                            this.material.uniforms.midpoint.value = THREE.Math.lerp(e, t, 0.1);
                        },
                        animateLines: function (e) {
                            var t = this.material.uniforms.offsetY.value,
                                n = mouseY * 0.25;
                            (this.material.uniforms.offsetY.value = THREE.Math.lerp(t, n, 0.1)), (this.material.uniforms.offset.value -= e * this.LINES_SPEED);
                        },
                        spawnCircle: function (e) {
                            var t = _.find(this.circles, function (e) {
                                return !e.alive;
                            });
                            t && ((t.alive = !0), (t = _.extend(t, s())), (t.position = new THREE.Vector2(THREE.Math.randFloat(0.1, 0.9), 0.3 - t.radius)), (t.speedFactor *= THREE.Math.randFloat(0.5, 1.4)), (t.spawnTime = e)), (this.lastSpawnTime = e);
                        },
                        killCircles: function (e, t) {
                            var n = 0.6;
                            _.each(this.circles, function (i) {
                                i.alive &&
                                !i.death &&
                                e - i.spawnTime > i.lifespan - n &&
                                (i.death = new r({
                                    from: { radius: i.radius },
                                    to: { radius: 0 },
                                    duration: n * 1e3,
                                    easing: "easeInQuad",
                                    step: function (e) {
                                        i.radius = e.radius;
                                    },
                                    callback: function () {
                                        (i.alive = !1), (i.death = null);
                                    },
                                })),
                                i.death && i.death.update(t);
                            });
                        },
                        animateCircles: function (e, t) {
                            e - this.lastSpawnTime > this.CIRCLE_SPAWN_DELAY && this.spawnCircle(e),
                                this.killCircles(e, t),
                                _.each(
                                    this.circles,
                                    _.bind(function (e) {
                                        THREE.Math.randFloat(0, 1) > 0.995 && (e.direction = -e.direction),
                                            (e.position.x += e.direction * THREE.Math.randFloat(0.6, 1.3) * this.CIRCLE_SPEED_X * t),
                                            (e.position.y += t * e.speedFactor * this.CIRCLE_SPEED_Y);
                                    }, this)
                                ),
                                this.updateCircleUniforms(),
                                this.updateCircleOffset();
                        },
                        updateCircleOffset: function () {
                            var e = new THREE.Vector2(-mouseX * 0.5, mouseY * 0.25);
                            this.material.uniforms.circleOffset.value.lerp(e, 0.1);
                        },
                        updateCircleUniforms: function () {
                            (this.material.uniforms.alive.value = _.map(this.circles, function (e) {
                                return e.alive ? 1 : 0;
                            })),
                                (this.material.uniforms.colors.value = _.map(this.circles, function (e) {
                                    return new THREE.Vector3(e.color.r, e.color.g, e.color.b);
                                })),
                                (this.material.uniforms.radii.value = _.pluck(this.circles, "radius")),
                                (this.material.uniforms.centers.value = _.pluck(this.circles, "position"));
                        },
                    });
                    return i;
                }),
                define("text!canyon/shaders/fragment/bubble.fs", [], function () {
                    return "varying vec2 vUv;\n\nconst int RING_PHASE = 0;\nconst int CROSS_PHASE = 1;\n\nuniform int phase;\nuniform float r1;\nuniform float r2;\nuniform vec3 color;\nuniform vec2 center;\nuniform float opacity;\nuniform float strokeWidth;\nuniform float crossLength;\nuniform float crossDecay;\n\nvec3 col = vec3(0.0);\nfloat alpha = 1.0;\n\nvoid drawRing() {\n  float border = 0.0001; // border smoothing length\n\n  vec3 c = color; // circle color\n  float dc = distance(vUv.xy, center); // distance from circle center\n  float db = r1 - dc; // distance from border\n  float t = 0.0;\n\n  if (dc < r1 + border) {\n    if (db > border) {\n      t = 1.0; // normal circle color\n    } else {\n      t = clamp(db / border, 0.0, 1.0); // smooth border\n    }\n    col = mix(color, c, t);\n  } else {\n    t = clamp(db / border, 0.0, 1.0); // smooth border\n    alpha = mix(0.0, 1.0, t);\n  }\n\n  if (dc < (r1 - (r1 - r2))) {\n    alpha = 0.0;\n  }\n}\n\nvoid drawCross() {\n  float thickness = strokeWidth / 2.0;\n  float dc = distance(vUv.xy, center);\n\n  alpha = 0.0;\n\n  if (vUv.x < (vUv.y + thickness) && vUv.x > (vUv.y - thickness)) {\n    col = vec3(1.0, 1.0, 1.0);\n    alpha = 1.0;\n  }\n\n  if (vUv.y > ((1.0 - vUv.x) - thickness) && vUv.y < ((1.0 - vUv.x) + thickness)) {\n    col = vec3(1.0, 1.0, 1.0);\n    alpha = 1.0;\n  }\n\n  if (dc < crossDecay || dc > crossLength) {\n    alpha = 0.0;\n  }\n}\n\nvoid main() {\n  if (phase == RING_PHASE) {\n    drawRing();\n  }\n\n  if (phase == CROSS_PHASE) {\n    drawCross();\n  }\n\n  gl_FragColor = vec4(col, alpha * opacity);\n}";
                }),
                define("canyon/shaders/bubble", ["./shader", "text!./vertex/basic.vs", "text!./fragment/bubble.fs", "../../tween"], function (e, t, n, r) {
                    var i = e.extend({
                        RING_SPEED: 0.05,
                        vertexShader: t,
                        fragmentShader: n,
                        uniforms: {
                            phase: { type: "i", value: 1 },
                            r1: { type: "f", value: 0 },
                            r2: { type: "f", value: 0 },
                            center: { type: "v2", value: new THREE.Vector2(0.5, 0.5) },
                            color: { type: "c", value: new THREE.Color(13172730) },
                            opacity: { type: "f", value: 1 },
                            strokeWidth: { type: "f", value: 0.05 },
                            crossLength: { type: "f", value: 0 },
                            crossDecay: { type: "f", value: 0 },
                        },
                        initialize: function (t) {
                            e.prototype.initialize.call(this), (this.material.transparent = !0), (this.alive = !1);
                        },
                        growRing: function () {
                            var e = this.material.uniforms.r1,
                                t = this.material.uniforms.r2,
                                n = 1e3;
                            (this.alive = !0),
                                (this.material.uniforms.phase.value = 0),
                                (this.material.uniforms.opacity.value = 1),
                                (this.radius1 = new r({
                                    from: { radius: 0 },
                                    to: { radius: 0.5 },
                                    duration: n,
                                    easing: "easeInQuad",
                                    step: function (t) {
                                        e.value = t.radius;
                                    },
                                    callback: _.bind(function () {
                                        this.radius1 = null;
                                    }, this),
                                })),
                                (this.radius2 = new r({
                                    from: { radius: 0 },
                                    to: { radius: 0.45 },
                                    duration: n * 1.1,
                                    easing: "easeInQuad",
                                    step: function (e) {
                                        t.value = e.radius;
                                    },
                                    callback: _.bind(function () {
                                        (this.radius2 = null), this.shrinkRing();
                                    }, this),
                                }));
                        },
                        shrinkRing: function () {
                            var e = this.material.uniforms.r1,
                                t = this.material.uniforms.r2,
                                n = this.material.uniforms.opacity,
                                i = 800;
                            (this.radius1 = new r({
                                from: { radius: 0.5, opacity: n.value },
                                to: { radius: 0, opacity: 0 },
                                duration: i,
                                easing: "easeOutQuart",
                                step: function (t) {
                                    (e.value = t.radius), (n.value = t.opacity);
                                },
                                callback: _.bind(function () {
                                    this.radius1 = null;
                                }, this),
                            })),
                                (this.radius2 = new r({
                                    from: { radius: 0.45 },
                                    to: { radius: 0 },
                                    duration: i,
                                    easing: "easeOutQuart",
                                    step: function (e) {
                                        t.value = e.radius;
                                    },
                                    callback: _.bind(function () {
                                        (this.radius2 = null), this.drawCross();
                                    }, this),
                                }));
                        },
                        drawCross: function () {
                            var e = this.material.uniforms.crossLength,
                                t = this.material.uniforms.crossDecay,
                                n = 250;
                            (this.material.uniforms.phase.value = 1),
                                (this.material.uniforms.opacity.value = 1),
                                (this.draw = new r({
                                    from: { value: 0 },
                                    to: { value: 0.5 },
                                    duration: n,
                                    easing: "linear",
                                    step: function (t) {
                                        e.value = t.value;
                                    },
                                    callback: _.bind(function () {
                                        this.draw = null;
                                    }, this),
                                })),
                                (this.erase = new r({
                                    from: { value: 0 },
                                    to: { value: 0.5 },
                                    duration: n * 2,
                                    easing: "linear",
                                    step: function (e) {
                                        t.value = e.value;
                                    },
                                    callback: _.bind(function () {
                                        (this.alive = !1), (this.erase = null), this.growRing();
                                    }, this),
                                }));
                        },
                        update: function (e, t) {
                            t < 300 && !this.alive && this.growRing(), this.radius1 && this.radius1.update(e), this.radius2 && this.radius2.update(e), this.draw && this.draw.update(e), this.erase && this.erase.update(e);
                        },
                    });
                    return i;
                }),
                define("canyon/canyon", ["../world", "./objects", "./textures", "./landscape", "./shaders/sky", "./shaders/bubble"], function (e, t, n, r, i, s) {
                    function u() {
                        var e = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
                        return new THREE.WebGLRenderTarget(WIDTH, HEIGHT, e);
                    }
                    var o = e.extend({
                        initialize: function (n) {
                            function y(e, t) {
                                var n = p.getObjectByName(e, !0),
                                    r = n.clone();
                                return t && (r.material = t), m.add(r), r;
                            }
                            e.prototype.initialize.call(this),
                                (this.thickLines = n.thickLines),
                                (this.CAMERA_SPEED = 150),
                                (this.BOUNDARIES = { x: WIDTH / 10, y: HEIGHT / 10 }),
                                this.camera.position.set(10, 10, 500),
                                (this.camera.target = new THREE.Vector3(this.scene.position.x, this.scene.position.y + 80, this.scene.position.z)),
                                this.camera.lookAt(this.camera.target);
                            var o = (this.glowCamera = this.camera.clone()),
                                u = new THREE.DirectionalLight(16777215, 1);
                            u.position.set(-500, 250, 250), u.target.position.set(0, 0, 0), this.scene.add(u), this.lights.push(u);
                            var a = WIDTH * 4,
                                f = HEIGHT * 4,
                                l = (this.skyShader = new i()),
                                c = (this.sky = new THREE.Mesh(new THREE.PlaneGeometry(a, f, 1, 1), l.material)),
                                h = f / 2 / Math.tan(THREE.Math.degToRad(this.camera.fov / 2));
                            (this.sky.width = a), (this.sky.height = f), this.sky.scale.set(1, 1, 1), c.position.set(0, 0, -h), this.camera.add(c);
                            var p = (this.landscape = r({ thickLines: this.thickLines }));
                            this.scene.add(p), this.initBlackParticles();
                            var d = 6,
                                v = (this.bubbles = new THREE.Object3D());
                            _.times(d, function () {
                                var e = t.createCross({ color: 13172215 }),
                                    n = new s();
                                (e.shader = n), (e.material = e.shader.material), (e.position.x = Math.random() * 150 - 75), (e.position.y = Math.random() * 45 + 5), (e.position.z = -(Math.random() * 1e3)), v.add(e);
                            }),
                                this.cameraContainer.add(v);
                            var m = (this.glowScene = new THREE.Scene());
                            m.add(o);
                            var g = p.getObjectByName("ground", !0).material.clone();
                            (g.defines = _.clone(g.defines)), delete g.defines.NORMAL_MODE, y("ground", g), y("peaks", g), y("peaks2", g), y("peaks3", g), y("groundGrid"), y("groundGrid2"), y("groundGrid3");
                            var b = this.thickLines ? 10 : 1,
                                w = new THREE.LineBasicMaterial({ color: 4107660, linewidth: b, opacity: 0.5, transparent: !0 });
                            (this.glowScene.getObjectByName("groundGrid").material = w),
                                (this.glowScene.getObjectByName("groundGrid2").material = w),
                                (this.glowScene.getObjectByName("groundGrid3").material = w),
                                (this.glowScene.getObjectByName("peaks").children[0].material = w),
                                (this.glowScene.getObjectByName("peaks2").children[0].material = w),
                                (this.glowScene.getObjectByName("peaks3").children[0].material = w);
                        },
                        setupDatGUI: function (e) {
                            var t = e.addFolder("Light position"),
                                n = this.lights[0];
                            t.add(n.position, "x"), t.add(n.position, "y"), t.add(n.position, "z"), t.open();
                        },
                        setupCompositing: function (e, t) {
                            var n = new THREE.RenderPass(this.glowScene, this.glowCamera),
                                r = new THREE.ShaderPass(THREE.HorizontalBlurShader),
                                i = new THREE.ShaderPass(THREE.VerticalBlurShader),
                                s = 3;
                            if (!this.thickLines) {
                                var o = new THREE.ShaderPass(THREE.StrokeShader),
                                    a = new THREE.SavePass(u()),
                                    f = new THREE.ShaderPass(THREE.BlendShader);
                                (f.uniforms.tDiffuse2.value = a.renderTarget),
                                    (o.uniforms.h.value = 1 / WIDTH),
                                    (o.uniforms.cells.value = [
                                        new THREE.Vector2(0, 0),
                                        new THREE.Vector2(1, 1),
                                        new THREE.Vector2(0, 1),
                                        new THREE.Vector2(-1, 1),
                                        new THREE.Vector2(-1, 0),
                                        new THREE.Vector2(-1, -1),
                                        new THREE.Vector2(0, -1),
                                        new THREE.Vector2(1, -1),
                                    ]);
                            }
                            (r.uniforms.h.value = s / WIDTH), (i.uniforms.v.value = s / HEIGHT), e.addPass(n), this.thickLines || (e.addPass(o), e.addPass(a)), e.addPass(r), e.addPass(i), this.thickLines || e.addPass(f);
                            var l = new THREE.ShaderPass(THREE.AdditiveBlendShader, "tDiffuse1");
                            l.uniforms.tDiffuse2.value = e.renderTarget2;
                            var c = new THREE.RenderPass(this.scene, this.camera),
                                h = new THREE.ShaderPass(THREE.FXAAShader);
                            (h.uniforms.resolution.value = new THREE.Vector2(DENSITY / WIDTH, DENSITY / HEIGHT)), (h.renderToScreen = !0);
                            var p = (this.finalComposer = new THREE.EffectComposer(t, u()));
                            p.addPass(c), p.addPass(l), p.addPass(h);
                        },
                        initBlackParticles: function () {
                            var e = n.get("blackcircle"),
                                t = new THREE.Geometry(),
                                r = 100;
                            for (var i = 0; i < r; i++) {
                                var s = new THREE.Vector3();
                                (s.x = Math.random() * 150 - 75), (s.y = Math.random() * 40), (s.z = Math.random() * -1e3), (s.speed = Math.random() * 500 + 100), t.vertices.push(s);
                            }
                            var o = new THREE.ParticleBasicMaterial({ size: 2, map: e, transparent: !0, sizeAttenuation: !0, depthWrite: !1 }),
                                u = (this.blackParticles = new THREE.ParticleSystem(t, o));
                            this.cameraContainer.add(u), this.glowCamera.add(u.clone());
                        },
                        animateBlackParticles: function (e) {
                            _.each(this.blackParticles.geometry.vertices, function (t, n) {
                                (t.z += t.speed * e), t.z > 1e3 && (t.z = -1e3);
                            }),
                                (this.blackParticles.geometry.verticesNeedUpdate = !0);
                        },
                        resize: function (e, t) {
                            var n = (e * 4 - this.sky.width) / this.sky.width,
                                r = (t * 4 - this.sky.height) / this.sky.height,
                                i = (t * 4) / 2 / Math.tan(THREE.Math.degToRad(this.camera.fov / 2));
                            this.sky.position.set(0, 0, -i), this.sky.scale.setX(1 + n), this.sky.scale.setY(1 + r), (this.sky.material.uniforms.aspect.value = e / t);
                        },
                        updateBubbles: function (e) {
                            _.each(
                                this.bubbles.children,
                                function (t) {
                                    (t.position.z += e * this.CAMERA_SPEED), t.position.z > 1e3 && (t.position.z = 0);
                                },
                                this
                            );
                        },
                        updateCamera: function () {
                            var e = this.BOUNDARIES.x * mouseX,
                                t = this.BOUNDARIES.y * -mouseY + 80,
                                n = new THREE.Vector3(this.camera.position.x + e, this.scene.position.y + t, this.scene.position.z);
                            this.camera.lookAt(this.camera.target.lerp(n, 0.1)), this.glowCamera.rotation.copy(this.camera.rotation);
                        },
                        update: function (e, t) {
                            (this.cameraContainer.position.z -= t * this.CAMERA_SPEED),
                            this.cameraContainer.position.z < -1e3 && (this.cameraContainer.position.z = 0),
                                (this.glowCamera.position.z -= t * this.CAMERA_SPEED),
                            this.glowCamera.position.z < -500 && (this.glowCamera.position.z = 500),
                                this.updateBubbles(t),
                                this.updateCamera(),
                                this.animateBlackParticles(t),
                                _.each(
                                    this.bubbles.children,
                                    _.bind(function (e) {
                                        var n = e.shader.update(t, this.cameraContainer.position.z - e.position.z);
                                    }, this)
                                ),
                                this.skyShader.update(e, t),
                                this.landscape.terrainShader.update(t);
                        },
                    });
                    return o;
                }),
                define("canyon/app", ["../class", "./canyon", "./objects", "./textures", "orbitcontrols", "effectcomposer", "compositingshaders"], function (e, t, n, r) {
                    var i = e.extend({
                        initialize: function (e) {
                            (this.name = "canyon"),
                                (this.description = '#02  Based on <a target="_blank" href="http://vimeo.com/58460459">Potus 3012</a> by Beeple'),
                                (this.renderer = e.renderer),
                                (this.container = e.container),
                                (this.compositing = e.enableCompositing),
                                (this.clock = new THREE.Clock(!1));
                            var t = this.renderer.context,
                                n = parseInt(t.getParameter(t.ALIASED_LINE_WIDTH_RANGE)[1]);
                            this.thickLines = n > 1;
                        },
                        initWorld: function () {
                            r.loadAll().done(
                                _.bind(function () {
                                    (this.world = new t({ thickLines: this.thickLines })), this.world.initHelpers(), this.world.toggleHelpers(), this.initCompositing(), this.datGUI && this.world.setupDatGUI(this.datGUI), this.trigger("ready");
                                }, this)
                            );
                        },
                        initCompositing: function () {
                            var e = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: !1 },
                                t = new THREE.WebGLRenderTarget(WIDTH, HEIGHT, e);
                            (this.composer = new THREE.EffectComposer(this.renderer, t)), this.world.setupCompositing(this.composer, this.renderer);
                        },
                        render: function (e) {
                            this.compositing && this.composer ? (this.composer.render(e), this.world.finalComposer.render(e)) : (this.renderer.clear(), this.renderer.render(this.world.scene, this.world.camera));
                        },
                        update: function () {
                            var e = this.clock.getDelta(),
                                t = this.clock.getElapsedTime();
                            this.paused || (requestAnimationFrame(this.update.bind(this)), this.stats && this.stats.begin(), this.world.update(t, e), this.render(e), this.stats && this.stats.end());
                        },
                        pause: function () {
                            this.clock.stop(), (this.paused = !0);
                        },
                        resume: function () {
                            this.clock.start(), (this.paused = !1);
                        },
                        toggleGUIMode: function () {
                            this.stats && this.datGUI && ($(this.stats.domElement).toggle(), $(this.datGUI.domElement).toggle());
                        },
                        resize: function (e, t) {
                            var n = this.world.finalComposer.passes[2];
                            n.uniforms.resolution.value.set(DENSITY / e, DENSITY / t);
                            if (this.thickLines)
                                var r = this.composer.passes[1],
                                    i = this.composer.passes[2];
                            else {
                                var s = this.composer.passes[1],
                                    r = this.composer.passes[3],
                                    i = this.composer.passes[4];
                                s.uniforms.h.value = 1 / e;
                            }
                            (r.uniforms.h.value = 3 / e), (i.uniforms.v.value = 3 / t), this.world.resize(e, t), this.world.setAspectRatio(e / t), (this.world.glowCamera.aspect = e / t), this.world.glowCamera.updateProjectionMatrix();
                        },
                    });
                    return i;
                }),
                define("mountains/textures", ["../textureloader"], function (e) {
                    var t = "textures/mountains/",
                        n = { stripes: "stripe2.png", flake: "flake.png", terrain: "displacement64.png" },
                        r = new e({ files: n, path: t });
                    return { files: n, loader: r, loadAll: r.loadAllFiles.bind(r), get: r.getById.bind(r) };
                }),
                define("mountains/materials", ["./textures"], function (e) {
                    var t = {};
                    return (t.flake = new THREE.MeshBasicMaterial({ map: e.get("flake"), transparent: !0, lights: !1, side: THREE.DoubleSide })), t;
                }),
                define("mountains/shaders/shader", ["../../class"], function (e) {
                    var t = e.extend({
                        initialize: function () {
                            this.material = new THREE.ShaderMaterial({ attributes: this.attributes || {}, uniforms: this.uniforms || {}, vertexShader: this.vertexShader, fragmentShader: this.fragmentShader });
                        },
                    });
                    return t;
                }),
                define("text!mountains/shaders/vertex/basic.vs", [], function () {
                    return "varying vec2 vUv;\n\nvoid main() {\n\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}";
                }),
                define("text!mountains/shaders/fragment/depth.fs", [], function () {
                    return "uniform sampler2D map;\nuniform float mNear;\nuniform float mFar;\nuniform float opacity;\n\nvarying vec2 vUv;\n\nvoid main() {\n  float alpha = texture2D(map, vUv.xy).a;\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n  float color = 1.0 - smoothstep(mNear, mFar, depth);\n  gl_FragColor = vec4(vec3(color), opacity * alpha);\n}";
                }),
                define("mountains/shaders/depth", ["./shader", "text!./vertex/basic.vs", "text!./fragment/depth.fs"], function (e, t, n) {
                    var r = e.extend({
                        vertexShader: t,
                        fragmentShader: n,
                        uniforms: { map: { type: "t", value: null }, opacity: { type: "f", value: 1 }, mNear: { type: "f", value: 1 }, mFar: { type: "f", value: 2e3 } },
                        initialize: function (t) {
                            e.prototype.initialize.call(this), THREE.Material.call(this.material), (this.material.transparent = !0), t && t.map && (this.material.uniforms.map.value = t.map);
                        },
                        update: function (e) {
                            (this.material.uniforms.mNear.value = e.near), (this.material.uniforms.mFar.value = e.far);
                        },
                    });
                    return r;
                }),
                define("mountains/flake", ["../class", "./materials", "./shaders/depth"], function (e, t, n) {
                    function i(e, t, n) {
                        return Math.min(Math.max(e, t), n);
                    }
                    var r = e.extend({
                        initialize: function (e) {
                            (this.mesh = new THREE.Mesh(e.geometry, t.flake)),
                                (this.angle = (Math.PI * 200) / 180),
                                (this.velocity = 75),
                                (this.startTime = e.delay / 1e3),
                                (this.mesh.position = e.position),
                                (this.startingPosition = e.position.clone()),
                                (this.mesh.visible = !1);
                        },
                        update: function (e, t) {
                            e > this.startTime &&
                            ((this.mesh.visible = !0),
                                (this.mesh.position.y -= this.velocity * t),
                                (this.mesh.position.x -= this.velocity * 1.25 * t),
                                (this.mesh.rotation.x += this.angle * t),
                                (this.mesh.rotation.y += this.angle * t),
                                (this.mesh.rotation.z += this.angle * t)),
                            this.mesh.position.y < -100 && this.reset();
                        },
                        reset: function () {
                            this.mesh.position = this.startingPosition.clone();
                        },
                    });
                    return r;
                }),
                define("mountains/objects", ["./flake"], function (e) {
                    var t = {};
                    return (
                        (t.createCamera = function (e) {
                            var e = _.extend({ fov: 45, aspectRatio: WIDTH / HEIGHT, near: 1, far: 1e4 }, e),
                                t = new THREE.PerspectiveCamera(e.fov, e.aspectRatio, e.near, e.far);
                            return t;
                        }),
                            (t.createSnow = function (t, n) {
                                var r = new THREE.Object3D(),
                                    i = [],
                                    s = 500,
                                    o = new THREE.PlaneGeometry(5, 5, 1, 1);
                                return (
                                    _.times(s, function (s) {
                                        var u = Math.random() * 1e4,
                                            a = new e({ geometry: o, position: new THREE.Vector3(Math.random() * t - t / 2, 300, -Math.random() * n), delay: u });
                                        r.add(a.mesh), i.push(a);
                                    }),
                                        (r.update = function (e, t) {
                                            _.each(i, function (n) {
                                                n.update(e, t);
                                            });
                                        }),
                                        r
                                );
                            }),
                            t
                    );
                }),
                define("text!mountains/shaders/vertex/bokeh2.vs", [], function () {
                    return "/**\n * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\nvarying vec2 vUv;\n\nvoid main() {\n\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}";
                }),
                define("text!mountains/shaders/fragment/bokeh2.fs", [], function () {
                    return "/**\n * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\nvarying vec2 vUv;\n\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float textureWidth;\nuniform float textureHeight;\n\nconst float PI = 3.14159265;\n\nfloat width = textureWidth; //texture width\nfloat height = textureHeight; //texture height\n\nvec2 texel = vec2(1.0/width,1.0/height);\n\nuniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\nuniform float focalLength; //focal length in mm\nuniform float fstop; //f-stop value\nuniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\n\n/*\nmake sure that these two values are the same for your camera, otherwise distances will be wrong.\n*/\n\nuniform float znear; // camera clipping start\nuniform float zfar; // camera clipping end\n\n//------------------------------------------\n//user variables\n\nconst int samples = SAMPLES; //samples on the first ring\nconst int rings = RINGS; //ring count\n\nconst int maxringsamples = rings * samples;\n\nuniform bool manualdof; // manual dof calculation\nfloat ndofstart = 1.0; // near dof blur start\nfloat ndofdist = 2.0; // near dof blur falloff distance\nfloat fdofstart = 1.0; // far dof blur start\nfloat fdofdist = 3.0; // far dof blur falloff distance\n\nfloat CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\n\nuniform bool vignetting; // use optical lens vignetting\n\nfloat vignout = 1.3; // vignetting outer border\nfloat vignin = 0.0; // vignetting inner border\nfloat vignfade = 22.0; // f-stops till vignete fades\n\nuniform bool shaderFocus;\n\nbool autofocus = shaderFocus;\n//use autofocus in shader - use with focusCoords\n// disable if you use external focalDepth value\n\nuniform vec2 focusCoords;\n// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\n// if center of screen use vec2(0.5, 0.5);\n\nuniform float maxblur;\n//clamp value of max blur (0.0 = no blur, 1.0 default)\n\nuniform float threshold; // highlight threshold;\nuniform float gain; // highlight gain;\n\nuniform float bias; // bokeh edge bias\nuniform float fringe; // bokeh chromatic aberration / fringing\n\nuniform bool noise; //use noise instead of pattern for sample dithering\n\nuniform float dithering;\nfloat namount = dithering; //dither amount\n\nuniform bool depthblur; // blur the depth buffer\nfloat dbsize = 1.25; // depth blur size\n\n/*\nnext part is experimental\nnot looking good with small sample and ring count\nlooks okay starting from samples = 4, rings = 4\n*/\n\nuniform bool pentagon; //use pentagon as bokeh shape?\nfloat feather = 0.4; //pentagon shape feather\n\n//------------------------------------------\n\nfloat penta(vec2 coords) {\n  //pentagonal shape\n  float scale = float(rings) - 1.3;\n  vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\n  vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\n  vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\n  vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\n  vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\n  vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\n\n  vec4  one = vec4( 1.0 );\n\n  vec4 P = vec4((coords),vec2(scale, scale));\n\n  vec4 dist = vec4(0.0);\n  float inorout = -4.0;\n\n  dist.x = dot( P, HS0 );\n  dist.y = dot( P, HS1 );\n  dist.z = dot( P, HS2 );\n  dist.w = dot( P, HS3 );\n\n  dist = smoothstep( -feather, feather, dist );\n\n  inorout += dot( dist, one );\n\n  dist.x = dot( P, HS4 );\n  dist.y = HS5.w - abs( P.z );\n\n  dist = smoothstep( -feather, feather, dist );\n  inorout += dist.x;\n\n  return clamp( inorout, 0.0, 1.0 );\n}\n\nfloat bdepth(vec2 coords) {\n  // Depth buffer blur\n  float d = 0.0;\n  float kernel[9];\n  vec2 offset[9];\n\n  vec2 wh = vec2(texel.x, texel.y) * dbsize;\n\n  offset[0] = vec2(-wh.x,-wh.y);\n  offset[1] = vec2( 0.0, -wh.y);\n  offset[2] = vec2( wh.x -wh.y);\n\n  offset[3] = vec2(-wh.x,  0.0);\n  offset[4] = vec2( 0.0,   0.0);\n  offset[5] = vec2( wh.x,  0.0);\n\n  offset[6] = vec2(-wh.x, wh.y);\n  offset[7] = vec2( 0.0,  wh.y);\n  offset[8] = vec2( wh.x, wh.y);\n\n  kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\n  kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\n  kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\n\n\n  for( int i=0; i<9; i++ ) {\n    float tmp = texture2D(tDepth, coords + offset[i]).r;\n    d += tmp * kernel[i];\n  }\n\n  return d;\n}\n\n\nvec3 color(vec2 coords,float blur) {\n  //processing the sample\n\n  vec3 col = vec3(0.0);\n\n  col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\n  col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\n  col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\n\n  vec3 lumcoeff = vec3(0.299,0.587,0.114);\n  float lum = dot(col.rgb, lumcoeff);\n  float thresh = max((lum-threshold)*gain, 0.0);\n  return col+mix(vec3(0.0),col,thresh*blur);\n}\n\nvec2 rand(vec2 coord) {\n  // generating noise / pattern texture for dithering\n\n  float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;\n\n  if (noise) {\n    noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\n    noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\n  }\n\n  return vec2(noiseX,noiseY);\n}\n\nvec3 debugFocus(vec3 col, float blur, float depth) {\n  float edge = 0.002*depth; //distance based edge smoothing\n  float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\n  float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\n\n  col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\n  col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\n\n  return col;\n}\n\nfloat linearize(float depth) {\n  return -zfar * znear / (depth * (zfar - znear) - zfar);\n}\n\n\nfloat vignette() {\n  float dist = distance(vUv.xy, vec2(0.5,0.5));\n  dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\n  return clamp(dist,0.0,1.0);\n}\n\nfloat gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\n  float rings2 = float(rings);\n  float step = PI*2.0 / float(ringsamples);\n  float pw = cos(j*step)*i;\n  float ph = sin(j*step)*i;\n  float p = 1.0;\n  if (pentagon) {\n    p = penta(vec2(pw,ph));\n  }\n  col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\n  return 1.0 * mix(1.0, i /rings2, bias) * p;\n}\n\nvoid main() {\n  //scene depth calculation\n\n  float depth = linearize(texture2D(tDepth,vUv.xy).x);\n\n  // Blur depth?\n  if (depthblur) {\n    depth = linearize(bdepth(vUv.xy));\n  }\n\n  //focal plane calculation\n\n  float fDepth = focalDepth;\n\n  if (autofocus) {\n\n    fDepth = linearize(texture2D(tDepth,focusCoords).x);\n\n  }\n\n  // dof blur factor calculation\n\n  float blur = 0.0;\n\n  if (manualdof) {\n    float a = depth-fDepth; // Focal plane\n    float b = (a-fdofstart)/fdofdist; // Far DoF\n    float c = (-a-ndofstart)/ndofdist; // Near Dof\n    blur = (a>0.0) ? b : c;\n  } else {\n    float f = focalLength; // focal length in mm\n    float d = fDepth*1000.0; // focal plane in mm\n    float o = depth*1000.0; // depth in mm\n\n    float a = (o*f)/(o-f);\n    float b = (d*f)/(d-f);\n    float c = (d-f)/(d*fstop*CoC);\n\n    blur = abs(a-b)*c;\n  }\n\n  blur = clamp(blur,0.0,1.0);\n\n  // calculation of pattern for dithering\n\n  vec2 noise = rand(vUv.xy)*namount*blur;\n\n  // getting blur x and y step factor\n\n  float w = (1.0/width)*blur*maxblur+noise.x;\n  float h = (1.0/height)*blur*maxblur+noise.y;\n\n  // calculation of final color\n\n  vec3 col = vec3(0.0);\n\n  if(blur < 0.05) {\n    //some optimization thingy\n    col = texture2D(tColor, vUv.xy).rgb;\n  } else {\n    col = texture2D(tColor, vUv.xy).rgb;\n    float s = 1.0;\n    int ringsamples;\n\n    for (int i = 1; i <= rings; i++) {\n      /*unboxstart*/\n      ringsamples = i * samples;\n\n      for (int j = 0 ; j < maxringsamples ; j++) {\n        if (j >= ringsamples) break;\n        s += gather(float(i), float(j), ringsamples, col, w, h, blur);\n      }\n      /*unboxend*/\n    }\n\n    col /= s; //divide by sample count\n  }\n\n  if (showFocus) {\n    col = debugFocus(col, blur, depth);\n  }\n\n  if (vignetting) {\n    col *= vignette();\n  }\n\n  gl_FragColor.rgb = col;\n  gl_FragColor.a = 1.0;\n  // gl_FragColor.a = texture2D(tColor, vUv.xy).a;\n}";
                }),
                define("mountains/shaders/bokeh2", ["./shader", "text!./vertex/bokeh2.vs", "text!./fragment/bokeh2.fs"], function (e, t, n) {
                    var r = e.extend({
                        vertexShader: t,
                        fragmentShader: n,
                        uniforms: {
                            textureWidth: { type: "f", value: 1 },
                            textureHeight: { type: "f", value: 1 },
                            focalDepth: { type: "f", value: 1 },
                            focalLength: { type: "f", value: 24 },
                            fstop: { type: "f", value: 2.25 },
                            tColor: { type: "t", value: null },
                            tDepth: { type: "t", value: null },
                            maxblur: { type: "f", value: 2 },
                            showFocus: { type: "i", value: 0 },
                            manualdof: { type: "i", value: 0 },
                            vignetting: { type: "i", value: 1 },
                            depthblur: { type: "i", value: 0 },
                            threshold: { type: "f", value: 0.5 },
                            gain: { type: "f", value: 0.2 },
                            bias: { type: "f", value: 0.15 },
                            fringe: { type: "f", value: 0.7 },
                            znear: { type: "f", value: 0.1 },
                            zfar: { type: "f", value: 100 },
                            noise: { type: "i", value: 1 },
                            dithering: { type: "f", value: 1e-4 },
                            pentagon: { type: "i", value: 0 },
                            shaderFocus: { type: "i", value: 1 },
                            focusCoords: { type: "v2", value: new THREE.Vector2() },
                        },
                        initialize: function (t) {
                            e.prototype.initialize.call(this),
                                (this.material.uniforms.tColor.value = t.tColor),
                                (this.material.uniforms.tDepth.value = t.tDepth),
                                (this.material.uniforms.textureWidth.value = WIDTH),
                                (this.material.uniforms.textureHeight.value = HEIGHT),
                                (this.material.defines = { RINGS: 3, SAMPLES: 4 });
                        },
                    });
                    return r;
                }),
                define("text!mountains/shaders/fragment/gradient.fs", [], function () {
                    return "// Gradient Shader for 1 midpoint\n\n// #ifdef GL_ES\n// precision highp float;\n// #endif\n\n// varying vec2 vUv;\n\n// uniform vec3 color1;\n// uniform vec3 color2;\n// uniform float midpoint;\n\n// void main() {\n//   vec3 midcolor = mix(color1, color2, 0.5);\n//   vec3 color = vec3(0.0);\n\n//   if (vUv.y < midpoint) {\n//     color = mix(color1, midcolor, vUv.y / midpoint);\n//   } else {\n//     color = mix(midcolor, color2, (vUv.y - midpoint) / (1.0 - midpoint));\n//   }\n\n//   gl_FragColor = vec4(color, 1.0);\n// }\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec2 vUv;\n\nuniform vec3 color1;\nuniform vec3 color2;\nuniform float midpoint;\n\nvoid main() {\n  vec3 color = vec3(0.0);\n  float s1 = midpoint - 0.1;\n  float s2 = midpoint + 0.15;\n\n  if (vUv.y < s1) {\n    color = color1;\n  } else if (vUv.y > s2) {\n    color = color2;\n  } else {\n    color = mix(color1, color2, (vUv.y - s1) / (s2 - s1));\n  }\n\n  gl_FragColor = vec4(color, 1.0);\n}";
                }),
                define("mountains/shaders/gradient", ["./shader", "text!./vertex/basic.vs", "text!./fragment/gradient.fs"], function (e, t, n) {
                    var r = e.extend({
                        vertexShader: t,
                        fragmentShader: n,
                        uniforms: { color1: { type: "c", value: new THREE.Color(0) }, color2: { type: "c", value: new THREE.Color(16777215) }, midpoint: { type: "f", value: 0.7 } },
                        initialize: function (t) {
                            e.prototype.initialize.call(this),
                            t && t.color1 && (this.material.uniforms.color1.value = t.color1),
                            t && t.color2 && (this.material.uniforms.color2.value = t.color2),
                            t && t.midpoint && (this.material.uniforms.midpoint.value = t.midpoint);
                        },
                        update: function () {
                            var e = this.material.uniforms.midpoint.value,
                                t = 0.7 + mouseY * 0.25;
                            this.material.uniforms.midpoint.value = THREE.Math.lerp(e, t, 0.1);
                        },
                    });
                    return r;
                }),
                define("mountains/mountains", ["../world", "./materials", "./textures", "./objects", "./shaders/bokeh2", "./shaders/gradient", "./shaders/depth"], function (e, t, n, r, i, s, o) {
                    function a(e, t, n) {
                        var r = (n * e.width + t) * 4;
                        return e.data[r];
                    }
                    var u = e.extend({
                        initialize: function () {
                            e.prototype.initialize.call(this),
                                (this.BOUNDARIES = { x: WIDTH / 10, y: HEIGHT / 10 }),
                                this.scene.add(this.camera),
                                this.cameraContainer.position.set(-500, 0, 0),
                                this.camera.position.set(0, 50, 500),
                                (this.camera.target = new THREE.Vector3(-500, 50, -500)),
                                this.camera.lookAt(this.camera.target),
                                (this.camera.speed = 60),
                                (this.camera.far = 1500),
                                (this.camera.near = 1);
                            var t = new THREE.DirectionalLight(16777215, 1.25);
                            t.position.set(-500, 250, 250),
                                t.target.position.set(0, 0, 0),
                                (t.shadowCameraVisible = !1),
                                (t.shadowCameraNear = 100),
                                (t.shadowCameraFar = 2e3),
                                (t.shadowCameraLeft = -400),
                                (t.shadowCameraRight = 400),
                                (t.shadowCameraTop = 400),
                                (t.shadowCameraBottom = -400),
                                (t.shadowMapWidth = 1024),
                                (t.shadowMapHeight = 1024),
                                (t.shadowDarkness = 0.3),
                                (t.castShadow = !1),
                                this.scene.add(t),
                                this.lights.push(t);
                            var i = n.get("stripes");
                            (i.wrapS = i.wrapT = THREE.RepeatWrapping), i.repeat.set(80, 80);
                            var s = new THREE.MeshLambertMaterial({ color: 11985889, shading: THREE.FlatShading, emissive: 4473924, map: i }),
                                o = (this.terrain = new THREE.Mesh(new THREE.PlaneGeometry(1e3, 1e3, 63, 63), s));
                            (o.rotation.x = -Math.PI / 2), (o.receiveShadow = !0), (o.castShadow = !0), this.scene.add(o);
                            var u = n.get("terrain").image,
                                f = document.createElement("canvas");
                            (f.width = 64), (f.height = 64);
                            var l = f.getContext("2d");
                            l.drawImage(u, 0, 0, f.width, f.height);
                            var c = l.getImageData(0, 0, f.width, f.height),
                                h = [];
                            for (var p = 0; p < c.height; p++) for (var d = 0; d < c.width; d++) h.push(a(c, d, p));
                            var v = 250;
                            _.each(o.geometry.vertices, function (e, t) {
                                e.z = (h[t] / 255) * v;
                            }),
                                (o.geometry.dynamic = !0),
                                (o.geometry.verticesNeedUpdate = !0),
                                o.geometry.computeFaceNormals(),
                                (o.geometry.normalsNeedUpdate = !0);
                            var m = (this.terrainLeft = o.clone());
                            m.position.set(-1e3, 0, 0), this.scene.add(m);
                            var g = (this.terrainRight = o.clone());
                            g.position.set(1e3, 0, 0), this.scene.add(g);
                            var y = (this.snow = r.createSnow(WIDTH, 1500));
                            this.cameraContainer.add(y), y.position.set(0, 50, 500);
                            var b = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
                            (this.rtDepth = new THREE.WebGLRenderTarget(WIDTH, HEIGHT, b)), this.initSky();
                        },
                        initSky: function () {
                            var e = new THREE.Color(4774911),
                                t = new THREE.Color(15659408);
                            (this.skyScene = new THREE.Scene()), (this.skyCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1)), (this.skyShader = new s({ color1: t, color2: e, midpoint: 0.7 }));
                            var n = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this.skyShader.material);
                            (n.name = "sky"), this.skyScene.add(n);
                        },
                        render: function (e, t) {
                            (this.scene.overrideMaterial = this.depthMaterial), e.render(this.scene, this.camera, this.rtDepth, !0), (this.scene.overrideMaterial = null), t.render();
                        },
                        setupCompositing: function (e) {
                            var t = new THREE.RenderPass(this.skyScene, this.skyCamera),
                                n = new THREE.RenderPass(this.scene, this.camera),
                                r = new THREE.ShaderPass(THREE.HorizontalDofShader),
                                i = new THREE.ShaderPass(THREE.VerticalDofShader),
                                s = 2;
                            (this.depthMaterial = new THREE.MeshDepthMaterial()),
                                (r.uniforms.tDepth.value = this.rtDepth),
                                (i.uniforms.tDepth.value = this.rtDepth),
                                (r.uniforms.h.value = s / WIDTH),
                                (i.uniforms.v.value = s / HEIGHT),
                                e.addPass(t),
                                e.addPass({
                                    enabled: !0,
                                    render: function (e) {
                                        e.clear(!1, !0, !1);
                                    },
                                }),
                                e.addPass(n),
                                (n.clear = !1),
                                e.addPass(r),
                                e.addPass(i),
                                (i.renderToScreen = !0);
                        },
                        setupDatGUI: function (e) {},
                        resize: function (e, t, n) {
                            (this.camera.aspect = e / t), (n.passes[3].uniforms.h.value = 2 / WIDTH), (n.passes[4].uniforms.v.value = 2 / HEIGHT);
                        },
                        updateCamera: function (e) {
                            this.cameraContainer.position.x += e * this.camera.speed;
                            if (this.cameraContainer.position.x > 500) {
                                var t = 500 - this.camera.target.x;
                                (this.cameraContainer.position.x = -500), (this.camera.target.x = -500 - t);
                            }
                            this.camera.position.x = this.cameraContainer.position.x;
                            var n = this.BOUNDARIES.x * mouseX,
                                r = this.BOUNDARIES.y * -mouseY + 50,
                                i = new THREE.Vector3(this.camera.position.x + n, this.scene.position.y + r, this.scene.position.z);
                            (this.camera.target.x += this.camera.speed * e), this.camera.lookAt(this.camera.target.lerp(i, 0.1));
                        },
                        update: function (e, t) {
                            this.updateCamera(t), (this.lights[0].position.x = this.camera.position.x - 500), (this.lights[0].target.position.x = this.lights[0].position.x + 500), this.snow.update(e, t), this.skyShader.update();
                        },
                    });
                    return u;
                }),
                define("mountains/app", ["class", "./textures", "./mountains", "./objects", "orbitcontrols"], function (e, t, n, r) {
                    var i = e.extend({
                        initialize: function (e) {
                            (this.name = "mountains"),
                                (this.description = '#03  Based on <a target="_blank" href="http://vimeo.com/9961551">Moytains</a> by Beeple'),
                                (this.renderer = e.renderer),
                                (this.container = e.container),
                                (this.compositing = e.enableCompositing),
                                (this.clock = new THREE.Clock(!1));
                        },
                        initWorld: function () {
                            t.loadAll().done(
                                _.bind(function () {
                                    (this.world = new n()), this.world.initHelpers(), this.world.toggleHelpers(), this.datGUI && this.world.setupDatGUI(this.datGUI), this.initCompositing(), this.trigger("ready");
                                }, this)
                            );
                        },
                        initCompositing: function () {
                            (this.composer = new THREE.EffectComposer(this.renderer)), this.world.setupCompositing(this.composer);
                        },
                        render: function (e) {
                            this.compositing && this.composer ? this.world.render(this.renderer, this.composer, e) : this.renderer.render(this.world.scene, this.world.camera);
                        },
                        update: function () {
                            var e = this.clock.getDelta(),
                                t = this.clock.getElapsedTime();
                            this.paused || (requestAnimationFrame(this.update.bind(this)), this.stats && this.stats.begin(), this.world.update(t, e), this.render(e), this.stats && this.stats.end());
                        },
                        pause: function () {
                            this.clock.stop(), (this.paused = !0);
                        },
                        resume: function () {
                            this.clock.start(), (this.paused = !1);
                        },
                        toggleGUIMode: function () {
                            this.stats && this.datGUI && ($(this.stats.domElement).toggle(), $(this.datGUI.domElement).toggle());
                        },
                        resize: function (e, t) {
                            this.world.setAspectRatio(e / t), this.world.resize(e, t, this.composer);
                        },
                    });
                    return i;
                }),
                define("road/materials", ["three"], function (e) {
                    var t = {};
                    return (
                        (t.whiteLambert = new e.MeshLambertMaterial({ color: 16777215, shading: e.FlatShading })),
                            (t.blackMaterial = new e.MeshBasicMaterial({ color: 0 })),
                            (t.greenWireframe = new e.MeshBasicMaterial({ color: 65280, wireframe: !0 })),
                            (t.greenLineMaterial = new e.LineBasicMaterial({ color: 65280 })),
                            (t.tealLine = new e.MeshBasicMaterial({ color: 8257535, wireframe: !0 })),
                            t
                    );
                }),
                define("road/objects", ["three", "./materials"], function (e, t) {
                    var n = {};
                    return (
                        (n.createCamera = function (t) {
                            var t = _.extend({ fov: 45, aspectRatio: window.innerWidth / window.innerHeight, near: 1, far: 1e4 }, t),
                                n = new e.PerspectiveCamera(t.fov, t.aspectRatio, t.near, t.far);
                            return n;
                        }),
                            (n.createGrid = function (t) {
                                var t = _.extend({ size: 100, step: 10, color: 0, opacity: 0.2 }, t),
                                    n = new e.Geometry(),
                                    r = t.size;
                                for (var i = -r; i <= r; i += t.step) n.vertices.push(new e.Vector3(-r, 0, i)), n.vertices.push(new e.Vector3(r, 0, i)), n.vertices.push(new e.Vector3(i, 0, -r)), n.vertices.push(new e.Vector3(i, 0, r));
                                var s = new e.LineBasicMaterial({ color: t.color, opacity: t.opacity }),
                                    o = new e.Line(n, s);
                                return (o.type = e.LinePieces), o;
                            }),
                            (n.createCube = function (t) {
                                var t = _.extend({ size: 10, material: new e.MeshBasicMaterial({ color: 0 }) }, t),
                                    n = t.size,
                                    r = new e.Mesh(new e.CubeGeometry(n, n, n), t.material);
                                return r;
                            }),
                            (n.loadModel = function (t) {
                                var n = new jQuery.Deferred(),
                                    r = new e.JSONLoader();
                                return (
                                    r.load(t, function (t, r) {
                                        n.resolve(new e.Mesh(t, r[0]));
                                    }),
                                        n.promise()
                                );
                            }),
                            n
                    );
                }),
                define("road/models", ["../modelloader"], function (e) {
                    var t = "models/",
                        n = { pillar: "pillar.js", pillarTop: "pillar-top.js" },
                        r = new e({ files: n, path: t });
                    return { loadAll: r.loadAllFiles.bind(r), get: r.getById.bind(r) };
                }),
                define("road/curves", ["three"], function (e) {
                    var t = {};
                    return (
                        (t.segments = [
                            new e.CubicBezierCurve3(new e.Vector3(-0.000003, 1e-6, 203.05304), new e.Vector3(23.146696, 1e-6, 196.850906), new e.Vector3(74.906815, 0.103815, 184.577896), new e.Vector3(67.778229, 7.215911, 152.21936)),
                            new e.CubicBezierCurve3(new e.Vector3(67.778229, 7.215911, 152.21936), new e.Vector3(60.649647, 14.328003, 119.86084), new e.Vector3(27.17379, -0.061909, 108.809753), new e.Vector3(-0.000001, 1e-6, 101.385696)),
                            new e.CubicBezierCurve3(new e.Vector3(-0.000001, 1e-6, 101.385696), new e.Vector3(-27.173798, 0.061911, 93.961639), new e.Vector3(-67.778229, 18.644653, 84.441147), new e.Vector3(-67.778229, 18.644653, 50.552025)),
                            new e.CubicBezierCurve3(new e.Vector3(-67.778229, 18.644653, 50.552025), new e.Vector3(-67.778229, 18.644653, 16.66291), new e.Vector3(-33.094025, 1e-6, 7.016156), new e.Vector3(-0.000003, 1e-6, -0.281647)),
                            new e.CubicBezierCurve3(new e.Vector3(-0.000003, 1e-6, -0.281647), new e.Vector3(33.094017, 1e-6, -7.57945), new e.Vector3(67.778229, 15.084962, -16.392532), new e.Vector3(67.778229, 15.084962, -50.281647)),
                            new e.CubicBezierCurve3(new e.Vector3(67.778229, 15.084962, -50.281647), new e.Vector3(67.778229, 15.084962, -84.170761), new e.Vector3(30.739862, 9.676497, -89.797722), new e.Vector3(12e-6, -0.000001, -100.281647)),
                            new e.CubicBezierCurve3(new e.Vector3(12e-6, -0.000001, -100.281647), new e.Vector3(-30.739819, -9.676495, -110.765564), new e.Vector3(-60.382263, -28.574028, -122.624451), new e.Vector3(-67.778244, -15, -152.782654)),
                            new e.CubicBezierCurve3(new e.Vector3(-67.778244, -15, -152.782654), new e.Vector3(-75.174225, -1.425972, -182.940857), new e.Vector3(-32.734283, -0.000001, -194.811523), new e.Vector3(16e-6, -0.000001, -203.582657)),
                        ]),
                            (t.path = new e.CurvePath()),
                            (t.path.curves = t.segments),
                            t
                    );
                }),
                define("road/pillars", ["three"], function (e) {
                    var t = {};
                    return (
                        (t.locations = [
                            new e.Vector3(-69.924065, -2.220383, -200.555115),
                            new e.Vector3(-90.849434, 16.835037, -131.393204),
                            new e.Vector3(14.147863, 15.186833, -60.1078),
                            new e.Vector3(46.454262, 11.690985, -120.717995),
                            new e.Vector3(100.640388, 9.458103, 163.619141),
                            new e.Vector3(-14.764275, -14.765525, -188.681961),
                            new e.Vector3(-4.78531, -6.048833, -182.56424),
                            new e.Vector3(-39.635326, -13.543379, -177.913742),
                            new e.Vector3(-14.492905, -24.306738, -177.613693),
                            new e.Vector3(-29.004236, -20.966387, -180.964218),
                            new e.Vector3(-42.54113, -9.643389, -208.578796),
                            new e.Vector3(-30.577366, -12.983742, -208.974686),
                            new e.Vector3(-53.172218, -2.220383, -205.52832),
                            new e.Vector3(-20.86977, 5.274163, -213.925232),
                            new e.Vector3(-30.848736, -3.442529, -220.042953),
                            new e.Vector3(19.932108, -5.6465, 215.314575),
                            new e.Vector3(9.644325, 14.123769, 182.262802),
                            new e.Vector3(30.348974, -17.198723, 210.079941),
                            new e.Vector3(8.800739, -15.286646, 214.399643),
                            new e.Vector3(-68.514641, -0.666766, 78.812645),
                            new e.Vector3(-74.760231, 8.362053, 67.111153),
                            new e.Vector3(-21.285807, -10.140958, 107.372864),
                            new e.Vector3(-43.108974, -2.475075, 97.445847),
                            new e.Vector3(1.011446, -14.665241, 118.004959),
                            new e.Vector3(12.228237, -10.439904, 94.730156),
                            new e.Vector3(-31.558161, -8.87346, 69.97319),
                            new e.Vector3(-22.621239, -8.317799, 81.029831),
                            new e.Vector3(-4.43346, -20.079678, 85.518066),
                            new e.Vector3(30.110031, 3.369871, 99.187508),
                            new e.Vector3(-46.444466, -1.180009, 73.228638),
                            new e.Vector3(57.673347, -1.892759, 161.526306),
                            new e.Vector3(43.732567, -13.952258, 152.71788),
                            new e.Vector3(23.005001, -3.922407, 129.872574),
                            new e.Vector3(29.854961, -5.261323, 138.347427),
                            new e.Vector3(34.651794, 13.950373, 124.698845),
                            new e.Vector3(49.244083, -7.233284, 172.512604),
                            new e.Vector3(51.37925, 4.134676, 139.298172),
                            new e.Vector3(34.53474, 1.603703, 177.705307),
                            new e.Vector3(2.129829, -8.090742, -87.262703),
                            new e.Vector3(23.832186, 3.344772, -118.265617),
                            new e.Vector3(13.075104, 0.811732, -112.14769),
                            new e.Vector3(28.855417, -3.747733, -106.261803),
                            new e.Vector3(78.065399, -3.217184, 168.643875),
                            new e.Vector3(46.67207, 22.483398, 101.614769),
                            new e.Vector3(89.865219, 7.647039, 130.657745),
                            new e.Vector3(86.624512, -3.720921, 156.536774),
                            new e.Vector3(72.314575, -1.748961, 133.761826),
                            new e.Vector3(46.67207, 22.483398, 101.614769),
                            new e.Vector3(69.333275, -0.410044, 120.544739),
                            new e.Vector3(56.383614, 9.818995, 111.817711),
                            new e.Vector3(76.698494, -10.439896, 147.404022),
                            new e.Vector3(99.528801, 1.619604, 147.020477),
                            new e.Vector3(72.841583, 1.619604, 181.04097),
                            new e.Vector3(59.8116, -17.926373, 195.84964),
                            new e.Vector3(45.752048, 1.783675, 204.977295),
                            new e.Vector3(58.888523, 5.474229, 212.175354),
                            new e.Vector3(76.163872, 5.269204, 196.339615),
                            new e.Vector3(96.316612, -1.971584, 175.969406),
                            new e.Vector3(95.625557, 14.016932, -29.347076),
                            new e.Vector3(82.813911, 6.067989, -8.976847),
                            new e.Vector3(65.538559, 6.273015, 6.858894),
                            new e.Vector3(52.402088, 2.58246, -0.33917),
                            new e.Vector3(66.618263, -7.859836, -7.357284),
                            new e.Vector3(74.896034, -11.667654, -22.65317),
                            new e.Vector3(99.701408, -6.233868, -55.70504),
                            new e.Vector3(83.389511, -5.379319, -60.020809),
                            new e.Vector3(55.955547, 1.965523, -94.987724),
                            new e.Vector3(67.778564, 5.376258, -84.987656),
                            new e.Vector3(43.498501, 14.629928, -98.701294),
                            new e.Vector3(74.628525, -2.383026, -76.512794),
                            new e.Vector3(78.551788, 9.609264, -87.540688),
                            new e.Vector3(87.403481, 9.609264, -48.462593),
                            new e.Vector3(90.037827, -0.206433, -72.067772),
                            new e.Vector3(79.308304, 14.629927, -37.15493),
                            new e.Vector3(27.688911, 14.629927, -34.356289),
                            new e.Vector3(14.373295, 14.629928, -85.823715),
                            new e.Vector3(57.972782, -0.206433, -43.081699),
                            new e.Vector3(54.934708, 9.609265, -61.733353),
                            new e.Vector3(42.948956, 9.609265, -72.685364),
                            new e.Vector3(26.830349, 1.965523, -82.110146),
                            new e.Vector3(41.847412, -18.293367, -48.764442),
                            new e.Vector3(47.002308, -6.233868, -31.672112),
                            new e.Vector3(35.69331, -6.233868, -22.013948),
                            new e.Vector3(-53.40295, -15.026654, -169.532761),
                            new e.Vector3(-77.864494, 4.792339, -152.890335),
                            new e.Vector3(-75.050423, -24.993448, -166.207886),
                            new e.Vector3(-74.447632, -31.017559, -142.371292),
                            new e.Vector3(-80.209267, -12.75826, -178.237564),
                            new e.Vector3(-66.658684, -20.556166, -183.043091),
                            new e.Vector3(-56.692078, -31.016151, -158.859146),
                            new e.Vector3(-73.739784, 12.974339, -126.737572),
                            new e.Vector3(-64.265984, -19.493813, -117.891846),
                            new e.Vector3(-56.42609, -29.85454, -145.325531),
                            new e.Vector3(-53.254337, -18.293365, -113.018303),
                            new e.Vector3(-39.719975, -18.112343, -143.836533),
                            new e.Vector3(-48.206852, -29.012661, -135.673782),
                            new e.Vector3(-11.169664, -9.968513, -128.227875),
                            new e.Vector3(-2.902144, -1.251821, -119.942078),
                            new e.Vector3(-37.321842, -8.746367, -126.841347),
                            new e.Vector3(-13.49951, -19.509727, -117.404198),
                            new e.Vector3(-25.222944, -16.169373, -119.822815),
                            new e.Vector3(-25.081341, -4.302496, -89.952202),
                            new e.Vector3(-34.896976, -8.263515, -96.803627),
                            new e.Vector3(-12.102392, 3.284912, -90.670273),
                            new e.Vector3(-43.998993, -9.602431, -103.747368),
                            new e.Vector3(-41.311543, 9.609265, -87.779564),
                            new e.Vector3(-60.001392, 9.609265, -93.204895),
                            new e.Vector3(-65.906464, -13.466378, -105.218391),
                            new e.Vector3(-55.168678, 17.825991, -6.101646),
                            new e.Vector3(-68.018654, 27.641687, -2.350389),
                            new e.Vector3(-76.577095, 18.365707, 15.128114),
                            new e.Vector3(-65.118492, 8.429991, 12.739216),
                            new e.Vector3(-81.214142, 6.636311, 48.619827),
                            new e.Vector3(-68.790512, 9.768908, 22.998909),
                            new e.Vector3(-77.227776, 28.596657, 31.490147),
                            new e.Vector3(-45.080051, 14.083374, 43.056961),
                            new e.Vector3(-43.796692, 9.286056, 24.920797),
                            new e.Vector3(-53.682049, 16.780602, 57.622665),
                            new e.Vector3(-28.210602, -10.98024, 16.571442),
                            new e.Vector3(-21.628857, -0.079923, 26.335567),
                            new e.Vector3(-54.394112, -0.260944, 5.215968),
                            new e.Vector3(-14.741057, -6.066782, 13.432004),
                            new e.Vector3(-42.966103, 11.798555, -2.306267),
                            new e.Vector3(-32.623032, 11.798555, -10.117819),
                            new e.Vector3(7.758904, -3.442529, -22.875816),
                            new e.Vector3(1.989553, -15.291476, 11.80082),
                            new e.Vector3(25.199577, -8.045743, 4.698078),
                            new e.Vector3(16.800121, 5.274162, -15.441923),
                            new e.Vector3(6.50318, -12.983741, -11.875666),
                            new e.Vector3(-12.218436, -32.418457, -12.212127),
                        ]),
                            (t.scales = [
                                new e.Vector3(1.420152, 1.420151, 1.420152),
                                new e.Vector3(1.938255, 1.938255, 1.938255),
                                new e.Vector3(2.42313, 2.42313, 2.42313),
                                new e.Vector3(2.076288, 2.076288, 2.076288),
                                new e.Vector3(0.669806, 0.669806, 0.669806),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(2.127787, 2.127787, 2.127787),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1.283336, 1.283336, 1.283336),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1.762825, 1.762825, 1.762825),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1.675632, 1.675631, 1.675632),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1.916129, 1.916129, 1.916129),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(0.669806, 0.669806, 0.669806),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1.462429, 1.462429, 1.462429),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(0.72627, 0.72627, 0.72627),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1.406791, 1.406791, 1.406791),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1.18628, 1.18628, 1.18628),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(0.695738, 0.695738, 0.695738),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(0.750125, 0.750125, 0.750125),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(0.665522, 0.665522, 0.665522),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1.229326, 1.229326, 1.229326),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1.784455, 1.784454, 1.784455),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(0.54925, 0.54925, 0.54925),
                                new e.Vector3(1.59206, 1.59206, 1.59206),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1.456782, 1.456782, 1.456782),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(1, 1, 1),
                                new e.Vector3(2.005709, 2.005709, 2.005709),
                            ]),
                            (t.rotationsY = [
                                0.37033915519714355,
                                0.37033915519714355,
                                -0.6171221733093262,
                                -0.4416244328022003,
                                -0.6171221733093262,
                                0.37033915519714355,
                                0.37033915519714355,
                                0.37033915519714355,
                                0.37033915519714355,
                                0.37033915519714355,
                                0.37033915519714355,
                                0.37033915519714355,
                                0.37033915519714355,
                                0.37033915519714355,
                                0.37033915519714355,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                                -1.6098090410232544,
                                -1.4465432167053223,
                                -0.8363050818443298,
                                0.023695094510912895,
                                -1.245148777961731,
                                -1.245148777961731,
                                -0.478750616312027,
                                -0.3514663875102997,
                                -0.3514663875102997,
                                -0.3514663875102997,
                                0.023695094510912895,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -0.9922836422920227,
                                -0.9922836422920227,
                                -0.9922836422920227,
                                -0.9922836422920227,
                                -0.9922836422920227,
                                -0.6171221733093262,
                                -0.6171221733093262,
                                -0.4416244328022003,
                                -0.4416244328022003,
                                -0.4416244328022003,
                                -0.6171221733093262,
                                -0.6171221733093262,
                                -0.9922836422920227,
                                -0.9922836422920227,
                                -0.9922836422920227,
                                -0.6171221733093262,
                                -0.9922836422920227,
                                -0.6171221733093262,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -0.6932804584503174,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -0.6171221733093262,
                                -0.9922836422920227,
                                -0.6171221733093262,
                                -0.9922836422920227,
                                -0.9922836422920227,
                                -0.9922836422920227,
                                -0.9922836422920227,
                                -0.6171221733093262,
                                -0.6171221733093262,
                                -0.6171221733093262,
                                -0.9922836422920227,
                                -0.9922836422920227,
                                -0.9922836422920227,
                                -0.6171221733093262,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -1.8859660625457764,
                                -4.697138786315918,
                                -4.307406425476074,
                                -4.307406425476074,
                                -4.307406425476074,
                                -4.307406425476074,
                                -4.307406425476074,
                                -4.697138786315918,
                                -4.307406425476074,
                                -4.307406425476074,
                                -4.307406425476074,
                                -4.307406425476074,
                                -4.307406425476074,
                                -4.307406425476074,
                                -6.149378776550293,
                                -6.149378776550293,
                                -6.149378776550293,
                                -6.149378776550293,
                                -6.149378776550293,
                                -3.413723945617676,
                                -3.413723945617676,
                                -3.413723945617676,
                                -3.413723945617676,
                                -3.413723945617676,
                                -3.413723945617676,
                                -3.413723945617676,
                                1.1258455514907837,
                                1.1258455514907837,
                                1.1258455514907837,
                                1.1258455514907837,
                                1.5992904901504517,
                                1.497353434562683,
                                1.1258455514907837,
                                -1.6098090410232544,
                                -1.6098090410232544,
                                -1.8568350076675415,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                                0.23216302692890167,
                            ]),
                            t
                    );
                }),
                define("road/shaders/shader", ["three", "class"], function (e, t) {
                    function r(e) {
                        var t = {};
                        return (
                            _.each(e, function (e, n) {
                                t[n] = _.clone(e);
                            }),
                                t
                        );
                    }
                    var n = t.extend({
                        initialize: function () {
                            (this.attributes = r(this.attributes)),
                                (this.uniforms = e.UniformsUtils.clone(this.uniforms)),
                                (this.material = new e.ShaderMaterial({ attributes: this.attributes || {}, uniforms: this.uniforms || {}, vertexShader: this.vertexShader, fragmentShader: this.fragmentShader }));
                        },
                    });
                    return n;
                }),
                define("text!road/shaders/vertex/basic.vs", [], function () {
                    return "varying vec3 vPosition;\nvarying vec3 vViewPosition;\nvarying vec3 vViewNormal;\n\nvoid main() {\n  vec4 pos = modelViewMatrix * vec4(position, 1.0);\n  vViewPosition = pos.xyz;\n  vPosition = position;\n  vViewNormal = normalize(normalMatrix * normal);\n  gl_Position = projectionMatrix * pos;\n}";
                }),
                define("text!road/shaders/fragment/pillar.fs", [], function () {
                    return "varying vec3 vPosition;\nvarying vec3 vViewPosition;\nvarying vec3 vViewNormal;\nconst float PI = 3.14159265359;\n\nuniform vec3 lineColor1;\nuniform vec3 lineColor2;\nuniform float lineWidth;\nuniform float colorBlend;\n\nfloat border(float start, float end, float dotNormalEye) {\n  return smoothstep(start, end, dotNormalEye);\n}\n\nvoid main() {\n  vec3 lineColor = mix(lineColor1, lineColor2, colorBlend);\n  float angle = atan(vPosition.z / vPosition.x);\n  vec3 black = vec3(0.0, 0.0, 0.0);\n  vec3 color = black;\n\n  vec2 normal = normalize(vViewNormal.xz);\n  vec2 eye = normalize(-vViewPosition.xz);\n  float dotNormalEye = dot(normal, eye);\n  float normalFactor = ((1.0 - (dotNormalEye / 1.0)) * 3.0) + 1.0;\n\n  float m = mod(angle, PI / 5.0);\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n  float d = depth / 200.0;\n  float range = lineWidth * d * normalFactor;\n  float tolerance = 0.005 * d;\n\n  if (m < range) {\n    if (m > (range - tolerance)) {\n      color = mix(lineColor, black, (m - (range - tolerance)) / tolerance);\n    } else {\n      color = lineColor;\n    }\n  }\n\n  if (m > ((PI / 5.0) - range) ) {\n    if (m < ((PI / 5.0) - range + tolerance)) {\n      color = mix(lineColor, black, ((PI / 5.0) - range + tolerance - m) / tolerance);\n    } else {\n      color = lineColor;\n    }\n  }\n\n  gl_FragColor = vec4(color * border(0.05, 0.9, dotNormalEye), 1.0);\n  // gl_FragColor = vec4(color, 1.0);\n}";
                }),
                define("road/shaders/pillar", ["./shader", "text!./vertex/basic.vs", "text!./fragment/pillar.fs", "shifty"], function (e, t, n, r) {
                    var i = e.extend({
                        vertexShader: t,
                        fragmentShader: n,
                        uniforms: { lineColor1: { type: "c", value: new THREE.Color(6619005) }, lineColor2: { type: "c", value: new THREE.Color(255) }, lineWidth: { type: "f", value: 0.015 }, colorBlend: { type: "f", value: 0 } },
                        initialize: function (t) {
                            e.prototype.initialize.call(this),
                            t.lineColor1 && (this.material.uniforms.lineColor1.value = t.lineColor1),
                            t.lineColor2 && (this.material.uniforms.lineColor2.value = t.lineColor2),
                                (this.material.shading = THREE.FlatShading),
                            t.lineWidth && (this.material.uniforms.lineWidth.value = t.lineWidth),
                                (this.lastColorChange = 0);
                        },
                        revertColor: function () {
                            var e = new r(),
                                t = this.material.uniforms.colorBlend;
                            e.tween({
                                from: { colorBlend: 1 },
                                to: { colorBlend: 0 },
                                duration: 750,
                                easing: "easeInOutQuad",
                                step: function (e) {
                                    t.value = e.colorBlend;
                                },
                            });
                        },
                        changeColor: function () {
                            var e = new r(),
                                t = this.material.uniforms.colorBlend;
                            e.tween({
                                from: { colorBlend: 0 },
                                to: { colorBlend: 1 },
                                duration: 750,
                                easing: "easeInOutQuad",
                                step: function (e) {
                                    t.value = e.colorBlend;
                                },
                                callback: this.revertColor.bind(this),
                            });
                        },
                        update: function (e, t) {
                            e - this.lastColorChange > 5 && (this.changeColor(), (this.lastColorChange = e));
                        },
                    });
                    return i;
                }),
                define("text!road/shaders/vertex/wireframe.vs", [], function () {
                    return "attribute vec3 barycentric;\nvarying vec3 vBarycentric;\n\nvoid main() {\n  vBarycentric = barycentric;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";
                }),
                define("text!road/shaders/fragment/wireframe.fs", [], function () {
                    return "#extension GL_OES_standard_derivatives : enable\n\nvarying vec3 vBarycentric;\n\nuniform vec3 fillColor;\nuniform vec3 lineColor1;\nuniform vec3 lineColor2;\nuniform float lineWidth;\nuniform float colorBlend;\n\nfloat edgeFactor(){\n  vec3 d = fwidth(vBarycentric);\n  vec3 a3 = smoothstep(vec3(0.0), d * lineWidth, vBarycentric);\n  return min(min(a3.x, a3.y), a3.z);\n}\n\nvoid main() {\n  vec3 color = fillColor;\n  vec3 lineColor = mix(lineColor1, lineColor2, colorBlend);\n  // if(any(lessThan(vBarycentric, vec3(0.02)))){\n  //     color = vec3(1.0);\n  // }\n\n  // gl_FragColor = vec4(color, 1.0);\n\n  // coloring by edge\n  gl_FragColor.rgb = mix(lineColor, fillColor, edgeFactor());\n  gl_FragColor.a = 1.0;\n}";
                }),
                define("road/shaders/wireframe", ["./shader", "text!./vertex/wireframe.vs", "text!./fragment/wireframe.fs", "shifty"], function (e, t, n, r) {
                    var i = e.extend({
                        vertexShader: t,
                        fragmentShader: n,
                        attributes: { barycentric: { type: "v3", value: [] } },
                        uniforms: {
                            fillColor: { type: "c", value: new THREE.Color(0) },
                            lineColor1: { type: "c", value: new THREE.Color(16777215) },
                            lineColor2: { type: "c", value: new THREE.Color(255) },
                            lineWidth: { type: "f", value: 3 },
                            colorBlend: { type: "f", value: 0 },
                        },
                        initialize: function (t) {
                            e.prototype.initialize.call(this),
                                (this.material.attributes.barycentric.value = t.barycentricAttributes),
                            t.lineColor1 && (this.material.uniforms.lineColor1.value = t.lineColor1),
                            t.lineColor2 && (this.material.uniforms.lineColor2.value = t.lineColor2),
                                (this.material.uniforms.lineWidth.value = window.innerWidth * 0.0015),
                                (this.lastColorChange = 0);
                        },
                        revertColor: function () {
                            var e = new r(),
                                t = this.material.uniforms.colorBlend;
                            e.tween({
                                from: { colorBlend: 1 },
                                to: { colorBlend: 0 },
                                duration: 750,
                                easing: "easeInOutQuad",
                                step: function (e) {
                                    t.value = e.colorBlend;
                                },
                            });
                        },
                        changeColor: function () {
                            var e = new r(),
                                t = this.material.uniforms.colorBlend;
                            e.tween({
                                from: { colorBlend: 0 },
                                to: { colorBlend: 1 },
                                duration: 750,
                                easing: "easeInOutQuad",
                                step: function (e) {
                                    t.value = e.colorBlend;
                                },
                                callback: this.revertColor.bind(this),
                            });
                        },
                        update: function (e, t) {
                            e - this.lastColorChange > 5 && (this.changeColor(), (this.lastColorChange = e));
                        },
                    });
                    return i;
                }),
                define("text!road/shaders/vertex/sky.vs", [], function () {
                    return "varying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";
                }),
                define("text!road/shaders/fragment/sky.fs", [], function () {
                    return "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec2 vUv;\n\nuniform vec3 color1;\nuniform vec3 color2;\nuniform float midpoint;\nuniform float range;\nuniform float offset;\n\nconst float lineCount = 20.0;\n\nvoid main() {\n  vec3 color = vec3(0.0);\n  float s1 = midpoint - (range / 2.0);\n  float s2 = midpoint + (range / 2.0);\n\n  // float y = vUv.y + offset / 10.0;\n  float y = vUv.y;\n\n  if (y < s1) {\n    color = color1;\n  } else if (y > s2) {\n    color = color2;\n  } else {\n    float t = (y - s1) / (s2 - s1);\n    // t += offset;\n    color = mix(color1, color2, (floor((t * lineCount) + offset) - offset) / lineCount);\n  }\n\n  gl_FragColor = vec4(color, 1.0);\n}";
                }),
                define("road/shaders/sky", ["./shader", "text!./vertex/sky.vs", "text!./fragment/sky.fs", "shifty"], function (e, t, n, r) {
                    var i = e.extend({
                        vertexShader: t,
                        fragmentShader: n,
                        uniforms: { color1: { type: "c", value: new THREE.Color(0) }, color2: { type: "c", value: new THREE.Color(16777215) }, midpoint: { type: "f", value: 0.5 }, range: { type: "f", value: 1 }, offset: { type: "f", value: 0 } },
                        initialize: function (t) {
                            e.prototype.initialize.call(this),
                            t && t.color1 && (this.material.uniforms.color1.value = t.color1),
                            t && t.color2 && (this.material.uniforms.color2.value = t.color2),
                            t && t.midpoint && (this.material.uniforms.midpoint.value = t.midpoint),
                                (this.lastBrightnessChange = 0);
                        },
                        brighten: function () {
                            var e = new r(),
                                t = this.material.uniforms.color1,
                                n = t.value.getHSL();
                            e.tween({
                                from: { offset: 0 },
                                to: { offset: 0.35 },
                                duration: 750,
                                easing: "easeInOutQuad",
                                step: function (e) {
                                    t.value.setHSL(n.h, n.s, n.l + e.offset);
                                },
                            });
                        },
                        darken: function () {
                            var e = new r(),
                                t = this.material.uniforms.color1,
                                n = t.value.getHSL();
                            e.tween({
                                from: { offset: 0 },
                                to: { offset: 0.35 },
                                duration: 750,
                                easing: "easeInOutQuad",
                                step: function (e) {
                                    t.value.setHSL(n.h, n.s, n.l - e.offset);
                                },
                                callback: this.brighten.bind(this),
                            });
                        },
                        update: function (e, t) {
                            var n = this.material.uniforms.offset,
                                r = 4,
                                i = 1 - n.value;
                            n.value + t > 1 ? (n.value = 0) : (n.value += t * r), e - this.lastBrightnessChange > 5 && (this.darken(), (this.lastBrightnessChange = e));
                        },
                    });
                    return i;
                }),
                define("road/road", ["three", "world", "./objects", "./models", "./curves", "./pillars", "./shaders/pillar", "./shaders/wireframe", "./shaders/sky"], function (e, t, n, r, i, s, o, u, a) {
                    function c(e) {
                        return 1 > (e /= 0.5) ? 0.5 * Math.pow(e, 2) : -0.5 * ((e -= 2) * e - 2);
                    }
                    var f = [
                            { color1: new e.Color(4057417), color2: new e.Color(13115194) },
                            { color1: new e.Color(5963672), color2: new e.Color(1384055) },
                            { color1: new e.Color(5701628), color2: new e.Color(1447414) },
                        ],
                        l = t.extend({
                            initialize: function () {
                                t.prototype.initialize.call(this), (this.progress = 0), (this.camera.speed = 2.5), (this.shaders = []), this.initTrack(), this.initPillars(), this.initSky();
                                var n = { minFilter: e.LinearFilter, magFilter: e.LinearFilter, format: e.RGBAFormat };
                                (this.skyTarget = new e.WebGLRenderTarget(512, 512, n)),
                                    (this.sceneTarget = new e.WebGLRenderTarget(window.innerWidth, window.innerHeight, n)),
                                    (this.camera.target = new e.Quaternion()),
                                    (this.targetQuaternion = new e.Quaternion()),
                                    this.camera.lookAt(this.camera.target),
                                    (this.projector = new e.Projector());
                            },
                            initSky: function () {
                                (this.skyScene = new e.Scene()), (this.skyCamera = new e.OrthographicCamera(-1, 1, 1, -1, 0, 1)), (this.skyShader = new a({ color1: new e.Color(3538766), color2: new e.Color(65539) }));
                                var t = new e.Mesh(new e.PlaneGeometry(2, 2), this.skyShader.material);
                                (t.name = "sky"), this.skyScene.add(t);
                            },
                            initTrack: function () {
                                this.trackGeometry = new e.Geometry();
                                var t = 24;
                                _.each(
                                    i.segments,
                                    function (n, r) {
                                        var i = r > 6 ? t + 1 : t,
                                            s = r < 1 ? 0 : 1;
                                        for (var o = s; o < i; o++) {
                                            var u = c(o * (1 / t)),
                                                a = n.getPoint(u),
                                                f = n.getTangent(u).multiplyScalar(2);
                                            f.applyAxisAngle(new e.Vector3(0, 1, 0), Math.PI / 2);
                                            var l = a.clone().sub(f),
                                                h = a.clone().add(f),
                                                p = h.clone(),
                                                d = h.clone(),
                                                v = l.clone(),
                                                m = l.clone();
                                            (l.y = h.y = a.y), (p.y = m.y = a.y - 0.1);
                                            var g = f.clone().multiplyScalar(0.05);
                                            p.add(g), m.sub(g), (d.y = v.y = a.y - 0.2), this.trackGeometry.vertices.push(l, h, p, d, v, m);
                                        }
                                    },
                                    this
                                ),
                                    this.createTrackFaces(this.trackGeometry),
                                    this.computeBarycentricCoordinates(this.trackGeometry),
                                    (this.trackShader = new u({ barycentricAttributes: this.trackGeometry.barycentricAttributes })),
                                    (this.trackShader.material.uniforms.lineColor1.value = new e.Color(5701628)),
                                    (this.trackShader.material.uniforms.lineColor2.value = new e.Color(15610040)),
                                    this.shaders.push(this.trackShader),
                                    (this.track = new e.Mesh(this.trackGeometry, this.trackShader.material)),
                                    (this.track.name = "track"),
                                    this.track.scale.multiplyScalar(10),
                                    this.scene.add(this.track),
                                    this.initTrackClone();
                            },
                            computeBarycentricCoordinates: function (t) {
                                var n = t.vertices,
                                    r = [],
                                    i = (t.barycentricAttributes = []),
                                    s = [new e.Vector3(1, 0, 0), new e.Vector3(0, 1, 0), new e.Vector3(0, 0, 1)];
                                _.each(t.faces, function (e, n) {
                                    var o = [e.a, e.b, e.c];
                                    (e.a = n * 3),
                                        (e.b = n * 3 + 1),
                                        (e.c = n * 3 + 2),
                                        _.each(o, function (e, n) {
                                            r.push(t.vertices[e].clone()), i.push(s[n]);
                                        });
                                }),
                                    (t.vertices = r),
                                    (t.verticesNeedUpdate = !0),
                                    (t.buffersNeedUpdate = !0);
                            },
                            initTrackClone: function () {
                                var e = i.path.getBoundingBox(),
                                    t = (e.maxZ - e.minZ) * 10;
                                (this.track2 = this.track.clone()),
                                    (this.track2.name = "track2"),
                                    (this.track2.geometry = this.track.geometry.clone()),
                                    (this.track2.geometry.vertices = _.first(this.track2.geometry.vertices, 900)),
                                    (this.track2.geometry.faces = _.first(this.track2.geometry.faces, 300)),
                                    (this.track2.geometry.verticesNeedUpdate = !0),
                                    (this.track2.geometry.buffersNeedUpdate = !0),
                                    this.track2.position.set(0, 0, -t),
                                    this.scene.add(this.track2);
                            },
                            initPillarClones: function () {
                                var e = this.pillars.clone(),
                                    t = [];
                                (e.name = "pillars2"),
                                    _.each(e.children, function (e) {
                                        e.position.z < 120 && t.push(e);
                                    }),
                                    _.each(t, function (t) {
                                        e.remove(t);
                                    }),
                                    e.position.set(0, 0, -4066.3),
                                    this.scene.add(e);
                            },
                            initPillars: function () {
                                (this.pillars = new e.Object3D()), (this.pillars.name = "pillars");
                                var t = r.get("pillar");
                                (this.pillar = t), t.geometry.computeVertexNormals(), (t.geometry.needsUpdate = !0);
                                var n = r.get("pillarTop");
                                (this.pillarTop = n), this.pillar.add(n), this.computeBarycentricCoordinates(n.geometry);
                                var i = [];
                                _.each(
                                    f,
                                    function (e) {
                                        var t = new u({ barycentricAttributes: n.geometry.barycentricAttributes, lineColor1: e.color1, lineColor2: e.color2 });
                                        i.push(t.material), this.shaders.push(t);
                                    },
                                    this
                                ),
                                    _.each(
                                        s.locations,
                                        function (e, t) {
                                            var n = this.pillar.clone(),
                                                r = f[t % 3],
                                                u = new o({ lineColor1: r.color1, lineColor2: r.color2, lineWidth: 0.009 / s.scales[t].x });
                                            this.shaders.push(u), (n.position = e), (n.scale = s.scales[t]), (n.rotation.y = s.rotationsY[t]), (n.material = u.material), (n.children[0].material = i[t % 3]), this.pillars.add(n);
                                        },
                                        this
                                    ),
                                    this.pillars.scale.multiplyScalar(10),
                                    this.scene.add(this.pillars),
                                    this.initPillarClones();
                            },
                            createTrackFaces: function (t) {
                                var n = t.faces;
                                for (var r = 0; r < this.trackGeometry.vertices.length - 6; r += 6)
                                    n.push(new e.Face3(r, r + 6, r + 1)),
                                        n.push(new e.Face3(r + 6, r + 7, r + 1)),
                                        n.push(new e.Face3(r + 1, r + 7, r + 2)),
                                        n.push(new e.Face3(r + 7, r + 8, r + 2)),
                                        n.push(new e.Face3(r + 2, r + 8, r + 3)),
                                        n.push(new e.Face3(r + 8, r + 9, r + 3)),
                                        n.push(new e.Face3(r + 3, r + 9, r + 4)),
                                        n.push(new e.Face3(r + 9, r + 10, r + 4)),
                                        n.push(new e.Face3(r + 4, r + 10, r + 5)),
                                        n.push(new e.Face3(r + 10, r + 11, r + 5)),
                                        n.push(new e.Face3(r + 5, r + 11, r)),
                                        n.push(new e.Face3(r + 11, r + 6, r));
                                t.needsUpdate = !0;
                            },
                            setupDatGUI: function (e) {
                                var t = e.addFolder("FXAA");
                                t.add(this.fxaa, "enabled"), t.open();
                                var n = e.addFolder("Glow");
                                n.add(this.blur, "blurriness", 0, 10).onChange(this.blur.onChangeBlurriness), n.add(this.additiveBlend, "opacity", 0, 1), n.open();
                                var r = e.addFolder("Camera");
                                r.add(this.camera, "speed", 0, 10), r.add(this, "progress", 0, 100).listen(), r.open();
                            },
                            render: function (e, t) {
                                this.skyScene && this.scene && (e.render(this.skyScene, this.skyCamera, this.skyTarget, !0), e.render(this.scene, this.camera, this.sceneTarget, !0), t[1].render(), t[0].render());
                            },
                            setupGlowComposer: function (t) {
                                var n = new e.CopyPass(this.sceneTarget),
                                    r = new e.ShaderPass(e.HorizontalBlurShader),
                                    i = new e.ShaderPass(e.VerticalBlurShader);
                                (this.blur = {
                                    blurriness: 2,
                                    onChangeBlurriness: function (e) {
                                        (r.uniforms.h.value = e / window.innerWidth), (i.uniforms.v.value = e / window.innerHeight);
                                    },
                                }),
                                    this.blur.onChangeBlurriness(this.blur.blurriness),
                                    t.addPass(n),
                                    t.addPass(r),
                                    t.addPass(i),
                                    (this.glowTarget = t.renderTarget1);
                            },
                            setupMainComposer: function (t) {
                                var n = new e.NormalBlendPass(this.skyTarget, this.sceneTarget),
                                    r = new e.AdditiveBlendPass(null, this.glowTarget, 0.8),
                                    i = (this.fxaa = new e.ShaderPass(e.FXAAShader));
                                (i.uniforms.resolution.value = new e.Vector2(DENSITY / WIDTH, DENSITY / HEIGHT)), (i.enabled = !1), (this.additiveBlend = r), t.addPass(n), t.addPass(r), t.addPass(i);
                            },
                            setupCompositing: function (e) {
                                this.setupGlowComposer(e[1]), this.setupMainComposer(e[0]);
                            },
                            updateCamera: function () {
                                var e = this.progress / 100,
                                    t = i.path.getPoint(e).multiplyScalar(10);
                                (this.camera.position = t), (this.camera.position.y += 6);
                                var n = i.path.getTangent(e),
                                    r = t.clone().add(n);
                                this.camera.lookAt(r), this.targetQuaternion.set(-mouseY / 8, -mouseX / 4, 0, 1).normalize(), this.camera.target.slerp(this.targetQuaternion, 0.1), this.camera.quaternion.multiply(this.camera.target);
                            },
                            updateShaders: function (e, t) {
                                _.each(this.shaders, function (n) {
                                    n.update(e, t);
                                }),
                                    this.skyShader.update(e, t);
                            },
                            update: function (e, t) {
                                this.updateCamera(), this.updateShaders(e, t), (this.progress += t * this.camera.speed), this.progress > 100 && (this.progress = 0);
                            },
                        });
                    return (
                        (e.CurvePath.prototype.getBoundingBox = function () {
                            var t = this.getPoints(),
                                n,
                                r,
                                i,
                                s,
                                o,
                                u;
                            (n = r = i = Number.NEGATIVE_INFINITY), (s = o = u = Number.POSITIVE_INFINITY);
                            var a,
                                f,
                                l,
                                c,
                                h = t[0] instanceof e.Vector3;
                            c = h ? new e.Vector3() : new e.Vector2();
                            for (f = 0, l = t.length; f < l; f++) (a = t[f]), a.x > n ? (n = a.x) : a.x < s && (s = a.x), a.y > r ? (r = a.y) : a.y < o && (o = a.y), h && (a.z > i ? (i = a.z) : a.z < u && (u = a.z)), c.add(a);
                            var p = { minX: s, minY: o, maxX: n, maxY: r, centroid: c.divideScalar(l) };
                            return h && ((p.maxZ = i), (p.minZ = u)), p;
                        }),
                            l
                    );
                }),
                define("road/app", ["class", "./objects", "./models", "./road", "orbitcontrols", "effectcomposer", "compositingshaders"], function (e, t, n, r) {
                    var i = e.extend({
                        initialize: function (e) {
                            (this.name = "road"),
                                (this.description = '#04  Based on <a target="_blank" href="http://vimeo.com/35215202">Yellowbrick</a> by Beeple'),
                                (this.renderer = e.renderer),
                                (this.container = e.container),
                                (this.clock = new THREE.Clock(!1)),
                                (this.compositing = e.enableCompositing);
                        },
                        initWorld: function () {
                            $.when(n.loadAll()).done(
                                _.bind(function () {
                                    (this.world = new r()), this.world.initHelpers(), this.world.toggleHelpers(), this.initCompositing(), this.datGUI && this.world.setupDatGUI(this.datGUI), this.trigger("ready");
                                }, this)
                            );
                        },
                        initCompositing: function () {
                            this.mainComposer = new THREE.EffectComposer(this.renderer);
                            var e = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat },
                                t = new THREE.WebGLRenderTarget(window.innerWidth / 2, window.innerHeight / 2, e);
                            (this.glowComposer = new THREE.EffectComposer(this.renderer, t)), this.world.setupCompositing([this.mainComposer, this.glowComposer]);
                            var n = new THREE.ShaderPass(THREE.CopyShader);
                            (n.renderToScreen = !0), this.mainComposer.addPass(n);
                        },
                        render: function () {
                            this.compositing && this.mainComposer && this.glowComposer
                                ? this.world.render(this.renderer, [this.mainComposer, this.glowComposer])
                                : (this.renderer.clear(), this.renderer.render(this.world.skyScene, this.world.skyCamera), this.renderer.clear(!1, !0, !1), this.renderer.render(this.world.scene, this.world.camera));
                        },
                        update: function () {
                            var e = this.clock.getDelta(),
                                t = this.clock.getElapsedTime();
                            this.paused || (requestAnimationFrame(this.update.bind(this)), this.stats && this.stats.begin(), this.world.update(t, e), this.render(), this.stats && this.stats.end());
                        },
                        pause: function () {
                            this.clock.stop(), (this.paused = !0);
                        },
                        resume: function () {
                            this.clock.start(), (this.paused = !1);
                        },
                        toggleGUIMode: function () {
                            this.stats && this.datGUI && ($(this.stats.domElement).toggle(), $(this.datGUI.domElement).toggle());
                        },
                        resize: function (e, t) {
                            this.world.setAspectRatio(e / t);
                        },
                    });
                    return i;
                }),
                define("datgui", {}),
                define("stats", {});
                var Detector = {
                    canvas: !!window.CanvasRenderingContext2D,
                    webgl: (function () {
                        try {
                            var e = document.createElement("canvas");
                            return !!window.WebGLRenderingContext && (e.getContext("webgl") || e.getContext("experimental-webgl"));
                        } catch (t) {
                            return !1;
                        }
                    })(),
                    workers: !!window.Worker,
                    fileapi: window.File && window.FileReader && window.FileList && window.Blob,
                    getWebGLErrorMessage: function () {
                        var e = document.createElement("p");
                        return (
                            this.webgl ||
                            (e.innerHTML = window.WebGLRenderingContext
                                ? [
                                    'Your browser or graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>.<br />',
                                    'Find out how to get it <a href="http://get.webgl.org/">here</a>.',
                                ].join("\n")
                                : [
                                    'Your browser or graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>.<br/>',
                                    'Find out how to get it <a href="http://get.webgl.org/">here</a>.',
                                ].join("\n")),
                                e
                        );
                    },
                    addGetWebGLMessage: function (e) {
                        var t, n, r;
                        (e = e || {}), (t = e.parent !== undefined ? e.parent : document.body), (n = e.id !== undefined ? e.id : "oldie"), (r = Detector.getWebGLErrorMessage()), (r.id = n), t.appendChild(r);
                    },
                };
                define("detector", (function (e) {
                    return function () {
                        var t, n;
                        return t || e.Detector;
                    };
                })(this));
                var hudSize = 120;
                (window.WIDTH = window.innerWidth),
                    (window.HEIGHT = window.innerHeight - hudSize),
                    (window.DENSITY = 1 / window.devicePixelRatio),
                    (window.mouseX = 0),
                    (window.mouseY = 0),
                    define("main", ["neons/app", "canyon/app", "mountains/app", "road/app", "datgui", "stats", "detector"], function (e, t, n, r, i, s, o) {
                        function m(e) {
                            (mouseX = (e.pageX / WIDTH) * 2 - 1), (mouseY = (e.pageY / HEIGHT) * 2 - 1);
                        }
                        function g() {
                            var e = (window.WIDTH = window.innerWidth),
                                t = (window.HEIGHT = window.innerHeight - 120);
                            a.setSize(e, t),
                                _.each(l, function (n) {
                                    n.resize(e, t);
                                });
                        }
                        function y(e) {
                            e.keyCode == 68 && !h && ((c = !c), p.toggleGUIMode(), p.world.toggleHelpers()), e.keyCode == 37 && b(), e.keyCode == 39 && w();
                        }
                        function b() {
                            d > 0 ? E(d - 1) : E(l.length - 1);
                        }
                        function w() {
                            d < l.length - 1 ? E(d + 1) : E(0);
                        }
                        function E(e) {
                            if (e < 0 || e >= l.length) return;
                            if (e === d || v) return;
                            var t = l[e],
                                n = function () {
                                    f.off("transitionend webkitTransitionEnd mozTransitionEnd msTransitionEnd oTransitionEnd"),
                                        f.removeClass("hidden"),
                                        S(t),
                                        t.resume(),
                                        t.update(),
                                        (v = !1),
                                    p && (x(p), p.pause()),
                                        (p = t),
                                        (d = e),
                                    h || (window.location.hash = e + 1);
                                };
                            f.addClass("hidden").on("transitionend webkitTransitionEnd mozTransitionEnd msTransitionEnd oTransitionEnd", n), (v = !0), T(e, t.description);
                        }
                        function S(e) {
                            c && ($(e.stats.domElement).show(), $(e.datGUI.domElement).show());
                        }
                        function x(e) {
                            c && ($(e.stats.domElement).hide(), $(e.datGUI.domElement).hide());
                        }
                        function T(e, t) {
                            $(".selected").removeClass("selected"), D.eq(e).addClass("selected"), P.text("0" + (e + 1)), H.html(t);
                        }
                        function N() {
                            return parseInt(window.location.hash.substring(1, window.location.hash.length));
                        }
                        function O() {
                            document[L]
                                ? p.pause()
                                : setTimeout(function () {
                                    p.resume(), p.update();
                                }, 50);
                        }
                        function B() {
                            var e = d - 1;
                            e < 0 && (e = l.length - 1), E(e);
                        }
                        function j() {
                            var e = (d + 1) % D.length;
                            E(e);
                        }
                        function F(e) {
                            var t = D.index($(e.target).closest("li"));
                            E(t);
                        }
                        function I(e) {
                            if (!h) {
                                var t = new i.GUI();
                                if (!_.isUndefined(e.compositing)) {
                                    var n = t.addFolder("General");
                                    n.add(e, "compositing"), n.open();
                                }
                                f.append(t.domElement), $(t.domElement).css({ position: "absolute", top: "0px", right: "10px" }), (e.datGUI = t);
                            }
                        }
                        function q(e) {
                            if (!h) {
                                var t = new s();
                                (t.domElement.style.position = "absolute"), (t.domElement.style.left = "0px"), (t.domElement.style.top = "0px"), f.append(t.domElement), (e.stats = t);
                            }
                        }
                        THREE.Math.lerp = function (e, t, n) {
                            return e + (t - e) * n;
                        };
                        if (!o.webgl) {
                            var u = $("#no-webgl");
                            $("body").prepend(u.html()), $(".no-webgl .content").append(o.getWebGLErrorMessage());
                        }
                        $("body").removeClass("no-transitions");
                        var a = new THREE.WebGLRenderer({ antialias: !0 });
                        (a.autoClear = !1), a.setSize(WIDTH, HEIGHT);
                        var f = $(".container");
                        f.append(a.domElement);
                        var l = [],
                            c = !1,
                            h = !_.isFunction(s);
                        l.push(new e({ renderer: a, container: f[0], enableCompositing: !1 })),
                            l.push(new t({ renderer: a, container: f[0], enableCompositing: !0 })),
                            l.push(new n({ renderer: a, container: f[0], enableCompositing: !0 })),
                            l.push(new r({ renderer: a, container: f[0], enableCompositing: !1 })),
                            _.each(l, function (e) {
                                I(e), q(e), e.toggleGUIMode();
                            });
                        var p = null,
                            d = -1,
                            v = !1;
                        _.each(l, function (e, t) {
                            e.initWorld();
                        }),
                        h ||
                        (window.onhashchange = function () {
                            E(N() - 1);
                        });
                        var C = N() - 1 || 0,
                            k = l[C];
                        k.on("ready", function () {
                            E(C);
                        }),
                            $(window).resize(g).on("keyup", y).on("mousemove", m);
                        var L, A;
                        typeof document.hidden != "undefined"
                            ? ((L = "hidden"), (A = "visibilitychange"))
                            : typeof document.mozHidden != "undefined"
                            ? ((L = "mozHidden"), (A = "mozvisibilitychange"))
                            : typeof document.msHidden != "undefined"
                                ? ((L = "msHidden"), (A = "msvisibilitychange"))
                                : typeof document.webkitHidden != "undefined" && ((L = "webkitHidden"), (A = "webkitvisibilitychange")),
                        typeof document.addEventListener != "undefined" && document.addEventListener(A, O, !1);
                        var M = $(".about"),
                            D = $(".thumbnails").find("li").not(":last-child"),
                            P = $(".current-page"),
                            H = $(".caption");
                        $(".close").on("click", function () {
                            M.removeClass("visible");
                        }),
                            $(".about-link").on("click", function () {
                                M.toggleClass("visible");
                            }),
                            $(".arrow.previous").on("click", function () {
                                B();
                            }),
                            $(".arrow.next").on("click", function () {
                                j();
                            }),
                            D.on("click", F);
                    }),
                    !function () {
                        var e = this,
                            t = e._,
                            n = {},
                            r = Array.prototype,
                            i = Object.prototype,
                            s = Function.prototype,
                            o = r.push,
                            u = r.slice,
                            a = r.concat,
                            f = i.toString,
                            l = i.hasOwnProperty,
                            c = r.forEach,
                            h = r.map,
                            p = r.reduce,
                            d = r.reduceRight,
                            v = r.filter,
                            m = r.every,
                            g = r.some,
                            y = r.indexOf,
                            b = r.lastIndexOf,
                            w = Array.isArray,
                            E = Object.keys,
                            S = s.bind,
                            x = function (e) {
                                return e instanceof x ? e : this instanceof x ? ((this._wrapped = e), void 0) : new x(e);
                            };
                        "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = x), (exports._ = x)) : (e._ = x), (x.VERSION = "1.5.1");
                        var T = (x.each = x.forEach = function (e, t, r) {
                            if (null != e)
                                if (c && e.forEach === c) e.forEach(t, r);
                                else if (e.length === +e.length) {
                                    for (var i = 0, s = e.length; s > i; i++) if (t.call(r, e[i], i, e) === n) return;
                                } else for (var o in e) if (x.has(e, o) && t.call(r, e[o], o, e) === n) return;
                        });
                        x.map = x.collect = function (e, t, n) {
                            var r = [];
                            return null == e
                                ? r
                                : h && e.map === h
                                    ? e.map(t, n)
                                    : (T(e, function (e, i, s) {
                                        r.push(t.call(n, e, i, s));
                                    }),
                                        r);
                        };
                        var N = "Reduce of empty array with no initial value";
                        (x.reduce = x.foldl = x.inject = function (e, t, n, r) {
                            var i = arguments.length > 2;
                            if ((null == e && (e = []), p && e.reduce === p)) return r && (t = x.bind(t, r)), i ? e.reduce(t, n) : e.reduce(t);
                            if (
                                (T(e, function (e, s, o) {
                                    i ? (n = t.call(r, n, e, s, o)) : ((n = e), (i = !0));
                                }),
                                    !i)
                            )
                                throw new TypeError(N);
                            return n;
                        }),
                            (x.reduceRight = x.foldr = function (e, t, n, r) {
                                var i = arguments.length > 2;
                                if ((null == e && (e = []), d && e.reduceRight === d)) return r && (t = x.bind(t, r)), i ? e.reduceRight(t, n) : e.reduceRight(t);
                                var s = e.length;
                                if (s !== +s) {
                                    var o = x.keys(e);
                                    s = o.length;
                                }
                                if (
                                    (T(e, function (u, a, f) {
                                        (a = o ? o[--s] : --s), i ? (n = t.call(r, n, e[a], a, f)) : ((n = e[a]), (i = !0));
                                    }),
                                        !i)
                                )
                                    throw new TypeError(N);
                                return n;
                            }),
                            (x.find = x.detect = function (e, t, n) {
                                var r;
                                return (
                                    C(e, function (e, i, s) {
                                        return t.call(n, e, i, s) ? ((r = e), !0) : void 0;
                                    }),
                                        r
                                );
                            }),
                            (x.filter = x.select = function (e, t, n) {
                                var r = [];
                                return null == e
                                    ? r
                                    : v && e.filter === v
                                        ? e.filter(t, n)
                                        : (T(e, function (e, i, s) {
                                            t.call(n, e, i, s) && r.push(e);
                                        }),
                                            r);
                            }),
                            (x.reject = function (e, t, n) {
                                return x.filter(
                                    e,
                                    function (e, r, i) {
                                        return !t.call(n, e, r, i);
                                    },
                                    n
                                );
                            }),
                            (x.every = x.all = function (e, t, r) {
                                t || (t = x.identity);
                                var i = !0;
                                return null == e
                                    ? i
                                    : m && e.every === m
                                        ? e.every(t, r)
                                        : (T(e, function (e, s, o) {
                                            return (i = i && t.call(r, e, s, o)) ? void 0 : n;
                                        }),
                                            !!i);
                            });
                        var C = (x.some = x.any = function (e, t, r) {
                            t || (t = x.identity);
                            var i = !1;
                            return null == e
                                ? i
                                : g && e.some === g
                                    ? e.some(t, r)
                                    : (T(e, function (e, s, o) {
                                        return i || (i = t.call(r, e, s, o)) ? n : void 0;
                                    }),
                                        !!i);
                        });
                        (x.contains = x.include = function (e, t) {
                            return null == e
                                ? !1
                                : y && e.indexOf === y
                                    ? e.indexOf(t) != -1
                                    : C(e, function (e) {
                                        return e === t;
                                    });
                        }),
                            (x.invoke = function (e, t) {
                                var n = u.call(arguments, 2),
                                    r = x.isFunction(t);
                                return x.map(e, function (e) {
                                    return (r ? t : e[t]).apply(e, n);
                                });
                            }),
                            (x.pluck = function (e, t) {
                                return x.map(e, function (e) {
                                    return e[t];
                                });
                            }),
                            (x.where = function (e, t, n) {
                                return x.isEmpty(t)
                                    ? n
                                        ? void 0
                                        : []
                                    : x[n ? "find" : "filter"](e, function (e) {
                                        for (var n in t) if (t[n] !== e[n]) return !1;
                                        return !0;
                                    });
                            }),
                            (x.findWhere = function (e, t) {
                                return x.where(e, t, !0);
                            }),
                            (x.max = function (e, t, n) {
                                if (!t && x.isArray(e) && e[0] === +e[0] && e.length < 65535) return Math.max.apply(Math, e);
                                if (!t && x.isEmpty(e)) return -1 / 0;
                                var r = { computed: -1 / 0, value: -1 / 0 };
                                return (
                                    T(e, function (e, i, s) {
                                        var o = t ? t.call(n, e, i, s) : e;
                                        o > r.computed && (r = { value: e, computed: o });
                                    }),
                                        r.value
                                );
                            }),
                            (x.min = function (e, t, n) {
                                if (!t && x.isArray(e) && e[0] === +e[0] && e.length < 65535) return Math.min.apply(Math, e);
                                if (!t && x.isEmpty(e)) return 1 / 0;
                                var r = { computed: 1 / 0, value: 1 / 0 };
                                return (
                                    T(e, function (e, i, s) {
                                        var o = t ? t.call(n, e, i, s) : e;
                                        o < r.computed && (r = { value: e, computed: o });
                                    }),
                                        r.value
                                );
                            }),
                            (x.shuffle = function (e) {
                                var t,
                                    n = 0,
                                    r = [];
                                return (
                                    T(e, function (e) {
                                        (t = x.random(n++)), (r[n - 1] = r[t]), (r[t] = e);
                                    }),
                                        r
                                );
                            });
                        var k = function (e) {
                            return x.isFunction(e)
                                ? e
                                : function (t) {
                                    return t[e];
                                };
                        };
                        x.sortBy = function (e, t, n) {
                            var r = k(t);
                            return x.pluck(
                                x
                                    .map(e, function (e, t, i) {
                                        return { value: e, index: t, criteria: r.call(n, e, t, i) };
                                    })
                                    .sort(function (e, t) {
                                        var n = e.criteria,
                                            r = t.criteria;
                                        if (n !== r) {
                                            if (n > r || n === void 0) return 1;
                                            if (r > n || r === void 0) return -1;
                                        }
                                        return e.index < t.index ? -1 : 1;
                                    }),
                                "value"
                            );
                        };
                        var L = function (e, t, n, r) {
                            var i = {},
                                s = k(null == t ? x.identity : t);
                            return (
                                T(e, function (t, o) {
                                    var u = s.call(n, t, o, e);
                                    r(i, u, t);
                                }),
                                    i
                            );
                        };
                        (x.groupBy = function (e, t, n) {
                            return L(e, t, n, function (e, t, n) {
                                (x.has(e, t) ? e[t] : (e[t] = [])).push(n);
                            });
                        }),
                            (x.countBy = function (e, t, n) {
                                return L(e, t, n, function (e, t) {
                                    x.has(e, t) || (e[t] = 0), e[t]++;
                                });
                            }),
                            (x.sortedIndex = function (e, t, n, r) {
                                n = null == n ? x.identity : k(n);
                                for (var i = n.call(r, t), s = 0, o = e.length; o > s; ) {
                                    var u = (s + o) >>> 1;
                                    n.call(r, e[u]) < i ? (s = u + 1) : (o = u);
                                }
                                return s;
                            }),
                            (x.toArray = function (e) {
                                return e ? (x.isArray(e) ? u.call(e) : e.length === +e.length ? x.map(e, x.identity) : x.values(e)) : [];
                            }),
                            (x.size = function (e) {
                                return null == e ? 0 : e.length === +e.length ? e.length : x.keys(e).length;
                            }),
                            (x.first = x.head = x.take = function (e, t, n) {
                                return null == e ? void 0 : null == t || n ? e[0] : u.call(e, 0, t);
                            }),
                            (x.initial = function (e, t, n) {
                                return u.call(e, 0, e.length - (null == t || n ? 1 : t));
                            }),
                            (x.last = function (e, t, n) {
                                return null == e ? void 0 : null == t || n ? e[e.length - 1] : u.call(e, Math.max(e.length - t, 0));
                            }),
                            (x.rest = x.tail = x.drop = function (e, t, n) {
                                return u.call(e, null == t || n ? 1 : t);
                            }),
                            (x.compact = function (e) {
                                return x.filter(e, x.identity);
                            });
                        var A = function (e, t, n) {
                            return t && x.every(e, x.isArray)
                                ? a.apply(n, e)
                                : (T(e, function (e) {
                                    x.isArray(e) || x.isArguments(e) ? (t ? o.apply(n, e) : A(e, t, n)) : n.push(e);
                                }),
                                    n);
                        };
                        (x.flatten = function (e, t) {
                            return A(e, t, []);
                        }),
                            (x.without = function (e) {
                                return x.difference(e, u.call(arguments, 1));
                            }),
                            (x.uniq = x.unique = function (e, t, n, r) {
                                x.isFunction(t) && ((r = n), (n = t), (t = !1));
                                var i = n ? x.map(e, n, r) : e,
                                    s = [],
                                    o = [];
                                return (
                                    T(i, function (n, r) {
                                        (t ? r && o[o.length - 1] === n : x.contains(o, n)) || (o.push(n), s.push(e[r]));
                                    }),
                                        s
                                );
                            }),
                            (x.union = function () {
                                return x.uniq(x.flatten(arguments, !0));
                            }),
                            (x.intersection = function (e) {
                                var t = u.call(arguments, 1);
                                return x.filter(x.uniq(e), function (e) {
                                    return x.every(t, function (t) {
                                        return x.indexOf(t, e) >= 0;
                                    });
                                });
                            }),
                            (x.difference = function (e) {
                                var t = a.apply(r, u.call(arguments, 1));
                                return x.filter(e, function (e) {
                                    return !x.contains(t, e);
                                });
                            }),
                            (x.zip = function () {
                                for (var e = x.max(x.pluck(arguments, "length").concat(0)), t = new Array(e), n = 0; e > n; n++) t[n] = x.pluck(arguments, "" + n);
                                return t;
                            }),
                            (x.object = function (e, t) {
                                if (null == e) return {};
                                for (var n = {}, r = 0, i = e.length; i > r; r++) t ? (n[e[r]] = t[r]) : (n[e[r][0]] = e[r][1]);
                                return n;
                            }),
                            (x.indexOf = function (e, t, n) {
                                if (null == e) return -1;
                                var r = 0,
                                    i = e.length;
                                if (n) {
                                    if ("number" != typeof n) return (r = x.sortedIndex(e, t)), e[r] === t ? r : -1;
                                    r = 0 > n ? Math.max(0, i + n) : n;
                                }
                                if (y && e.indexOf === y) return e.indexOf(t, n);
                                for (; i > r; r++) if (e[r] === t) return r;
                                return -1;
                            }),
                            (x.lastIndexOf = function (e, t, n) {
                                if (null == e) return -1;
                                var r = null != n;
                                if (b && e.lastIndexOf === b) return r ? e.lastIndexOf(t, n) : e.lastIndexOf(t);
                                for (var i = r ? n : e.length; i--; ) if (e[i] === t) return i;
                                return -1;
                            }),
                            (x.range = function (e, t, n) {
                                arguments.length <= 1 && ((t = e || 0), (e = 0)), (n = arguments[2] || 1);
                                for (var r = Math.max(Math.ceil((t - e) / n), 0), i = 0, s = new Array(r); r > i; ) (s[i++] = e), (e += n);
                                return s;
                            });
                        var O = function () {};
                        (x.bind = function (e, t) {
                            var n, r;
                            if (S && e.bind === S) return S.apply(e, u.call(arguments, 1));
                            if (!x.isFunction(e)) throw new TypeError();
                            return (
                                (n = u.call(arguments, 2)),
                                    (r = function () {
                                        if (this instanceof r) {
                                            O.prototype = e.prototype;
                                            var i = new O();
                                            O.prototype = null;
                                            var s = e.apply(i, n.concat(u.call(arguments)));
                                            return Object(s) === s ? s : i;
                                        }
                                        return e.apply(t, n.concat(u.call(arguments)));
                                    })
                            );
                        }),
                            (x.partial = function (e) {
                                var t = u.call(arguments, 1);
                                return function () {
                                    return e.apply(this, t.concat(u.call(arguments)));
                                };
                            }),
                            (x.bindAll = function (e) {
                                var t = u.call(arguments, 1);
                                if (0 === t.length) throw new Error("bindAll must be passed function names");
                                return (
                                    T(t, function (t) {
                                        e[t] = x.bind(e[t], e);
                                    }),
                                        e
                                );
                            }),
                            (x.memoize = function (e, t) {
                                var n = {};
                                return (
                                    t || (t = x.identity),
                                        function () {
                                            var r = t.apply(this, arguments);
                                            return x.has(n, r) ? n[r] : (n[r] = e.apply(this, arguments));
                                        }
                                );
                            }),
                            (x.delay = function (e, t) {
                                var n = u.call(arguments, 2);
                                return setTimeout(function () {
                                    return e.apply(null, n);
                                }, t);
                            }),
                            (x.defer = function (e) {
                                return x.delay.apply(x, [e, 1].concat(u.call(arguments, 1)));
                            }),
                            (x.throttle = function (e, t, n) {
                                var r,
                                    i,
                                    s,
                                    o = null,
                                    u = 0;
                                n || (n = {});
                                var a = function () {
                                    (u = n.leading === !1 ? 0 : new Date()), (o = null), (s = e.apply(r, i));
                                };
                                return function () {
                                    var f = new Date();
                                    u || n.leading !== !1 || (u = f);
                                    var l = t - (f - u);
                                    return (r = this), (i = arguments), 0 >= l ? (clearTimeout(o), (o = null), (u = f), (s = e.apply(r, i))) : o || n.trailing === !1 || (o = setTimeout(a, l)), s;
                                };
                            }),
                            (x.debounce = function (e, t, n) {
                                var r,
                                    i = null;
                                return function () {
                                    var s = this,
                                        o = arguments,
                                        u = function () {
                                            (i = null), n || (r = e.apply(s, o));
                                        },
                                        a = n && !i;
                                    return clearTimeout(i), (i = setTimeout(u, t)), a && (r = e.apply(s, o)), r;
                                };
                            }),
                            (x.once = function (e) {
                                var t,
                                    n = !1;
                                return function () {
                                    return n ? t : ((n = !0), (t = e.apply(this, arguments)), (e = null), t);
                                };
                            }),
                            (x.wrap = function (e, t) {
                                return function () {
                                    var n = [e];
                                    return o.apply(n, arguments), t.apply(this, n);
                                };
                            }),
                            (x.compose = function () {
                                var e = arguments;
                                return function () {
                                    for (var t = arguments, n = e.length - 1; n >= 0; n--) t = [e[n].apply(this, t)];
                                    return t[0];
                                };
                            }),
                            (x.after = function (e, t) {
                                return function () {
                                    return --e < 1 ? t.apply(this, arguments) : void 0;
                                };
                            }),
                            (x.keys =
                                E ||
                                function (e) {
                                    if (e !== Object(e)) throw new TypeError("Invalid object");
                                    var t = [];
                                    for (var n in e) x.has(e, n) && t.push(n);
                                    return t;
                                }),
                            (x.values = function (e) {
                                var t = [];
                                for (var n in e) x.has(e, n) && t.push(e[n]);
                                return t;
                            }),
                            (x.pairs = function (e) {
                                var t = [];
                                for (var n in e) x.has(e, n) && t.push([n, e[n]]);
                                return t;
                            }),
                            (x.invert = function (e) {
                                var t = {};
                                for (var n in e) x.has(e, n) && (t[e[n]] = n);
                                return t;
                            }),
                            (x.functions = x.methods = function (e) {
                                var t = [];
                                for (var n in e) x.isFunction(e[n]) && t.push(n);
                                return t.sort();
                            }),
                            (x.extend = function (e) {
                                return (
                                    T(u.call(arguments, 1), function (t) {
                                        if (t) for (var n in t) e[n] = t[n];
                                    }),
                                        e
                                );
                            }),
                            (x.pick = function (e) {
                                var t = {},
                                    n = a.apply(r, u.call(arguments, 1));
                                return (
                                    T(n, function (n) {
                                        n in e && (t[n] = e[n]);
                                    }),
                                        t
                                );
                            }),
                            (x.omit = function (e) {
                                var t = {},
                                    n = a.apply(r, u.call(arguments, 1));
                                for (var i in e) x.contains(n, i) || (t[i] = e[i]);
                                return t;
                            }),
                            (x.defaults = function (e) {
                                return (
                                    T(u.call(arguments, 1), function (t) {
                                        if (t) for (var n in t) e[n] === void 0 && (e[n] = t[n]);
                                    }),
                                        e
                                );
                            }),
                            (x.clone = function (e) {
                                return x.isObject(e) ? (x.isArray(e) ? e.slice() : x.extend({}, e)) : e;
                            }),
                            (x.tap = function (e, t) {
                                return t(e), e;
                            });
                        var M = function (e, t, n, r) {
                            if (e === t) return 0 !== e || 1 / e == 1 / t;
                            if (null == e || null == t) return e === t;
                            e instanceof x && (e = e._wrapped), t instanceof x && (t = t._wrapped);
                            var i = f.call(e);
                            if (i != f.call(t)) return !1;
                            switch (i) {
                                case "[object String]":
                                    return e == String(t);
                                case "[object Number]":
                                    return e != +e ? t != +t : 0 == e ? 1 / e == 1 / t : e == +t;
                                case "[object Date]":
                                case "[object Boolean]":
                                    return +e == +t;
                                case "[object RegExp]":
                                    return e.source == t.source && e.global == t.global && e.multiline == t.multiline && e.ignoreCase == t.ignoreCase;
                            }
                            if ("object" != typeof e || "object" != typeof t) return !1;
                            for (var s = n.length; s--; ) if (n[s] == e) return r[s] == t;
                            var o = e.constructor,
                                u = t.constructor;
                            if (o !== u && !(x.isFunction(o) && o instanceof o && x.isFunction(u) && u instanceof u)) return !1;
                            n.push(e), r.push(t);
                            var a = 0,
                                l = !0;
                            if ("[object Array]" == i) {
                                if (((a = e.length), (l = a == t.length))) for (; a-- && (l = M(e[a], t[a], n, r)); );
                            } else {
                                for (var c in e) if (x.has(e, c) && (a++, !(l = x.has(t, c) && M(e[c], t[c], n, r)))) break;
                                if (l) {
                                    for (c in t) if (x.has(t, c) && !a--) break;
                                    l = !a;
                                }
                            }
                            return n.pop(), r.pop(), l;
                        };
                        (x.isEqual = function (e, t) {
                            return M(e, t, [], []);
                        }),
                            (x.isEmpty = function (e) {
                                if (null == e) return !0;
                                if (x.isArray(e) || x.isString(e)) return 0 === e.length;
                                for (var t in e) if (x.has(e, t)) return !1;
                                return !0;
                            }),
                            (x.isElement = function (e) {
                                return !!e && 1 === e.nodeType;
                            }),
                            (x.isArray =
                                w ||
                                function (e) {
                                    return "[object Array]" == f.call(e);
                                }),
                            (x.isObject = function (e) {
                                return e === Object(e);
                            }),
                            T(["Arguments", "Function", "String", "Number", "Date", "RegExp"], function (e) {
                                x["is" + e] = function (t) {
                                    return f.call(t) == "[object " + e + "]";
                                };
                            }),
                        x.isArguments(arguments) ||
                        (x.isArguments = function (e) {
                            return !!e && !!x.has(e, "callee");
                        }),
                        "function" != typeof /./ &&
                        (x.isFunction = function (e) {
                            return "function" == typeof e;
                        }),
                            (x.isFinite = function (e) {
                                return isFinite(e) && !isNaN(parseFloat(e));
                            }),
                            (x.isNaN = function (e) {
                                return x.isNumber(e) && e != +e;
                            }),
                            (x.isBoolean = function (e) {
                                return e === !0 || e === !1 || "[object Boolean]" == f.call(e);
                            }),
                            (x.isNull = function (e) {
                                return null === e;
                            }),
                            (x.isUndefined = function (e) {
                                return e === void 0;
                            }),
                            (x.has = function (e, t) {
                                return l.call(e, t);
                            }),
                            (x.noConflict = function () {
                                return (e._ = t), this;
                            }),
                            (x.identity = function (e) {
                                return e;
                            }),
                            (x.times = function (e, t, n) {
                                for (var r = Array(Math.max(0, e)), i = 0; e > i; i++) r[i] = t.call(n, i);
                                return r;
                            }),
                            (x.random = function (e, t) {
                                return null == t && ((t = e), (e = 0)), e + Math.floor(Math.random() * (t - e + 1));
                            });
                        var _ = { escape: { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "/": "&#x2F;" } };
                        _.unescape = x.invert(_.escape);
                        var D = { escape: new RegExp("[" + x.keys(_.escape).join("") + "]", "g"), unescape: new RegExp("(" + x.keys(_.unescape).join("|") + ")", "g") };
                        x.each(["escape", "unescape"], function (e) {
                            x[e] = function (t) {
                                return null == t
                                    ? ""
                                    : ("" + t).replace(D[e], function (t) {
                                        return _[e][t];
                                    });
                            };
                        }),
                            (x.result = function (e, t) {
                                if (null == e) return void 0;
                                var n = e[t];
                                return x.isFunction(n) ? n.call(e) : n;
                            }),
                            (x.mixin = function (e) {
                                T(x.functions(e), function (t) {
                                    var n = (x[t] = e[t]);
                                    x.prototype[t] = function () {
                                        var e = [this._wrapped];
                                        return o.apply(e, arguments), F.call(this, n.apply(x, e));
                                    };
                                });
                            });
                        var P = 0;
                        (x.uniqueId = function (e) {
                            var t = ++P + "";
                            return e ? e + t : t;
                        }),
                            (x.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g });
                        var H = /(.)^/,
                            B = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "	": "t", "\u2028": "u2028", "\u2029": "u2029" },
                            j = /\\|'|\r|\n|\t|\u2028|\u2029/g;
                        (x.template = function (e, t, n) {
                            var r;
                            n = x.defaults({}, n, x.templateSettings);
                            var i = new RegExp([(n.escape || H).source, (n.interpolate || H).source, (n.evaluate || H).source].join("|") + "|$", "g"),
                                s = 0,
                                o = "__p+='";
                            e.replace(i, function (t, n, r, i, u) {
                                return (
                                    (o += e.slice(s, u).replace(j, function (e) {
                                        return "\\" + B[e];
                                    })),
                                    n && (o += "'+\n((__t=(" + n + "))==null?'':_.escape(__t))+\n'"),
                                    r && (o += "'+\n((__t=(" + r + "))==null?'':__t)+\n'"),
                                    i && (o += "';\n" + i + "\n__p+='"),
                                        (s = u + t.length),
                                        t
                                );
                            }),
                                (o += "';\n"),
                            n.variable || (o = "with(obj||{}){\n" + o + "}\n"),
                                (o = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + o + "return __p;\n");
                            try {
                                r = new Function(n.variable || "obj", "_", o);
                            } catch (u) {
                                throw ((u.source = o), u);
                            }
                            if (t) return r(t, x);
                            var a = function (e) {
                                return r.call(this, e, x);
                            };
                            return (a.source = "function(" + (n.variable || "obj") + "){\n" + o + "}"), a;
                        }),
                            (x.chain = function (e) {
                                return x(e).chain();
                            });
                        var F = function (e) {
                            return this._chain ? x(e).chain() : e;
                        };
                        x.mixin(x),
                            T(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (e) {
                                var t = r[e];
                                x.prototype[e] = function () {
                                    var n = this._wrapped;
                                    return t.apply(n, arguments), ("shift" != e && "splice" != e) || 0 !== n.length || delete n[0], F.call(this, n);
                                };
                            }),
                            T(["concat", "join", "slice"], function (e) {
                                var t = r[e];
                                x.prototype[e] = function () {
                                    return F.call(this, t.apply(this._wrapped, arguments));
                                };
                            }),
                            x.extend(x.prototype, {
                                chain: function () {
                                    return (this._chain = !0), this;
                                },
                                value: function () {
                                    return this._wrapped;
                                },
                            });
                    }.call(this),
                    define("underscore", (function (e) {
                        return function () {
                            var t, n;
                            return t || e._;
                        };
                    })(this)),
                    require(["main"]);
                e];
                x.prototype[e] = function () {
                    return F.call(this, t.apply(this._wrapped, arguments));
                };
            }),
            x.extend(x.prototype, {
                chain: function () {
                    return (this._chain = !0), this;
                },
                value: function () {
                    return this._wrapped;
                },
            });
    }.call(this),
    define("underscore", (function (e) {
        return function () {
            var t, n;
            return t || e._;
        };
    })(this)),
    require(["main"]);
